import { markQExceptionHandled } from "../q/q";
import { minErr } from "../../shared/utils";

const $intervalMinErr = minErr("$interval");

export function $IntervalProvider() {
  this.$get = [
    "$$intervalFactory",
    // TODO Add type
    function ($$intervalFactory) {
      const intervals = {};
      const setIntervalFn = function (tick, delay, deferred) {
        const id = window.setInterval(tick, delay);
        intervals[id] = deferred;
        return id;
      };
      const clearIntervalFn = function (id) {
        window.clearInterval(id);
        delete intervals[id];
      };

      const interval = $$intervalFactory(setIntervalFn, clearIntervalFn);

      /**
       * @ngdoc method
       * @name $interval#cancel
       *
       * @description
       * Cancels a task associated with the `promise`.
       *
       * @param {Promise=} promise returned by the `$interval` function.
       * @returns {boolean} Returns `true` if the task was successfully canceled.
       */
      interval.cancel = function (promise) {
        if (!promise) return false;

        if (!Object.prototype.hasOwnProperty.call(promise, "$$intervalId")) {
          throw $intervalMinErr(
            "badprom",
            "`$interval.cancel()` called with a promise that was not generated by `$interval()`.",
          );
        }

        if (
          !Object.prototype.hasOwnProperty.call(intervals, promise.$$intervalId)
        )
          return false;

        const id = promise.$$intervalId;
        const deferred = intervals[id];

        // Interval cancels should not report an unhandled promise.
        markQExceptionHandled(deferred.promise);
        deferred.reject("canceled");
        clearIntervalFn(id);

        return true;
      };

      return interval;
    },
  ];
}
