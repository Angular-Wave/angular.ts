import { markQExceptionHandled } from "../q/q";
import { isDefined, minErr, sliceArgs } from "../../shared/utils";

const $timeoutMinErr = minErr("$timeout");

export class TimeoutProvider {
  $get = [
    "$rootScope",
    "$browser",
    "$q",
    "$exceptionHandler",
    /**
     *
     * @param {import('../scope/scope').Scope} $rootScope
     * @param {import('../../services/browser').Browser} $browser
     * @param {*} $q
     * @param {import('../exception-handler').ErrorHandler} $exceptionHandler
     * @returns
     */
    ($rootScope, $browser, $q, $exceptionHandler) => {
      const deferreds = {};

      /**
    
       * AngularJS's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
       * block and delegates any exceptions to
       * {@link $exceptionHandler} service.
       *
       * The return value of calling `$timeout` is a promise, which will be resolved when
       * the delay has passed and the timeout function, if provided, is executed.
       *
       * To cancel a timeout request, call `$timeout.cancel(promise)`.
       *
       * If you only want a promise that will be resolved after some specified delay
       * then you can call `$timeout` without the `fn` function.
       *
       * @param {function()=} fn A function, whose execution should be delayed.
       * @param {number=} [delay=0] Delay in milliseconds.
       * @returns {import("../q/q").QPromise<any>} Promise that will be resolved when the timeout is reached. The promise
       *   will be resolved with the return value of the `fn` function.
       *
       */
      function timeout(fn, delay, invokeApply = true) {
        const args = sliceArgs(arguments, 3);
        const skipApply = isDefined(invokeApply) && !invokeApply;
        const deferred = $q.defer();
        const { promise } = deferred;
        let timeoutId;

        timeoutId = $browser.defer(
          () => {
            try {
              deferred.resolve(fn.apply(null, args));
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            } finally {
              delete deferreds[promise.$$timeoutId];
            }

            if (!skipApply) $rootScope.$apply();
          },
          delay,
          "$timeout",
        );

        promise.$$timeoutId = timeoutId;
        deferreds[timeoutId] = deferred;

        return promise;
      }

      /**
       * Cancels a task associated with the `promise`. As a result of this, the promise will be
       * resolved with a rejection.
       *
       * @param {import("../q/q").QPromise<any>} promise Promise returned by the `$timeout` function.
       * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
       *   canceled.
       */
      timeout.cancel = function (promise) {
        if (!promise) return false;

        if (!Object.prototype.hasOwnProperty.call(promise, "$$timeoutId")) {
          throw $timeoutMinErr(
            "badprom",
            "`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.",
          );
        }

        if (
          !Object.prototype.hasOwnProperty.call(deferreds, promise.$$timeoutId)
        )
          return false;
        const id = promise.$$timeoutId;
        const deferred = deferreds[id];

        // Timeout cancels should not report an unhandled promise.
        markQExceptionHandled(deferred.promise);
        deferred.reject("canceled");
        delete deferreds[id];

        return $browser.cancel(id);
      };

      return timeout;
    },
  ];
}
