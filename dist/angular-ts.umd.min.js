!(function (t, e) {
  "object" == typeof exports && "undefined" != typeof module
    ? e(exports)
    : "function" == typeof define && define.amd
      ? define(["exports"], e)
      : e(
          ((t =
            "undefined" != typeof globalThis ? globalThis : t || self).angular =
            {}),
        );
})(this, function (t) {
  "use strict";
  const e = "ng-valid",
    n = "ng-invalid",
    r = "ng-pristine",
    s = "ng-dirty",
    i = "ng-untouched",
    o = "ng-touched",
    a = "ng-empty",
    c = "ng-not-empty",
    l = /^((?:x|data)[-])/i,
    u = /[-]+(.)/g,
    h = {
      ngMinlength: "minlength",
      ngMaxlength: "maxlength",
      ngMin: "min",
      ngMax: "max",
      ngPattern: "pattern",
      ngStep: "step",
    },
    d = Symbol("isProxy");
  function p(t) {
    return !(!t || !t[d]);
  }
  const f = dt("ng");
  let $ = 0;
  function m() {
    return ($ += 1), $;
  }
  function g(t) {
    return E(t) ? t.toLowerCase() : t;
  }
  function y(t) {
    if (null == t || T(t)) return !1;
    if (Array.isArray(t) || t instanceof Array || E(t)) return !0;
    const e = "length" in Object(t) && t.length;
    return A(e) && ((e >= 0 && e - 1 in t) || "function" == typeof t.item);
  }
  function v(t) {
    return void 0 === t;
  }
  function b(t) {
    return void 0 !== t;
  }
  function w(t) {
    return null !== t && "object" == typeof t;
  }
  function E(t) {
    return "string" == typeof t;
  }
  function C(t) {
    return null === t;
  }
  function O(t) {
    return null == t;
  }
  function A(t) {
    return "number" == typeof t;
  }
  function S(t) {
    return "[object Date]" === toString.call(t);
  }
  function x(t) {
    switch (toString.call(t)) {
      case "[object Error]":
      case "[object Exception]":
      case "[object DOMException]":
        return !0;
      default:
        return t instanceof Error;
    }
  }
  function k(t) {
    return "function" == typeof t;
  }
  function _(t) {
    return "[object RegExp]" === toString.call(t);
  }
  function T(t) {
    return t && t.window === t;
  }
  function j(t) {
    return t && t.$evalAsync && t.$watch;
  }
  function R(t) {
    return "boolean" == typeof t;
  }
  function L(t) {
    return t && k(t.then);
  }
  function N(t) {
    return E(t) ? t.trim() : t;
  }
  function V(t, e) {
    const n = e;
    return t.replace(/[A-Z]/g, (t, e) => (e ? n : "") + t.toLowerCase());
  }
  function P(t, ...e) {
    return (function (t, e) {
      const n = t.$$hashKey;
      for (let n = 0, r = e.length; n < r; ++n) {
        const r = e[n];
        if (!w(r) && !k(r)) continue;
        const s = Object.keys(r);
        for (let e = 0, n = s.length; e < n; e++) {
          const n = s[e],
            i = r[n];
          t[n] = i;
        }
      }
      return (
        (function (t, e) {
          e ? (t.$$hashKey = e) : delete t.$$hashKey;
        })(t, n),
        t
      );
    })(t, e);
  }
  function M(t) {
    return parseInt(t, 10);
  }
  function D(t) {
    return Number.isNaN(t);
  }
  function I(t, e) {
    return P(Object.create(t), e);
  }
  function U(t) {
    return k(t.toString) && t.toString !== toString;
  }
  function H(t) {
    return !(!t || !(t.nodeName || (t.attr && t.find)));
  }
  function F(t) {
    return g(t.nodeName);
  }
  function q(t, e) {
    return -1 !== Array.prototype.indexOf.call(t, e);
  }
  function B(t, e) {
    const n = t.indexOf(e);
    return n >= 0 && t.splice(n, 1), n;
  }
  function K(t, e) {
    return t === e || (t != t && e != e);
  }
  function z(t, e) {
    if (t === e) return !0;
    if (null === t || null === e) return !1;
    if (t != t && e != e) return !0;
    const n = typeof t;
    let r, s, i;
    if (n === typeof e && "object" === n) {
      if (!Array.isArray(t)) {
        if (S(t)) return !!S(e) && K(t.getTime(), e.getTime());
        if (_(t)) return !!_(e) && t.toString() === e.toString();
        if (j(t) || j(e) || T(t) || T(e) || Array.isArray(e) || S(e) || _(e))
          return !1;
        for (s in ((i = Object.create(null)), t))
          if ("$" !== s.charAt(0) && !k(t[s])) {
            if (!z(t[s], e[s])) return !1;
            i[s] = !0;
          }
        for (s in e)
          if (!(s in i) && "$" !== s.charAt(0) && b(e[s]) && !k(e[s]))
            return !1;
        return !0;
      }
      if (!Array.isArray(e)) return !1;
      if ((r = t.length) === e.length) {
        for (s = 0; s < r; s++) if (!z(t[s], e[s])) return !1;
        return !0;
      }
    }
    return !1;
  }
  function W(t, e) {
    if ("hasOwnProperty" === t)
      throw f("badname", "hasOwnProperty is not a valid {0} name", e);
  }
  function G(t) {
    if (null == t) return "";
    switch (typeof t) {
      case "string":
        break;
      case "number":
        t = `${t}`;
        break;
      default:
        t = !U(t) || Array.isArray(t) || S(t) ? X(t) : t.toString();
    }
    return t;
  }
  function Q(t, e, n) {
    return t.concat(Array.prototype.slice.call(e, n));
  }
  function Y(t, e) {
    return Array.prototype.slice.call(t, e);
  }
  function Z(t, e) {
    const n = arguments.length > 2 ? Y(arguments, 2) : [];
    return !k(e) || e instanceof RegExp
      ? e
      : n.length
        ? function () {
            return arguments.length
              ? e.apply(t, Q(n, arguments, 0))
              : e.apply(t, n);
          }
        : function () {
            return arguments.length ? e.apply(t, arguments) : e.call(t);
          };
  }
  function J(t, e) {
    let n = e;
    return (
      "string" == typeof t && "$" === t.charAt(0) && "$" === t.charAt(1)
        ? (n = void 0)
        : T(e)
          ? (n = "$WINDOW")
          : e && window.document === e
            ? (n = "$DOCUMENT")
            : j(e) && (n = "$SCOPE"),
      n
    );
  }
  function X(t, e) {
    if (!v(t)) return A(e) || (e = e ? 2 : null), JSON.stringify(t, J, e);
  }
  function tt(t, e, n) {
    const r = t.getTimezoneOffset(),
      s = (function (t, e) {
        const n = Date.parse(`Jan 01, 1970 00:00:00 ${t}`) / 6e4;
        return D(n) ? e : n;
      })(e, r);
    return (function (t, e) {
      const n = new Date(t.getTime());
      return n.setMinutes(n.getMinutes() + e), n;
    })(t, 1 * (s - r));
  }
  function et(t) {
    const e = {};
    return (
      (t || "").split("&").forEach((t) => {
        let n, r, s;
        t &&
          ((r = t = t.replace(/\+/g, "%20")),
          (n = t.indexOf("=")),
          -1 !== n && ((r = t.substring(0, n)), (s = t.substring(n + 1))),
          (r = nt(r)),
          b(r) &&
            ((s = !b(s) || nt(s)),
            Object.hasOwnProperty.call(e, r)
              ? Array.isArray(e[r])
                ? e[r].push(s)
                : (e[r] = [e[r], s])
              : (e[r] = s)));
      }),
      e
    );
  }
  function nt(t) {
    try {
      return decodeURIComponent(t);
    } catch (t) {}
  }
  function rt(t) {
    return st(t, !0)
      .replace(/%26/gi, "&")
      .replace(/%3D/gi, "=")
      .replace(/%2B/gi, "+");
  }
  function st(t, e) {
    return encodeURIComponent(t)
      .replace(/%40/gi, "@")
      .replace(/%3A/gi, ":")
      .replace(/%24/g, "$")
      .replace(/%2C/gi, ",")
      .replace(/%3B/gi, ";")
      .replace(/%20/g, e ? "%20" : "+");
  }
  const it = ["ng-", "data-ng-"];
  function ot(t, e) {
    if (Array.isArray(t)) {
      e = e || [];
      for (let n = 0, r = t.length; n < r; n++) e[n] = t[n];
    } else if (w(t)) {
      e = e || {};
      for (const n in t)
        (n.startsWith("$") && "$" === n.charAt(1)) || (e[n] = t[n]);
    }
    return e || t;
  }
  function at(t, e = "Assertion failed") {
    if (!t) throw new Error(e);
  }
  function ct(t, e, n) {
    if (!t) throw f("areq", "Argument '{0}' is {1}", e || "?", n || "required");
    return t;
  }
  function lt(t, e, n) {
    return (
      n && Array.isArray(t) && (t = t[t.length - 1]),
      ct(
        k(t),
        e,
        `not a function, got ${t && "object" == typeof t ? t.constructor.name || "Object" : typeof t}`,
      ),
      t
    );
  }
  const ut = { objectMaxDepth: 5, urlErrorParamsEnabled: !0 };
  function ht(t) {
    var e;
    return (
      w(t) &&
        (b(t.objectMaxDepth) &&
          (ut.objectMaxDepth =
            A((e = t.objectMaxDepth)) && e > 0 ? t.objectMaxDepth : NaN),
        b(t.urlErrorParamsEnabled) &&
          R(t.urlErrorParamsEnabled) &&
          (ut.urlErrorParamsEnabled = t.urlErrorParamsEnabled)),
      ut
    );
  }
  function dt(t) {
    const e = 'https://errors.angularjs.org/"NG_VERSION_FULL"/',
      n = `${e.replace(".", "\\.")}[\\s\\S]*`,
      r = new RegExp(n, "g");
    return function (...n) {
      const s = n[0],
        i = n[1];
      let o = `[${t ? `${t}:` : ""}${s}] `;
      const a = Y(n, 2).map((t) =>
        (function (t) {
          if ("function" == typeof t)
            return t.toString().replace(/ \{[\s\S]*$/, "");
          if (v(t)) return "undefined";
          if ("string" != typeof t) {
            const e = [];
            let n = structuredClone(p(t) ? t.$target : t);
            return JSON.stringify(n, (t, n) => {
              const r = J(t, n);
              if (w(r)) {
                if (e.indexOf(r) >= 0) return "...";
                e.push(r);
              }
              return r;
            });
          }
          return t;
        })(t),
      );
      let c, l;
      if (
        ((o += i.replace(/\{\d+\}/g, (t) => {
          const e = +t.slice(1, -1);
          return e < a.length ? a[e].replace(r, "") : t;
        })),
        (o += `\n${e}${t ? `${t}/` : ""}${s}`),
        ht().urlErrorParamsEnabled)
      )
        for (l = 0, c = "?"; l < a.length; l++, c = "&")
          o += `${c}p${l}=${encodeURIComponent(a[l])}`;
      return new Error(o);
    };
  }
  function pt(t) {
    const e = t && t.$$hashKey;
    if (e) return "function" == typeof e ? t.$$hashKey() : e;
    const n = typeof t;
    return "function" === n || ("object" === n && null !== t)
      ? ((t.$$hashKey = `${n}:${m()}`), t.$$hashKey)
      : "undefined" === n
        ? `${n}:${m()}`
        : `${n}:${t}`;
  }
  function ft(t, e) {
    return t || e
      ? t
        ? e
          ? (Array.isArray(t) && (t = t.join(" ")),
            Array.isArray(e) && (e = e.join(" ")),
            t + " " + e)
          : t
        : e
      : "";
  }
  function $t(t) {
    return t.replace(l, "").replace(u, (t, e, n) => (n ? e.toUpperCase() : e));
  }
  function mt(t) {
    return (function (t, e) {
      if (t.nodeType !== Node.ELEMENT_NODE) return !1;
      const n = t;
      return "true" === n.dataset[e] || "true" === n.getAttribute(e);
    })(t, "animate");
  }
  function gt(t) {
    return !t || !Object.keys(t).length;
  }
  const yt = "ng",
    vt = new Map(),
    bt = "$scope";
  let wt = 1;
  const Et = /-([a-z])/g,
    Ct = /_([a-z])/g,
    Ot = [
      "multiple",
      "selected",
      "checked",
      "disabled",
      "readonly",
      "required",
      "open",
    ],
    At = ["INPUT", "SELECT", "OPTION", "TEXTAREA", "BUTTON", "FORM", "DETAILS"];
  function St(t, e) {
    return e.toUpperCase();
  }
  function xt(t) {
    return t.replace(Et, St);
  }
  function kt(t) {
    return t.replace(Ct, St);
  }
  function _t(t, e) {
    const n = t[yt],
      r = n && vt.get(n);
    r &&
      (e ? delete r.data[e] : (r.data = {}),
      (function (t) {
        const e = t[yt],
          { events: n, data: r } = vt.get(e);
        (r && Object.keys(r).length) ||
          (n && Object.keys(n).length) ||
          (vt.delete(e), (t[yt] = void 0));
      })(t));
  }
  function Tt(t, e = !1) {
    let n = t[yt],
      r = n && vt.get(n);
    return (
      e &&
        !r &&
        ((t[yt] = n = ++wt),
        (r = { events: {}, data: {}, handle: null }),
        vt.set(n, r)),
      r
    );
  }
  function jt(t) {
    return !/<|&#?\w+;/.test(t);
  }
  function Rt(t) {
    switch (t.nodeType) {
      case Node.ELEMENT_NODE:
      case Node.DOCUMENT_NODE:
      case Node.COMMENT_NODE:
      case void 0:
        return !0;
      default:
        return !1;
    }
  }
  function Lt(t, e) {
    t &&
      (Array.isArray(t)
        ? t.forEach((t) => Lt(t, e))
        : (!e && Rt(t) && zt([t]), Rt(t) && zt(t.querySelectorAll("*"))),
      delete t[yt],
      (t.innerHTML = ""));
  }
  function Nt(t, e, n) {
    if (Rt(t)) {
      let r;
      const s = b(n),
        i = !s && e && !w(e),
        o = !e,
        a = Tt(t, !i),
        c = a && a.data;
      if (s) c[xt(e)] = n;
      else {
        if (o) return c;
        if (i) return c && c[xt(e)];
        for (r in e) c[xt(r)] = e[r];
      }
    }
  }
  function Vt(t, e, n) {
    if (Rt(t)) {
      const r = Tt(t, !0);
      (r && r.data)[xt(e)] = n;
    } else t.parentElement && Vt(t.parentElement, e, n);
  }
  function Pt(t, e) {
    if (Rt(t)) {
      const n = Tt(t, !1),
        r = n && n.data;
      if (!e) return;
      return r && r[xt(e)];
    }
  }
  function Mt(t) {
    return Pt(t, bt);
  }
  function Dt(t, e) {
    return Vt(t, bt, e);
  }
  function It(t, e) {
    return Vt(t, "$isolateScope", e);
  }
  function Ut(t, e) {
    return Ht(t, `$${e || "ngController"}Controller`);
  }
  function Ht(t, e) {
    let n;
    for (t.nodeType === Node.DOCUMENT_NODE && (t = t.documentElement); t; ) {
      if (b((n = Pt(t, e)))) return n;
      t =
        t.parentNode || (t.nodeType === Node.DOCUMENT_FRAGMENT_NODE && t.host);
    }
  }
  function Ft(t, e = !1) {
    e || Lt(t);
    const n = t.parentNode;
    n && n.removeChild(t);
  }
  function qt(t) {
    let e;
    if ("string" == typeof t) {
      e = new DOMParser()
        .parseFromString(t, "text/html")
        .body.firstChild.cloneNode(!0);
    } else {
      if (!(t instanceof Element || t instanceof Node))
        throw new Error("Input must be an HTML string or a DOM element.");
      e = t.cloneNode(!0);
    }
    for (; e.firstChild; ) e.removeChild(e.firstChild);
    const n = document.createElement("div");
    n.appendChild(e);
    const r = n.innerHTML;
    try {
      if (e.nodeType === Node.TEXT_NODE) return r.toLowerCase();
      if (e.nodeType === Node.COMMENT_NODE)
        return `\x3c!--${e.data.trim()}--\x3e`;
      {
        const t = r.match(/^(<[^>]+>)/);
        if (t)
          return t[1].replace(/^<([\w-]+)/, (t, e) => "<" + e.toLowerCase());
      }
    } catch (t) {
      return r.toLowerCase();
    }
    return r.toLowerCase();
  }
  function Bt(t) {
    let e = t[0];
    const n = t[t.length - 1];
    let r;
    for (let s = 1; e !== n && (e = e.nextSibling); s++)
      (r || t[s] !== e) &&
        (r || (r = Array.prototype.slice.call(t, 0, s)), r.push(e));
    return r || t;
  }
  function Kt(t, e) {
    const n = e.toLowerCase();
    return !(!Ot.includes(n) || !At.includes(t.nodeName)) && n;
  }
  function zt(t) {
    for (let e = 0, n = t.length; e < n; e++) {
      const n = (vt.get(t[e][yt]) || {}).events;
      n && n.$destroy && t[e].dispatchEvent(new Event("$destroy")), _t(t[e]);
    }
  }
  function Wt(t) {
    return Ht(t, "$injector");
  }
  function Gt(t) {
    const e = document.createElement("template");
    return (e.innerHTML = t.trim()), e.content.firstChild;
  }
  function Qt(t) {
    const e = document.createElement("template");
    return (e.innerHTML = t.trim()), e.content.childNodes;
  }
  function Yt(t) {
    switch ((Lt(t, !0), t.nodeType)) {
      case Node.ELEMENT_NODE:
      case Node.DOCUMENT_NODE:
      case Node.DOCUMENT_FRAGMENT_NODE:
        t.replaceChildren();
    }
  }
  function Zt(t, e, n) {
    if (n) {
      const t = (function (t) {
        const { length: e } = t;
        for (let n = 0; n < e; n++) {
          const e = t[n];
          if (e.nodeType === Node.ELEMENT_NODE) return e;
        }
      })(n);
      !t || t.parentNode || t.previousElementSibling || (n = null);
    }
    n ? n.after(t) : e.prepend(t);
  }
  const Jt = "$provide",
    Xt = "$injector",
    te = "$compileProvider";
  class ee {
    constructor(t, e, n) {
      at(E(t), "name required"),
        at(Array.isArray(e), "requires array required"),
        (this.name = t),
        (this.requires = e),
        (this.invokeQueue = []),
        (this.configBlocks = []),
        (this.runBlocks = []),
        (this.infoState = {}),
        n && this.config(n);
    }
    info(t) {
      return b(t)
        ? (at(w(t), "module info value must be an object"),
          (this.infoState = t),
          this)
        : this.infoState;
    }
    value(t, e) {
      return this.invokeQueue.push([Jt, "value", [t, e]]), this;
    }
    constant(t, e) {
      return this.invokeQueue.unshift([Jt, "constant", [t, e]]), this;
    }
    config(t) {
      return this.configBlocks.push([Xt, "invoke", [t]]), this;
    }
    run(t) {
      return this.runBlocks.push(t), this;
    }
    component(t, e) {
      return (
        e && k(e) && (e.$$moduleName = t),
        this.invokeQueue.push([te, "component", [t, e]]),
        this
      );
    }
    factory(t, e) {
      return (
        e && k(e) && (e.$$moduleName = t),
        this.invokeQueue.push([Jt, "factory", [t, e]]),
        this
      );
    }
    service(t, e) {
      return (
        e && k(e) && (e.$$moduleName = t),
        this.invokeQueue.push([Jt, "service", [t, e]]),
        this
      );
    }
    provider(t, e) {
      return (
        e && k(e) && (e.$$moduleName = t),
        this.invokeQueue.push([Jt, "provider", [t, e]]),
        this
      );
    }
    decorator(t, e) {
      return (
        e && k(e) && (e.$$moduleName = t),
        this.configBlocks.push([Jt, "decorator", [t, e]]),
        this
      );
    }
    directive(t, e) {
      return (
        e && k(e) && (e.$$moduleName = t),
        this.invokeQueue.push([te, "directive", [t, e]]),
        this
      );
    }
    animation(t, e) {
      return (
        e && k(e) && (e.$$moduleName = t),
        this.invokeQueue.push(["$animateProvider", "register", [t, e]]),
        this
      );
    }
    filter(t, e) {
      return (
        e && k(e) && (e.$$moduleName = t),
        this.invokeQueue.push(["$filterProvider", "register", [t, e]]),
        this
      );
    }
    controller(t, e) {
      return (
        e && k(e) && (e.$$moduleName = t),
        this.invokeQueue.push(["$controllerProvider", "register", [t, e]]),
        this
      );
    }
  }
  const ne = /^([^(]+?)=>/,
    re = /^[^(]*\(\s*([^)]*)\)/m,
    se = /,/,
    ie = /^\s*(_?)(\S+?)\1\s*$/,
    oe = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
    ae = dt(Xt),
    ce = "Provider",
    le = !0;
  class ue {
    constructor(t) {
      (this.cache = {}),
        (this.strictDi = t),
        (this.path = []),
        (this.modules = {});
    }
    get(t) {
      if (Object.prototype.hasOwnProperty.call(this.cache, t)) {
        if (this.cache[t] === le)
          throw ae(
            "cdep",
            "Circular dependency found: {0}",
            `${t} <- ${this.path.join(" <- ")}`,
          );
        return this.cache[t];
      }
      this.path.unshift(t), (this.cache[t] = le);
      try {
        this.cache[t] = this.factory(t);
      } catch (e) {
        throw (delete this.cache[t], e);
      }
      return this.cache[t];
    }
    injectionArgs(t, e, n) {
      const r = [],
        s = (function (t, e, n) {
          let r, s, i;
          if ("function" == typeof t) {
            if (!(r = t.$inject)) {
              if (((r = []), t.length)) {
                if (e)
                  throw ae(
                    "strictdi",
                    "{0} is not using explicit annotation and cannot be invoked in strict mode",
                    n,
                  );
                (s = (function (t) {
                  const e = pe(t).replace(oe, ""),
                    n = e.match(ne) || e.match(re);
                  return n;
                })(t)),
                  s[1].split(se).forEach(function (t) {
                    t.replace(ie, function (t, e, n) {
                      r.push(n);
                    });
                  });
              }
              t.$inject = r;
            }
          } else
            Array.isArray(t)
              ? ((i = t.length - 1), lt(t[i], "fn"), (r = t.slice(0, i)))
              : lt(t, "fn", !0);
          return r;
        })(t, this.strictDi, n);
      for (let t = 0, { length: n } = s; t < n; t++) {
        const n = s[t];
        if ("string" != typeof n)
          throw ae(
            "itkn",
            "Incorrect injection token! Expected service name as string, got {0}",
            n,
          );
        r.push(
          e && Object.prototype.hasOwnProperty.call(e, n) ? e[n] : this.get(n),
        );
      }
      return r;
    }
    invoke(t, e, n, r) {
      "string" == typeof n && ((r = n), (n = null));
      const s = this.injectionArgs(t, n, r);
      if ((Array.isArray(t) && (t = t[t.length - 1]), /^class\b/.test(pe(t)))) {
        s.unshift(null);
        return new (Function.prototype.bind.apply(t, s))();
      }
      return t.apply(e, s);
    }
    instantiate(t, e, n) {
      const r = Array.isArray(t) ? t[t.length - 1] : t,
        s = this.injectionArgs(t, e, n);
      return s.unshift(null), new (Function.prototype.bind.apply(r, s))();
    }
    loadNewModules() {}
    factory(t) {
      console.error(`Unhandled ${t}`);
    }
  }
  class he extends ue {
    constructor(t, e) {
      super(e), (this.cache = t);
    }
    factory(t) {
      throw (
        (this.path.push(t),
        ae("unpr", "Unknown provider: {0}", this.path.join(" <- ")))
      );
    }
  }
  class de extends ue {
    constructor(t, e) {
      super(t),
        (this.providerInjector = e),
        (this.modules = this.providerInjector.modules);
    }
    factory(t) {
      const e = this.providerInjector.get(t + ce);
      return this.invoke(e.$get, e, void 0, t);
    }
    has(t) {
      const e = Object.prototype.hasOwnProperty.call(
          this.providerInjector.cache,
          t + ce,
        ),
        n = Object.prototype.hasOwnProperty.call(this.cache, t);
      return e || n;
    }
  }
  function pe(t) {
    return Function.prototype.toString.call(t);
  }
  const fe = /^([^(]+?)=>/,
    $e = /^[^(]*\(\s*([^)]*)\)/m,
    me = /,/,
    ge = /^\s*(_?)(\S+?)\1\s*$/,
    ye = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
    ve = dt(Xt),
    be = "Provider";
  function we(t, e = !1) {
    at(Array.isArray(t), "modules required");
    const n = new Map(),
      r = {
        $provide: {
          provider: Oe(c),
          factory: Oe(l),
          service: Oe(function (t, e) {
            return l(t, [Xt, (t) => t.instantiate(e)]);
          }),
          value: Oe(function (t, e) {
            return (r[t + be] = { $get: () => e });
          }),
          constant: Oe(function (t, e) {
            W(t, "constant"), (s.cache[t] = e), (i.cache[t] = e);
          }),
          decorator: function (t, e) {
            const n = s.get(t + be),
              r = n.$get;
            n.$get = function () {
              const t = o.invoke(r, n);
              return o.invoke(e, null, { $delegate: t });
            };
          },
        },
      },
      s = (r.$injector = new he(r, e)),
      i = new de(e, s);
    r.$injectorProvider = { $get: () => i };
    let o = i;
    const a = u(t);
    return (
      (o = i.get(Xt)),
      a.forEach((t) => {
        t && o.invoke(t);
      }),
      (o.loadNewModules = function (t) {
        u(t).forEach((t) => {
          t && o.invoke(t);
        });
      }),
      o
    );
    function c(t, e) {
      let n;
      if (
        (W(t, "service"),
        (n = k(e) || Array.isArray(e) ? s.instantiate(e) : e),
        !n.$get)
      )
        throw ve("pget", "Provider '{0}' must define $get factory method.", t);
      return (r[t + be] = n), n;
    }
    function l(t, e) {
      return c(t, {
        $get: () => {
          const n = o.invoke(e, this);
          if (v(n))
            throw ve(
              "undef",
              "Provider '{0}' must return a value from $get factory method.",
              t,
            );
          return n;
        },
      });
    }
    function u(t) {
      ct(v(t) || Array.isArray(t), "modulesToLoad", "not an array");
      let e = [];
      return (
        t.forEach((t) => {
          if (!n.get(t)) {
            n.set(t, !0);
            try {
              if (E(t)) {
                const n = window.angular.module(t);
                (o.modules[t] = n),
                  (e = e.concat(u(n.requires)).concat(n.runBlocks));
                n.invokeQueue.concat(n.configBlocks).forEach((t) => {
                  const e = s.get(t[0]);
                  e[t[1]].apply(e, t[2]);
                });
              } else
                k(t) || Array.isArray(t)
                  ? e.push(s.invoke(t))
                  : lt(t, "module");
            } catch (e) {
              throw (
                (Array.isArray(t) && (t = t[t.length - 1]),
                e.message &&
                  e.stack &&
                  -1 === e.stack.indexOf(e.message) &&
                  (e.message = `${e.message}\n${e.stack}`),
                ve(
                  "modulerr",
                  "Failed to instantiate module {0} due to:\n{1}",
                  t,
                  e.stack || e.message || e,
                ))
              );
            }
          }
        }),
        e
      );
    }
  }
  function Ee(t) {
    const e = (function (t) {
      return Function.prototype.toString.call(t);
    })(t).replace(ye, "");
    return e.match(fe) || e.match($e);
  }
  function Ce(t, e, n) {
    let r, s, i;
    if ("function" == typeof t) {
      if (!(r = t.$inject)) {
        if (((r = []), t.length)) {
          if (e)
            throw ve(
              "strictdi",
              "{0} is not using explicit annotation and cannot be invoked in strict mode",
              n,
            );
          (s = Ee(t)),
            s[1].split(me).forEach(function (t) {
              t.replace(ge, function (t, e, n) {
                r.push(n);
              });
            });
        }
        t.$inject = r;
      }
    } else
      Array.isArray(t)
        ? ((i = t.length - 1), lt(t[i], "fn"), (r = t.slice(0, i)))
        : lt(t, "fn", !0);
    return r;
  }
  function Oe(t) {
    return function (e, n) {
      if (!w(e)) return t(e, n);
      Object.entries(e).forEach(([e, n]) => {
        t(e, n);
      });
    };
  }
  class Ae {
    constructor(t) {
      if (
        (ct(t, "element"),
        (this.initial = null),
        (this._node = null),
        (this._element = void 0),
        (this._nodes = void 0),
        (this.linked = !1),
        (this.isList = !1),
        E(t))
      ) {
        this.initial = t;
        let e = Gt(t);
        switch (!0) {
          case e instanceof Element:
            this.element = e;
            break;
          case e instanceof Node:
            this.node = e;
        }
      } else if (t instanceof NodeList)
        (this.initial = Array.from(t).map((t) => t.cloneNode(!0))),
          1 == t.length
            ? (this.node = t[0])
            : ((this._nodes = Array.from(t)), (this.isList = !0));
      else if (t instanceof Element)
        (this.initial = t.cloneNode(!0)), (this.element = t);
      else if (t instanceof Node)
        (this.initial = t.cloneNode(!0)), (this._node = t);
      else {
        if (!(t instanceof Array))
          throw new Error("Invalid element passed to NodeRef");
        1 == t.length
          ? ((this.initial = t[0].cloneNode(!0)), (this.node = t[0]))
          : ((this.initial = Array.from(t).map((t) => t.cloneNode(!0))),
            (this.nodes = t));
      }
    }
    get element() {
      return ct(this._element, "element"), this._element;
    }
    set element(t) {
      ct(t instanceof Element, "element"),
        (this._element = t),
        (this._nodes = void 0),
        (this.isList = !1);
    }
    get node() {
      return (
        ct(this._node || this._element, "node"), this._node || this._element
      );
    }
    set node(t) {
      ct(t instanceof Node, "node"),
        (this._node = t),
        t.nodeType === Node.ELEMENT_NODE
          ? (this._element = t)
          : (this._element = void 0);
    }
    set nodes(t) {
      ct(Array.isArray(t) && t.every((t) => t instanceof Node), "nodes"),
        (this._nodes = t),
        (this.isList = !0);
    }
    get nodes() {
      return ct(this._nodes, "nodes"), this._nodes;
    }
    get nodelist() {
      if ((ct(this.isList, "nodes"), 0 === this._nodes.length))
        return this._nodes;
      if (this._nodes[0].parentElement)
        return this._nodes[0].parentElement.childNodes;
      {
        const t = document.createDocumentFragment();
        return (
          this._nodes.forEach((e) => {
            t.appendChild(e);
          }),
          t.childNodes
        );
      }
    }
    get dom() {
      return this.isList ? this.nodelist : this.node;
    }
    get size() {
      return this.isList ? this._nodes.length : 1;
    }
    getAny() {
      return this.isList ? this._nodes[0] : this._element || this._node;
    }
    getAll() {
      return this.isList ? this._nodes : this._element || this._node;
    }
    collection() {
      return this.isList
        ? Array.from(this._nodes)
        : [this._element || this._node];
    }
    setAll(t) {
      return (
        ct(t, "nodes"),
        t instanceof NodeList
          ? (this._nodes = Array.from(t))
          : Array.isArray(t)
            ? (this.nodes = t)
            : (this.node = t)
      );
    }
    getIndex(t) {
      return this.isList ? this._nodes[t] : this.node;
    }
    setIndex(t, e) {
      ct(null !== t, "index"),
        ct(e, "node"),
        this.isList ? (this._nodes[t] = e) : (this.node = e);
    }
    clone() {
      const t = this.isList
        ? this.nodes.map((t) => t.cloneNode(!0))
        : this.node.cloneNode(!0);
      return new Ae(t);
    }
    isElement() {
      return void 0 !== this._element;
    }
  }
  const Se = dt("$controller"),
    xe = /^(\S+)(\s+as\s+([\w$]+))?$/;
  function ke(t, e) {
    if (E(t)) {
      const e = xe.exec(t);
      if (e) return e[3];
    }
  }
  class _e {
    constructor() {
      this.controllers = new Map();
    }
    has(t) {
      return this.controllers.has(t);
    }
    register(t, e) {
      W(t, "controller"),
        w(t)
          ? Object.entries(t).forEach(([t, e]) => {
              this.controllers.set(t, e);
            })
          : this.controllers.set(t, e);
    }
    $get = [
      "$injector",
      (t) => (e, n, r, s) => {
        let i,
          o,
          a,
          c = s && E(s) ? s : null;
        if (((r = !0 === r), E(e))) {
          if (((o = e.match(xe)), !o))
            throw Se(
              "ctrlfmt",
              "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.",
              e,
            );
          if (((a = o[1]), (c = c || o[3]), !(e = this.controllers.get(a))))
            throw Se(
              "ctrlreg",
              "The controller with the name '{0}' is not registered.",
              a,
            );
          lt(e, a, !0);
        }
        if (r) {
          const r = (Array.isArray(e) ? e[e.length - 1] : e).prototype;
          return (
            (i = Object.create(r || null)),
            c &&
              ((i.$controllerIdentifier = c),
              this.addIdentifier(n, c, i, a || e.name)),
            function () {
              const r = t.invoke(e, i, n, a);
              return (
                r !== i &&
                  (w(r) || k(r)) &&
                  ((i = r),
                  c &&
                    ((i.$controllerIdentifier = c),
                    this.addIdentifier(n, c, i, a || e.name))),
                i
              );
            }.bind(this, { instance: i, identifier: c })
          );
        }
        return (
          (i = t.instantiate(e, n, a)),
          c && this.addIdentifier(n, c, i, a || e.name),
          i
        );
      },
    ];
    addIdentifier(t, e, n, r) {
      if (!t || !w(t.$scope))
        throw dt("$controller")(
          "noscp",
          "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
          r,
          e,
        );
      t.$scope[e] = n;
    }
  }
  const Te = document.createElement("a"),
    je = Le(window.location.href);
  let Re;
  function Le(t) {
    if (!E(t)) return t;
    const e = t;
    Te.setAttribute("href", e);
    let { hostname: n } = Te;
    return (
      !("[::1]" === Te.hostname) && n.indexOf(":") > -1 && (n = `[${n}]`),
      {
        href: Te.href,
        protocol: Te.protocol ? Te.protocol.replace(/:$/, "") : "",
        host: Te.host,
        search: Te.search ? Te.search.replace(/^\?/, "") : "",
        hash: Te.hash ? Te.hash.replace(/^#/, "") : "",
        hostname: n,
        port: Te.port,
        pathname:
          "/" === Te.pathname.charAt(0) ? Te.pathname : `/${Te.pathname}`,
      }
    );
  }
  function Ne(t) {
    return Ve(
      t,
      (function () {
        if (document.baseURI) return document.baseURI;
        Re ||
          ((Re = document.createElement("a")),
          (Re.href = "."),
          (Re = Re.cloneNode(!1)));
        return Re.href;
      })(),
    );
  }
  function Ve(t, e) {
    return (
      (t = Le(t)), (e = Le(e)), t.protocol === e.protocol && t.host === e.host
    );
  }
  Te.href = "http://[::1]";
  const Pe = dt("$sce"),
    Me = {
      HTML: "html",
      CSS: "css",
      MEDIA_URL: "mediaUrl",
      URL: "url",
      RESOURCE_URL: "resourceUrl",
      JS: "js",
    };
  function De(t) {
    if ("self" === t) return t;
    if (E(t)) {
      if (t.indexOf("***") > -1)
        throw Pe(
          "iwcard",
          "Illegal sequence *** in string matcher.  String: {0}",
          t,
        );
      return (
        (t = ((e = t), e.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1"))
          .replace(/\\\*\\\*/g, ".*")
          .replace(/\\\*/g, "[^:/.?&;]*")),
        new RegExp(`^${t}$`)
      );
    }
    var e;
    if (_(t)) return new RegExp(`^${t.source}$`);
    throw Pe(
      "imatcher",
      'Matchers may only be "self", string patterns or RegExp objects',
    );
  }
  function Ie() {
    this.SCE_CONTEXTS = Me;
    let t = ["self"],
      e = [];
    (this.trustedResourceUrlList = function (e) {
      return arguments.length && (t = e.map((t) => De(t))), t;
    }),
      (this.bannedResourceUrlList = function (t) {
        return arguments.length && (e = t.map((t) => De(t))), e;
      }),
      (this.$get = [
        "$injector",
        "$$sanitizeUri",
        function (n, r) {
          let s = function () {
            throw Pe(
              "unsafe",
              "Attempting to use an unsafe value in a safe context.",
            );
          };
          function i(t, e) {
            return "self" === t ? Ve(e, je) || Ne(e) : !!t.exec(e.href);
          }
          function o(t) {
            const e = function (t) {
              this.$$unwrapTrustedValue = function () {
                return t;
              };
            };
            return (
              t && (e.prototype = new t()),
              (e.prototype.valueOf = function () {
                return this.$$unwrapTrustedValue();
              }),
              (e.prototype.toString = function () {
                return this.$$unwrapTrustedValue().toString();
              }),
              e
            );
          }
          n.has("$sanitize") && (s = n.get("$sanitize"));
          const a = o(),
            c = {};
          return (
            (c[Me.HTML] = o(a)),
            (c[Me.CSS] = o(a)),
            (c[Me.MEDIA_URL] = o(a)),
            (c[Me.URL] = o(c[Me.MEDIA_URL])),
            (c[Me.JS] = o(a)),
            (c[Me.RESOURCE_URL] = o(c[Me.URL])),
            {
              trustAs: function (t, e) {
                const n = Object.prototype.hasOwnProperty.call(c, t)
                  ? c[t]
                  : null;
                if (!n)
                  throw Pe(
                    "icontext",
                    "Attempted to trust a value in invalid context. Context: {0}; Value: {1}",
                    t,
                    e,
                  );
                if (null === e || v(e) || "" === e) return e;
                if ("string" != typeof e)
                  throw Pe(
                    "itype",
                    "Attempted to trust a non-string value in a content requiring a string: Context: {0}",
                    t,
                  );
                return new n(e);
              },
              getTrusted: function (n, o) {
                if (null === o || v(o) || "" === o) return o;
                const a = Object.prototype.hasOwnProperty.call(c, n)
                  ? c[n]
                  : null;
                if (a && o instanceof a) return o.$$unwrapTrustedValue();
                if (
                  (k(o.$$unwrapTrustedValue) && (o = o.$$unwrapTrustedValue()),
                  n === Me.MEDIA_URL || n === Me.URL)
                )
                  return r(o.toString(), n === Me.MEDIA_URL);
                if (n === Me.RESOURCE_URL) {
                  if (
                    (function (n) {
                      const r = Le(n.toString());
                      let s,
                        o,
                        a = !1;
                      for (s = 0, o = t.length; s < o; s++)
                        if (i(t[s], r)) {
                          a = !0;
                          break;
                        }
                      if (a)
                        for (s = 0, o = e.length; s < o; s++)
                          if (i(e[s], r)) {
                            a = !1;
                            break;
                          }
                      return a;
                    })(o)
                  )
                    return o;
                  throw Pe(
                    "insecurl",
                    "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}",
                    o.toString(),
                  );
                }
                if (n === Me.HTML) return s();
                throw Pe(
                  "unsafe",
                  "Attempting to use an unsafe value in a safe context.",
                );
              },
              valueOf: function (t) {
                return t instanceof a ? t.$$unwrapTrustedValue() : t;
              },
            }
          );
        },
      ]);
  }
  function Ue() {
    let t = !0;
    (this.enabled = function (e) {
      return arguments.length && (t = !!e), t;
    }),
      (this.$get = [
        "$parse",
        "$sceDelegate",
        "$exceptionHandler",
        function (e, n, r) {
          const s = ot(Me);
          (s.isEnabled = function () {
            return t;
          }),
            (s.trustAs = n.trustAs),
            (s.getTrusted = n.getTrusted),
            (s.valueOf = n.valueOf),
            t ||
              ((s.trustAs = s.getTrusted =
                function (t, e) {
                  return e;
                }),
              (s.valueOf = function (t) {
                return t;
              })),
            (s.parseAs = function (t, n) {
              const r = e(n);
              return r.literal && r.constant
                ? r
                : e(n, (e) => s.getTrusted(t, e));
            });
          const i = s.parseAs,
            { getTrusted: o } = s,
            { trustAs: a } = s;
          return (
            Object.entries(Me).forEach(([t, e]) => {
              const n = g(t);
              (s[kt(`parse_as_${n}`)] = function (t) {
                return i(e, t);
              }),
                (s[kt(`get_trusted_${n}`)] = function (t) {
                  try {
                    return o(e, t);
                  } catch (t) {
                    r(t);
                  }
                }),
                (s[kt(`trust_as_${n}`)] = function (t) {
                  return a(e, t);
                });
            }),
            s
          );
        },
      ]);
  }
  const He = {};
  function Fe(t, e, n, r) {
    return {
      restrict: "A",
      compile(s, i) {
        const o = t(i[n]);
        return function (t, n) {
          n.addEventListener(r, (n) => {
            try {
              o(t, { $event: n });
            } catch (t) {
              e(t);
            }
          });
        };
      },
    };
  }
  "click copy cut dblclick focus blur keydown keyup keypress load mouseover mousein mouseout mouseleave paste submit touchstart touchend touchmove"
    .split(" ")
    .forEach((t) => {
      const e = $t(`ng-${t}`);
      He[e] = ["$parse", "$exceptionHandler", (n, r) => Fe(n, r, e, t)];
    });
  const qe = dt("$compile"),
    Be = /^\w/,
    Ke = document.createElement("div");
  class ze {
    static $nonscope = !0;
    constructor(t, e, n, r, s, i) {
      if (
        ((this.$rootScope = t),
        (this.$animate = e),
        (this.$exceptionHandler = n),
        (this.$sce = r),
        i)
      ) {
        const t = Object.keys(i);
        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e];
          this[n] = i[n];
        }
      } else this.$attr = {};
      this.$nodeRef = s;
    }
    get $$element() {
      return this.$nodeRef.node;
    }
    $normalize = $t;
    $addClass(t) {
      t &&
        t.length > 0 &&
        (mt(this.$$element)
          ? this.$animate.addClass(this.$$element, t)
          : this.$nodeRef.element.classList.add(t));
    }
    $removeClass(t) {
      t &&
        t.length > 0 &&
        (mt(this.$$element)
          ? this.$animate.removeClass(this.$$element, t)
          : this.$nodeRef.element.classList.remove(t));
    }
    $updateClass(t, e) {
      const n = We(t, e);
      n &&
        n.length &&
        (mt(this.$$element)
          ? this.$animate.addClass(this.$$element, n)
          : this.$nodeRef.element.classList.add(...n.trim().split(/\s+/)));
      const r = We(e, t);
      r &&
        r.length &&
        (mt(this.$$element)
          ? this.$animate.removeClass(this.$$element, r)
          : this.$nodeRef.element.classList.remove(...r.trim().split(/\s+/)));
    }
    $set(t, e, n, r) {
      const s = Kt(this.$$element, t),
        i = h[t];
      let o = t;
      if (
        (s ? ((this.$$element[t] = e), (r = s)) : i && ((this[i] = e), (o = i)),
        (this[t] = e),
        r
          ? (this.$attr[t] = r)
          : (r = this.$attr[t]) || (this.$attr[t] = r = V(t, "-")),
        "img" === this.$nodeRef.node.nodeName.toLowerCase() &&
          "srcset" === t &&
          (this[t] = e = this.sanitizeSrcset(e, "$set('srcset', value)")),
        !1 !== n)
      ) {
        let t = p(this.$$element) ? this.$$element.$target : this.$$element;
        null === e || v(e)
          ? t.removeAttribute(r)
          : Be.test(r)
            ? s && !1 === e
              ? t.removeAttribute(r)
              : s
                ? t.toggleAttribute(r, e)
                : t.setAttribute(r, e)
            : this.setSpecialAttr(this.$$element, r, e);
      }
      const { $$observers: a } = this;
      a &&
        a[o] &&
        a[o].forEach((t) => {
          try {
            t(e);
          } catch (t) {
            this.$exceptionHandler(t);
          }
        });
    }
    $observe(t, e) {
      const n = this.$$observers || (this.$$observers = Object.create(null)),
        r = n[t] || (n[t] = []);
      return (
        r.push(e),
        r.$$inter ||
          !Object.prototype.hasOwnProperty.call(this, t) ||
          v(this[t]) ||
          e(this[t]),
        function () {
          B(r, e);
        }
      );
    }
    setSpecialAttr(t, e, n) {
      Ke.innerHTML = `<span ${e}>`;
      const { attributes: r } = Ke.firstChild,
        s = r[0];
      r.removeNamedItem(s.name), (s.value = n), t.attributes.setNamedItem(s);
    }
    sanitizeSrcset(t, e) {
      if (!t) return t;
      if (!E(t))
        throw qe(
          "srcset",
          'Can\'t pass trusted values to `{0}`: "{1}"',
          e,
          t.toString(),
        );
      for (
        var n = "",
          r = N(t),
          s = /\s/.test(r) ? /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/ : /(,)/,
          i = r.split(s),
          o = Math.floor(i.length / 2),
          a = 0;
        a < o;
        a++
      ) {
        var c = 2 * a;
        (n += this.$sce.getTrustedMediaUrl(N(i[c]))), (n += " " + N(i[c + 1]));
      }
      var l = N(i[2 * a]).split(/\s/);
      return (
        (n += this.$sce.getTrustedMediaUrl(N(l[0]))),
        2 === l.length && (n += " " + N(l[1])),
        n
      );
    }
  }
  function We(t, e) {
    const n = new Set(t.split(/\s+/)),
      r = new Set(e.split(/\s+/));
    return [...n].filter((t) => !r.has(t)).join(" ");
  }
  function Ge(t, e) {
    return {
      restrict: "A",
      compile: () => (n, r) => {
        const s = r;
        "" === e && (e = t);
        const i = xt(e);
        n[i] || (n[i] = s.getAttribute(t));
        const o = new MutationObserver((e) => {
          const r = e[0].target.getAttribute(t);
          n[i] !== r && (n[i] = r);
        });
        o.observe(s, { attributes: !0, attributeFilter: [t] }),
          n.$on("$destroy", () => {
            o.disconnect();
          });
      },
    };
  }
  const Qe = dt("$compile"),
    Ye = ["ngIf", "ngRepeat"],
    Ze = ["ngSrc", "ngSrcset", "src", "srcset"],
    Je = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/,
    Xe = /^(on[a-z]+|formaction)$/,
    tn = "Directive";
  function en(t, e) {
    const n = {},
      r = Object.create(null);
    function s(t, e, n) {
      const s = /^([@&]|[=<]())(\??)\s*([\w$]*)$/,
        i = Object.create(null);
      return (
        Object.entries(t).forEach(([t, o]) => {
          if ((o = o.trim()) in r) return void (i[t] = r[o]);
          const a = o.match(s);
          if (!a)
            throw Qe(
              "iscp",
              "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}",
              e,
              t,
              o,
              n ? "controller bindings definition" : "isolate scope definition",
            );
          (i[t] = {
            mode: a[1][0],
            collection: "*" === a[2],
            optional: "?" === a[3],
            attrName: a[4] || t,
          }),
            a[4] && (r[o] = i[t]);
        }),
        i
      );
    }
    function i(t, e) {
      const n = { isolateScope: null, bindToController: null };
      if (
        (w(t.scope) &&
          (!0 === t.bindToController
            ? ((n.bindToController = s(t.scope, e, !0)), (n.isolateScope = {}))
            : (n.isolateScope = s(t.scope, e, !1))),
        w(t.bindToController) &&
          (n.bindToController = s(t.bindToController, e, !0)),
        n.bindToController && !t.controller)
      )
        throw Qe(
          "noctrl",
          "Cannot bind to controller without directive '{0}'s controller.",
          e,
        );
      return n;
    }
    (this.directive = function e(r, s) {
      return (
        ct(r, "name"),
        W(r, "directive"),
        E(r)
          ? (!(function (t) {
              const e = t.charAt(0);
              if (!e || e !== g(e))
                throw Qe(
                  "baddir",
                  "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter",
                  t,
                );
              if (t !== t.trim())
                throw Qe(
                  "baddir",
                  "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces",
                  t,
                );
            })(r),
            ct(s, "directiveFactory"),
            Object.prototype.hasOwnProperty.call(n, r) ||
              ((n[r] = []),
              t.factory(r + tn, [
                "$injector",
                "$exceptionHandler",
                function (t, e) {
                  const s = [];
                  return (
                    n[r].forEach((n, i) => {
                      try {
                        let e = t.invoke(n);
                        const o = (t) => () => t;
                        k(e)
                          ? (e = { compile: o(e) })
                          : !e.compile && e.link && (e.compile = o(e.link)),
                          (e.priority = e.priority || 0),
                          (e.index = i),
                          (e.name = e.name || r),
                          (e.require = (function (t) {
                            const e = t.require || (t.controller && t.name);
                            return (
                              !Array.isArray(e) &&
                                w(e) &&
                                Object.entries(e).forEach(([t, n]) => {
                                  const r = n.match(Je);
                                  n.substring(r[0].length) || (e[t] = r[0] + t);
                                }),
                              e
                            );
                          })(e)),
                          (e.restrict = (function (t, e) {
                            if (t && (!E(t) || !/[EA]/.test(t)))
                              throw Qe(
                                "badrestrict",
                                "Restrict property '{0}' of directive '{1}' is invalid",
                                t,
                                e,
                              );
                            return t || "EA";
                          })(e.restrict, r)),
                          (e.$$moduleName = n.$$moduleName),
                          s.push(e);
                      } catch (t) {
                        e(t);
                      }
                    }),
                    s
                  );
                },
              ])),
            n[r].push(s))
          : Object.entries(r).forEach(([t, n]) => e(t, n)),
        this
      );
    }),
      (this.component = function (t, e) {
        if (!E(t))
          return (
            Object.entries(t).forEach(([t, e]) => this.component(t, e)), this
          );
        const n = e.controller || function () {};
        function r(t) {
          function r(e) {
            return k(e) || Array.isArray(e)
              ? function (n, r) {
                  return t.invoke(e, this, { $element: n, $attrs: r });
                }
              : e;
          }
          const s = e.template || e.templateUrl ? e.template : "",
            i = {
              controller: n,
              controllerAs: ke(e.controller) || e.controllerAs || "$ctrl",
              template: r(s),
              templateUrl: r(e.templateUrl),
              transclude: e.transclude,
              scope: {},
              bindToController: e.bindings || {},
              restrict: "E",
              require: e.require,
            };
          return (
            Object.entries(e).forEach(([t, e]) => {
              "$" === t.charAt(0) && (i[t] = e);
            }),
            i
          );
        }
        return (
          Object.entries(e).forEach(([t, e]) => {
            "$" === t.charAt(0) && ((r[t] = e), k(n) && (n[t] = e));
          }),
          (r.$inject = ["$injector"]),
          this.directive(t, r)
        );
      }),
      (this.aHrefSanitizationTrustedUrlList = function (t) {
        return b(t)
          ? (e.aHrefSanitizationTrustedUrlList(t), this)
          : e.aHrefSanitizationTrustedUrlList();
      }),
      (this.imgSrcSanitizationTrustedUrlList = function (t) {
        return b(t)
          ? (e.imgSrcSanitizationTrustedUrlList(t), this)
          : e.imgSrcSanitizationTrustedUrlList();
      });
    let o = !1;
    this.strictComponentBindingsEnabled = function (t) {
      return b(t) ? ((o = t), this) : o;
    };
    const a = Object.create(null);
    (this.addPropertySecurityContext = function (t, e, n) {
      const r = `${t.toLowerCase()}|${e.toLowerCase()}`;
      if (r in a && a[r] !== n)
        throw Qe(
          "ctxoverride",
          "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.",
          t,
          e,
          a[r],
          n,
        );
      return (a[r] = n), this;
    }),
      (function () {
        function t(t, e) {
          e.forEach((e) => {
            a[e.toLowerCase()] = t;
          });
        }
        t(Me.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]),
          t(Me.CSS, ["*|style"]),
          t(Me.URL, [
            "area|href",
            "area|ping",
            "a|href",
            "a|ping",
            "blockquote|cite",
            "body|background",
            "del|cite",
            "input|src",
            "ins|cite",
            "q|cite",
          ]),
          t(Me.MEDIA_URL, [
            "audio|src",
            "img|src",
            "img|srcset",
            "source|src",
            "source|srcset",
            "track|src",
            "video|src",
            "video|poster",
          ]),
          t(Me.RESOURCE_URL, [
            "*|formAction",
            "applet|code",
            "applet|codebase",
            "base|href",
            "embed|src",
            "frame|src",
            "form|action",
            "head|profile",
            "html|manifest",
            "iframe|src",
            "link|href",
            "media|src",
            "object|codebase",
            "object|data",
            "script|src",
          ]);
      })(),
      (this.$get = [
        "$injector",
        "$interpolate",
        "$exceptionHandler",
        "$templateRequest",
        "$parse",
        "$controller",
        "$rootScope",
        "$sce",
        "$animate",
        function (t, e, r, s, c, u, h, d, f) {
          let $;
          function m() {
            for (let t = 0, e = $.length; t < e; ++t)
              try {
                $[t]();
              } catch (t) {
                r(t);
              }
            $ = void 0;
          }
          const g = e.startSymbol(),
            y = e.endSymbol(),
            C =
              "{{" === g && "}}" === y
                ? (t) => t
                : (t) => t.replace(/\{\{/g, g).replace(/}}/g, y),
            O = /^ng(Attr|Prop|On|Observe)([A-Z].*)$/;
          return A;
          function A(t, e, n, r, s) {
            let i = new Ae(t),
              o = S(i, e, n, r, s),
              a = null;
            return function (t, e, n) {
              if (!i)
                throw Qe("multilink", "This element has already been linked.");
              ct(t, "scope"), i.getAny() && Dt(i.getAny(), t);
              s && s.needsNewScope && (t = t.$parent.$new());
              n = n || {};
              let r,
                {
                  transcludeControllers: c,
                  parentBoundTranscludeFn: l,
                  futureParentElement: u,
                } = n;
              l && l.$$boundTransclude && (l = l.$$boundTransclude);
              a ||
                (a = (function (t) {
                  const e = t;
                  if (!e) return "html";
                  return "foreignobject" !== F(e) &&
                    toString.call(e).match(/SVG/)
                    ? "svg"
                    : "html";
                })(u));
              if ("html" !== a) {
                const t = Gt("<div></div>");
                t.append(i.node);
                const e = G(a, t.innerHTML);
                r = new Ae(e[0]);
              } else r = e ? i.clone() : i;
              if (c)
                for (const t in c)
                  ct(r.element, "element"),
                    Vt(r.element, `$${t}Controller`, c[t].instance);
              e && e(r.dom, t);
              o && o(t, r, l);
              e || (i = o = null);
              return (r.linked = !0), r.getAll();
            };
          }
          function S(t, e, n, s, i) {
            const o = [];
            let a,
              c = !1;
            for (let l = 0; l < t.size; l++) {
              const u = new ze(h, f, r, d),
                p = T(t.getIndex(l), u, 0 === l ? n : void 0, s);
              let $, m, g;
              if (
                (($ = p.length
                  ? V(
                      p,
                      t.getIndex(l),
                      u,
                      e,
                      null,
                      [],
                      [],
                      Object.assign({}, i, {
                        index: l,
                        parentNodeRef: t,
                        ctxNodeRef: t,
                      }),
                    )
                  : null),
                ($ && $.terminal) ||
                  !(g = t.getIndex(l).childNodes) ||
                  !g.length)
              )
                m = null;
              else {
                let t = $
                  ? ($.transcludeOnThisElement || !$.templateOnThisElement) &&
                    $.transclude
                  : e;
                m = S(new Ae(g), t);
              }
              ($ || m) &&
                (o.push({ index: l, nodeLinkFn: $, childLinkFn: m }),
                (c = !0),
                (a = a || $)),
                (i = null);
            }
            return c
              ? function (n, r, s) {
                  ct(r, "nodeRef");
                  let i = [];
                  if (a) {
                    const e = r.isList ? r.nodes.length : 1;
                    (i = new Array(e)),
                      o.forEach((e) => {
                        let n = e.index;
                        0 === n
                          ? (i[n] = r.isList ? r.nodes[n] : r.node)
                          : t.getIndex(n) && (i[n] = r.nodes[n]);
                      });
                  } else
                    r.isList
                      ? r.nodes.forEach((t) => i.push(t))
                      : i.push(r.node);
                  o.forEach(({ index: t, nodeLinkFn: r, childLinkFn: o }) => {
                    const a = i[t];
                    let c, l;
                    (a.stable = !0),
                      r
                        ? ((c = r.scope ? n.$new() : n),
                          (l = r.transcludeOnThisElement
                            ? _(n, r.transclude, s)
                            : !r.templateOnThisElement && s
                              ? s
                              : !s && e
                                ? _(n, e)
                                : null),
                          r.scope && Dt(a, c),
                          r(o, c, a, l))
                        : o && o(n, new Ae(a.childNodes), s);
                  });
                }
              : null;
          }
          function _(t, e, n) {
            function r(r, s, i, o, a) {
              r || ((r = t.$transcluded(a)).$$transcluded = !0);
              return e(r, s, {
                parentBoundTranscludeFn: n,
                transcludeControllers: i,
                futureParentElement: o,
              });
            }
            const s = (r.$$slots = Object.create(null));
            for (const r in e.$$slots)
              e.$$slots[r] ? (s[r] = _(t, e.$$slots[r], n)) : (s[r] = null);
            return r;
          }
          function T(t, n, s, i) {
            const o = [],
              { nodeType: a } = t,
              u = n.$attr;
            let h;
            switch (a) {
              case Node.ELEMENT_NODE:
                (h = t.nodeName.toLowerCase()),
                  i !== $t(h) && U(o, $t(h), "E", s);
                for (let e = 0; e < t.attributes?.length; e++) {
                  let a = !1,
                    h = !1,
                    d = !1,
                    p = !1,
                    f = t.attributes[e],
                    $ = f.name,
                    m = f.value,
                    g = $t($.toLowerCase());
                  const y = g.match(O);
                  y &&
                    ((a = "Attr" === y[1]),
                    (h = "Prop" === y[1]),
                    (d = "On" === y[1]),
                    (p = "Observe" === y[1]),
                    ($ = $.replace(l, "")
                      .toLowerCase()
                      .substring(4 + y[1].length)
                      .replace(/_(.)/g, (t, e) => e.toUpperCase()))),
                    h || d
                      ? ((n[g] = m),
                        (u[g] = f.name),
                        h ? Q(t, o, g, $) : o.push(Fe(c, r, g, $)))
                      : p
                        ? o.push(Ge($, m))
                        : ((g = $t($.toLowerCase())),
                          (u[g] = $),
                          (!a && Object.prototype.hasOwnProperty.call(n, g)) ||
                            ((n[g] = m), Kt(t, g) && (n[g] = !0)),
                          Y(t, o, m, g, a),
                          g !== i && U(o, g, "A", s));
                }
                "input" === h &&
                  "hidden" === t.getAttribute("type") &&
                  t.setAttribute("autocomplete", "off");
                break;
              case Node.TEXT_NODE:
                !(function (t, n) {
                  const r = e(n, !0);
                  r &&
                    t.push({
                      priority: 0,
                      compile: () => (t, e) => {
                        r.expressions.forEach((n) => {
                          t.$watch(n, () => {
                            const n = r(p(t) ? t.$target : t);
                            if (1 === e.nodeType) e.innerHTML = n;
                            else e.nodeValue = n;
                          });
                        });
                      },
                    });
                })(o, t.nodeValue);
            }
            return o.sort(B), o;
          }
          function L(t, e, n, r, s, i) {
            let o;
            return t
              ? A(e, n, r, s, i)
              : function () {
                  o || ((o = A(e, n, r, s, i)), (e = n = i = null));
                  return o.apply(this, arguments);
                };
          }
          function V(t, e, n, s, i, o, a, c) {
            c = c || {};
            let l = -Number.MAX_VALUE,
              {
                newScopeDirective: p,
                controllerDirectives: $,
                newIsolateScopeDirective: m,
                templateDirective: g,
                nonTlbTranscludeDirective: y,
                hasElementTranscludeDirective: b,
                ctxNodeRef: O,
                parentNodeRef: A,
              } = c,
              S = !1,
              x = !1,
              _ = new Ae(e);
            const R = c.index;
            let V, I, U;
            n.$nodeRef = _;
            let B,
              K = i,
              z = s,
              Q = !1,
              Y = !1,
              tt = function (t, s, i, c) {
                let l, g, y, E, C, O, A, S, x;
                e === i
                  ? ((S = n), (A = n.$nodeRef))
                  : ((A = new Ae(i)), (S = new ze(h, f, r, d, A, n))),
                  (E = s),
                  m ? (y = s.$newIsolate()) : p && (E = s.$parent),
                  c &&
                    ((O = function (t, e, n, r) {
                      let s;
                      j(t) || ((r = n), (n = e), (e = t), (t = void 0));
                      b && (s = C);
                      n || (n = b ? A.node.parentElement : A.node);
                      if (!r) {
                        return c(t, e, s, n, _);
                      }
                      {
                        const i = c.$$slots[r];
                        if (i) {
                          return i(t, e, s, n, _);
                        }
                        if (v(i))
                          throw Qe(
                            "noslot",
                            'No parent directive that requires a transclusion with slot name "{0}". Element: {1}',
                            r,
                            qt(A.element),
                          );
                      }
                    }),
                    (O.$$boundTransclude = c),
                    (O.isSlotFilled = function (t) {
                      return !!c.$$slots[t];
                    })),
                  $ &&
                    (C = (function (t, e, n, r, s, i, o) {
                      const a = Object.create(null);
                      for (const c in r) {
                        const l = r[c],
                          h = {
                            $scope: l === o || l.$$isolateScope ? s : i,
                            $element: t.node,
                            $attrs: e,
                            $transclude: n,
                          };
                        let { controller: d } = l;
                        "@" === d && (d = e[l.name]);
                        const p = u(d, h, !0, l.controllerAs);
                        (a[l.name] = p),
                          Vt(t, `$${l.name}Controller`, p.instance);
                      }
                      return a;
                    })(A, S, O, $, y, s, m)),
                  m &&
                    ((y.$target.$$isolateBindings = m.$$isolateBindings),
                    (x = et(s, S, y, y.$$isolateBindings, m)),
                    x.removeWatches && y.$on("$destroy", x.removeWatches));
                for (const t in C) {
                  const e = $[t],
                    n = C[t],
                    r = e.$$bindings.bindToController,
                    s = n();
                  (n.instance = E.$new(s)),
                    Vt(A.node, `$${e.name}Controller`, n.instance),
                    (n.bindingInfo = et(E, S, n.instance, r, e));
                }
                for (
                  $ &&
                    Object.entries($).forEach(([t, e]) => {
                      const { require: n } = e;
                      e.bindToController &&
                        !Array.isArray(n) &&
                        w(n) &&
                        P(C[t].instance, M(t, n, A.element, C));
                    }),
                    C &&
                      Object.values(C).forEach((t) => {
                        const e = t.instance;
                        if (k(e.$onChanges))
                          try {
                            e.$onChanges(t.bindingInfo.initialChanges);
                          } catch (t) {
                            r(t);
                          }
                        if (k(e.$onInit))
                          try {
                            e.$target.$onInit();
                          } catch (t) {
                            r(t);
                          }
                        k(e.$onDestroy) &&
                          E.$on("$destroy", () => {
                            e.$onDestroy();
                          });
                      }),
                    l = 0,
                    g = o.length;
                  l < g;
                  l++
                ) {
                  let t = o[l];
                  const e =
                    t.require && M(t.directiveName, t.require, A.element, C);
                  try {
                    t(t.isolateScope ? y : s, A.node, S, e, O);
                  } catch (t) {
                    console.error(t), r(t, qt(A.getAny()));
                  }
                }
                var _ = s;
                for (
                  m && (m.template || null === m.templateUrl) && (_ = y),
                    t &&
                      i &&
                      i.childNodes &&
                      i.childNodes.length &&
                      t(_, new Ae(i.childNodes), c),
                    l = a.length - 1;
                  l >= 0;
                  l--
                ) {
                  let t = a[l];
                  const e =
                    t.require && M(t.directiveName, t.require, A.node, C);
                  try {
                    t.isolateScope && It(A.node, y),
                      t(t.isolateScope ? y : s, A.node, S, e, O);
                  } catch (t) {
                    console.error(t), r(t, qt(A.getAny()));
                  }
                }
                C &&
                  Object.values(C).forEach((t) => {
                    const e = t.instance;
                    k(e.$postLink) && e.$postLink();
                  });
              };
            for (
              let i = 0, u = t.length;
              i < u && ((V = t[i]), (U = void 0), !(l > V.priority));
              i++
            ) {
              (B = V.scope),
                B &&
                  (V.templateUrl ||
                    (w(B)
                      ? (W("new/isolated scope", m || p, V, _), (m = V))
                      : W("new/isolated scope", m, V, _)),
                  (p = p || V)),
                (I = V.name);
              const h = V.replace && (V.templateUrl || V.template),
                d = V.transclude && !Ye.includes(V.name);
              if (!Q && (h || d)) {
                let e;
                for (let n = i + 1; (e = t[n++]); )
                  if (
                    (e.transclude && !Ye.includes(e.name)) ||
                    (e.replace && (e.templateUrl || e.template))
                  ) {
                    Y = !0;
                    break;
                  }
                Q = !0;
              }
              if (
                (!V.templateUrl &&
                  V.controller &&
                  (($ = $ || Object.create(null)),
                  W(`'${I}' controller`, $[I], V, _),
                  ($[I] = V)),
                (B = V.transclude),
                B)
              )
                if (
                  ((S = !0),
                  Ye.includes(V.name) || (W("transclusion", y, V, _), (y = V)),
                  "element" === B)
                )
                  (b = !0),
                    (l = V.priority),
                    (U = _),
                    (_ = new Ae(document.createComment(""))),
                    (n.$nodeRef = _),
                    (e = _.node),
                    (O.node = e),
                    J(new Ae(U.getAny()), e, R),
                    (z = L(Y, U.getAny(), s, l, K && K.name, {
                      nonTlbTranscludeDirective: y,
                    }));
                else {
                  const t = Object.create(null);
                  if (w(B)) {
                    U = document.createDocumentFragment();
                    const e = Object.create(null),
                      n = Object.create(null);
                    Object.entries(B).forEach(([r, s]) => {
                      const i = "?" === s.charAt(0);
                      (s = i ? s.substring(1) : s),
                        (e[s] = r),
                        (t[r] = null),
                        (n[r] = i);
                    }),
                      _.element.childNodes.forEach((r) => {
                        const s = e[$t(F(r))];
                        s
                          ? ((n[s] = !0),
                            (t[s] = t[s] || document.createDocumentFragment()),
                            t[s].appendChild(r))
                          : U.appendChild(r);
                      }),
                      Object.entries(n).forEach(([t, e]) => {
                        if (!e)
                          throw Qe(
                            "reqslot",
                            "Required transclusion slot `{0}` was not filled.",
                            t,
                          );
                      });
                    for (const e in t)
                      if (t[e]) {
                        const n = t[e].childNodes;
                        t[e] = L(Y, n, s);
                      }
                    U = U.childNodes;
                  } else U = e.cloneNode(!0).childNodes;
                  Yt(e),
                    (z = L(Y, U, s, void 0, void 0, {
                      needsNewScope: V.$$isolateScope || V.$$newScope,
                    })),
                    (z.$$slots = t);
                }
              if (V.template)
                if (
                  ((x = !0),
                  W("template", g, V, _),
                  (g = V),
                  (B = k(V.template) ? V.template(_.node, n) : V.template),
                  (B = C(B)),
                  V.replace)
                ) {
                  if (
                    ((K = V),
                    (U = jt(B) ? [] : nn(G(V.templateNamespace, N(B)))),
                    E(U) &&
                      (U = Array.from(Qt(U)).filter(
                        (t) => t.nodeType === Node.ELEMENT_NODE,
                      )),
                    (e = U[0]),
                    1 !== U.length || e.nodeType !== Node.ELEMENT_NODE)
                  )
                    throw Qe(
                      "tplrt",
                      "Template for directive '{0}' must have exactly one root element. {1}",
                      I,
                      "",
                    );
                  J(_, e), A && A.setIndex(R, e);
                  const r = { $attr: {} },
                    s = T(e, r),
                    o = t.splice(i + 1, t.length - (i + 1));
                  (m || p) && D(s, m, p),
                    (t = t.concat(s).concat(o)),
                    H(n, r),
                    (u = t.length);
                } else _.getAny().innerHTML = B;
              if (V.templateUrl)
                (x = !0),
                  W("template", g, V, _),
                  (g = V),
                  V.replace && (K = V),
                  (tt = q(t.splice(i, t.length - i), _, n, e, S && z, o, a, {
                    index: R,
                    controllerDirectives: $,
                    newScopeDirective: p !== V && p,
                    newIsolateScopeDirective: m,
                    templateDirective: g,
                    nonTlbTranscludeDirective: y,
                    futureParentElement: c.futureParentElement,
                  })),
                  (u = t.length);
              else if (V.compile)
                try {
                  const t = V.compile(_.getAny(), n, z),
                    e = V.$$originalDirective || V;
                  k(t) ? nt(null, Z(e, t)) : t && nt(Z(e, t.pre), Z(e, t.post));
                } catch (t) {
                  r(t, qt(_.getAny()));
                }
              V.terminal && ((tt.terminal = !0), (l = Math.max(l, V.priority)));
            }
            return (
              (tt.scope = p && !0 === p.scope),
              (tt.transcludeOnThisElement = S),
              (tt.templateOnThisElement = x),
              (tt.transclude = z),
              (c.hasElementTranscludeDirective = b),
              tt
            );
            function nt(t, e) {
              t &&
                ((t.require = V.require),
                (t.directiveName = I),
                (m === V || V.$$isolateScope) &&
                  (t = X(t, { isolateScope: !0 })),
                o.push(t)),
                e &&
                  ((e.require = V.require),
                  (e.directiveName = I),
                  (m === V || V.$$isolateScope) &&
                    (e = X(e, { isolateScope: !0 })),
                  a.push(e));
            }
          }
          function M(t, e, n, r) {
            let s;
            if (E(e)) {
              const i = e.match(Je),
                o = e.substring(i[0].length),
                a = i[1] || i[3],
                c = "?" === i[2];
              if (
                ("^^" === a
                  ? (n = n.parentElement ? n.parentElement : void 0)
                  : ((s = r && r[o]), (s = s && s.instance)),
                !s)
              ) {
                const t = `$${o}Controller`;
                s =
                  "^^" === a && n && n.nodeType === Node.DOCUMENT_NODE
                    ? null
                    : n
                      ? a
                        ? Ht(n, t)
                        : Pt(n, t)
                      : void 0;
              }
              if (!s && !c)
                throw Qe(
                  "ctreq",
                  "Controller '{0}', required by directive '{1}', can't be found!",
                  o,
                  t,
                );
            } else if (Array.isArray(e)) {
              s = [];
              for (let i = 0, o = e.length; i < o; i++) s[i] = M(t, e[i], n, r);
            } else
              w(e) &&
                ((s = {}),
                Object.entries(e).forEach(([e, i]) => {
                  s[e] = M(t, i, n, r);
                }));
            return s || null;
          }
          function D(t, e, n) {
            for (let r = 0, s = t.length; r < s; r++)
              t[r] = I(t[r], { $$isolateScope: e, $$newScope: n });
          }
          function U(e, r, s, o) {
            let a = !1;
            if (Object.prototype.hasOwnProperty.call(n, r))
              for (let n, c = t.get(r + tn), l = 0, u = c.length; l < u; l++)
                if (
                  ((n = c[l]),
                  (v(o) || o > n.priority) && -1 !== n.restrict.indexOf(s))
                ) {
                  if (!n.$$bindings) {
                    const t = (n.$$bindings = i(n, n.name));
                    w(t.isolateScope) && (n.$$isolateBindings = t.isolateScope);
                  }
                  e.push(n), (a = n);
                }
            return a;
          }
          function H(t, e) {
            const n = e.$attr,
              r = t.$attr;
            Object.entries(t).forEach(([r, s]) => {
              "$" !== r.charAt(0) &&
                (e[r] &&
                  e[r] !== s &&
                  (s.length
                    ? (s += ("style" === r ? ";" : " ") + e[r])
                    : (s = e[r])),
                t.$set(r, s, !0, n[r]));
            }),
              Object.entries(e).forEach(([e, s]) => {
                Object.prototype.hasOwnProperty.call(t, e) ||
                  "$" === e.charAt(0) ||
                  ((t[e] = s), "class" !== e && "style" !== e && (r[e] = n[e]));
              });
          }
          function q(t, e, n, i, o, a, c, l) {
            let u,
              h,
              d = [];
            const p = e.getAny(),
              f = t.shift(),
              $ = I(f, {
                templateUrl: null,
                transclude: null,
                replace: null,
                $$originalDirective: f,
              }),
              m = k(f.templateUrl)
                ? f.templateUrl(e.getAny(), n)
                : f.templateUrl,
              { templateNamespace: g } = f;
            return (
              Yt(e.getAny()),
              s(m)
                .then((r) => {
                  let s, y, v, b;
                  if (((r = C(r)), f.replace)) {
                    if (
                      ((v = jt(r)
                        ? []
                        : E(r)
                          ? Array.from(Qt(r)).filter(
                              (t) =>
                                t.nodeType !== Node.COMMENT_NODE &&
                                t.nodeType !== Node.TEXT_NODE,
                            )
                          : nn(G(g, N(r)))),
                      (s = v[0]),
                      1 !== v.length || s.nodeType !== Node.ELEMENT_NODE)
                    )
                      throw Qe(
                        "tplrt",
                        "Template for directive '{0}' must have exactly one root element. {1}",
                        f.name,
                        m,
                      );
                    (y = { $attr: {} }), J(e, s, l.index);
                    const i = T(s, y);
                    w(f.scope) && D(i, !0), (t = i.concat(t)), H(n, y);
                  } else (s = p), (e.getAny().innerHTML = r);
                  for (
                    t.unshift($),
                      u = V(t, s, n, o, f, a, c, { ...l, ctxNodeRef: e }),
                      i &&
                        Object.entries(i).forEach(([t, n]) => {
                          n === s && (i[t] = e);
                        }),
                      h = S(new Ae(e.getAny().childNodes), o);
                    d.length;

                  ) {
                    const t = d.shift(),
                      n = d.shift(),
                      r = d.shift();
                    let i = e.getAny();
                    if (!t.$$destroyed) {
                      if (n !== p) {
                        const t = n.className;
                        (l.hasElementTranscludeDirective && f.replace) ||
                          ((i = s.cloneNode(!0)), n.appendChild(i));
                        try {
                          "" !== t && n.classList.add(...i.classList);
                        } catch (t) {}
                      }
                      (b = u.transcludeOnThisElement
                        ? _(t, u.transclude, r)
                        : r),
                        u(h, t, i, b);
                    }
                  }
                  d = null;
                })
                .catch((t) => {
                  x(t) && r(t);
                }),
              function (t, e, n, r, s) {
                let i = s;
                e.$$destroyed ||
                  (d
                    ? d.push(e, n, r)
                    : (u.transcludeOnThisElement && (i = _(e, u.transclude, s)),
                      u(h, e, n, r, i)));
              }
            );
          }
          function B(t, e) {
            const n = e.priority - t.priority;
            return 0 !== n
              ? n
              : t.name !== e.name
                ? t.name < e.name
                  ? -1
                  : 1
                : t.index - e.index;
          }
          function W(t, e, n, r) {
            function s(t) {
              return t ? ` (module: ${t})` : "";
            }
            if (e)
              throw Qe(
                "multidir",
                "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}",
                e.name,
                s(e.$$moduleName),
                n.name,
                s(n.$$moduleName),
                t,
                qt(r.getAny()),
              );
          }
          function G(t, e) {
            switch ((t = (t || "html").toLowerCase())) {
              case "svg":
              case "math":
                var n = document.createElement("div");
                return (
                  (n.innerHTML = `<${t}>${e}</${t}>`),
                  n.childNodes[0].childNodes
                );
              default:
                return e;
            }
          }
          function Q(t, e, n, r) {
            if (Xe.test(r))
              throw Qe(
                "nodomevents",
                "Property bindings for HTML DOM event properties are disallowed",
              );
            const s = F(t),
              i = (function (t, e) {
                const n = e.toLowerCase();
                return a[`${t}|${n}`] || a[`*|${n}`];
              })(s, r);
            let o = (t) => t;
            "srcset" !== r || ("img" !== s && "source" !== s)
              ? i && (o = d.getTrusted.bind(d, i))
              : (o = (t) =>
                  (function (t, e) {
                    if (!t) return t;
                    if (!E(t))
                      throw Qe(
                        "srcset",
                        'Can\'t pass trusted values to `{0}`: "{1}"',
                        e,
                        t.toString(),
                      );
                    for (
                      var n = "",
                        r = N(t),
                        s = /\s/.test(r)
                          ? /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/
                          : /(,)/,
                        i = r.split(s),
                        o = Math.floor(i.length / 2),
                        a = 0;
                      a < o;
                      a++
                    ) {
                      var c = 2 * a;
                      (n += d.getTrustedMediaUrl(N(i[c]))),
                        (n += " " + N(i[c + 1]));
                    }
                    var l = N(i[2 * a]).split(/\s/);
                    return (
                      (n += d.getTrustedMediaUrl(N(l[0]))),
                      2 === l.length && (n += " " + N(l[1])),
                      n
                    );
                  })(d.valueOf(t), "ng-prop-srcset")),
              e.push({
                priority: 100,
                compile: function (t, e) {
                  const s = c(e[n]);
                  return {
                    pre: function (t, i) {
                      function a() {
                        const e = s(t);
                        i[r] = o(e);
                      }
                      a(),
                        t.$watch(r, a),
                        t.$watch(e[n], (t) => {
                          d.valueOf(t), a();
                        });
                    },
                  };
                },
              });
          }
          function Y(t, n, r, s, i) {
            const o = F(t),
              a = (function (t, e) {
                return "srcdoc" === e
                  ? d.HTML
                  : "src" === e || "ngSrc" === e
                    ? -1 ===
                      ["img", "video", "audio", "source", "track"].indexOf(t)
                      ? d.RESOURCE_URL
                      : d.MEDIA_URL
                    : "xlinkHref" === e
                      ? "image" === t
                        ? d.MEDIA_URL
                        : "a" === t
                          ? d.URL
                          : d.RESOURCE_URL
                      : ("form" === t && "action" === e) ||
                          ("base" === t && "href" === e) ||
                          ("link" === t && "href" === e)
                        ? d.RESOURCE_URL
                        : "a" !== t || ("href" !== e && "ngHref" !== e)
                          ? void 0
                          : d.URL;
              })(o, s),
              c = !i,
              l = Ze.includes(s) || i;
            let u = e(r, c, a, l);
            if (u) {
              if ("multiple" === s && "select" === o)
                throw Qe(
                  "selmulti",
                  "Binding to the 'multiple' attribute is not supported. Element: {0}",
                  qt(t.outerHTML),
                );
              if (Xe.test(s))
                throw Qe(
                  "nodomevents",
                  "Interpolations for HTML DOM event attributes are disallowed",
                );
              n.push({
                priority: 100,
                compile: () => ({
                  pre: function (t, n, i) {
                    const o =
                        i.$$observers || (i.$$observers = Object.create(null)),
                      c = i[s];
                    c !== r && ((u = c && e(c, !0, a, l)), (r = c)),
                      u &&
                        ((i[s] = u(t)),
                        ((o[s] || (o[s] = [])).$$inter = !0),
                        u.expressions.forEach((e) => {
                          (
                            (i.$$observers && i.$$observers[s].$$scope) ||
                            t
                          ).$watch(e, () => {
                            let e = u(t);
                            "class" === s
                              ? i.$updateClass(e, i.$$element.classList.value)
                              : i.$set(s, e);
                          });
                        }),
                        0 == u.expressions.length && i.$set(s, c));
                  },
                }),
              });
            }
          }
          function J(t, e, n) {
            const r = t.getAny().parentNode;
            if (r)
              if (b(n)) {
                const t = r.childNodes[n];
                t && r.replaceChild(e, t);
              } else r.insertBefore(e, r.firstChild);
            const s = document.createDocumentFragment();
            t.collection().forEach((t) => {
              s.appendChild(t);
            }),
              (t.node = e);
          }
          function X(t, e) {
            return P(
              function () {
                return t.apply(null, arguments);
              },
              t,
              e,
            );
          }
          function tt(t, e) {
            if (o)
              throw Qe(
                "missingattr",
                "Attribute '{0}' of '{1}' is non-optional and must be set!",
                t,
                e,
              );
          }
          function et(t, n, r, s, i) {
            const o = [],
              a = {};
            let l;
            function u(e, n, s) {
              k(r.$onChanges) &&
                ($ || (t.$postUpdate(m), ($ = [])),
                l || ((l = {}), $.push(h)),
                (l[e] = { currentValue: n, firstChange: s }));
            }
            function h() {
              r.$onChanges && r.$onChanges(l), (l = void 0);
            }
            return (
              s &&
                Object.entries(s).forEach(([s, l]) => {
                  const { attrName: d, optional: p, mode: f } = l;
                  let $,
                    m,
                    g,
                    y,
                    C,
                    O = !0,
                    A = !0;
                  switch (f) {
                    case "@":
                      p ||
                        Object.hasOwnProperty.call(n, d) ||
                        (tt(d, i.name), (r[s] = n[d] = void 0)),
                        (C = n.$observe(d, (t) => {
                          (E(t) || R(t)) &&
                            (u(s, t, A),
                            (r[s] = t),
                            O ? (O = !1) : (h(), (A = !1)));
                        })),
                        (n.$$observers[d].$$scope = t),
                        ($ = n[d]),
                        E($) ? (r[s] = e($)(t)) : R($) && (r[s] = $),
                        (a[s] = { currentValue: r[s], firstChange: !0 }),
                        o.push(C);
                      break;
                    case "=":
                      if (!Object.hasOwnProperty.call(n, d)) {
                        if (p) break;
                        tt(d, i.name), (n[d] = void 0);
                      }
                      if (p && !n[d]) break;
                      m = c(n[d]);
                      var S = !!m.inputs;
                      (y = m.literal ? z : K),
                        (g =
                          m.assign ||
                          function () {
                            throw (
                              (($ = r.$target[s] = m(t)),
                              Qe(
                                "nonassign",
                                "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                                n[d],
                                d,
                                i.name,
                              ))
                            );
                          }),
                        ($ = r.$target[s] = m(t.$target));
                      var x = function (e) {
                        return (
                          y(e, r[s]) ||
                            (y(e, $) ? g(t, (e = r[s])) : (r[s] = e)),
                          ($ = e),
                          $
                        );
                      };
                      if (((x.$stateful = !0), l.collection))
                        C = t.$watch(n[d], x);
                      else {
                        if (n[d]) {
                          let e = n[d];
                          t.$watch(
                            e,
                            (e) => {
                              var r = c(n[d], x);
                              e
                                ? (m.literal ? (t.$target[d] = e) : (t[d] = e),
                                  r(t))
                                : (t[d] = t[n[d]]);
                            },
                            !0,
                          );
                        }
                        C = r.$watch(
                          d,
                          (e) => {
                            if (e !== $ || v(n[d])) {
                              if ((S && !m.literal) || (v(n[d]) && b(e)))
                                throw (
                                  ((r.$target[d] = $),
                                  Qe(
                                    "nonassign",
                                    "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                                    n[d],
                                    d,
                                    i.name,
                                  ))
                                );
                              w(e)
                                ? Object.entries(e).forEach(([e, n]) => {
                                    t.$target[e] = n;
                                  })
                                : (g(t.$target, ($ = e)),
                                  t.$handler.watchers
                                    .get(n[d])
                                    ?.forEach((t) => {
                                      t.listenerFn(e);
                                    }));
                            }
                          },
                          !0,
                        );
                      }
                      o.push(C);
                      break;
                    case "<":
                      if (!Object.hasOwnProperty.call(n, d)) {
                        if (p) break;
                        tt(d, i.name), (n[d] = void 0);
                      }
                      if (p && !n[d]) break;
                      (m = c(n[d])),
                        (r.$target[s] = m(t.$target)),
                        (a[s] = { currentValue: r.$target[s], firstChange: A }),
                        (t.$target.attrs = n),
                        n[d] &&
                          ((C = t.$watch(
                            n[d],
                            (t) => {
                              (r.$target[s] = t), u(s, t, A), A && (A = !1);
                            },
                            !0,
                          )),
                          o.push(C));
                      break;
                    case "&":
                      if (
                        (p || Object.hasOwnProperty.call(n, d) || tt(d, i.name),
                        (m = Object.prototype.hasOwnProperty.call(n, d)
                          ? c(n[d])
                          : () => {}),
                        m.toString() === (() => {}).toString() && p)
                      )
                        break;
                      r.$target[s] = function (e) {
                        return m(t.$target, e);
                      };
                  }
                }),
              {
                initialChanges: a,
                removeWatches:
                  o.length &&
                  function () {
                    for (let t = 0, e = o.length; t < e; ++t) o[t]();
                  },
              }
            );
          }
        },
      ]);
  }
  function nn(t) {
    let e = t.length;
    if (e <= 1) return t;
    for (; e--; ) {
      const n = t[e];
      (n.nodeType === Node.COMMENT_NODE ||
        (n.nodeType === Node.TEXT_NODE && "" === n.nodeValue.trim())) &&
        [].splice.call(t, e, 1);
    }
    return t;
  }
  en.$inject = ["$provide", "$$sanitizeUriProvider"];
  const rn = {
      $nonscope: !0,
      $addControl: () => {},
      $getControls: () => [],
      $$renameControl: (t, e) => {
        t.$name = e;
      },
      $removeControl: () => {},
      $setValidity: () => {},
      $setDirty: () => {},
      $setPristine: () => {},
      $setSubmitted: () => {},
      $$setSubmitted: () => {},
    },
    sn = "ng-pending",
    on = "ng-submitted";
  class an {
    static $nonscope = !0;
    static $inject = [
      "$element",
      "$attrs",
      "$scope",
      "$animate",
      "$interpolate",
    ];
    constructor(t, r, s, i, o) {
      (this.$$controls = []),
        (this.$name = o(r.name || r.ngForm || "")(s)),
        (this.$dirty = !1),
        (this.$pristine = !0),
        (this.$valid = !0),
        (this.$invalid = !1),
        (this.$submitted = !1),
        (this.$$parentForm = rn),
        (this.$$element = t),
        (this.$$animate = i),
        (this.$error = {}),
        (this.$$success = {}),
        (this.$pending = void 0),
        (this.$$classCache = {});
      const a = this.$$element.classList.contains(e);
      (this.$$classCache[e] = a), (this.$$classCache[n] = !a);
    }
    $rollbackViewValue() {
      this.$$controls.forEach((t) => {
        t.$rollbackViewValue();
      });
    }
    $commitViewValue() {
      this.$$controls.forEach((t) => {
        t.$commitViewValue();
      });
    }
    $addControl(t) {
      W(t.$name, "input"),
        this.$$controls.push(t),
        t.$name && (this[t.$name] = t),
        (t.$target.$$parentForm = this);
    }
    $getControls() {
      return ot(this.$$controls);
    }
    $$renameControl(t, e) {
      const n = t.$name;
      this[n] === t && delete this[n], (this[e] = t), (t.$name = e);
    }
    $removeControl(t) {
      t.$name && this[t.$name] === t && delete this[t.$name],
        this.$pending &&
          Object.keys(this.$pending).forEach((e) => {
            this.$setValidity(e, null, t);
          }),
        this.$error &&
          Object.keys(this.$error).forEach((e) => {
            this.$setValidity(e, null, t);
          }),
        this.$$success &&
          Object.keys(this.$$success).forEach((e) => {
            this.$setValidity(e, null, t);
          }),
        B(this.$$controls, t),
        (t.$target.$$parentForm = rn);
    }
    $setDirty() {
      this.$$animate.removeClass(this.$$element, r),
        this.$$animate.addClass(this.$$element, s),
        (this.$dirty = !0),
        (this.$pristine = !1),
        this.$$parentForm.$setDirty();
    }
    $setPristine() {
      this.$$animate.setClass(this.$$element, r, `${s} ${on}`),
        (this.$dirty = !1),
        (this.$pristine = !0),
        (this.$submitted = !1),
        this.$$controls.forEach((t) => {
          t.$setPristine();
        });
    }
    $setUntouched() {
      this.$$controls.forEach((t) => {
        t.$setUntouched();
      });
    }
    $setSubmitted() {
      let t = this;
      for (; t.$$parentForm && t.$$parentForm !== rn; ) t = t.$$parentForm;
      t.$$setSubmitted();
    }
    $$setSubmitted() {
      this.$$animate.addClass(this.$$element, on),
        (this.$submitted = !0),
        this.$$controls.forEach((t) => {
          t.$$setSubmitted && t.$$setSubmitted();
        });
    }
    set(t, e, n) {
      const r = t[e];
      if (r) {
        -1 === r.indexOf(n) && r.push(n);
      } else p(t) && (t = t.$target), (t[e] = [n]);
    }
    unset(t, e, n) {
      const r = t[e];
      if (!r) return;
      -1 === B(r, n) && B(r, n.$target), 0 === r.length && delete t[e];
    }
    $setValidity(t, r, s) {
      let i,
        o = this;
      function a(t, e, n) {
        n && !t.$$classCache[e]
          ? (t.$$animate.addClass(t.$$element, e), (t.$$classCache[e] = !0))
          : !n &&
            t.$$classCache[e] &&
            (t.$$animate.removeClass(t.$$element, e), (t.$$classCache[e] = !1));
      }
      function c(t, r, s) {
        (r = r ? `-${V(r, "-")}` : ""),
          a(t, e + r, !0 === s),
          a(t, n + r, !1 === s);
      }
      v(r)
        ? (function (t, e, n, r) {
            t[e] || (t[e] = {});
            o.set(t[e], n, r);
          })(this, "$pending", t, s)
        : (function (t, e, n, r) {
            t[e] && o.unset(t[e], n, r);
            gt(t[e]) && (t[e] = void 0);
          })(this, "$pending", t, s),
        R(r)
          ? r
            ? (this.unset(this.$error, t, s), this.set(this.$$success, t, s))
            : (this.set(this.$error, t, s), this.unset(this.$$success, t, s))
          : (this.unset(this.$error, t, s), this.unset(this.$$success, t, s)),
        this.$pending
          ? (a(this, sn, !0),
            (this.$valid = this.$invalid = void 0),
            c(this, "", null))
          : (a(this, sn, !1),
            (this.$valid = gt(this.$error)),
            (this.$invalid = !this.$valid),
            c(this, "", this.$valid)),
        (i =
          this.$pending && this.$pending[t]
            ? void 0
            : !this.$error[t] && (!!this.$$success[t] || null)),
        c(this, t, i),
        this.$$parentForm.$setValidity(t, i, this);
    }
  }
  const cn = function (t) {
      return [
        "$parse",
        function (n) {
          return {
            name: "form",
            restrict: t ? "EA" : "E",
            require: ["form", "^^?form"],
            controller: an,
            compile: function (s, i) {
              s.classList.add(r, e);
              const o = i.name ? "name" : !(!t || !i.ngForm) && "ngForm";
              return {
                pre: function (t, e, r, s) {
                  const i = s[0];
                  if (!("action" in r)) {
                    const t = function (t) {
                      i.$commitViewValue(),
                        i.$setSubmitted(),
                        t.preventDefault();
                    };
                    e.addEventListener("submit", t),
                      e.addEventListener("$destroy", () => {
                        setTimeout(
                          () => {
                            e.removeEventListener("submit", t);
                          },
                          0,
                          !1,
                        );
                      });
                  }
                  (s[1] || i.$$parentForm).$addControl(i);
                  let a = o
                    ? (function (t) {
                        if ("" === t) return n('this[""]').assign;
                        return n(t).assign || (() => {});
                      })(i.$name)
                    : () => {};
                  o &&
                    (a(t, i),
                    r.$observe(o, (e) => {
                      i.$name !== e &&
                        ((t.$target[i.$name] = void 0),
                        i.$$parentForm.$$renameControl(i, e),
                        (t.$target !== i.$$parentForm &&
                          i.$$parentForm !== rn) ||
                          (t.$target[e] = i));
                    })),
                    e.addEventListener("$destroy", () => {
                      i.$target.$$parentForm.$removeControl(i),
                        a(t, void 0),
                        P(i, rn);
                    });
                },
              };
            },
          };
        },
      ];
    },
    ln = cn(),
    un = cn("ngForm"),
    hn = /(\s+|^)default(\s+|$)/;
  class dn {
    static $nonscope = !0;
    static $inject = ["$attrs", "$scope"];
    constructor(t, e) {
      (this.$$attrs = t), (this.$$scope = e), this.parentCtrl;
    }
    $onInit() {
      const t = this.parentCtrl ? this.parentCtrl.$options : fn,
        e = this.$$scope.$eval(this.$$attrs.ngModelOptions);
      this.$options = t.createChild(e);
    }
  }
  class pn {
    static $nonscope = !0;
    constructor(t) {
      this.$$options = t;
    }
    getOption(t) {
      return this.$$options[t];
    }
    createChild(t) {
      let e = !1;
      return (
        (t = Object.assign({}, t)),
        Object.entries(t).forEach(([n, r]) => {
          "$inherit" === r
            ? "*" === n
              ? (e = !0)
              : ((t[n] = this.$$options[n]),
                "updateOn" === n &&
                  (t.updateOnDefault = this.$$options.updateOnDefault))
            : "updateOn" === n &&
              ((t.updateOnDefault = !1),
              (t[n] = N(r.replace(hn, () => ((t.updateOnDefault = !0), " ")))));
        }, this),
        e && (delete t["*"], mn(t, this.$$options)),
        mn(t, fn.$$options),
        new pn(t)
      );
    }
  }
  const fn = new pn({
      updateOn: "",
      updateOnDefault: !0,
      debounce: 0,
      getterSetter: !1,
      allowInvalid: !1,
    }),
    $n = function () {
      return {
        restrict: "A",
        priority: 10,
        require: { parentCtrl: "?^^ngModelOptions" },
        bindToController: !0,
        controller: dn,
      };
    };
  function mn(t, e) {
    Object.keys(e).forEach((n) => {
      b(t[n]) || (t[n] = e[n]);
    });
  }
  const gn = dt("ngModel");
  class yn {
    static $nonscope = !0;
    static $inject = [
      "$scope",
      "$exceptionHandler",
      "$attrs",
      "$element",
      "$parse",
      "$animate",
      "$interpolate",
    ];
    constructor(t, r, s, i, o, a, c) {
      (this.$viewValue = Number.NaN),
        (this.$modelValue = Number.NaN),
        (this.$$rawModelValue = void 0),
        (this.$validators = {}),
        (this.$asyncValidators = {}),
        (this.$parsers = []),
        (this.$formatters = []),
        (this.$viewChangeListeners = []),
        (this.$untouched = !0),
        (this.$touched = !1),
        (this.$pristine = !0),
        (this.$dirty = !1),
        (this.$valid = !0),
        (this.$invalid = !1),
        (this.$error = {}),
        (this.$$success = {}),
        (this.$pending = void 0),
        (this.$name = c(s.name || "", !1)(t)),
        (this.$$parentForm = rn),
        (this.$options = fn),
        (this.$$updateEvents = ""),
        (this.$$updateEventHandler = this.$$updateEventHandler.bind(this)),
        (this.$$parsedNgModel = o(s.ngModel)),
        (this.$$parsedNgModelAssign = this.$$parsedNgModel.assign),
        (this.$$ngModelGet = this.$$parsedNgModel),
        (this.$$ngModelSet = this.$$parsedNgModelAssign),
        (this.$$pendingDebounce = null),
        (this.$$parserValid = void 0),
        (this.$$parserName = "parse"),
        (this.$$currentValidationRunId = 0),
        (this.$$scope = t),
        (this.$$rootScope = t.$root),
        (this.$$attr = s),
        (this.$$element = i),
        (this.$$animate = a),
        (this.$$parse = o),
        (this.$$exceptionHandler = r),
        (this.$$hasNativeValidators = !1),
        (this.$$classCache = {});
      const l = this.$$element.classList.contains(e);
      var u;
      (this.$$classCache[e] = l),
        (this.$$classCache[n] = !l),
        (this.$$eventRemovers = new Set()),
        (u = this).$$scope.$watch("value", () => {
          const t = u.$$ngModelGet(u.$$scope);
          t === u.$modelValue ||
            (u.$modelValue != u.$modelValue && t != t) ||
            u.$$setModelValue(t);
        });
    }
    set(t, e) {
      t[e] = !0;
    }
    unset(t, e) {
      delete t[e];
    }
    $setValidity(t, r) {
      let s,
        i = this;
      function o(t, e, n) {
        n && !t.$$classCache[e]
          ? (t.$$animate.addClass(t.$$element, e), (t.$$classCache[e] = !0))
          : !n &&
            t.$$classCache[e] &&
            (t.$$animate.removeClass(t.$$element, e), (t.$$classCache[e] = !1));
      }
      function a(t, r, s) {
        (r = r ? `-${V(r, "-")}` : ""),
          o(t, e + r, !0 === s),
          o(t, n + r, !1 === s);
      }
      v(r)
        ? (function (t, e, n) {
            t[e] || (t[e] = {}), i.set(t[e], n);
          })(this, "$pending", t)
        : (function (t, e, n) {
            t[e] && i.unset(t[e], n), gt(t[e]) && (t[e] = void 0);
          })(this, "$pending", t),
        R(r)
          ? r
            ? (delete this.$error[t], this.set(this.$$success, t))
            : (this.set(this.$error, t), delete this.$$success[t])
          : (delete this.$error[t], delete this.$$success[t]),
        this.$pending
          ? (o(this, sn, !0),
            (this.$valid = this.$invalid = void 0),
            a(this, "", null))
          : (o(this, sn, !1),
            (this.$valid = gt(this.$error)),
            (this.$invalid = !this.$valid),
            a(this, "", this.$valid)),
        (s =
          this.$pending && this.$pending[t]
            ? void 0
            : !this.$error[t] && (!!this.$$success[t] || null)),
        a(this, t, s),
        this.$$parentForm.$setValidity(t, s, this);
    }
    $$initGetterSetters() {
      if (this.$options.getOption("getterSetter")) {
        const t = this.$$parse(`${this.$$attr.ngModel}()`),
          e = this.$$parse(`${this.$$attr.ngModel}($$$p)`);
        (this.$$ngModelGet = (e) => {
          let n = this.$$parsedNgModel(e);
          return k(n) && (n = t(e)), n;
        }),
          (this.$$ngModelSet = (t, n) => {
            k(this.$$parsedNgModel(t))
              ? e(t, { $$$p: n })
              : this.$$parsedNgModelAssign(t, n);
          });
      } else if (!this.$$parsedNgModel.assign)
        throw gn(
          "nonassign",
          "Expression '{0}' is non-assignable. Element: {1}",
          this.$$attr.ngModel,
          qt(this.$$element),
        );
    }
    $render() {}
    $isEmpty(t) {
      return v(t) || "" === t || null === t || t != t;
    }
    $$updateEmptyClasses(t) {
      this.$isEmpty(t)
        ? mt(this.$$element)
          ? (this.$$animate.removeClass(this.$$element, c),
            this.$$animate.addClass(this.$$element, a))
          : (this.$$element.classList.remove(c),
            this.$$element.classList.add(a))
        : mt(this.$$element)
          ? (this.$$animate.removeClass(this.$$element, a),
            this.$$animate.addClass(this.$$element, c))
          : (this.$$element.classList.remove(a),
            this.$$element.classList.add(c));
    }
    $setPristine() {
      (this.$dirty = !1),
        (this.$pristine = !0),
        this.$$element &&
          (mt(this.$$element)
            ? (this.$$animate.removeClass(this.$$element, a),
              this.$$animate.addClass(this.$$element, r))
            : (this.$$element.classList.remove(a),
              this.$$element.classList.add(r)));
    }
    $setDirty() {
      (this.$dirty = !0),
        (this.$pristine = !1),
        mt(this.$$element)
          ? (this.$$animate.removeClass(this.$$element, r),
            this.$$animate.addClass(this.$$element, s))
          : (this.$$element.classList.remove(r),
            this.$$element.classList.add(s)),
        this.$$parentForm.$setDirty();
    }
    $setUntouched() {
      (this.$touched = !1),
        (this.$untouched = !0),
        mt(this.$$element)
          ? this.$$animate.setClass(this.$$element, i, o)
          : (this.$$element.classList.remove(o),
            this.$$element.classList.add(i));
    }
    $setTouched() {
      (this.$touched = !0),
        (this.$untouched = !1),
        mt(this.$$element)
          ? this.$$animate.setClass(this.$$element, o, i)
          : (this.$$element.classList.remove(i),
            this.$$element.classList.add(o));
    }
    $rollbackViewValue() {
      clearTimeout(this.$$pendingDebounce),
        (this.$viewValue = this.$$lastCommittedViewValue),
        this.$render();
    }
    $validate() {
      if (D(this.$modelValue)) return;
      const t = this.$$lastCommittedViewValue,
        e = this.$$rawModelValue,
        n = this.$valid,
        r = this.$modelValue,
        s = this.$options.getOption("allowInvalid"),
        i = this;
      this.$$runValidators(e, t, (t) => {
        s ||
          n === t ||
          ((i.$modelValue = t ? e : void 0),
          i.$modelValue !== r && i.$$writeModelToScope());
      });
    }
    $$runValidators(t, e, n) {
      this.$$currentValidationRunId++;
      const r = this.$$currentValidationRunId,
        s = this;
      function i(t, e) {
        r === s.$$currentValidationRunId && s.$setValidity(t, e);
      }
      function o(t) {
        r === s.$$currentValidationRunId && n(t);
      }
      !(function () {
        const t = s.$$parserName;
        if (!v(s.$$parserValid))
          return (
            s.$$parserValid ||
              (Object.keys(s.$validators).forEach((t) => {
                i(t, null);
              }),
              Object.keys(s.$asyncValidators).forEach((t) => {
                i(t, null);
              })),
            i(t, s.$$parserValid),
            s.$$parserValid
          );
        i(t, null);
        return !0;
      })()
        ? o(!1)
        : (function () {
              let n = !0;
              if (
                (Object.entries(s.$validators).forEach(([r, s]) => {
                  const o = Boolean(s(t, e));
                  (n = n && o), i(r, o);
                }),
                !n)
              )
                return (
                  Object.keys(s.$asyncValidators).forEach((t) => {
                    i(t, null);
                  }),
                  !1
                );
              return !0;
            })()
          ? (function () {
              const n = [];
              let r = !0;
              Object.entries(s.$asyncValidators).forEach(([s, o]) => {
                const a = o(t, e);
                if (!L(a))
                  throw gn(
                    "nopromise",
                    "Expected asynchronous validator to return a promise but got '{0}' instead.",
                    a,
                  );
                i(s, void 0),
                  n.push(
                    a.then(
                      () => {
                        i(s, !0);
                      },
                      () => {
                        (r = !1), i(s, !1);
                      },
                    ),
                  );
              }),
                n.length
                  ? Promise.all(n).then(
                      () => {
                        o(r);
                      },
                      () => {},
                    )
                  : o(!0);
            })()
          : o(!1);
    }
    $commitViewValue() {
      clearTimeout(this.$$pendingDebounce),
        (this.$$lastCommittedViewValue !== this.$viewValue ||
          ("" === this.$viewValue && this.$$hasNativeValidators)) &&
          ((void 0 === this.$$lastCommittedViewValue &&
            Number.isNaN(this.$viewValue)) ||
            (this.$$updateEmptyClasses(this.$viewValue),
            (this.$$lastCommittedViewValue = this.$viewValue),
            this.$pristine && this.$setDirty(),
            this.$$parseAndValidate()));
    }
    $$parseAndValidate() {
      let t = this.$$lastCommittedViewValue;
      const e = this;
      if (
        ((this.$$parserValid = !v(t) || void 0),
        this.$setValidity(this.$$parserName, null),
        (this.$$parserName = "parse"),
        this.$$parserValid)
      )
        for (let e = 0; e < this.$parsers.length; e++)
          if (((t = this.$parsers[e](t)), v(t))) {
            this.$$parserValid = !1;
            break;
          }
      D(this.$modelValue) &&
        (this.$modelValue = this.$$ngModelGet(this.$$scope));
      const n = this.$modelValue,
        r = this.$options.getOption("allowInvalid");
      function s() {
        e.$modelValue != n && e.$$writeModelToScope();
      }
      (this.$$rawModelValue = t),
        r && ((this.$modelValue = t), s()),
        this.$$runValidators(t, this.$$lastCommittedViewValue, (n) => {
          r || ((e.$modelValue = n ? t : void 0), s());
        });
    }
    $$writeModelToScope() {
      this.$$ngModelSet(this.$$scope.$target, this.$modelValue),
        Object.values(this.$viewChangeListeners).forEach((t) => {
          try {
            t();
          } catch (t) {
            this.$$exceptionHandler(t);
          }
        }, this);
    }
    $setViewValue(t, e) {
      (this.$viewValue = t),
        this.$options?.getOption("updateOnDefault") &&
          this.$$debounceViewValueCommit(e);
    }
    $$debounceViewValueCommit(t) {
      let e = this.$options.getOption("debounce");
      A(e[t])
        ? (e = e[t])
        : A(e.default) && -1 === this.$options.getOption("updateOn").indexOf(t)
          ? (e = e.default)
          : A(e["*"]) && (e = e["*"]),
        clearTimeout(this.$$pendingDebounce);
      const n = this;
      e > 0
        ? (this.$$pendingDebounce = setTimeout(() => {
            n.$commitViewValue();
          }, e))
        : this.$commitViewValue();
    }
    $overrideModelOptions(t) {
      this.$$removeAllEventListeners(),
        (this.$options = this.$options.createChild(t)),
        (this.$$updateEvents = this.$options.$$options.updateOn),
        this.$$setUpdateOnEvents();
    }
    $processModelValue() {
      const t = this.$$format();
      this.$viewValue !== t &&
        (this.$$updateEmptyClasses(t),
        (this.$viewValue = this.$$lastCommittedViewValue = t),
        this.$render(),
        this.$$runValidators(this.$modelValue, this.$viewValue, () => {}));
    }
    $$format() {
      const t = this.$formatters;
      let e = t.length,
        n = this.$modelValue;
      for (; e--; ) n = t[e](n);
      return n;
    }
    $$setModelValue(t) {
      (this.$modelValue = this.$$rawModelValue = t),
        (this.$$parserValid = void 0),
        this.$processModelValue();
    }
    $$removeAllEventListeners() {
      this.$$eventRemovers.forEach((t) => t()), this.$$eventRemovers.clear();
    }
    $$setUpdateOnEvents() {
      this.$$updateEvents &&
        this.$$updateEvents.split(" ").forEach((t) => {
          this.$$element.addEventListener(t, this.$$updateEventHandler),
            this.$$eventRemovers.add(() =>
              this.$$element.removeEventListener(t, this.$$updateEventHandler),
            );
        }),
        (this.$$updateEvents = this.$options.getOption("updateOn")),
        this.$$updateEvents &&
          this.$$updateEvents.split(" ").forEach((t) => {
            this.$$element.addEventListener(t, this.$$updateEventHandler),
              this.$$eventRemovers.add(() =>
                this.$$element.removeEventListener(
                  t,
                  this.$$updateEventHandler,
                ),
              );
          });
    }
    $$updateEventHandler(t) {
      this.$$debounceViewValueCommit(t && t.type);
    }
  }
  function vn() {
    return {
      restrict: "A",
      require: ["ngModel", "^?form", "^?ngModelOptions"],
      controller: yn,
      priority: 1,
      compile: (t) => (
        t.classList.add(r, i, e),
        {
          pre: (t, e, n, r) => {
            const s = r[0],
              i = r[1] || s.$$parentForm,
              o = r[2];
            o && (s.$options = o.$options),
              s.$$initGetterSetters(),
              i.$addControl(s),
              n.$observe("name", (t) => {
                s.$name !== t && s.$$parentForm.$$renameControl(s, t);
              });
            let a = t.$watch(n.ngModel, (t) => {
              s.$$setModelValue(p(t) ? t.$target : t);
            });
            t.$on("$destroy", () => {
              s.$$parentForm.$removeControl(s), a();
            });
          },
          post: (t, e, n, r) => {
            const s = r[0];
            s.$$setUpdateOnEvents(),
              e.addEventListener("blur", () => {
                s.$touched || s.$setTouched();
              });
          },
        }
      ),
    };
  }
  const bn =
      /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/,
    wn =
      /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i,
    En =
      /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/,
    Cn = /^\s*([-+])?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/,
    On = /^(\d{4,})-(\d{2})-(\d{2})$/,
    An = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,
    Sn = /^(\d{4,})-W(\d\d)$/,
    xn = /^(\d{4,})-(\d\d)$/,
    kn = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,
    _n = "validity",
    Tn = new Map();
  "date,datetime-local,month,time,week".split(",").forEach((t) => {
    Tn.set(t, !0);
  });
  const jn = {
    text: function (t, e, n, r) {
      Ln(t, e, n, r), Rn(r);
    },
    date: Pn("date", On, Nn(On, ["yyyy", "MM", "dd"])),
    "datetime-local": Pn(
      "datetimelocal",
      An,
      Nn(An, ["yyyy", "MM", "dd", "HH", "mm", "ss", "sss"]),
    ),
    time: Pn("time", kn, Nn(kn, ["HH", "mm", "ss", "sss"])),
    week: Pn("week", Sn, function (t, e) {
      if (S(t)) return t;
      if (E(t)) {
        Sn.lastIndex = 0;
        const n = Sn.exec(t);
        if (n) {
          const t = +n[1],
            r = +n[2];
          let s = 0,
            i = 0,
            o = 0,
            a = 0;
          const c = (function (t) {
              const e = new Date(t, 0, 1).getDay();
              return new Date(t, 0, (e <= 4 ? 5 : 12) - e);
            })(t),
            l = 7 * (r - 1);
          return (
            e &&
              ((s = e.getHours()),
              (i = e.getMinutes()),
              (o = e.getSeconds()),
              (a = e.getMilliseconds())),
            new Date(t, 0, c.getDate() + l, s, i, o, a)
          );
        }
      }
      return NaN;
    }),
    month: Pn("month", xn, Nn(xn, ["yyyy", "MM"])),
    number: function (t, e, n, r, s, i, o) {
      let a;
      if (
        (Mn(t, e, n, r, "number"), Dn(r), Ln(t, e, n, r), b(n.min) || n.ngMin)
      ) {
        let e = n.min || o(n.ngMin)(t);
        (a = In(e)),
          (r.$validators.min = function (t, e) {
            return r.$isEmpty(e) || v(a) || e >= a;
          }),
          n.$observe("min", (t) => {
            t !== e && ((a = In(t)), (e = t), r.$validate());
          });
      }
      if (b(n.max) || n.ngMax) {
        let e = n.max || o(n.ngMax)(t),
          s = In(e);
        (r.$validators.max = function (t, e) {
          return r.$isEmpty(e) || v(s) || e <= s;
        }),
          n.$observe("max", (t) => {
            t !== e && ((s = In(t)), (e = t), r.$validate());
          });
      }
      if (b(n.step) || n.ngStep) {
        let e = n.step || o(n.ngStep)(t),
          s = In(e);
        (r.$validators.step = function (t, e) {
          return r.$isEmpty(e) || v(s) || Fn(e, a || 0, s);
        }),
          n.$observe("step", (t) => {
            t !== e && ((s = In(t)), (e = t), r.$validate());
          });
      }
    },
    url: function (t, e, n, r) {
      Ln(t, e, n, r),
        Rn(r),
        (r.$validators.url = function (t, e) {
          const n = t || e;
          return r.$isEmpty(n) || wn.test(n);
        });
    },
    email: function (t, e, n, r) {
      Ln(t, e, n, r),
        Rn(r),
        (r.$validators.email = function (t, e) {
          const n = t || e;
          return r.$isEmpty(n) || En.test(n);
        });
    },
    radio: function (t, e, n, r) {
      const s = !n.ngTrim || "false" !== N(n.ngTrim);
      v(n.name) && e.setAttribute("name", m());
      e.addEventListener("change", function (t) {
        let i;
        e.checked &&
          ((i = n.value), s && (i = N(i)), r.$setViewValue(i, t && t.type));
      }),
        (r.$render = function () {
          let { value: t } = n;
          s && (t = N(t)), (e.checked = t === r.$viewValue);
        }),
        n.$observe("value", r.$render);
    },
    range: function (t, e, n, r) {
      Mn(t, e, n, r, "range"), Dn(r), Ln(t, e, n, r);
      const s = r.$$hasNativeValidators && "range" === e.type;
      let i = s ? 0 : void 0,
        o = s ? 100 : void 0,
        a = s ? 1 : void 0;
      const { validity: c } = e,
        l = b(n.min),
        u = b(n.max),
        h = b(n.step),
        d = r.$render;
      (r.$render =
        s && b(c.rangeUnderflow) && b(c.rangeOverflow)
          ? function () {
              d(), r.$setViewValue(e.value);
            }
          : d),
        l &&
          ((i = In(n.min)),
          (r.$validators.min = s
            ? function () {
                return !0;
              }
            : function (t, e) {
                return r.$isEmpty(e) || v(i) || e >= i;
              }),
          p("min", function (t) {
            if (((i = In(t)), D(r.$modelValue))) return;
            if (s) {
              let t = e.value;
              i > t && ((t = i), (e.value = t)), r.$setViewValue(t);
            } else r.$validate();
          }));
      u &&
        ((o = In(n.max)),
        (r.$validators.max = s
          ? function () {
              return !0;
            }
          : function (t, e) {
              return r.$isEmpty(e) || v(o) || e <= o;
            }),
        p("max", function (t) {
          if (((o = In(t)), D(r.$modelValue))) return;
          if (s) {
            let t = e.value;
            o < t && ((e.value = o), (t = o < i ? i : o)), r.$setViewValue(t);
          } else r.$validate();
        }));
      h &&
        ((a = In(n.step)),
        (r.$validators.step = s
          ? function () {
              return !c.stepMismatch;
            }
          : function (t, e) {
              return r.$isEmpty(e) || v(a) || Fn(e, i || 0, a);
            }),
        p("step", function (t) {
          if (((a = In(t)), D(r.$modelValue))) return;
          s
            ? r.$viewValue !== e.value && r.$setViewValue(e.value)
            : r.$validate();
        }));
      function p(t, r) {
        e.setAttribute(t, n[t]);
        let s = n[t];
        n.$observe(t, (t) => {
          t !== s && ((s = t), r(t));
        });
      }
    },
    checkbox: function (t, e, n, r, s, i, o) {
      const a = qn(o, t, "ngTrueValue", n.ngTrueValue, !0),
        c = qn(o, t, "ngFalseValue", n.ngFalseValue, !1);
      e.addEventListener("change", function (t) {
        r.$setViewValue(e.checked, t && t.type);
      }),
        (r.$render = function () {
          e.checked = r.$viewValue;
        }),
        (r.$isEmpty = function (t) {
          return !1 === t;
        }),
        r.$formatters.push((t) => z(t, a)),
        r.$parsers.push((t) => (t ? a : c));
    },
    hidden: () => {},
    button: () => {},
    submit: () => {},
    reset: () => {},
    file: () => {},
  };
  function Rn(t) {
    t.$formatters.push((e) => (t.$isEmpty(e) ? e : e.toString()));
  }
  function Ln(t, e, n, r) {
    const s = e.type.toLowerCase();
    let i,
      o = !1;
    e.addEventListener("compositionstart", () => {
      o = !0;
    }),
      e.addEventListener("compositionend", () => {
        (o = !1), a();
      });
    let a = function (t) {
      if ((i && (clearTimeout(i), (i = null)), o)) return;
      let a = e.value;
      const c = t && t.type;
      "password" === s || (n.ngTrim && "false" === n.ngTrim) || (a = N(a)),
        (r.$viewValue !== a || ("" === a && r.$$hasNativeValidators)) &&
          r.$target.$setViewValue(a, c);
    };
    ["input", "change", "paste", "drop", "cut"].forEach((t) => {
      e.addEventListener(t, a);
    }),
      Tn[s] &&
        r.$$hasNativeValidators &&
        s === n.type &&
        e.addEventListener("keydown wheel mousedown", function (t) {
          if (!i) {
            const e = this[_n],
              n = e.badInput,
              r = e.typeMismatch;
            i = setTimeout(() => {
              (i = null), (e.badInput === n && e.typeMismatch === r) || a(t);
            });
          }
        }),
      (r.$render = function () {
        const t = r.$isEmpty(r.$viewValue) ? "" : r.$viewValue;
        e.value !== t && (e.value = t);
      });
  }
  function Nn(t, e) {
    return function (n, r) {
      let s, i;
      if (S(n)) return n;
      if (E(n)) {
        if (
          ('"' === n.charAt(0) &&
            '"' === n.charAt(n.length - 1) &&
            (n = n.substring(1, n.length - 1)),
          bn.test(n))
        )
          return new Date(n);
        if (((t.lastIndex = 0), (s = t.exec(n)), s)) {
          s.shift(),
            (i = r
              ? {
                  yyyy: r.getFullYear(),
                  MM: r.getMonth() + 1,
                  dd: r.getDate(),
                  HH: r.getHours(),
                  mm: r.getMinutes(),
                  ss: r.getSeconds(),
                  sss: r.getMilliseconds() / 1e3,
                }
              : { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 }),
            Object.entries(s).forEach(([t, n]) => {
              t < e.length && (i[e[t]] = +n);
            });
          const t = new Date(
            i.yyyy,
            i.MM - 1,
            i.dd,
            i.HH,
            i.mm,
            i.ss || 0,
            1e3 * i.sss || 0,
          );
          return i.yyyy < 100 && t.setFullYear(i.yyyy), t;
        }
      }
      return NaN;
    };
  }
  const Vn = /\b\d{4}-(0[1-9]|1[0-2])\b/;
  function Pn(t, e, n) {
    return function (r, s, i, o, a, c, l) {
      if (
        (Mn(r, s, i, o, t),
        Ln(0, s, i, o),
        o.$parsers.push((n) =>
          o.$isEmpty(n)
            ? null
            : e.test(n)
              ? ["month", "week", "datetimelocal", "time", "date"].includes(t)
                ? n
                : d(n, undefined)
              : void (o.$$parserName = t),
        ),
        o.$formatters.push(function (e) {
          if (e && !E(e))
            throw gn("datefmt", "Expected `{0}` to be a String", e);
          if ("month" === t) {
            if (null == e) return "";
            if (!Vn.test(e))
              throw gn("datefmt", "Expected month `{0}` to be a 'YYYY-DD'", e);
          }
          if ("week" === t) {
            if (null == e) return "";
            if (!Sn.test(e))
              throw gn("datefmt", "Expected week `{0}` to be a 'yyyy-Www'", e);
          }
          if ("datetimelocal" === t) {
            if (null == e) return "";
            if (!An.test(e))
              throw gn(
                "datefmt",
                "Expected week `{0}` to be a in date time format. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats#local_date_and_time_strings",
                e,
              );
          }
          return e;
        }),
        b(i.min) || i.ngMin)
      ) {
        let e = i.min || l(i.ngMin)(r),
          s = h(e);
        (o.$validators.min = function (e) {
          return "month" === t
            ? v(s) || n(e) >= n(s)
            : !u(e) || v(s) || n(e) >= s;
        }),
          i.$observe("min", (t) => {
            t !== e && ((s = h(t)), (e = t), o.$validate());
          });
      }
      if (b(i.max) || i.ngMax) {
        let e = i.max || l(i.ngMax)(r),
          s = h(e);
        (o.$validators.max = function (e) {
          return "month" === t
            ? v(s) || n(e) <= n(s)
            : !u(e) || v(s) || n(e) <= s;
        }),
          i.$observe("max", (t) => {
            t !== e && ((s = h(t)), (e = t), o.$validate());
          });
      }
      function u(t) {
        return t && !(t.getTime && t.getTime() != t.getTime());
      }
      function h(t) {
        return b(t) && !S(t) ? d(t) || void 0 : t;
      }
      function d(t, e) {
        const r = o.$options.getOption("timezone");
        let s = n(t, e);
        return !Number.isNaN(s) && r && (s = tt(s, r)), s;
      }
    };
  }
  function Mn(t, e, n, r, s) {
    const i = e;
    (r.$$hasNativeValidators = w(i.validity)) &&
      r.$parsers.push((t) => {
        const n = e[_n] || {};
        if (!n.badInput && !n.typeMismatch) return t;
        r.$$parserName = s;
      });
  }
  function Dn(t) {
    t.$parsers.push((e) =>
      t.$isEmpty(e)
        ? null
        : Cn.test(e)
          ? parseFloat(e)
          : void (t.$$parserName = "number"),
    ),
      t.$formatters.push((e) => {
        if (!t.$isEmpty(e)) {
          if (!A(e)) throw gn("numfmt", "Expected `{0}` to be a number", e);
          e = e.toString();
        }
        return e;
      });
  }
  function In(t) {
    return b(t) && !A(t) && (t = parseFloat(t)), D(t) ? void 0 : t;
  }
  function Un(t) {
    return (0 | t) === t;
  }
  function Hn(t) {
    const e = t.toString(),
      n = e.indexOf(".");
    if (-1 === n) {
      if (t > -1 && t < 1) {
        const t = /e-(\d+)$/.exec(e);
        if (t) return Number(t[1]);
      }
      return 0;
    }
    return e.length - n - 1;
  }
  function Fn(t, e, n) {
    let r = Number(t);
    const s = !Un(r),
      i = !Un(e),
      o = !Un(n);
    if (s || i || o) {
      const t = s ? Hn(r) : 0,
        a = i ? Hn(e) : 0,
        c = o ? Hn(n) : 0,
        l = 10 ** Math.max(t, a, c);
      (r *= l),
        (e *= l),
        (n *= l),
        s && (r = Math.round(r)),
        i && (e = Math.round(e)),
        o && (n = Math.round(n));
    }
    return (r - e) % n === 0;
  }
  function qn(t, e, n, r, s) {
    let i;
    if (b(r)) {
      if (((i = t(r)), !i.constant))
        throw gn(
          "constexpr",
          "Expected constant expression for `{0}`, but saw `{1}`.",
          n,
          r,
        );
      return i(e);
    }
    return s;
  }
  function Bn(t, e, n) {
    return {
      restrict: "E",
      require: ["?ngModel"],
      link: {
        pre(r, s, i, o) {
          o[0] && (jn[g(i.type)] || jn.text)(r, s, i, o[0], t, e, n);
        },
      },
    };
  }
  function Kn() {
    const t = {
      configurable: !0,
      enumerable: !1,
      get() {
        return this.getAttribute("value") || "";
      },
      set(t) {
        this.setAttribute("value", t);
      },
    };
    return {
      restrict: "E",
      priority: 200,
      compile(e, n) {
        if ("hidden" === g(n.type))
          return {
            pre(e, n) {
              const r = n;
              r.parentNode && r.parentNode.insertBefore(r, r.nextSibling),
                Object.defineProperty && Object.defineProperty(r, "value", t);
            },
          };
      },
    };
  }
  Bn.$inject = ["$browser", "$filter", "$parse"];
  const zn = /^(true|false|\d+)$/;
  function Wn() {
    function t(t, e, n) {
      const r = b(n) ? n : null;
      (t.value = r), e.$set("value", n);
    }
    return {
      restrict: "A",
      priority: 100,
      compile: (e, n) =>
        zn.test(n.ngValue)
          ? function (e, n, r) {
              t(n, r, e.$eval(r.ngValue));
            }
          : function (e, n, r) {
              e.$watch(r.ngValue, (e) => {
                t(n, r, e);
              });
            },
    };
  }
  function Gn(t) {
    return {
      restrict: "E",
      terminal: !0,
      compile(e, n) {
        "text/ng-template" === n.type && t.set(n.id, e.innerText);
      },
    };
  }
  Gn.$inject = ["$templateCache"];
  class Qn {
    static $nonscope = [
      "ngModelCtrl",
      "selectValueMap",
      "emptyOption",
      "optionsMap",
      "$scope",
      "$element",
    ];
    static $inject = ["$element", "$scope"];
    constructor(t, e) {
      (this.$element = t),
        (this.$scope = e),
        (this.selectValueMap = {}),
        (this.ngModelCtrl = {}),
        (this.multiple = !1),
        (this.unknownOption = document.createElement("option")),
        (this.hasEmptyOption = !1),
        (this.emptyOption = void 0),
        (this.optionsMap = new Map()),
        (this.renderScheduled = !1),
        (this.updateScheduled = !1),
        e.$on("$destroy", () => {
          this.renderUnknownOption = () => {};
        });
    }
    renderUnknownOption(t) {
      const e = this.generateUnknownOptionValue(t);
      (this.unknownOption.value = e),
        this.$element.prepend(this.unknownOption),
        (this.unknownOption.selected = !0),
        this.unknownOption.setAttribute("selected", "selected"),
        (this.$element.value = e);
    }
    updateUnknownOption(t) {
      const e = this.generateUnknownOptionValue(t);
      (this.unknownOption.value = e),
        (this.unknownOption.selected = !0),
        this.unknownOption.setAttribute("selected", "selected"),
        (this.$element.value = e);
    }
    generateUnknownOptionValue(t) {
      return v(t) ? "? undefined:undefined ?" : `? ${pt(t)} ?`;
    }
    removeUnknownOption() {
      this.unknownOption.parentElement && this.unknownOption.remove();
    }
    selectEmptyOption() {
      this.emptyOption &&
        ((this.$element.value = ""),
        (this.emptyOption.selected = !0),
        this.emptyOption.setAttribute("selected", "selected"));
    }
    unselectEmptyOption() {
      this.hasEmptyOption && (this.emptyOption.selected = !1);
    }
    readValue() {
      const t = this.$element.value,
        e = t in this.selectValueMap ? this.selectValueMap[t] : t;
      return this.hasOption(e) ? e : null;
    }
    writeValue(t) {
      const e = this.$element.options[this.$element.selectedIndex];
      if ((e && (e.selected = !1), this.hasOption(t))) {
        this.removeUnknownOption();
        const e = pt(t);
        this.$element.value = e in this.selectValueMap ? e : t;
        const n = this.$element.options[this.$element.selectedIndex];
        n ? (n.selected = !0) : this.selectUnknownOrEmptyOption(t);
      } else this.selectUnknownOrEmptyOption(t);
    }
    addOption(t, e) {
      if (e.nodeType === Node.COMMENT_NODE) return;
      W(t, '"option value"'),
        "" === t && ((this.hasEmptyOption = !0), (this.emptyOption = e));
      const n = this.optionsMap.get(t) || 0;
      this.optionsMap.set(t, n + 1), this.scheduleRender();
    }
    removeOption(t) {
      const e = this.optionsMap.get(t);
      e &&
        (1 === e
          ? (this.optionsMap.delete(t),
            "" === t &&
              ((this.hasEmptyOption = !1), (this.emptyOption = void 0)))
          : this.optionsMap.set(t, e - 1));
    }
    hasOption(t) {
      return !!this.optionsMap.get(t);
    }
    $hasEmptyOption() {
      return this.hasEmptyOption;
    }
    $isUnknownOptionSelected() {
      return this.$element.options[0] === this.unknownOption;
    }
    $isEmptyOptionSelected() {
      return (
        this.hasEmptyOption &&
        this.$element.options[this.$element.selectedIndex] === this.emptyOption
      );
    }
    selectUnknownOrEmptyOption(t) {
      null == t && this.emptyOption
        ? (this.removeUnknownOption(), this.selectEmptyOption())
        : this.unknownOption.parentElement
          ? this.updateUnknownOption(t)
          : this.renderUnknownOption(t);
    }
    scheduleRender() {
      this.renderScheduled ||
        ((this.renderScheduled = !0),
        this.$scope.$postUpdate(() => {
          (this.renderScheduled = !1), this.ngModelCtrl.$render();
        }));
    }
    scheduleViewValueUpdate(t = !1) {
      this.updateScheduled ||
        ((this.updateScheduled = !0),
        this.$scope.$postUpdate(() => {
          this.$scope.$$destroyed ||
            ((this.updateScheduled = !1),
            this.ngModelCtrl.$setViewValue(this.readValue()),
            t && this.ngModelCtrl.$render());
        }));
    }
    registerOption(t, e, n, r, s) {
      let i, o;
      if (n.$attr.ngValue)
        n.$observe("value", (t) => {
          let n;
          const r = e.selected;
          b(o) &&
            (this.removeOption(i), delete this.selectValueMap[o], (n = !0)),
            (o = pt(t)),
            (i = t),
            (this.selectValueMap[o] = t),
            this.addOption(t, e),
            e.setAttribute("value", o),
            n && r && this.scheduleViewValueUpdate();
        });
      else if (r)
        n.$observe("value", (t) => {
          let n;
          this.readValue();
          const r = e.selected;
          b(i) && (this.removeOption(i), (n = !0)),
            (i = t),
            this.addOption(t, e),
            n && r && this.scheduleViewValueUpdate();
        });
      else if (s) {
        let r;
        (t.value = s(t)),
          n.value || (n.$set("value", t.value), this.addOption(t.value, e)),
          t.$watch("value", () => {
            let i = s(t);
            n.value || n.$set("value", i);
            const o = e.selected;
            r !== i && (this.removeOption(r), (r = i)),
              this.addOption(i, e),
              r && o && this.scheduleViewValueUpdate();
          });
      } else this.addOption(n.value, e);
      n.$observe("disabled", (t) => {
        ("true" === t || (t && e.selected)) &&
          (this.multiple
            ? this.scheduleViewValueUpdate(!0)
            : (this.ngModelCtrl.$setViewValue(null),
              this.ngModelCtrl.$render()));
      }),
        e.addEventListener("$destroy", () => {
          const t = this.readValue(),
            e = n.value;
          this.removeOption(e),
            this.scheduleRender(),
            ((this.multiple && t && -1 !== t.indexOf(e)) || t === e) &&
              this.scheduleViewValueUpdate(!0);
        });
    }
  }
  function Yn() {
    return {
      restrict: "E",
      require: ["select", "?ngModel"],
      controller: Qn,
      priority: 1,
      link: {
        pre: function (t, e, n, r) {
          const s = r[0],
            i = r[1];
          if (!i) return void (s.registerOption = () => {});
          if (
            ((s.ngModelCtrl = i),
            e.addEventListener("change", () => {
              s.removeUnknownOption();
              const t = s.readValue();
              i.$setViewValue(t);
            }),
            n.multiple)
          ) {
            let t;
            (s.multiple = !0),
              (s.readValue = function () {
                const t = [],
                  n = e.getElementsByTagName("option");
                return (
                  Array.from(n).forEach((e) => {
                    if (e.selected && !e.disabled) {
                      const n = e.value;
                      t.push(n in s.selectValueMap ? s.selectValueMap[n] : n);
                    }
                  }),
                  t
                );
              }),
              (s.writeValue = function (t) {
                const n = e.getElementsByTagName("option");
                Array.from(n).forEach((e) => {
                  const n =
                    !!t && (q(t, e.value) || q(t, s.selectValueMap[e.value]));
                  n !== e.selected && (e.selected = n);
                });
              });
            let n = NaN;
            n !== i.$viewValue ||
              z(t, i.$viewValue) ||
              ((t = ot(i.$viewValue)), i.$render()),
              (n = i.$viewValue),
              (i.$isEmpty = function (t) {
                return !t || 0 === t.length;
              });
          }
        },
        post: function (t, e, n, r) {
          const s = r[1];
          if (!s) return;
          const i = r[0];
          s.$render = function () {
            i.writeValue(s.$viewValue);
          };
        },
      },
    };
  }
  function Zn(t) {
    return {
      restrict: "E",
      priority: 100,
      compile(e, n) {
        let r, s;
        return (
          b(n.ngValue) ||
            (b(n.value)
              ? (r = t(n.value, !0))
              : ((s = t(e.textContent, !0)),
                s || n.$set("value", e.textContent))),
          function (t, e, n) {
            const i = "$selectController",
              o = e.parentElement,
              a = Pt(o, i) || Pt(o.parentElement, i);
            a && a.registerOption(t, e, n, r, s);
          }
        );
      },
    };
  }
  function Jn() {
    return {
      restrict: "EA",
      link(t, e, n) {
        t.$watch(n.ngBind, (t) => {
          e.textContent = G(p(t) ? t.$target : t);
        });
      },
    };
  }
  function Xn() {
    return {
      restrict: "EA",
      link(t, e, n) {
        n.$observe("ngBindTemplate", (t) => {
          e.textContent = v(t) ? "" : t;
        });
      },
    };
  }
  function tr(t) {
    return {
      restrict: "A",
      compile: (e, n) => (
        t(n.ngBindHtml),
        (t, e) => {
          t.$watch(n.ngBindHtml, (t) => {
            (v(t) || C(t)) && (t = ""), (e.innerHTML = t);
          });
        }
      ),
    };
  }
  function er(t, e) {
    return (
      (t = `ngClass${t}`),
      function () {
        return {
          restrict: "EA",
          link(n, r, s) {
            let i,
              o = Pt(r, "$classCounts"),
              a = !0;
            function c(t, e) {
              const n = [];
              return (
                t &&
                  t.forEach((t) => {
                    (e > 0 || o[t]) &&
                      ((o[t] = (o[t] || 0) + e),
                      o[t] === +(e > 0) && n.push(t));
                  }),
                n.join(" ")
              );
            }
            o || ((o = Object.create(null)), Vt(r, "$classCounts", o)),
              "ngClass" !== t &&
                n.$watch("$index", () => {
                  !(function (t) {
                    t === e
                      ? ((o = c(rr((o = i)), 1)),
                        mt(r)
                          ? s.$addClass(o)
                          : n.$postUpdate(() => {
                              "" !== o &&
                                r.classList.add(...o.trim().split(" "));
                            }))
                      : (function (t) {
                          (t = c(rr(t), -1)),
                            mt(r)
                              ? s.$removeClass(t)
                              : n.$postUpdate(() => {
                                  "" !== t &&
                                    r.classList.remove(...t.trim().split(" "));
                                });
                        })(i);
                    var o;
                    a = t;
                  })(1 & n.$index);
                }),
              n.$watch(s[t], (t) => {
                !(function (t) {
                  a === e &&
                    (function (t, e) {
                      const n = rr(t),
                        i = rr(e),
                        o = nr(n, i),
                        a = nr(i, n),
                        l = c(o, -1),
                        u = c(a, 1);
                      mt(r)
                        ? (s.$addClass(u), s.$removeClass(l))
                        : ("" !== u && r.classList.add(...u.trim().split(" ")),
                          "" !== l &&
                            r.classList.remove(...l.trim().split(" ")));
                    })(i, t);
                  i = t;
                })(sr(t));
              });
          },
        };
      }
    );
  }
  function nr(t, e) {
    if (!t || !t.length) return [];
    if (!e || !e.length) return t;
    const n = [];
    t: for (let r = 0; r < t.length; r++) {
      const s = t[r];
      for (let t = 0; t < e.length; t++) if (s === e[t]) continue t;
      n.push(s);
    }
    return n;
  }
  function rr(t) {
    return t && t.split(" ");
  }
  function sr(t) {
    if (!t) return t;
    let e = t;
    return (
      Array.isArray(t)
        ? (e = t.map(sr).join(" "))
        : w(t)
          ? (e = Object.keys(t)
              .filter((e) => t[e])
              .join(" "))
          : E(t) || (e = `${t}`),
      e
    );
  }
  (Zn.$inject = ["$interpolate"]), (tr.$inject = ["$parse"]);
  const ir = er("", !0),
    or = er("Odd", 0),
    ar = er("Even", 1);
  function cr() {
    return {
      restrict: "EA",
      compile(t, e) {
        e.$set("ngCloak", void 0), t.classList.remove("ng-cloak");
      },
    };
  }
  function lr() {
    return { restrict: "A", scope: !0, controller: "@", priority: 500 };
  }
  const ur = "ng-hide",
    hr = "ng-hide-animate";
  function dr(t) {
    return {
      restrict: "A",
      link(e, n, r) {
        e.$watch(r.ngShow, (e) => {
          mt(n)
            ? t[e ? "removeClass" : "addClass"](n, ur, { tempClasses: hr })
            : e
              ? n.classList.remove(ur)
              : n.classList.add(ur);
        });
      },
    };
  }
  function pr(t) {
    return {
      restrict: "A",
      link(e, n, r) {
        e.$watch(r.ngHide, (e) => {
          mt(n)
            ? t[e ? "addClass" : "removeClass"](n, ur, { tempClasses: hr })
            : e
              ? n.classList.add(ur)
              : n.classList.remove(ur);
        });
      },
    };
  }
  function fr(t) {
    return {
      transclude: "element",
      priority: 600,
      terminal: !0,
      restrict: "A",
      link(e, n, r, s, i) {
        let o, a, c;
        e.$watch(r.ngIf, (e) => {
          e
            ? a ||
              i((e, r) => {
                (a = r),
                  (o = e),
                  mt(e) ? t.enter(e, n.parentElement, n) : n.after(e);
              })
            : (c && (Ft(c), (c = null)),
              a && (a.$destroy(), (a = null)),
              o &&
                ((c = o),
                mt(c)
                  ? t.leave(c).done((t) => {
                      !1 !== t && (c = null);
                    })
                  : n.nextElementSibling.remove(),
                (o = null)));
        });
      },
    };
  }
  function $r(t, e, n) {
    return {
      restrict: "EA",
      priority: 400,
      terminal: !0,
      transclude: "element",
      controller: () => {},
      compile(r, s) {
        const i = s.ngInclude || s.src,
          o = s.onload || "",
          a = s.autoscroll;
        return (r, s, c, l, u) => {
          function h() {
            !b(a) || (a && !r.$eval(a)) || e();
          }
          let d,
            p,
            f,
            $ = 0;
          const m = () => {
            p && (p.remove(), (p = null)),
              d && (d.$destroy(), (d = null)),
              f &&
                (mt(f)
                  ? n.leave(f).done((t) => {
                      !1 !== t && (p = null);
                    })
                  : f.remove(),
                (p = f),
                (f = null));
          };
          r.$watch(i, async (e) => {
            const i = function (t) {
                !1 !== t && h();
              },
              a = ++$;
            e
              ? (await t(e, !0).then(
                  (t) => {
                    if (r.$$destroyed) return;
                    if (a !== $) return;
                    const c = r.$new();
                    l.template = t;
                    const p = u(c, (t) => {
                      m(),
                        mt(t) ? n.enter(t, null, s).done(i) : (s.after(t), h());
                    });
                    (d = c),
                      (f = p),
                      d.$emit("$includeContentLoaded", e),
                      r.$eval(o);
                  },
                  () => {
                    r.$$destroyed ||
                      (a === $ && (m(), r.$emit("$includeContentError", e)));
                  },
                ),
                r.$emit("$includeContentRequested", e))
              : (m(), (l.template = null));
          });
        };
      },
    };
  }
  function mr(t) {
    return {
      restrict: "EA",
      priority: -400,
      require: "ngInclude",
      link(e, n, r, s) {
        (n.innerHTML = s.template), t(n.childNodes)(e);
      },
    };
  }
  function gr() {
    return {
      priority: 450,
      compile: () => ({
        pre(t, e, n) {
          const r = Ut(e);
          r ? r.$eval(n.ngInit) : t.$eval(n.ngInit);
        },
      }),
    };
  }
  function yr() {
    return { restrict: "EA", terminal: !0, priority: 1e3 };
  }
  (dr.$inject = ["$animate"]),
    (pr.$inject = ["$animate"]),
    (fr.$inject = ["$animate"]),
    ($r.$inject = ["$templateRequest", "$anchorScroll", "$animate"]),
    (mr.$inject = ["$compile"]);
  const vr = dt("ngRef");
  function br(t) {
    return {
      priority: -1,
      restrict: "A",
      compile(e, n) {
        const r = $t(F(e)),
          s = t(n.ngRef),
          i =
            s.assign ||
            function () {
              throw vr(
                "nonassign",
                'Expression in ngRef="{0}" is non-assignable!',
                n.ngRef,
              );
            };
        return (t, e, o) => {
          let a;
          if (Object.prototype.hasOwnProperty.call(o, "ngRefRead")) {
            if ("$element" === o.ngRefRead) a = e;
            else if (((a = Pt(e, `$${o.ngRefRead}Controller`)), !a))
              throw vr(
                "noctrl",
                'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"',
                o.ngRefRead,
                n.ngRef,
              );
          } else a = Pt(e, `$${r}Controller`);
          (a = a || e),
            i(t, a),
            e.addEventListener("$destroy", () => {
              s(t) === a && i(t, null);
            });
        };
      },
    };
  }
  br.$inject = ["$parse"];
  const wr = "$$NG_REMOVED",
    Er = dt("ngRepeat"),
    Cr = /^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/;
  function Or(t) {
    function e(t, e, n, r, s, i, o) {
      t[n] !== r && (t[n] = r),
        s && (t[s] = i),
        r && (t.$target.$$hashKey = r.$$hashKey),
        (t.$index = e),
        (t.$first = 0 === e),
        (t.$last = e === o - 1),
        (t.$middle = !(t.$first || t.$last)),
        (t.$odd = !(t.$even = !(1 & e)));
    }
    function n(t) {
      return t.clone;
    }
    function r(t) {
      return t.clone;
    }
    function s(t, e, n) {
      return pt(n);
    }
    function i(t, e) {
      return e;
    }
    return {
      restrict: "A",
      transclude: "element",
      priority: 1e3,
      terminal: !0,
      compile: (o, a) => {
        const c = a.ngRepeat,
          l = !!a.animate;
        let u = c.match(
          /^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/,
        );
        if (!u)
          throw Er(
            "iexp",
            "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
            c,
          );
        const h = u[1],
          d = u[2],
          p = u[3];
        if (((u = h.match(Cr)), !u))
          throw Er(
            "iidexp",
            "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
            h,
          );
        const f = u[3] || u[1],
          $ = u[2];
        if (
          p &&
          (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(p) ||
            /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(
              p,
            ))
        )
          throw Er(
            "badident",
            "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
            p,
          );
        return function (o, a, u, h, m) {
          let g = Object.create(null);
          o.$watch(d, (u) => {
            var h,
              d,
              v,
              b,
              w,
              E,
              C,
              O,
              A,
              S,
              x,
              k,
              _ = a,
              T = Object.create(null);
            if ((p && (o[p] = u), y(u))) (A = u), (O = s);
            else {
              (O = i), (A = []);
              for (const t in u)
                Object.hasOwnProperty.call(u, t) &&
                  "$" !== t.charAt(0) &&
                  A.push(t);
            }
            for (b = A.length, x = new Array(b), h = 0; h < b; h++)
              if (
                ((w = u === A ? h : A[h]),
                (E = u[w]),
                (C = O(o, w, E, h)),
                g[C])
              )
                (S = g[C]), delete g[C], (T[C] = S), (x[h] = S);
              else {
                if (T[C])
                  throw (
                    (Object.values(x).forEach((t) => {
                      t && t.scope && (g[t.id] = t);
                    }),
                    Er(
                      "dupes",
                      "Duplicates keys in a repeater are not allowed. Repeater: {0}, Duplicate key: {1} for value: {2}",
                      c,
                      C,
                      E,
                    ))
                  );
                (x[h] = { id: C, scope: void 0, clone: void 0 }), (T[C] = !0);
              }
            for (var j in g) {
              if (
                ((k = (S = g[j]).clone),
                l ? t.leave(k) : k.remove(),
                k.parentNode)
              )
                for (h = 0, d = k.length; h < d; h++) k[h][wr] = !0;
              S.scope.$destroy();
            }
            for (h = 0; h < b; h++)
              if (((w = u === A ? h : A[h]), (E = u[w]), (S = x[h]).scope)) {
                v = _;
                do {
                  v = v.nextSibling;
                } while (v && v[wr]);
                n(S) !== v && t.move(Bt(S.clone), null, _),
                  (_ = r(S)),
                  e(S.scope, h, f, E, $, w, b);
              } else
                m((n, r) => {
                  S.scope = r;
                  const s = n;
                  l ? t.enter(n, null, _) : _.after(n),
                    (_ = s),
                    (S.clone = n),
                    (T[S.id] = S),
                    e(S.scope, h, f, E, $, w, b);
                });
            g = T;
          });
        };
      },
    };
  }
  function Ar() {
    return {
      restrict: "A",
      link: (t, e, n) => {
        let r;
        t.$watch(n.ngStyle, (t) => {
          if (r) {
            const t = Object.keys(r);
            for (let n = 0, r = t.length; n < r; n++)
              e.style.removeProperty(t[n]);
          }
          if (t) {
            r = { ...t.$target };
            const n = Object.entries(t);
            for (let t = 0, r = n.length; t < r; t++) {
              const [r, s] = n[t];
              e.style.setProperty(r, s);
            }
          }
        });
      },
    };
  }
  function Sr(t) {
    return {
      require: "ngSwitch",
      controller: [
        "$scope",
        class {
          constructor() {
            this.cases = {};
          }
        },
      ],
      link(e, n, r, s) {
        const i = r.ngSwitch || r.on;
        let o = [];
        const a = [],
          c = [],
          l = [],
          u = function (t, e) {
            return function (n) {
              !1 !== n && t.splice(e, 1);
            };
          };
        e.$watch(i, (e) => {
          let n, r;
          for (; c.length; ) t.cancel(c.pop());
          for (n = 0, r = l.length; n < r; ++n) {
            const e = Bt(a[n].clone);
            if ((l[n].$destroy(), mt(e))) {
              (c[n] = t.leave(e)).done(u(c, n));
            } else e.remove();
          }
          (a.length = 0),
            (l.length = 0),
            (o = s.cases[`!${e}`] || s.cases["?"]) &&
              Object.values(o).forEach((e) => {
                e.transclude((n, r) => {
                  l.push(r);
                  const s = e.element,
                    i = { clone: n, comment: document.createComment("") };
                  a.push(i),
                    mt(n)
                      ? t.enter(n, s.parentElement, s)
                      : Zt(n, s.parentElement, s);
                });
              });
        });
      },
    };
  }
  function xr() {
    return {
      transclude: "element",
      terminal: !0,
      priority: 1200,
      restrict: "EA",
      require: "^ngSwitch",
      link(t, e, n, r, s) {
        const i = n.ngSwitchWhen
          .split(n.ngSwitchWhenSeparator)
          .sort()
          .filter((t, e, n) => n[e - 1] !== t);
        i.forEach((t) => {
          (r.cases[`!${t}`] = r.cases[`!${t}`] || []),
            r.cases[`!${t}`].push({ transclude: s, element: e });
        });
      },
    };
  }
  function kr() {
    return {
      restrict: "EA",
      transclude: "element",
      terminal: !0,
      priority: 1200,
      require: "^ngSwitch",
      link(t, e, n, r, s) {
        (r.cases["?"] = r.cases["?"] || []),
          r.cases["?"].push({ transclude: s, element: e });
      },
    };
  }
  (Or.$inject = ["$animate"]), (Sr.$inject = ["$animate"]);
  const _r = dt("ngOptions"),
    Tr =
      /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
    jr = [
      "$compile",
      "$parse",
      function (t, e) {
        const n = document.createElement("option"),
          r = document.createElement("optgroup");
        return {
          restrict: "A",
          terminal: !0,
          require: ["select", "ngModel"],
          link: {
            pre: function (t, e, n, r) {
              r[0].registerOption = () => {};
            },
            post: function (s, i, o, a) {
              const c = a[0],
                l = a[1],
                { multiple: u } = o;
              for (let t = 0, e = i.childNodes, n = e.length; t < n; t++)
                if ("" === e[t].value) {
                  (c.hasEmptyOption = !0), (c.emptyOption = e[t]);
                  break;
                }
              Yt(i);
              const h = !!c.emptyOption;
              let d;
              n.cloneNode(!1).nodeValue = "?";
              const p = (function (t, n, r) {
                  const s = t.match(Tr);
                  if (!s)
                    throw _r(
                      "iexp",
                      "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}",
                      t,
                      qt(n[0]),
                    );
                  const i = s[5] || s[7],
                    o = s[6],
                    a = / as /.test(s[0]) && s[1],
                    c = s[9],
                    l = e(s[2] ? s[1] : i),
                    u = (a && e(a)) || l,
                    h = c && e(c),
                    d = c
                      ? function (t, e) {
                          return h(r, e);
                        }
                      : function (t) {
                          return pt(t);
                        },
                    p = function (t, e) {
                      return d(t, b(t, e));
                    },
                    f = e(s[2] || s[1]),
                    $ = e(s[3] || ""),
                    m = e(s[4] || ""),
                    g = e(s[8]),
                    v = {};
                  let b = o
                    ? function (t, e) {
                        return (v[o] = e), (v[i] = t), v;
                      }
                    : function (t) {
                        return (v[i] = t), v;
                      };
                  function w(t, e, n, r, s) {
                    (this.selectValue = t),
                      (this.viewValue = e),
                      (this.label = n),
                      (this.group = r),
                      (this.disabled = s);
                  }
                  function E(t) {
                    let e;
                    if (!o && y(t)) e = t;
                    else {
                      e = [];
                      for (const n in t)
                        Object.prototype.hasOwnProperty.call(t, n) &&
                          "$" !== n.charAt(0) &&
                          e.push(n);
                    }
                    return e;
                  }
                  return {
                    trackBy: c,
                    getTrackByValue: p,
                    getWatchables: e(g, (t) => {
                      const e = [],
                        n = E((t = t || [])),
                        i = n.length;
                      for (let o = 0; o < i; o++) {
                        const i = t === n ? o : n[o],
                          a = t[i],
                          c = b(a, i),
                          l = d(a, c);
                        if ((e.push(l), s[2] || s[1])) {
                          const t = f(r, c);
                          e.push(t);
                        }
                        if (s[4]) {
                          const t = m(r, c);
                          e.push(t);
                        }
                      }
                      return e;
                    }),
                    getOptions() {
                      const t = [],
                        e = {},
                        n = g(r) || [],
                        s = E(n),
                        i = s.length;
                      for (let o = 0; o < i; o++) {
                        const i = n === s ? o : s[o],
                          a = n[i],
                          c = b(a, i),
                          l = u(r, c),
                          h = d(l, c),
                          p = new w(h, l, f(r, c), $(r, c), m(r, c));
                        t.push(p), (e[h] = p);
                      }
                      return {
                        items: t,
                        selectValueMap: e,
                        getOptionFromViewValue: (t) => e[p(t)],
                        getViewValueFromOption: (t) =>
                          c ? structuredClone(t.viewValue) : t.viewValue,
                      };
                    },
                  };
                })(o.ngOptions, i, s),
                f = document.createDocumentFragment();
              if (
                ((c.generateUnknownOptionValue = () => "?"),
                u
                  ? ((c.writeValue = function (t) {
                      if (!d) return;
                      const e = (t && t.map(m)) || [];
                      d.items.forEach((t) => {
                        t.element.selected &&
                          !q(e, t) &&
                          (t.element.selected = !1);
                      });
                    }),
                    (c.readValue = function () {
                      const t = i.value || [],
                        e = [];
                      return (
                        t.forEach((t) => {
                          const n = d.selectValueMap[t];
                          n &&
                            !n.disabled &&
                            e.push(d.getViewValueFromOption(n));
                        }),
                        e
                      );
                    }),
                    p.trackBy &&
                      s.$watchCollection(
                        () => {
                          if (Array.isArray(l.$viewValue))
                            return l.$viewValue.map((t) =>
                              p.getTrackByValue(t),
                            );
                        },
                        () => {
                          l.$render();
                        },
                      ))
                  : ((c.writeValue = function (t) {
                      if (!d) return;
                      const e = i.options[i.selectedIndex],
                        n = d.getOptionFromViewValue(t);
                      e && e.removeAttribute("selected"),
                        n
                          ? (i.value !== n.selectValue &&
                              (c.removeUnknownOption(),
                              (i.value = n.selectValue),
                              (n.element.selected = !0)),
                            n.element.setAttribute("selected", "selected"))
                          : c.selectUnknownOrEmptyOption(t);
                    }),
                    (c.readValue = function () {
                      const t = d.selectValueMap[i.value];
                      return t && !t.disabled
                        ? (c.unselectEmptyOption(),
                          c.removeUnknownOption(),
                          d.getViewValueFromOption(t))
                        : null;
                    })),
                h)
              ) {
                const e = t(c.emptyOption);
                ct(e, "LinkFn required"),
                  e(s),
                  i.prepend(c.emptyOption),
                  c.emptyOption[0].nodeType === Node.COMMENT_NODE &&
                    ((c.hasEmptyOption = !1),
                    (c.registerOption = function (t, e) {
                      "" === e.value &&
                        ((c.hasEmptyOption = !0),
                        (c.emptyOption = e),
                        l.$render(),
                        e.addEventListener("$destroy", () => {
                          const t = c.$isEmptyOptionSelected();
                          (c.hasEmptyOption = !1),
                            (c.emptyOption = void 0),
                            t && l.$render();
                        }));
                    }));
              }
              function $(t, e) {
                const r = n.cloneNode(!1);
                e.appendChild(r),
                  (function (t, e) {
                    (t.element = e),
                      (e.disabled = t.disabled),
                      t.label !== e.label &&
                        ((e.label = t.label), (e.textContent = t.label));
                    e.value = t.selectValue;
                  })(t, r);
              }
              function m(t) {
                const e = d.getOptionFromViewValue(t),
                  n = e && e.element;
                return n && !n.selected && (n.selected = !0), e;
              }
              s.$watchCollection(p.getWatchables, function () {
                const t = d && c.readValue();
                if (d)
                  for (let t = d.items.length - 1; t >= 0; t--) {
                    const e = d.items[t];
                    b(e.group) ? Ft(e.element.parentNode) : Ft(e.element);
                  }
                d = p.getOptions();
                const e = {};
                if (
                  (d.items.forEach((t) => {
                    let n;
                    b(t.group)
                      ? ((n = e[t.group]),
                        n ||
                          ((n = r.cloneNode(!1)),
                          f.appendChild(n),
                          (n.label = null === t.group ? "null" : t.group),
                          (e[t.group] = n)),
                        $(t, n))
                      : $(t, f);
                  }),
                  i.appendChild(f),
                  l.$render(),
                  !l.$isEmpty(t))
                ) {
                  const e = c.readValue();
                  (p.trackBy || u ? z(t, e) : t === e) ||
                    (l.$setViewValue(e), l.$render());
                }
              });
            },
          },
        };
      },
    ],
    Rr = dt("ngTransclude"),
    Lr = [
      "$compile",
      function (t) {
        return {
          restrict: "EA",
          compile: function (e) {
            const n = t(e.childNodes);
            return (
              Yt(e),
              function (t, e, r, s, i) {
                if (!i)
                  throw Rr(
                    "orphan",
                    "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}",
                    qt(e),
                  );
                r.ngTransclude === r.$attr.ngTransclude &&
                  (r.ngTransclude = "");
                const o = r.ngTransclude || r.ngTranscludeSlot;
                function a() {
                  n(t, (t) => {
                    e.append(t);
                  });
                }
                i(
                  function (t, n) {
                    !(function (t) {
                      if (t instanceof Array) return !1;
                      if (t.nodeType !== Node.TEXT_NODE || t.nodeValue.trim())
                        return !0;
                    })(t)
                      ? (a(), n.$destroy())
                      : t instanceof NodeList
                        ? Array.from(t).forEach((t) => {
                            e.append(t);
                          })
                        : e.append(t);
                  },
                  null,
                  o,
                ),
                  o && !i.isSlotFilled(o) && a();
              }
            );
          },
        };
      },
    ];
  function Nr() {
    return {
      restrict: "A",
      require: "ngModel",
      link(t, e, n, r) {
        r.$viewChangeListeners.push(() => t.$eval(n.ngChange));
      },
    };
  }
  const Vr = /^\/(.+)\/([a-z]*)$/,
    Pr = {};
  Ot.forEach((t) => {
    if ("multiple" === t) return;
    function e(e, r, s) {
      e.$watch(s[n], (e) => {
        s.$set(t, !!e);
      });
    }
    let n = $t(`ng-${t}`),
      r = e;
    "checked" === t &&
      (r = function (t, r, s) {
        s.ngModel !== s[n] && e(t, 0, s);
      }),
      (Pr[n] = function () {
        return { restrict: "A", priority: 100, link: r };
      });
  }),
    Object.entries(h).forEach(([t]) => {
      Pr[t] = function () {
        return {
          priority: 100,
          link(e, n, r) {
            if ("ngPattern" === t && "/" === r.ngPattern.charAt(0)) {
              const t = r.ngPattern.match(Vr);
              if (t) return void r.$set("ngPattern", new RegExp(t[1], t[2]));
            }
            e.$watch(r[t], (e) => {
              r.$set(t, e);
            });
          },
        };
      };
    }),
    ["src", "srcset", "href"].forEach((t) => {
      const e = $t(`ng-${t}`);
      Pr[e] = [
        "$sce",
        function (n) {
          return {
            priority: 99,
            link(r, s, i) {
              let o = t;
              "href" === t &&
                "[object SVGAnimatedString]" === toString.call(s.href) &&
                ((o = "xlinkHref"), (i.$attr[o] = "href")),
                i.$set(e, n.getTrustedMediaUrl(i[e])),
                i.$observe(e, (e) => {
                  e ? i.$set(o, e) : "href" === t && i.$set(o, null);
                });
            },
          };
        },
      ];
    });
  const Mr = [
      "$parse",
      (t) => ({
        restrict: "A",
        require: "?ngModel",
        link: (e, n, r, s) => {
          if (!s) return;
          let i =
            Object.prototype.hasOwnProperty.call(r, "required") ||
            t(r.ngRequired)(e);
          r.ngRequired || (r.required = !0),
            (s.$validators.required = (t, e) => !i || !s.$isEmpty(e)),
            r.$observe("required", (t) => {
              i !== t && ((i = t), s.$validate());
            });
        },
      }),
    ],
    Dr = [
      "$parse",
      (t) => ({
        restrict: "A",
        require: "?ngModel",
        compile: (e, n) => {
          var r, s;
          return (
            n.ngPattern &&
              ((r = n.ngPattern),
              (s =
                "/" === n.ngPattern.charAt(0) && Vr.test(n.ngPattern)
                  ? function () {
                      return n.ngPattern;
                    }
                  : t(n.ngPattern))),
            function (t, e, n, i) {
              if (i) {
                var o = n.pattern;
                n.ngPattern ? (o = s(t)) : (r = n.pattern);
                var a = Hr(o, r, e);
                n.$observe("pattern", function (t) {
                  var n = a;
                  (a = Hr(t, r, e)),
                    (n && n.toString()) !== (a && a.toString()) &&
                      i.$validate();
                }),
                  (i.$validators.pattern = function (t, e) {
                    return i.$isEmpty(e) || v(a) || a.test(e);
                  });
              }
            }
          );
        },
      }),
    ],
    Ir = [
      "$parse",
      (t) => ({
        restrict: "A",
        require: "?ngModel",
        link: (e, n, r, s) => {
          if (!s) return;
          let i = r.maxlength || t(r.ngMaxlength)(e),
            o = Fr(i);
          r.$observe("maxlength", (t) => {
            i !== t && ((o = Fr(t)), (i = t), s.$validate());
          }),
            (s.$validators.maxlength = function (t, e) {
              return o < 0 || s.$isEmpty(e) || e.length <= o;
            });
        },
      }),
    ],
    Ur = [
      "$parse",
      function (t) {
        return {
          restrict: "A",
          require: "?ngModel",
          link(e, n, r, s) {
            if (!s) return;
            let i = r.minlength || t(r.ngMinlength)(e),
              o = Fr(i) || -1;
            r.$observe("minlength", (t) => {
              i !== t && ((o = Fr(t) || -1), (i = t), s.$validate());
            }),
              (s.$validators.minlength = function (t, e) {
                return s.$isEmpty(e) || e.length >= o;
              });
          },
        };
      },
    ];
  function Hr(t, e, n) {
    if (t) {
      if (
        (p(t) && (t = t.$target), E(t) && (t = new RegExp(`^${t}$`)), !t.test)
      )
        throw dt("ngPattern")(
          "noregexp",
          "Expected {0} to be a RegExp but was {1}. Element: {2}",
          e,
          t,
          qt(n),
        );
      return t;
    }
  }
  function Fr(t) {
    const e = M(t);
    return D(e) ? -1 : e;
  }
  class qr {
    constructor() {
      this.autoScrollingEnabled = !0;
    }
    disableAutoScrolling() {
      this.autoScrollingEnabled = !1;
    }
    $get = [
      "$location",
      "$rootScope",
      function (t, e) {
        function n(t) {
          if (t) {
            t.scrollIntoView();
            const e = (function () {
              let t = r.yOffset;
              if (k(t)) t = t();
              else if (H(t)) {
                const e = t[0];
                t =
                  "fixed" !== window.getComputedStyle(e).position
                    ? 0
                    : e.getBoundingClientRect().bottom;
              } else A(t) || (t = 0);
              return t;
            })();
            if (e) {
              const n = t.getBoundingClientRect().top;
              window.scrollBy(0, n - e);
            }
          } else window.scrollTo(0, 0);
        }
        const r = function (e) {
          let r;
          (e = E(e) ? e : A(e) ? e.toString() : t.hash())
            ? (r = document.getElementById(e)) ||
              (r = (function (t) {
                let e = null;
                return (
                  Array.prototype.some.call(t, (t) => {
                    if ("a" === F(t)) return (e = t), !0;
                  }),
                  e
                );
              })(document.getElementsByName(e)))
              ? n(r)
              : "top" === e && n(null)
            : n(null);
        };
        return (
          this.autoScrollingEnabled &&
            ((e.$location = t),
            e.$watch("$location.$$hash", (t, n) => {
              if (t === n && "" === t) return;
              const s = () => e.$evalAsync(r);
              "complete" === document.readyState
                ? window.setTimeout(() => s())
                : window.addEventListener("load", () => s());
            })),
          r
        );
      },
    ];
  }
  const Br = 1,
    Kr = 2,
    zr = 3,
    Wr = 4,
    Gr = 5,
    Qr = 6,
    Yr = 7,
    Zr = 8,
    Jr = 9,
    Xr = 10,
    ts = 11,
    es = 12,
    ns = 13,
    rs = 14,
    ss = 15,
    is = 16,
    os = 17,
    as = "-add",
    cs = "-remove",
    ls = "-active",
    us = "ng-animate",
    hs = "$$ngAnimateChildren";
  let ds, ps, fs, $s;
  void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend
    ? ((ds = "WebkitTransition"), (ps = "webkitTransitionEnd transitionend"))
    : ((ds = "transition"), (ps = "transitionend")),
    void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend
      ? ((fs = "WebkitAnimation"), ($s = "webkitAnimationEnd animationend"))
      : ((fs = "animation"), ($s = "animationend"));
  const ms = "Duration",
    gs = ns,
    ys = "Delay",
    vs = "TimingFunction",
    bs = fs + ys,
    ws = fs + ms,
    Es = ds + ys,
    Cs = ds + ms,
    Os = dt("ng");
  function As(t, e, n) {
    if (!t) throw Os("areq", "Argument '{0}' is {1}", e || "?", n);
    return t;
  }
  function Ss(t, e, n) {
    let r = "";
    return (
      (t = Array.isArray(t)
        ? t
        : t && E(t) && t.length
          ? t.split(/\s+/)
          : []).forEach((t, s) => {
        t &&
          t.length > 0 &&
          ((r += s > 0 ? " " : ""), (r += n ? e + t : t + e));
      }),
      r
    );
  }
  function xs(t) {
    if (!t) return t;
    for (let e = 0; e < t.length; e++) {
      const n = t[e];
      if (n.nodeType === Node.ELEMENT_NODE) return n;
    }
  }
  function ks(t) {
    if (!(t = t || {}).$$prepared) {
      let e = t.domOperation || (() => {});
      (t.domOperation = function () {
        (t.$$domOperationFired = !0), e(), (e = () => {});
      }),
        (t.$$prepared = !0);
    }
    return t;
  }
  function _s(t, e) {
    Ts(t, e), js(t, e);
  }
  function Ts(t, e) {
    e.from && (e.from = null);
  }
  function js(t, e) {
    e.to && (e.to = null);
  }
  function Rs(t, e, n) {
    const r = e.options || {},
      s = n.options || {},
      i = `${r.addClass || ""} ${s.addClass || ""}`,
      o = `${r.removeClass || ""} ${s.removeClass || ""}`,
      a = (function (t, e, n) {
        const r = 1,
          s = -1,
          i = {};
        (t = a(t)),
          (e = a(e)),
          Object.keys(e).forEach((t) => {
            i[t] = r;
          }),
          (n = a(n)),
          Object.keys(n).forEach((t) => {
            i[t] = i[t] === r ? null : s;
          });
        const o = { addClass: "", removeClass: "" };
        function a(t) {
          E(t) && (t = t.trim().split(" "));
          const e = {};
          return (
            t &&
              t.forEach((t) => {
                t.length && (e[t] = !0);
              }),
            e
          );
        }
        return (
          Object.entries(i).forEach(([e, n]) => {
            var i, a;
            n === r
              ? ((i = "addClass"), (a = !t[e] || t[e + cs]))
              : n === s && ((i = "removeClass"), (a = t[e] || t[e + as])),
              a && (o[i].length && (o[i] += " "), (o[i] += e));
          }),
          o
        );
      })(t.getAttribute("class"), i, o);
    s.preparationClasses &&
      ((r.preparationClasses = Vs(s.preparationClasses, r.preparationClasses)),
      delete s.preparationClasses);
    const c = r.domOperation !== (() => {}) ? r.domOperation : null;
    return (
      P(r, s),
      c && (r.domOperation = c),
      a.addClass ? (r.addClass = a.addClass) : (r.addClass = null),
      a.removeClass ? (r.removeClass = a.removeClass) : (r.removeClass = null),
      (e.addClass = r.addClass),
      (e.removeClass = r.removeClass),
      r
    );
  }
  function Ls(t, e) {
    const n = e ? "paused" : "",
      r = fs + "PlayState";
    return Ns(t, [r, n]), [r, n];
  }
  function Ns(t, e) {
    const n = e[0],
      r = e[1];
    t.style[n] = r;
  }
  function Vs(t, e) {
    return t ? (e ? `${t} ${e}` : t) : e;
  }
  const Ps = dt("$animate");
  function Ms(t, e) {
    return t || e
      ? t
        ? e
          ? (Array.isArray(t) && (t = t.join(" ")),
            Array.isArray(e) && (e = e.join(" ")),
            `${t} ${e}`)
          : t
        : e
      : "";
  }
  function Ds(t) {
    return w(t) ? t : {};
  }
  function Is(t) {
    const e = this;
    let n = null,
      r = null;
    (this.$$registeredAnimations = Object.create(null)),
      (this.register = function (n, r) {
        if (n && "." !== n.charAt(0))
          throw Ps(
            "notcsel",
            "Expecting class selector starting with '.' got '{0}'.",
            n,
          );
        const s = `${n}-animation`;
        (e.$$registeredAnimations[n.substring(1)] = s), t.factory(s, r);
      }),
      (this.customFilter = function (t) {
        return 1 === arguments.length && (r = k(t) ? t : null), r;
      }),
      (this.classNameFilter = function (t) {
        if (
          1 === arguments.length &&
          ((n = t instanceof RegExp ? t : null), n)
        ) {
          if (new RegExp(`[(\\s|\\/)]${us}[(\\s|\\/)]`).test(n.toString()))
            throw (
              ((n = null),
              Ps(
                "nongcls",
                '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.',
                us,
              ))
            );
        }
        return n;
      }),
      (this.$get = [
        "$$animateQueue",
        function (t) {
          return {
            on: t.on,
            off: t.off,
            pin: t.pin,
            enabled: t.enabled,
            cancel(t) {
              t.cancel && t.cancel();
            },
            enter: (e, n, r, s) => (
              Zt(e, (n = n || r.parentElement), r), t.push(e, "enter", Ds(s))
            ),
            move: (e, n, r, s) => (
              Zt(e, (n = n || r.parentElement), r), t.push(e, "move", Ds(s))
            ),
            leave: (e, n) =>
              t.push(e, "leave", Ds(n), () => {
                Array.isArray(e) ? e.forEach((t) => Ft(t)) : Ft(e);
              }),
            addClass: (e, n, r) => (
              ((r = Ds(r)).addClass = Ms(r.addClass, n)),
              t.push(e, "addClass", r)
            ),
            removeClass: (e, n, r) => (
              ((r = Ds(r)).removeClass = Ms(r.removeClass, n)),
              t.push(e, "removeClass", r)
            ),
            setClass: (e, n, r, s) => (
              ((s = Ds(s)).addClass = Ms(s.addClass, n)),
              (s.removeClass = Ms(s.removeClass, r)),
              t.push(e, "setClass", s)
            ),
            animate: (e, n, r, s, i) => (
              ((i = Ds(i)).from = i.from ? P(i.from, n) : n),
              (i.to = i.to ? P(i.to, r) : r),
              (s = s || "ng-inline-animate"),
              (i.tempClasses = Ms(i.tempClasses, s)),
              t.push(e, "animate", i)
            ),
          };
        },
      ]);
  }
  function Us(t) {
    return t.replace(/#$/, "");
  }
  Is.$inject = ["$provide"];
  class Hs {
    constructor(t) {
      (this.taskTracker = t),
        (this.pendingDeferIds = {}),
        (this.urlChangeListeners = []),
        (this.urlChangeInit = !1),
        (this.cachedState = null),
        (this.lastHistoryState = null),
        (this.lastBrowserUrl = window.location.href),
        (this.baseElement = document.querySelector("base")),
        (this.$$completeOutstandingRequest =
          this.taskTracker.completeTask.bind(t)),
        (this.$$incOutstandingRequestCount =
          this.taskTracker.incTaskCount.bind(t)),
        (this.notifyWhenNoOutstandingRequests =
          this.taskTracker.notifyWhenNoPendingTasks.bind(t)),
        this.cacheState();
    }
    url(t, e) {
      return (
        void 0 === e && (e = null),
        t
          ? ((t = Le(t).href),
            (this.lastBrowserUrl === t && this.lastHistoryState === e) ||
              ((this.lastBrowserUrl = t),
              (this.lastHistoryState = e),
              history.pushState(e, "", t),
              this.cacheState()),
            this)
          : Us(window.location.href)
      );
    }
    state() {
      return this.cachedState;
    }
    cacheStateAndFireUrlChange() {
      this.fireStateOrUrlChange();
    }
    cacheState() {
      const t = history.state ?? null;
      z(t, this.lastCachedState) ||
        ((this.cachedState = t),
        (this.lastCachedState = t),
        (this.lastHistoryState = t));
    }
    fireStateOrUrlChange() {
      const t = this.lastHistoryState;
      this.cacheState(),
        (this.lastBrowserUrl === this.url() && t === this.cachedState) ||
          ((this.lastBrowserUrl = this.url()),
          (this.lastHistoryState = this.cachedState),
          this.urlChangeListeners.forEach((t) => {
            t(Us(window.location.href), this.cachedState);
          }));
    }
    onUrlChange(t) {
      return (
        this.urlChangeInit ||
          (window.addEventListener(
            "popstate",
            this.cacheStateAndFireUrlChange.bind(this),
          ),
          window.addEventListener(
            "hashchange",
            this.cacheStateAndFireUrlChange.bind(this),
          ),
          (this.urlChangeInit = !0)),
        this.urlChangeListeners.push(t),
        t
      );
    }
    $$applicationDestroyed() {
      window.removeEventListener(
        "popstate",
        this.cacheStateAndFireUrlChange.bind(this),
      ),
        window.removeEventListener(
          "hashchange",
          this.cacheStateAndFireUrlChange.bind(this),
        );
    }
    $$checkUrlChange() {
      this.fireStateOrUrlChange();
    }
    baseHref() {
      const t = this.baseElement?.getAttribute("href");
      return t ? t.replace(/^(https?:)?\/\/[^/]*/, "") : "";
    }
    defer(t, e = 0, n = this.taskTracker.DEFAULT_TASK_TYPE) {
      let r;
      return (
        this.taskTracker.incTaskCount(n),
        (r = window.setTimeout(() => {
          delete this.pendingDeferIds[r], this.taskTracker.completeTask(t, n);
        }, e)),
        (this.pendingDeferIds[r] = n),
        r
      );
    }
    cancel(t) {
      if (Object.prototype.hasOwnProperty.call(this.pendingDeferIds, t)) {
        const e = this.pendingDeferIds[t];
        return (
          delete this.pendingDeferIds[t],
          window.clearTimeout(t),
          this.taskTracker.completeTask(() => {}, e),
          !0
        );
      }
      return !1;
    }
  }
  class Fs {
    $get = ["$$taskTrackerFactory", (t) => new Hs(t)];
  }
  function qs() {
    this.$get = [
      function () {
        var t = [];
        function e(e) {
          t.push(e),
            t.length > 1 ||
              window.requestAnimationFrame(function () {
                for (var e = 0; e < t.length; e++) t[e]();
                t = [];
              });
        }
        return function () {
          var t = !1;
          return (
            e(function () {
              t = !0;
            }),
            function (n) {
              t ? n() : e(n);
            }
          );
        };
      },
    ];
  }
  let Bs, Ks;
  function zs() {
    this.$get = [
      "$$animateAsyncRun",
      function (t) {
        return (Bs = t), Ws;
      },
    ];
  }
  class Ws {
    static chain(t, e) {
      let n = 0;
      !(function r() {
        n !== t.length
          ? t[n]((t) => {
              !1 !== t ? (n++, r()) : e(!1);
            })
          : e(!0);
      })();
    }
    static all(t, e) {
      let n = 0,
        r = !0;
      function s(s) {
        (r = r && s), ++n === t.length && e(r);
      }
      t.forEach((t) => {
        t.done(s);
      });
    }
    constructor(t) {
      this.setHost(t);
      const e = Bs();
      (this._doneCallbacks = []),
        (this._tick = (t) => {
          document.hidden
            ? ((t) => {
                setTimeout(t, 0, !1);
              })(t)
            : e(t);
        }),
        (this._state = 0);
    }
    setHost(t) {
      this.host = t || {};
    }
    done(t) {
      2 === this._state ? t() : this._doneCallbacks.push(t);
    }
    progress() {}
    getPromise() {
      if (!this.promise) {
        const t = this;
        this.promise = new Promise((e, n) => {
          t.done((t) => {
            !1 === t ? n() : e();
          });
        });
      }
      return this.promise;
    }
    then(t, e) {
      return this.getPromise().then(t, e);
    }
    catch(t) {
      return this.getPromise().catch(t);
    }
    finally(t) {
      return this.getPromise().finally(t);
    }
    pause() {
      this.host.pause && this.host.pause();
    }
    resume() {
      this.host.resume && this.host.resume();
    }
    end() {
      this.host.end && this.host.end(), this._resolve(!0);
    }
    cancel() {
      this.host.cancel && this.host.cancel(), this._resolve(!1);
    }
    complete(t) {
      0 === this._state &&
        ((this._state = 1),
        this._tick(() => {
          this._resolve(t);
        }));
    }
    _resolve(t) {
      2 !== this._state &&
        (this._doneCallbacks.forEach((e) => {
          e(t);
        }),
        (this._doneCallbacks.length = 0),
        (this._state = 2));
    }
  }
  class Gs {
    $get = () => new Map();
  }
  const Qs = (t, e) => {
    Ks.error(t, e);
  };
  function Ys() {
    this.$get = [
      "$log",
      function (t) {
        return (Ks = t), Qs;
      },
    ];
  }
  function Zs() {
    return function (t, e, n, r) {
      if (!y(t)) {
        if (null == t) return t;
        throw dt("filter")("notarray", "Expected array but received: {0}", t);
      }
      let s;
      r = r || "$";
      let i = !1;
      switch (Xs(e)) {
        case "function":
          s = e;
          break;
        case "boolean":
        case "null":
        case "number":
        case "string":
          i = !0;
        case "object":
          s = (function (t, e, n, r) {
            const s = w(t) && n in t;
            let i;
            !0 === e
              ? (e = z)
              : k(e) ||
                (e = function (t, e) {
                  return (
                    !v(t) &&
                    (null === t || null === e
                      ? t === e
                      : !(w(e) || (w(t) && !U(t))) &&
                        ((t = `${t}`.toLowerCase()),
                        (e = `${e}`.toLowerCase()),
                        -1 !== t.indexOf(e)))
                  );
                });
            return (
              (i = function (i) {
                return s && !w(i) ? Js(i, t[n], e, n, !1) : Js(i, t, e, n, r);
              }),
              i
            );
          })(e, n, r, i);
          break;
        default:
          return t;
      }
      return Array.prototype.filter.call(t, s);
    };
  }
  function Js(t, e, n, r, s, i) {
    const o = Xs(t),
      a = Xs(e);
    if ("string" === a && "!" === e.charAt(0))
      return !Js(t, e.substring(1), n, r, s);
    if (Array.isArray(t)) return t.some((t) => Js(t, e, n, r, s));
    switch (o) {
      case "object":
        if (s) {
          for (let s in t)
            if (s.charAt && "$" !== s.charAt(0) && Js(t[s], e, n, r, !0))
              return !0;
          return !i && Js(t, e, n, r, !1);
        }
        if ("object" === a) {
          for (let s in e) {
            const i = e[s];
            if (k(i) || v(i)) continue;
            const o = s === r;
            if (!Js(o ? t : t[s], i, n, r, o, o)) return !1;
          }
          return !0;
        }
        return n(t, e);
      case "function":
        return !1;
      default:
        return n(t, e);
    }
  }
  function Xs(t) {
    return null === t ? "null" : typeof t;
  }
  function ti() {
    return function (t, e) {
      return v(e) && (e = 2), X(t, e);
    };
  }
  function ei() {
    return function (t, e, n) {
      return (
        k(t) && (t = t()),
        D((e = Math.abs(Number(e)) === 1 / 0 ? Number(e) : M(e)))
          ? t
          : (A(t) && (t = t.toString()),
            y(t)
              ? ((n =
                  (n = !n || isNaN(n) ? 0 : M(n)) < 0
                    ? Math.max(0, t.length + n)
                    : n),
                e >= 0
                  ? ni(t, n, n + e)
                  : 0 === n
                    ? ni(t, e, t.length)
                    : ni(t, Math.max(0, n + e), n))
              : t)
      );
    };
  }
  function ni(t, e, n) {
    return E(t) ? t.slice(e, n) : [].slice.call(t, e, n);
  }
  function ri(t) {
    return function (r, s, i, o) {
      if (null == r) return r;
      if (k(r)) return r();
      if (!y(r))
        throw dt("orderBy")("notarray", "Expected array but received: {0}", r);
      Array.isArray(s) || (s = [s]), 0 === s.length && (s = ["+"]);
      const a = s.map((e) => {
        let n = 1,
          r = (t) => t;
        if (k(e)) r = e;
        else if (
          E(e) &&
          (("+" !== e.charAt(0) && "-" !== e.charAt(0)) ||
            ((n = "-" === e.charAt(0) ? -1 : 1), (e = e.substring(1))),
          "" !== e)
        ) {
          let n = t(e);
          if (n.constant) {
            const t = n();
            r = (e) => e[t];
          } else r = n;
        }
        return { get: r, descending: n };
      });
      const c = i ? -1 : 1,
        l = k(o) ? o : n,
        u = Array.prototype.map.call(r, function (t, n) {
          return {
            value: t,
            tieBreaker: { value: n, type: "number", index: n },
            predicateValues: a.map((r) =>
              (function (t, n) {
                let r = typeof t;
                null === t
                  ? (r = "null")
                  : "object" === r &&
                    (t = (function (t) {
                      if (k(t.valueOf) && e((t = t.valueOf()))) return t;
                      if (U(t) && e((t = t.toString()))) return t;
                      return t;
                    })(t));
                return { value: t, type: r, index: n };
              })(r.get(t), n),
            ),
          };
        });
      return (
        u.sort(function (t, e) {
          for (let n = 0, r = a.length; n < r; n++) {
            const r = l(t.predicateValues[n], e.predicateValues[n]);
            if (r) return r * a[n].descending * c;
          }
          return (
            (l(t.tieBreaker, e.tieBreaker) || n(t.tieBreaker, e.tieBreaker)) * c
          );
        }),
        (r = u.map((t) => t.value))
      );
    };
    function e(t) {
      switch (typeof t) {
        case "number":
        case "boolean":
        case "string":
          return !0;
        default:
          return !1;
      }
    }
    function n(t, e) {
      let n = 0;
      const r = t.type,
        s = e.type;
      if (r === s) {
        let s = t.value,
          i = e.value;
        "string" === r
          ? ((s = s.toLowerCase()), (i = i.toLowerCase()))
          : "object" === r && (w(s) && (s = t.index), w(i) && (i = e.index)),
          s !== i && (n = s < i ? -1 : 1);
      } else
        n =
          "undefined" === r
            ? 1
            : "undefined" === s
              ? -1
              : "null" === r
                ? 1
                : "null" === s || r < s
                  ? -1
                  : 1;
      return n;
    }
  }
  function si(t) {
    return function (e, n, r) {
      return t.is(e, n, r);
    };
  }
  function ii(t) {
    return function (e, n, r) {
      return t.includes(e, n, r);
    };
  }
  function oi(t) {
    const e = "Filter";
    function n(r, s) {
      if (w(r)) {
        const t = {};
        return (
          Object.entries(r).forEach(([e, r]) => {
            t[e] = n(e, r);
          }),
          t
        );
      }
      return t.factory(r + e, s);
    }
    (this.register = n),
      (this.$get = [
        "$injector",
        function (t) {
          return function (n) {
            return t.get(n + e);
          };
        },
      ]),
      n("filter", Zs),
      n("json", ti),
      n("limitTo", ei),
      n("orderBy", ri),
      n("isState", si),
      n("includedByState", ii);
  }
  (ri.$inject = ["$parse"]),
    (si.$inject = ["$state"]),
    (ii.$inject = ["$state"]),
    (oi.$inject = ["$provide"]);
  class ai {
    constructor(t) {
      this.$filter = t;
    }
    compile(t) {
      let e,
        n,
        r = ci(t, this.$filter);
      (e = (function (t) {
        if (1 === t.body.length && li(t.body[0].expression))
          return {
            type: zr,
            left: t.body[0].expression,
            right: { type: os },
            operator: "=",
          };
      })(r)) && (n = this.recurse(e));
      const s = (function (t) {
        if (1 !== t.length) return;
        const e = t[0].expression,
          n = e.toWatch;
        return 1 !== n.length || n[0] !== e ? n : void 0;
      })(r.body);
      let i;
      if (s) {
        i = [];
        for (const [t, e] of Object.entries(s)) {
          const n = this.recurse(e);
          (n.isPure = e.isPure), (e.input = n), i.push(n), (e.watchId = t);
        }
      }
      const o = [];
      r.body.forEach((t) => {
        o.push(this.recurse(t.expression));
      });
      const a =
        0 === r.body.length
          ? () => {}
          : 1 === r.body.length
            ? o[0]
            : function (t, e) {
                let n;
                return (
                  o.forEach((r) => {
                    n = r(t, e);
                  }),
                  n
                );
              };
      return (
        n && (a.assign = (t, e, r) => n(t, r, e)),
        i && (a.inputs = i),
        (a.decoratedNode = r),
        a
      );
    }
    recurse(t, e, n) {
      let r, s;
      const i = this;
      let o;
      switch (t.type) {
        case ts:
          return this.value(t.value, e);
        case Yr:
          return (
            (s = this.recurse(t.argument)), this[`unary${t.operator}`](s, e)
          );
        case Qr:
        case Gr:
          return (
            (r = this.recurse(t.left)),
            (s = this.recurse(t.right)),
            this[`binary${t.operator}`](r, s, e)
          );
        case Wr:
          return this["ternary?:"](
            this.recurse(t.test),
            this.recurse(t.alternate),
            this.recurse(t.consequent),
            e,
          );
        case Xr:
          return i.identifier(t.name, e, n);
        case Jr:
          return (
            (r = this.recurse(t.object, !1, !!n)),
            t.computed || (s = t.property.name),
            t.computed && (s = this.recurse(t.property)),
            t.computed
              ? this.computedMember(r, s, e, n)
              : this.nonComputedMember(r, s, e, n)
          );
        case Zr:
          return (
            (o = []),
            t.arguments.forEach((t) => {
              o.push(i.recurse(t));
            }),
            t.filter && (s = this.$filter(t.callee.name)),
            t.filter || (s = this.recurse(t.callee, !0)),
            t.filter
              ? function (t, n, r) {
                  const i = [];
                  for (let e = 0; e < o.length; ++e) {
                    const s = o[e](t, n, r);
                    i.push(s);
                  }
                  const a = () => s.apply(void 0, i);
                  return e ? { context: void 0, name: void 0, value: a } : a;
                }
              : function (t, n, r) {
                  const i = s(t, n, r);
                  let a;
                  if (null != i.value && k(i.value)) {
                    const e = [];
                    for (let s = 0; s < o.length; ++s) {
                      const i = o[s](t, n, r);
                      e.push(k(i) ? i() : i);
                    }
                    a = i.value.apply(i.context, e);
                  }
                  return e ? { value: a } : a;
                }
          );
        case zr:
          return (
            (r = this.recurse(t.left, !0, 1)),
            (s = this.recurse(t.right)),
            function (t, n, i) {
              const o = r(t, n, i),
                a = s(t, n, i);
              return (o.context[o.name] = a), e ? { value: a } : a;
            }
          );
        case es:
          return (
            (o = []),
            t.elements.forEach((t) => {
              o.push(i.recurse(t));
            }),
            function (t, n, r) {
              const s = [];
              for (let e = 0; e < o.length; ++e) s.push(o[e](t, n, r));
              return e ? { value: s } : s;
            }
          );
        case rs:
          return (
            (o = []),
            t.properties.forEach((t) => {
              t.computed
                ? o.push({
                    key: i.recurse(t.key),
                    computed: !0,
                    value: i.recurse(t.value),
                  })
                : o.push({
                    key: t.key.type === Xr ? t.key.name : `${t.key.value}`,
                    computed: !1,
                    value: i.recurse(t.value),
                  });
            }),
            function (t, n, r) {
              const s = {};
              for (let e = 0; e < o.length; ++e)
                o[e].computed
                  ? (s[o[e].key(t, n, r)] = o[e].value(t, n, r))
                  : (s[o[e].key] = o[e].value(t, n, r));
              return e ? { value: s } : s;
            }
          );
        case ss:
          return function (t) {
            return e ? { value: t } : t;
          };
        case is:
          return function (t, n) {
            return e ? { value: n } : n;
          };
        case os:
          return function (t, n, r) {
            return e ? { value: r } : r;
          };
      }
    }
    "unary+"(t, e) {
      return function (n, r, s) {
        let i = t(n, r, s);
        return (i = b(i) ? +i : 0), e ? { value: i } : i;
      };
    }
    "unary-"(t, e) {
      return function (n, r, s) {
        let i = t(n, r, s);
        return (i = b(i) ? -i : -0), e ? { value: i } : i;
      };
    }
    "unary!"(t, e) {
      return function (n, r, s) {
        const i = !t(n, r, s);
        return e ? { value: i } : i;
      };
    }
    "binary+"(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i),
          a = e(r, s, i),
          c =
            ((u = a),
            void 0 === (l = o) || w(l) ? u : void 0 === u || w(u) ? l : l + u);
        var l, u;
        return n ? { value: c } : c;
      };
    }
    "binary-"(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i),
          a = e(r, s, i),
          c = (b(o) ? o : 0) - (b(a) ? a : 0);
        return n ? { value: c } : c;
      };
    }
    "binary*"(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) * e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary/"(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) / e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary%"(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) % e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary==="(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) === e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary!=="(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) !== e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary=="(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) == e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary!="(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) != e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary<"(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) < e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary>"(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) > e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary<="(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) <= e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary>="(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) >= e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary&&"(t, e, n) {
      return (r, s, i) => {
        const o = t(r, s, i) && e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "binary||"(t, e, n) {
      return function (r, s, i) {
        const o = t(r, s, i) || e(r, s, i);
        return n ? { value: o } : o;
      };
    }
    "ternary?:"(t, e, n, r) {
      return function (s, i, o) {
        const a = t(s, i, o) ? e(s, i, o) : n(s, i, o);
        return r ? { value: a } : a;
      };
    }
    value(t, e) {
      return function () {
        return e ? { context: void 0, name: void 0, value: t } : t;
      };
    }
    identifier(t, e, n) {
      return function (r, s) {
        const i = s && t in s ? s : r;
        let o;
        return (
          n && 1 !== n && i && null == i[t] && (i[t] = {}),
          i && (o = i[t]),
          e ? { context: i, name: t, value: o } : o
        );
      };
    }
    computedMember(t, e, n, r) {
      return function (s, i, o) {
        const a = t(s, i, o);
        let c, l;
        return (
          null != a &&
            ((c = e(s, i, o)),
            (c = (function (t) {
              return `${t}`;
            })(c)),
            r && 1 !== r && a && !a[c] && (a[c] = {}),
            (l = a[c])),
          n ? { context: a, name: c, value: l } : l
        );
      };
    }
    nonComputedMember(t, e, n, r) {
      return function (s, i, o) {
        const a = t(s, i, o);
        r && 1 !== r && a && null == a[e] && (a[e] = {});
        const c = null != a ? a[e] : void 0;
        return n ? { context: a, name: e, value: c } : c;
      };
    }
  }
  function ci(t, e, n) {
    let r,
      s,
      i,
      o,
      a,
      c,
      l,
      u,
      h,
      d,
      p,
      f = t;
    const $ = (f.isPure = (function (t, e) {
      switch (t.type) {
        case Jr:
          if (t.computed) return !1;
          break;
        case Yr:
          return 1;
        case Qr:
          return "+" !== t.operator && 1;
        case Zr:
          return !1;
      }
      return void 0 === e ? 2 : e;
    })(t, n));
    switch (t.type) {
      case Br:
        return (
          (r = !0),
          f.body.forEach((t) => {
            let n = ci(t.expression, e, $);
            r = r && n.constant;
          }),
          (f.constant = r),
          f
        );
      case ts:
        return (f.constant = !0), (f.toWatch = []), f;
      case Yr:
        var m = ci(f.argument, e, $);
        return (f.constant = m.constant), (f.toWatch = m.toWatch), f;
      case Qr:
        return (
          (o = ci(f.left, e, $)),
          (a = ci(f.right, e, $)),
          (f.constant = o.constant && a.constant),
          (f.toWatch = o.toWatch.concat(a.toWatch)),
          f
        );
      case Gr:
        return (
          (o = ci(f.left, e, $)),
          (a = ci(f.right, e, $)),
          (f.constant = o.constant && a.constant),
          (f.toWatch = f.constant ? [] : [t]),
          f
        );
      case Wr:
        return (
          (c = ci(t.test, e, $)),
          (l = ci(t.alternate, e, $)),
          (u = ci(t.consequent, e, $)),
          (f.constant = c.constant && l.constant && u.constant),
          (f.toWatch = f.constant ? [] : [t]),
          f
        );
      case Xr:
        return (f.constant = !1), (f.toWatch = [t]), f;
      case Jr:
        return (
          (h = ci(t.object, e, $)),
          t.computed && (d = ci(t.property, e, $)),
          (f.constant = h.constant && (!f.computed || d.constant)),
          (f.toWatch = f.constant ? [] : [t]),
          f
        );
      case Zr:
        return (
          (i =
            !!t.filter &&
            (function (t, e) {
              const n = t(e);
              return !n.$stateful;
            })(e, t.callee.name)),
          (r = i),
          (s = []),
          t.arguments.forEach((t) => {
            (m = ci(t, e, $)),
              (r = r && m.constant),
              s.push.apply(s, m.toWatch);
          }),
          (f.constant = r),
          (f.toWatch = i ? s : [f]),
          f
        );
      case zr:
        return (
          (o = ci(t.left, e, $)),
          (a = ci(t.right, e, $)),
          (f.constant = o.constant && a.constant),
          (f.toWatch = [f]),
          f
        );
      case es:
        return (
          (r = !0),
          (s = []),
          t.elements.forEach((t) => {
            (m = ci(t, e, $)),
              (r = r && m.constant),
              s.push.apply(s, m.toWatch);
          }),
          (f.constant = r),
          (f.toWatch = s),
          f
        );
      case rs:
        return (
          (r = !0),
          (s = []),
          t.properties.forEach((t) => {
            (m = ci(t.value, e, $)),
              (r = r && m.constant),
              s.push.apply(s, m.toWatch),
              t.computed &&
                ((p = ci(t.key, e, !1)),
                (r = r && p.constant),
                s.push.apply(s, p.toWatch));
          }),
          (f.constant = r),
          (f.toWatch = s),
          f
        );
      case ss:
      case is:
        return (f.constant = !1), (f.toWatch = []), f;
    }
  }
  function li(t) {
    return t.type === Xr || t.type === Jr;
  }
  const ui = dt("$parse"),
    hi = { n: "\n", f: "\f", r: "\r", t: "\t", v: "\v", "'": "'", '"': '"' },
    di = new Set("+ - * / % === !== == != < > <= >= && || ! = |".split(" "));
  class pi {
    constructor(t) {
      this.options = t;
    }
    lex(t) {
      for (
        this.text = t, this.index = 0, this.tokens = [];
        this.index < this.text.length;

      ) {
        const t = this.text.charAt(this.index);
        if ('"' === t || "'" === t) this.readString(t);
        else if (this.isNumber(t) || ("." === t && this.isNumber(this.peek())))
          this.readNumber();
        else if (
          this.isIdentifierStart &&
          this.isIdentifierStart(this.peekMultichar())
        )
          this.readIdent();
        else if (this.is(t, "(){}[].,;:?"))
          this.tokens.push({ index: this.index, text: t }), this.index++;
        else if (this.isWhitespace(t)) this.index++;
        else {
          const e = t + this.peek(),
            n = e + this.peek(2),
            r = di.has(t),
            s = di.has(e),
            i = di.has(n);
          if (r || s || i) {
            const r = i ? n : s ? e : t;
            this.tokens.push({ index: this.index, text: r, operator: !0 }),
              (this.index += r.length);
          } else
            this.throwError(
              "Unexpected next character ",
              this.index,
              this.index + 1,
            );
        }
      }
      return this.tokens;
    }
    is(t, e) {
      return -1 !== e.indexOf(t);
    }
    peek(t) {
      const e = t || 1;
      return (
        this.index + e < this.text.length && this.text.charAt(this.index + e)
      );
    }
    isNumber(t) {
      return t >= "0" && t <= "9" && "string" == typeof t;
    }
    isWhitespace(t) {
      return " " === t || "\r" === t || "\t" === t || "\n" === t || "\v" === t;
    }
    isIdentifierStart(t) {
      return this.options.isIdentifierStart
        ? this.options.isIdentifierStart(t, this.codePointAt(t))
        : (t >= "a" && t <= "z") ||
            (t >= "A" && t <= "Z") ||
            "_" === t ||
            "$" === t;
    }
    isIdentifierContinue(t) {
      return this.options.isIdentifierContinue
        ? this.options.isIdentifierContinue(t, this.codePointAt(t))
        : (t >= "a" && t <= "z") ||
            (t >= "A" && t <= "Z") ||
            "_" === t ||
            "$" === t ||
            (t >= "0" && t <= "9");
    }
    codePointAt(t) {
      return 1 === t.length
        ? t.charCodeAt(0)
        : (t.charCodeAt(0) << 10) + t.charCodeAt(1) - 56613888;
    }
    peekMultichar() {
      const t = this.text.charAt(this.index),
        e = this.peek();
      if (!e) return t;
      const n = t.charCodeAt(0),
        r = e.charCodeAt(0);
      return n >= 55296 && n <= 56319 && r >= 56320 && r <= 57343 ? t + e : t;
    }
    isExpOperator(t) {
      return "-" === t || "+" === t || this.isNumber(t);
    }
    throwError(t, e, n) {
      n = n || this.index;
      const r = b(e)
        ? `s ${e}-${this.index} [${this.text.substring(e, n)}]`
        : ` ${n}`;
      throw ui(
        "lexerr",
        `Lexer Error: ${t} at column${r} in expression [${this.text}].`,
      );
    }
    readNumber() {
      let t = "";
      const e = this.index;
      for (; this.index < this.text.length; ) {
        const e = this.text.charAt(this.index).toLowerCase();
        if ("." === e || this.isNumber(e)) t += e;
        else {
          const n = this.peek();
          if ("e" === e && this.isExpOperator(n)) t += e;
          else if (
            this.isExpOperator(e) &&
            n &&
            this.isNumber(n) &&
            "e" === t.charAt(t.length - 1)
          )
            t += e;
          else {
            if (
              !this.isExpOperator(e) ||
              (n && this.isNumber(n)) ||
              "e" !== t.charAt(t.length - 1)
            )
              break;
            this.throwError("Invalid exponent");
          }
        }
        this.index++;
      }
      this.tokens.push({ index: e, text: t, constant: !0, value: Number(t) });
    }
    readIdent() {
      const t = this.index;
      for (
        this.index += this.peekMultichar().length;
        this.index < this.text.length;

      ) {
        const t = this.peekMultichar();
        if (this.isIdentifierContinue && !this.isIdentifierContinue(t)) break;
        this.index += t.length;
      }
      this.tokens.push({
        index: t,
        text: this.text.slice(t, this.index),
        identifier: !0,
      });
    }
    readString(t) {
      const e = this.index;
      let n = "",
        r = !1;
      for (this.index++; this.index < this.text.length; ) {
        const s = this.text[this.index];
        if (r)
          (n += "u" === s ? this.handleUnicodeEscape() : hi[s] || s), (r = !1);
        else if ("\\" === s) r = !0;
        else {
          if (s === t)
            return (
              this.tokens.push({
                index: e,
                text: this.text.slice(e, this.index + 1),
                constant: !0,
                value: n,
              }),
              void this.index++
            );
          n += s;
        }
        this.index++;
      }
      this.throwError("Unterminated quote", e);
    }
    handleUnicodeEscape() {
      const t = this.text.substring(this.index + 1, this.index + 5);
      return (
        t.match(/[\da-f]{4}/i) ||
          this.throwError(`Invalid unicode escape [\\u${t}]`),
        (this.index += 4),
        String.fromCharCode(parseInt(t, 16))
      );
    }
  }
  const fi = dt("$parse"),
    $i = new Map(
      Object.entries({ true: !0, false: !1, null: null, undefined: void 0 }),
    );
  class mi {
    constructor(t) {
      (this.lexer = t),
        (this.selfReferential = { this: { type: ss }, $locals: { type: is } });
    }
    ast(t) {
      (this.text = t), (this.tokens = this.lexer.lex(t));
      const e = this.program();
      return (
        0 !== this.tokens.length &&
          this.throwError("is an unexpected token", this.tokens[0]),
        e
      );
    }
    program() {
      const t = [];
      let e = !0;
      for (; e; )
        this.tokens.length > 0 &&
          !this.peek("}", ")", ";", "]") &&
          t.push(this.expressionStatement()),
          this.expect(";") || (e = !1);
      return { type: Br, body: t };
    }
    expressionStatement() {
      return { type: Kr, expression: this.filterChain() };
    }
    filterChain() {
      let t = this.assignment();
      for (; this.expect("|"); ) t = this.filter(t);
      return t;
    }
    assignment() {
      let t = this.ternary();
      if (this.expect("=")) {
        if (!li(t))
          throw fi("lval", "Trying to assign a value to a non l-value");
        t = { type: zr, left: t, right: this.assignment(), operator: "=" };
      }
      return t;
    }
    ternary() {
      const t = this.logicalOR();
      let e, n;
      return this.expect("?") && ((e = this.assignment()), this.consume(":"))
        ? ((n = this.assignment()),
          { type: Wr, test: t, alternate: e, consequent: n })
        : t;
    }
    logicalOR() {
      let t = this.logicalAND();
      for (; this.expect("||"); )
        t = { type: Gr, operator: "||", left: t, right: this.logicalAND() };
      return t;
    }
    logicalAND() {
      let t = this.equality();
      for (; this.expect("&&"); )
        t = { type: Gr, operator: "&&", left: t, right: this.equality() };
      return t;
    }
    equality() {
      let t,
        e = this.relational();
      for (; (t = this.expect("==", "!=", "===", "!==")); )
        e = { type: Qr, operator: t.text, left: e, right: this.relational() };
      return e;
    }
    relational() {
      let t,
        e = this.additive();
      for (; (t = this.expect("<", ">", "<=", ">=")); )
        e = { type: Qr, operator: t.text, left: e, right: this.additive() };
      return e;
    }
    additive() {
      let t,
        e = this.multiplicative();
      for (; (t = this.expect("+", "-")); )
        e = {
          type: Qr,
          operator: t.text,
          left: e,
          right: this.multiplicative(),
        };
      return e;
    }
    multiplicative() {
      let t,
        e = this.unary();
      for (; (t = this.expect("*", "/", "%")); )
        e = { type: Qr, operator: t.text, left: e, right: this.unary() };
      return e;
    }
    unary() {
      let t;
      return (t = this.expect("+", "-", "!"))
        ? { type: Yr, operator: t.text, prefix: !0, argument: this.unary() }
        : this.primary();
    }
    primary() {
      let t, e;
      for (
        this.expect("(")
          ? ((t = this.filterChain()), this.consume(")"))
          : this.expect("[")
            ? (t = this.arrayDeclaration())
            : this.expect("{")
              ? (t = this.object())
              : Object.prototype.hasOwnProperty.call(
                    this.selfReferential,
                    this.peek().text,
                  )
                ? (t = structuredClone(
                    this.selfReferential[this.consume().text],
                  ))
                : $i.has(this.peek().text)
                  ? (t = { type: ts, value: $i.get(this.consume().text) })
                  : this.peek().identifier
                    ? (t = this.identifier())
                    : this.peek().constant
                      ? (t = this.constant())
                      : this.throwError(
                          "not a primary expression",
                          this.peek(),
                        );
        (e = this.expect("(", "[", "."));

      )
        "(" === e.text
          ? ((t = { type: Zr, callee: t, arguments: this.parseArguments() }),
            this.consume(")"))
          : "[" === e.text
            ? ((t = {
                type: Jr,
                object: t,
                property: this.assignment(),
                computed: !0,
              }),
              this.consume("]"))
            : "." === e.text
              ? (t = {
                  type: Jr,
                  object: t,
                  property: this.identifier(),
                  computed: !1,
                })
              : this.throwError("IMPOSSIBLE");
      return t;
    }
    filter(t) {
      const e = [t],
        n = { type: Zr, callee: this.identifier(), arguments: e, filter: !0 };
      for (; this.expect(":"); ) e.push(this.assignment());
      return n;
    }
    parseArguments() {
      const t = [];
      if (")" !== this.peekToken().text)
        do {
          t.push(this.filterChain());
        } while (this.expect(","));
      return t;
    }
    identifier() {
      const t = this.consume();
      return (
        t.identifier || this.throwError("is not a valid identifier", t),
        { type: Xr, name: t.text }
      );
    }
    constant() {
      return { type: ts, value: this.consume().value };
    }
    arrayDeclaration() {
      const t = [];
      if ("]" !== this.peekToken().text)
        do {
          if (this.peek("]")) break;
          t.push(this.assignment());
        } while (this.expect(","));
      return this.consume("]"), { type: es, elements: t };
    }
    object() {
      const t = [];
      let e;
      if ("}" !== this.peekToken().text)
        do {
          if (this.peek("}")) break;
          (e = { type: ns, kind: "init" }),
            this.peek().constant
              ? ((e.key = this.constant()),
                (e.computed = !1),
                this.consume(":"),
                (e.value = this.assignment()))
              : this.peek().identifier
                ? ((e.key = this.identifier()),
                  (e.computed = !1),
                  this.peek(":")
                    ? (this.consume(":"), (e.value = this.assignment()))
                    : (e.value = e.key))
                : this.peek("[")
                  ? (this.consume("["),
                    (e.key = this.assignment()),
                    this.consume("]"),
                    (e.computed = !0),
                    this.consume(":"),
                    (e.value = this.assignment()))
                  : this.throwError("invalid key", this.peek()),
            t.push(e);
        } while (this.expect(","));
      return this.consume("}"), { type: rs, properties: t };
    }
    throwError(t, e) {
      throw fi(
        "syntax",
        "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].",
        e.text,
        t,
        e.index + 1,
        this.text,
        this.text.substring(e.index),
      );
    }
    consume(t) {
      if (0 === this.tokens.length)
        throw fi("ueoe", "Unexpected end of expression: {0}", this.text);
      const e = this.expect(t);
      if (e) return e;
      this.throwError(`is unexpected, expecting [${t}]`, this.peek());
    }
    peekToken() {
      if (0 === this.tokens.length)
        throw fi("ueoe", "Unexpected end of expression: {0}", this.text);
      return this.tokens[0];
    }
    peek(...t) {
      return this.peekAhead(0, ...t);
    }
    peekAhead(t, ...e) {
      if (this.tokens.length > t) {
        const n = this.tokens[t],
          r = n.text;
        if (e.includes(r) || (!e[0] && !e[1] && !e[2] && !e[3])) return n;
      }
      return !1;
    }
    expect(...t) {
      const e = this.peek(...t);
      return !!e && (this.tokens.shift(), e);
    }
  }
  class gi {
    constructor(t, e) {
      (this.ast = new mi(t)), (this.astCompiler = new ai(e));
    }
    parse(t) {
      const { ast: e } = this.getAst(t),
        n = this.astCompiler.compile(e);
      return (
        (n.literal = (function (t) {
          return (
            0 === t.body.length ||
            (1 === t.body.length &&
              (t.body[0].expression.type === ts ||
                t.body[0].expression.type === es ||
                t.body[0].expression.type === rs))
          );
        })(e)),
        (n.constant = (function (t) {
          return t.constant;
        })(e)),
        n
      );
    }
    getAst(t) {
      return (t = t.trim()), { ast: this.ast.ast(t) };
    }
  }
  function yi() {
    const t = Object.create(null);
    var e, n;
    (this.setIdentifierFns = function (t, r) {
      return (e = t), (n = r), this;
    }),
      (this.$get = [
        "$filter",
        function (r) {
          var s = {
            isIdentifierStart: k(e) && e,
            isIdentifierContinue: k(n) && n,
          };
          return function (e, n) {
            var o, a;
            switch (typeof e) {
              case "string":
                if (((e = e.trim()), !(o = t[(a = e)]))) {
                  var c = new pi(s);
                  (o = new gi(c, r).parse(e)), (t[a] = bi(o));
                }
                return i(o, n);
              case "function":
                return i(e, n);
              default:
                return i(() => {}, n);
            }
          };
          function i(t, e) {
            if (!e) return t;
            t.$$interceptor &&
              ((e = (function (t, e) {
                function n(n) {
                  return e(t(n));
                }
                return (
                  (n.$stateful = t.$stateful || e.$stateful),
                  (n.$$pure = t.$$pure && e.$$pure),
                  n
                );
              })(t.$$interceptor, e)),
              (t = t.$$intercepted));
            let n = !1;
            const r = function (r, s, i, o) {
              const a = n && o ? o[0] : t(r, s, i, o);
              if (r?.getter) return;
              const c = k(a) ? a() : a;
              return e(p(c) ? c.$target : c);
            };
            return (
              (r.$$intercepted = t),
              (r.$$interceptor = e),
              (r.literal = t.literal),
              (r.oneTime = t.oneTime),
              (r.constant = t.constant),
              (r.decoratedNode = t.decoratedNode),
              e.$stateful ||
                ((n = !t.inputs),
                (r.inputs = t.inputs ? t.inputs : [t]),
                e.$$pure ||
                  (r.inputs = r.inputs.map(function (t) {
                    return 2 === t.isPure
                      ? function (e) {
                          return t(e);
                        }
                      : t;
                  }))),
              bi(r)
            );
          }
        },
      ]);
  }
  function vi(t, e, n, r) {
    const s = t.$watch(() => (s(), r(t)), e, n);
    return s;
  }
  function bi(t) {
    return (
      t.constant
        ? (t.$$watchDelegate = vi)
        : t.inputs && (t.$$watchDelegate = wi),
      t
    );
  }
  function wi(t, e, n, r) {
    let s,
      i = r.inputs;
    if (1 === i.length) {
      let o = Ei,
        a = i[0];
      return t.$watch(
        (t) => {
          const e = a(t);
          return (
            Ei(e, o, a.isPure) ||
              ((s = r(t, void 0, void 0, [e])), (o = e && Ci(e))),
            s
          );
        },
        e,
        n,
      );
    }
    {
      const o = [],
        a = [];
      for (let t = 0, e = i.length; t < e; t++) (o[t] = Ei), (a[t] = null);
      return t.$watch(
        (t) => {
          let e = !1;
          for (let n = 0, r = i.length; n < r; n++) {
            const r = i[n](t);
            (e || (e = !Ei(r, o[n], i[n].isPure))) &&
              ((a[n] = r), (o[n] = r && Ci(r)));
          }
          return e && (s = r(t, void 0, void 0, a)), s;
        },
        e,
        n,
      );
    }
  }
  function Ei(t, e, n) {
    return null == t || null == e
      ? t === e
      : !("object" == typeof t && "object" == typeof (t = Ci(t)) && !n) &&
          (t === e || (t != t && e != e));
  }
  function Ci(t) {
    return k(t.valueOf)
      ? t.valueOf()
      : {}.constructor.prototype.valueOf.call(t);
  }
  const Oi = dt("$interpolate");
  function Ai(t, e) {
    throw Oi("interr", "Can't interpolate: {0}\n{1}", t, e.toString());
  }
  class Si {
    constructor() {
      (this.startSymbol = "{{"), (this.endSymbol = "}}");
    }
    $get = [
      "$parse",
      "$sce",
      function (t, e) {
        const n = this,
          r = n.startSymbol.length,
          s = n.endSymbol.length,
          i = new RegExp(n.startSymbol.replace(/./g, a), "g"),
          o = new RegExp(n.endSymbol.replace(/./g, a), "g");
        function a(t) {
          return `\\\\\\${t}`;
        }
        function c(t) {
          return t.replace(i, n.startSymbol).replace(o, n.endSymbol);
        }
        function l(i, o, a, l) {
          const u = a === e.URL || a === e.MEDIA_URL;
          if (!i.length || -1 === i.indexOf(n.startSymbol)) {
            if (o) return;
            let t = c(i);
            u && (t = e.getTrusted(a, t));
            const n = () => t;
            return (
              (n.exp = i), (n.expressions = []), (n.$$watchDelegate = vi), n
            );
          }
          let h, d;
          l = !!l;
          let p = 0;
          const f = [];
          let $;
          const m = i.length;
          let g;
          const y = [],
            w = [];
          let E;
          for (; p < m; ) {
            if (
              -1 === (h = i.indexOf(n.startSymbol, p)) ||
              -1 === (d = i.indexOf(n.endSymbol, h + r))
            ) {
              p !== m && y.push(c(i.substring(p)));
              break;
            }
            p !== h && y.push(c(i.substring(p, h))),
              (g = i.substring(h + r, d)),
              f.push(g),
              (p = d + s),
              w.push(y.length),
              y.push("");
          }
          E = 1 === y.length && 1 === w.length;
          const C =
            u && E
              ? void 0
              : function (t) {
                  try {
                    return (
                      (t = a && !u ? e.getTrusted(a, t) : e.valueOf(t)),
                      l && !b(t) ? t : G(t)
                    );
                  } catch (t) {
                    Ai(i, t);
                  }
                };
          if ((($ = f.map((e) => t(e, C))), !o || f.length)) {
            const t = function (t) {
              for (let e = 0, n = f.length; e < n; e++) {
                if (l && v(t[e])) return;
                y[w[e]] = t[e];
              }
              return u
                ? e.getTrusted(a, E ? y[0] : y.join(""))
                : (a &&
                    y.length > 1 &&
                    (function (t) {
                      throw Oi(
                        "noconcat",
                        "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce",
                        t,
                      );
                    })(i),
                  y.join(""));
            };
            return P(
              (e, n) => {
                let r = 0;
                const s = f.length,
                  o = new Array(s);
                try {
                  for (; r < s; r++) {
                    if (n) {
                      const i = f[r].trim();
                      e.$watch(i, () => {
                        let r = new Array(s),
                          i = 0;
                        for (; i < s; i++) {
                          let t = (0, $[i])(e);
                          r[i] = t;
                        }
                        n(t(r));
                      });
                    }
                    o[r] = $[r](e);
                  }
                  return t(o);
                } catch (t) {
                  Ai(i, t);
                }
              },
              {
                exp: i,
                expressions: f,
                $$watchDelegate(e, n) {
                  let r;
                  return e.$watch($, function (s, i) {
                    const o = t(s);
                    n.call(this, o, s !== i ? r : o, e), (r = o);
                  });
                },
              },
            );
          }
        }
        return (
          (l.startSymbol = function () {
            return n.startSymbol;
          }),
          (l.endSymbol = function () {
            return n.endSymbol;
          }),
          l
        );
      },
    ];
  }
  let xi = {},
    ki = "";
  function _i(t) {
    try {
      return decodeURIComponent(t);
    } catch (e) {
      return t;
    }
  }
  const Ti = "application/json",
    ji = { "Content-Type": `${Ti};charset=utf-8` },
    Ri = /^\[|^\{(?!\{)/,
    Li = { "[": /]$/, "{": /}$/ },
    Ni = /^\)]\}',?\n/,
    Vi = dt("$http");
  function Pi(t) {
    return w(t) ? (S(t) ? t.toISOString() : X(t)) : t;
  }
  function Mi() {
    this.$get = function () {
      return function (t) {
        if (!t) return "";
        const e = [];
        return (
          Object.keys(t)
            .sort()
            .forEach((n) => {
              const r = t[n];
              null === r ||
                v(r) ||
                k(r) ||
                (Array.isArray(r)
                  ? r.forEach((t) => {
                      e.push(`${st(n)}=${st(Pi(t))}`);
                    })
                  : e.push(`${st(n)}=${st(Pi(r))}`));
            }),
          e.join("&")
        );
      };
    };
  }
  function Di(t, e) {
    if (E(t)) {
      const r = t.replace(Ni, "").trim();
      if (r) {
        const s = e("Content-Type"),
          i = s && 0 === s.indexOf(Ti);
        if (
          i ||
          (function (t) {
            const e = t.match(Ri);
            return e && Li[e[0]].test(t);
          })(r)
        )
          try {
            t = E((n = r)) ? JSON.parse(n) : n;
          } catch (e) {
            if (!i) return t;
            throw Vi(
              "baddata",
              'Data must be a valid JSON object. Received: "{0}". Parse error: "{1}"',
              t,
              e,
            );
          }
      }
    }
    var n;
    return t;
  }
  function Ii(t) {
    const e = Object.create(null);
    let n;
    function r(t, n) {
      t && (e[t] = e[t] ? `${e[t]}, ${n}` : n);
    }
    return (
      E(t)
        ? t.split("\n").forEach((t) => {
            (n = t.indexOf(":")),
              r(t.substring(0, n).trim().toLowerCase(), N(t.substring(n + 1)));
          })
        : w(t) &&
          Object.entries(t).forEach(([t, e]) => {
            r(g(t), N(e));
          }),
      e
    );
  }
  function Ui(t) {
    let e;
    return function (n) {
      if ((e || (e = Ii(t)), n)) {
        let t = e[g(n)];
        return void 0 === t && (t = null), t;
      }
      return e;
    };
  }
  function Hi(t, e, n, r) {
    return k(r)
      ? r(t, e, n)
      : (Array.isArray(r) &&
          r.forEach((r) => {
            t = r(t, e, n);
          }),
        t);
  }
  function Fi(t) {
    return t >= 200 && t < 300;
  }
  function qi() {
    const t = (this.defaults = {
      transformResponse: [Di],
      transformRequest: [
        function (t) {
          return !w(t) ||
            ((e = t), "[object File]" === toString.call(e)) ||
            (function (t) {
              return "[object Blob]" === toString.call(t);
            })(t) ||
            (function (t) {
              return "[object FormData]" === toString.call(t);
            })(t)
            ? t
            : X(t);
          var e;
        },
      ],
      headers: {
        common: { Accept: "application/json, text/plain, */*" },
        post: ot(ji),
        put: ot(ji),
        patch: ot(ji),
      },
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      paramSerializer: "$httpParamSerializer",
    });
    let e = !1;
    this.useApplyAsync = function (t) {
      return b(t) ? ((e = !!t), this) : e;
    };
    const n = (this.interceptors = []),
      r = (this.xsrfTrustedOrigins = []);
    Object.defineProperty(this, "xsrfWhitelistedOrigins", {
      get() {
        return this.xsrfTrustedOrigins;
      },
      set(t) {
        this.xsrfTrustedOrigins = t;
      },
    }),
      (this.$get = [
        "$browser",
        "$httpBackend",
        "$rootScope",
        "$injector",
        "$sce",
        function (s, i, o, a, c) {
          const l = new Map();
          t.paramSerializer = E(t.paramSerializer)
            ? a.get(t.paramSerializer)
            : t.paramSerializer;
          const u = [];
          n.forEach((t) => {
            u.unshift(E(t) ? a.get(t) : a.invoke(t));
          });
          const h = (function (t) {
            const e = [je].concat(t.map(Le));
            return function (t) {
              const n = Le(t);
              return e.some(Ve.bind(null, n));
            };
          })(r);
          function d(n) {
            if (!w(n))
              throw dt("$http")(
                "badreq",
                "Http request configuration must be an object.  Received: {0}",
                n,
              );
            if (!E(c.valueOf(n.url)))
              throw dt("$http")(
                "badreq",
                "Http request configuration url must be a string or a $sce trusted object.  Received: {0}",
                n.url,
              );
            const r = P(
              {
                method: "get",
                transformRequest: t.transformRequest,
                transformResponse: t.transformResponse,
                paramSerializer: t.paramSerializer,
              },
              n,
            );
            var p;
            (r.headers = (function (e) {
              let n = t.headers,
                r = P({}, e.headers);
              return (
                (n = P({}, n.common, n[g(e.method)])),
                Object.keys(n).forEach((t) => {
                  const e = g(t);
                  Object.keys(r).some((t) => g(t) === e) || (r[t] = n[t]);
                }),
                (function (t, e) {
                  let n;
                  const r = {};
                  return (
                    Object.entries(t).forEach(([t, s]) => {
                      k(s) ? ((n = s(e)), null != n && (r[t] = n)) : (r[t] = s);
                    }),
                    r
                  );
                })(r, ot(e))
              );
            })(n)),
              (r.method = E((p = r.method)) ? p.toUpperCase() : p),
              (r.paramSerializer = E(r.paramSerializer)
                ? a.get(r.paramSerializer)
                : r.paramSerializer),
              s.$$incOutstandingRequestCount("$http");
            const f = [],
              $ = [];
            let m = Promise.resolve(r);
            return (
              u.forEach((t) => {
                (t.request || t.requestError) &&
                  f.unshift(t.request, t.requestError),
                  (t.response || t.responseError) &&
                    $.push(t.response, t.responseError);
              }),
              (m = y(m, f)),
              (m = m.then(function (n) {
                const { headers: r } = n,
                  s = Hi(n.data, Ui(r), void 0, n.transformRequest);
                v(s) &&
                  Object.keys(r).forEach((t) => {
                    "content-type" === g(t) && delete r[t];
                  });
                v(n.withCredentials) &&
                  !v(t.withCredentials) &&
                  (n.withCredentials = t.withCredentials);
                return (function (n, r) {
                  const {
                    promise: s,
                    resolve: a,
                    reject: u,
                  } = Promise.withResolvers();
                  let p, f;
                  const $ = n.headers;
                  let { url: m } = n;
                  E(m) || (m = c.valueOf(m));
                  (m = (function (t, e) {
                    e.length > 0 &&
                      (t += (-1 === t.indexOf("?") ? "?" : "&") + e);
                    return t;
                  })(m, n.paramSerializer(n.params))),
                    d.pendingRequests.push(n),
                    s.then(A, A),
                    (n.cache || t.cache) &&
                      !1 !== n.cache &&
                      "GET" === n.method &&
                      (p = w(n.cache) ? n.cache : w(t.cache) ? t.cache : l);
                  p &&
                    ((f = p.get(m)),
                    b(f)
                      ? L(f)
                        ? f.then(O, O)
                        : Array.isArray(f)
                          ? C(f[1], f[0], ot(f[2]), f[3], f[4])
                          : C(f, 200, {}, "OK", "complete")
                      : p.set(m, s));
                  if (v(f)) {
                    const e = h(n.url)
                      ? (function () {
                          let t, e, n, r, s;
                          const i = document.cookie;
                          if (i !== ki)
                            for (
                              ki = i, t = ki.split("; "), xi = {}, n = 0;
                              n < t.length;
                              n++
                            )
                              (e = t[n]),
                                (r = e.indexOf("=")),
                                r > 0 &&
                                  ((s = _i(e.substring(0, r))),
                                  v(xi[s]) && (xi[s] = _i(e.substring(r + 1))));
                          return xi;
                        })()[n.xsrfCookieName || t.xsrfCookieName]
                      : void 0;
                    e && ($[n.xsrfHeaderName || t.xsrfHeaderName] = e),
                      i(
                        n.method,
                        m,
                        r,
                        y,
                        $,
                        n.timeout,
                        n.withCredentials,
                        n.responseType,
                        g(n.eventHandlers),
                        g(n.uploadEventHandlers),
                      );
                  }
                  return s;
                  function g(t) {
                    if (t) {
                      const n = {};
                      return (
                        Object.entries(t).forEach(([t, r]) => {
                          n[t] = function (t) {
                            function n() {
                              r(t);
                            }
                            e ? setTimeout(() => o.$apply(n)) : o.$apply(n);
                          };
                        }),
                        n
                      );
                    }
                  }
                  function y(t, n, r, s, i) {
                    function o() {
                      C(n, t, r, s, i);
                    }
                    p && (Fi(t) ? p.set(m, [t, n, Ii(r), s, i]) : p.delete(m)),
                      e ? setTimeout(o) : o();
                  }
                  function C(t, e, r, s, i) {
                    (Fi((e = e >= -1 ? e : 0)) ? a : u)({
                      data: t,
                      status: e,
                      headers: Ui(r),
                      config: n,
                      statusText: s,
                      xhrStatus: i,
                    });
                  }
                  function O(t) {
                    C(
                      t.data,
                      t.status,
                      ot(t.headers()),
                      t.statusText,
                      t.xhrStatus,
                    );
                  }
                  function A() {
                    const t = d.pendingRequests.indexOf(n);
                    -1 !== t && d.pendingRequests.splice(t, 1);
                  }
                })(n, s).then(C, C);
              })),
              (m = y(m, $)),
              (m = m.finally(function () {
                s.$$completeOutstandingRequest(() => {}, "$http");
              })),
              m
            );
            function y(t, e) {
              for (let n = 0, r = e.length; n < r; ) {
                const r = e[n++],
                  s = e[n++];
                t = t.then(r, s);
              }
              return (e.length = 0), t;
            }
            function C(t) {
              const e = P({}, t);
              return (
                (e.data = Hi(t.data, t.headers, t.status, r.transformResponse)),
                Fi(t.status) ? e : Promise.reject(e)
              );
            }
          }
          return (
            (d.pendingRequests = []),
            (function (...t) {
              t.forEach((t) => {
                d[t] = function (e, n) {
                  return d(P({}, n || {}, { method: t, url: e }));
                };
              });
            })("get", "delete", "head"),
            (function (...t) {
              t.forEach((t) => {
                d[t] = function (e, n, r) {
                  return d(P({}, r || {}, { method: t, url: e, data: n }));
                };
              });
            })("post", "put", "patch"),
            (d.defaults = t),
            d
          );
        },
      ]);
  }
  function Bi() {
    this.$get = [
      "$browser",
      function (t) {
        return (function (t) {
          return function (e, n, r, s, i, o, a, c, l, u) {
            n = n || t.url();
            const h = new XMLHttpRequest();
            let d = !1;
            if (
              (h.open(e, n, !0),
              i &&
                Object.entries(i).forEach(([t, e]) => {
                  b(e) && h.setRequestHeader(t, e);
                }),
              (h.onload = function () {
                const t = h.statusText || "";
                let e = h.status;
                0 === e &&
                  (e = h.response ? 200 : "file" === Le(n).protocol ? 404 : 0),
                  $(s, e, h.response, h.getAllResponseHeaders(), t, "complete");
              }),
              (h.onerror = function () {
                $(s, -1, null, null, "", "error");
              }),
              (h.ontimeout = function () {
                $(s, -1, null, null, "", "timeout");
              }),
              (h.onabort = function () {
                $(s, -1, null, null, "", d ? "timeout" : "abort");
              }),
              l &&
                l &&
                Object.entries(l).forEach(([t, e]) => {
                  h.addEventListener(t, e);
                }),
              u &&
                Object.entries(u).forEach(([t, e]) => {
                  h.upload.addEventListener(t, e);
                }),
              a && (h.withCredentials = !0),
              c)
            )
              try {
                h.responseType = c;
              } catch (t) {
                if ("json" !== c) throw t;
              }
            if ((h.send(v(r) ? null : r), o > 0))
              var p = setTimeout(() => {
                f("timeout");
              }, o);
            else
              L(o) &&
                o.then(() => {
                  f(b(o.$$timeoutId) ? "timeout" : "abort");
                });
            function f(t) {
              (d = "timeout" === t), h && h.abort();
            }
            function $(t, e, n, r, s, i) {
              b(p) && clearTimeout(p), t(e, n, r, s, i);
            }
          };
        })(t);
      },
    ];
  }
  const Ki = { http: 80, https: 443, ftp: 21 },
    zi = /^([^?#]*)(\?([^#]*))?(#(.*))?$/,
    Wi = dt("$location");
  class Gi {
    constructor(t, e) {
      const n = Le(t);
      (this.appBase = t),
        (this.appBaseNoFile = e),
        (this.$$absUrl = ""),
        (this.$$html5 = !1),
        (this.$$replace = !1),
        (this.$$protocol = n.protocol),
        (this.$$host = n.hostname),
        (this.$$port = M(n.port) || Ki[n.protocol] || null),
        (this.$$path = void 0),
        (this.$$hash = void 0),
        (this.$$urlUpdatedByLocation = !1);
    }
    absUrl() {
      return this.$$absUrl;
    }
    url(t) {
      if (v(t)) return this.$$url;
      const e = zi.exec(t);
      return (
        (e[1] || "" === t) && this.path(decodeURIComponent(e[1])),
        (e[2] || e[1] || "" === t) && this.search(e[3] || ""),
        this.hash(e[5] || ""),
        this
      );
    }
    protocol() {
      return this.$$protocol;
    }
    host() {
      return this.$$host;
    }
    port() {
      return this.$$port;
    }
    path(t) {
      if (v(t)) return this.$$path;
      let e = null !== t ? t.toString() : "";
      return (
        (this.$$path = "/" === e.charAt(0) ? e : `/${e}`),
        this.$$compose(),
        this
      );
    }
    hash(t) {
      return v(t)
        ? this.$$hash
        : ((this.$$hash = null !== t ? t.toString() : ""),
          this.$$compose(),
          this);
    }
    replace() {
      return (this.$$replace = !0), this;
    }
    search(t, e) {
      switch (arguments.length) {
        case 0:
          return this.$$search;
        case 1:
          if (E(t) || A(t)) (t = t.toString()), (this.$$search = et(t));
          else {
            if (!w(t))
              throw Wi(
                "isrcharg",
                "The first argument of the `$location#search()` call must be a string or an object.",
              );
            (t = structuredClone(t, {})),
              Object.entries(t).forEach(([e, n]) => {
                null == n && delete t[e];
              }),
              (this.$$search = t);
          }
          break;
        default:
          v(e) || null === e ? delete this.$$search[t] : (this.$$search[t] = e);
      }
      return this.$$compose(), this;
    }
    $$compose() {
      (this.$$url = (function (t, e, n) {
        const r = (function (t) {
            const e = [];
            return (
              t &&
                Object.entries(t).forEach(([t, n]) => {
                  Array.isArray(n)
                    ? n.forEach((n) => {
                        e.push(st(t, !0) + (!0 === n ? "" : `=${st(n, !0)}`));
                      })
                    : e.push(st(t, !0) + (!0 === n ? "" : `=${st(n, !0)}`));
                }),
              e.length ? e.join("&") : ""
            );
          })(e),
          s = n ? `#${rt(n)}` : "";
        return (
          (function (t) {
            const e = t.split("/");
            let n = e.length;
            for (; n--; ) e[n] = rt(e[n].replace(/%2F/g, "/"));
            return e.join("/");
          })(t) +
          (r ? `?${r}` : "") +
          s
        );
      })(this.$$path, this.$$search, this.$$hash)),
        (this.$$absUrl = this.$$normalizeUrl(this.$$url)),
        (this.$$urlUpdatedByLocation = !0);
    }
    $$normalizeUrl(t) {
      throw new Error(`Method not implemented ${t}`);
    }
    state(t) {
      if (!arguments.length) return this.$$state;
      if (!(this instanceof Qi && this.$$html5))
        throw Wi(
          "nostate",
          "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API",
        );
      return (
        (this.$$state = v(t) ? null : t),
        (this.$$urlUpdatedByLocation = !0),
        this
      );
    }
    $$parseLinkUrl(t, e) {
      throw new Error(`Method not implemented ${t} ${e}`);
    }
    $$parse(t) {
      throw new Error(`Method not implemented ${t}`);
    }
  }
  class Qi extends Gi {
    constructor(t, e, n) {
      super(t, e), (this.$$html5 = !0), (this.basePrefix = n || "");
    }
    $$parse(t) {
      const e = to(this.appBaseNoFile, t);
      if (!E(e))
        throw Wi(
          "ipthprfx",
          'Invalid url "{0}", missing path prefix "{1}".',
          t,
          this.appBaseNoFile,
        );
      Ji(e, this, !0), this.$$path || (this.$$path = "/"), this.$$compose();
    }
    $$normalizeUrl(t) {
      return this.appBaseNoFile + t.substring(1);
    }
    $$parseLinkUrl(t, e) {
      if (e && "#" === e[0]) return this.hash(e.slice(1)), !0;
      let n, r, s;
      return (
        b((n = to(this.appBase, t)))
          ? ((r = n),
            (s =
              this.basePrefix && b((n = to(this.basePrefix, n)))
                ? this.appBaseNoFile + (to("/", n) || n)
                : this.appBase + r))
          : b((n = to(this.appBaseNoFile, t)))
            ? (s = this.appBaseNoFile + n)
            : this.appBaseNoFile === `${t}/` && (s = this.appBaseNoFile),
        s && this.$$parse(s),
        !!s
      );
    }
  }
  class Yi extends Gi {
    constructor(t, e, n) {
      super(t, e), (this.hashPrefix = n);
    }
    $$parse(t) {
      const e = to(this.appBase, t) || to(this.appBaseNoFile, t);
      let n;
      v(e) || "#" !== e.charAt(0)
        ? this.$$html5
          ? (n = e)
          : ((n = ""), v(e) && ((this.appBase = t), this.replace()))
        : ((n = to(this.hashPrefix, e)), v(n) && (n = e)),
        Ji(n, this, !1),
        (this.$$path = (function (t, e, n) {
          const r = /^\/[A-Z]:(\/.*)/;
          let s;
          Xi(e, n) && (e = e.replace(n, ""));
          if (r.exec(e)) return t;
          return (s = r.exec(t)), s ? s[1] : t;
        })(this.$$path, n, this.appBase)),
        this.$$compose();
    }
    $$normalizeUrl(t) {
      return this.appBase + (t ? this.hashPrefix + t : "");
    }
    $$parseLinkUrl(t) {
      return eo(this.appBase) === eo(t) && (this.$$parse(t), !0);
    }
  }
  class Zi {
    constructor() {
      (this.hashPrefixConf = "!"),
        (this.html5ModeConf = {
          enabled: !1,
          requireBase: !0,
          rewriteLinks: !0,
        });
    }
    setHashPrefix(t) {
      this.hashPrefixConf = t;
    }
    getHashPrefix() {
      return this.hashPrefixConf;
    }
    setHtml5Mode(t) {
      if ((R(t) && (this.html5ModeConf.enabled = t), w(t))) {
        const e = t;
        b(e.enabled) &&
          R(e.enabled) &&
          (this.html5ModeConf.enabled = e.enabled),
          b(e.requireBase) &&
            R(e.requireBase) &&
            (this.html5ModeConf.requireBase = e.requireBase),
          b(e.rewriteLinks) &&
            (R(e.rewriteLinks) || E(e.rewriteLinks)) &&
            (this.html5ModeConf.rewriteLinks = e.rewriteLinks);
      }
    }
    getHtml5Mode() {
      return this.html5ModeConf;
    }
    $get = [
      "$rootScope",
      "$browser",
      "$rootElement",
      (t, e, n) => {
        let r, s;
        const i = e.baseHref(),
          o = e.url();
        let a;
        if (this.getHtml5Mode().enabled) {
          if (!i && this.getHtml5Mode().requireBase)
            throw Wi(
              "nobase",
              "$location in HTML5 mode requires a <base> tag to be present!",
            );
          (a =
            (c = o).substring(0, c.indexOf("/", c.indexOf("//") + 2)) +
            (i || "/")),
            (s = Qi);
        } else (a = eo(o)), (s = Yi);
        var c;
        const l = (function (t) {
          return t.substring(0, eo(t).lastIndexOf("/") + 1);
        })(a);
        (r = new s(a, l, `#${this.getHashPrefix()}`)),
          r.$$parseLinkUrl(o, o),
          (r.$$state = e.state());
        const u = /^\s*(javascript|mailto):/i;
        function h(t, n) {
          const s = r.url(),
            i = r.$$state;
          try {
            e.url(t, n), (r.$$state = e.state());
          } catch (t) {
            throw (r.url(s), (r.$$state = i), t);
          }
        }
        n.addEventListener("click", (t) => {
          const e = this.getHtml5Mode().rewriteLinks;
          if (
            !e ||
            t.ctrlKey ||
            t.metaKey ||
            t.shiftKey ||
            2 === t.which ||
            2 === t.button
          )
            return;
          let s = t.target;
          for (; "a" !== s.nodeName.toLowerCase(); )
            if (s === n || !(s = s.parentElement)) return;
          if (E(e) && v(s.getAttribute(e))) return;
          let i = s.href;
          const o = s.getAttribute("href") || s.getAttribute("xlink:href");
          w(i) &&
            "[object SVGAnimatedString]" === i.toString() &&
            (i = Le(i.animVal).href),
            u.test(i) ||
              !i ||
              s.getAttribute("target") ||
              t.defaultPrevented ||
              (r.$$parseLinkUrl(i, o) && t.preventDefault());
        }),
          r.absUrl() !== o && e.url(r.absUrl(), !0);
        let d = !0;
        e.onUrlChange((e, n) => {
          Xi(e, l)
            ? t.$evalAsync(() => {
                const s = r.absUrl(),
                  i = r.$$state;
                let o;
                r.$$parse(e),
                  (r.$$state = n),
                  (o = t.$broadcast(
                    "$locationChangeStart",
                    e,
                    s,
                    n,
                    i,
                  ).defaultPrevented),
                  r.absUrl() === e &&
                    (o
                      ? (r.$$parse(s), (r.$$state = i), h(s, i))
                      : ((d = !1), f(s, i)));
              })
            : (window.location.href = e);
        });
        const p = () => {
          if (d || r.$$urlUpdatedByLocation) {
            r.$$urlUpdatedByLocation = !1;
            const i = e.url(),
              o = r.absUrl(),
              a = e.state(),
              c =
                !((n = i) === (s = o) || Le(n).href === Le(s).href) ||
                (r.$$html5 && a !== r.$$state);
            (d || c) &&
              ((d = !1),
              setTimeout(() => {
                const e = r.absUrl(),
                  { defaultPrevented: n } = t.$broadcast(
                    "$locationChangeStart",
                    e,
                    i,
                    r.$$state,
                    a,
                  );
                r.absUrl() === e &&
                  (n
                    ? (r.$$parse(i), (r.$$state = a))
                    : (c && h(e, a === r.$$state ? null : r.$$state), f(i, a)));
              }));
          }
          var n, s;
          r.$$replace = !1;
        };
        return p(), t.$on("$updateBrowser", p), r;
        function f(e, n) {
          t.$broadcast("$locationChangeSuccess", r.absUrl(), e, r.$$state, n);
        }
      },
    ];
  }
  function Ji(t, e, n) {
    if (/^\s*[\\/]{2,}/.test(t)) throw Wi("badpath", 'Invalid url "{0}".', t);
    const r = "/" !== t.charAt(0);
    r && (t = `/${t}`);
    const s = Le(t),
      i =
        r && "/" === s.pathname.charAt(0)
          ? s.pathname.substring(1)
          : s.pathname;
    (e.$$path = (function (t, e) {
      const n = t.split("/");
      let r = n.length;
      for (; r--; )
        (n[r] = decodeURIComponent(n[r])),
          e && (n[r] = n[r].replace(/\//g, "%2F"));
      return n.join("/");
    })(i, n)),
      (e.$$search = et(s.search)),
      (e.$$hash = decodeURIComponent(s.hash)),
      e.$$path && "/" !== e.$$path.charAt(0) && (e.$$path = `/${e.$$path}`);
  }
  function Xi(t, e) {
    return t.slice(0, e.length) === e;
  }
  function to(t, e) {
    if (Xi(e, t)) return e.substring(t.length);
  }
  function eo(t) {
    const e = t.indexOf("#");
    return -1 === e ? t : t.substring(0, e);
  }
  let no = {
    debug: void 0,
    error: void 0,
    info: void 0,
    log: void 0,
    warn: void 0,
  };
  class ro {
    constructor() {
      this.debug = !0;
    }
    debugEnabled(t) {
      return void 0 !== t ? ((this.debug = t), this) : this.debug;
    }
    formatError(t) {
      return (
        x(t) &&
          (t.stack
            ? (t =
                t.message && -1 === t.stack.indexOf(t.message)
                  ? `Error: ${t.message}\n${t.stack}`
                  : t.stack)
            : t.sourceURL && (t = `${t.message}\n${t.sourceURL}:${t.line}`)),
        t
      );
    }
    consoleLog(t) {
      const e = window.console || {},
        n = e[t] || e.log || (() => {});
      return (...t) => {
        const r = t.map((t) => this.formatError(t));
        return n.apply(e, r);
      };
    }
    $get() {
      return (
        (no = {
          log: this.consoleLog("log"),
          info: this.consoleLog("info"),
          warn: this.consoleLog("warn"),
          error: this.consoleLog("error"),
          debug: (() => {
            const t = this.consoleLog("debug");
            return (...e) => {
              this.debug && t.apply(this, e);
            };
          })(),
        }),
        no
      );
    }
  }
  let so,
    io,
    oo = 0;
  const ao = [];
  class co {
    constructor() {
      this.rootScope = lo();
    }
    $get = [
      "$exceptionHandler",
      "$parse",
      (t, e) => ((io = t), (so = e), this.rootScope),
    ];
  }
  function lo(t = {}, e) {
    if (C(t) || !0 === t[uo] || !0 === (t.constructor && t.constructor[uo]))
      return t;
    if ("object" == typeof t) {
      const n = new Proxy(t, e || new ho());
      for (const e in t)
        if (Object.prototype.hasOwnProperty.call(t, e))
          try {
            if (
              (t.constructor.$nonscope &&
                Array.isArray(t.constructor.$nonscope) &&
                t.constructor.$nonscope.includes(e)) ||
              (t.$nonscope &&
                Array.isArray(t.$nonscope) &&
                t.$nonscope.includes(e))
            )
              continue;
            t[e] = lo(t[e], n.$handler);
          } catch (t) {}
      return n;
    }
    return t;
  }
  const uo = "$nonscope";
  class ho {
    constructor(t, e) {
      (this.context = t ? (t.context ? t.context : t) : void 0),
        (this.watchers = t ? t.watchers : new Map()),
        (this.$$listeners = new Map()),
        (this.foreignListeners = t ? t.foreignListeners : new Map()),
        (this.foreignProxies = t ? t.foreignProxies : new Set()),
        (this.objectListeners = t ? t.objectListeners : new WeakMap()),
        (this.functionListeners = t ? t.functionListeners : new Map()),
        (this.$proxy = null),
        (this.$handler = this),
        (this.$target = null),
        (this.$value = null),
        (this.$children = []),
        (this.$id = ((oo += 1), oo)),
        (this.$root = t ? t.$root : this),
        (this.$parent = e || (this.$root === this ? null : t)),
        (this.$$asyncQueue = []),
        (this.filters = []),
        (this.$$destroyed = !1),
        (this.scheduled = []);
    }
    set(t, e, n, r) {
      if ("undefined" === e)
        throw new Error("Attempting to set undefined property");
      if (
        (t.constructor?.$nonscope &&
          Array.isArray(t.constructor.$nonscope) &&
          t.constructor.$nonscope.includes(e)) ||
        (t.$nonscope && Array.isArray(t.$nonscope) && t.$nonscope.includes(e))
      )
        return (t[e] = n), !0;
      (this.$proxy = r), (this.$target = t);
      const s = t[e];
      if (void 0 !== s && Number.isNaN(s) && Number.isNaN(n)) return !0;
      if (s && s[d]) {
        if (Array.isArray(n)) {
          if (s !== n) {
            const t = this.watchers.get(e);
            t && this.scheduleListener(t);
            const n = this.foreignListeners.get(e);
            n && this.scheduleListener(n);
          }
          return (
            this.objectListeners.get(t[e]) && this.objectListeners.delete(t[e]),
            (t[e] = lo(n, this)),
            this.objectListeners.set(t[e], [e]),
            !0
          );
        }
        if (w(n)) {
          if (
            (Object.prototype.hasOwnProperty.call(t, e) &&
              Object.keys(s)
                .filter((t) => !n[t])
                .forEach((t) => {
                  delete s[t];
                }),
            s !== n)
          ) {
            const t = this.watchers.get(e);
            t && this.scheduleListener(t);
            const r = this.foreignListeners.get(e);
            r && this.scheduleListener(r), this.checkeListenersForAllKeys(n);
          }
          return (t[e] = lo(n, this)), !0;
        }
        if (v(n)) {
          let n = !1;
          if (
            (Object.keys(s.$target).forEach((t) => {
              s.$target[t]?.[d] && (n = !0), delete s[t];
            }),
            (t[e] = void 0),
            !n)
          ) {
            let t = this.watchers.get(e);
            t && this.scheduleListener(t);
          }
          return !0;
        }
        if (b(n)) {
          t[e] = n;
          let s = this.watchers.get(e);
          if (
            (s && this.scheduleListener(s),
            Array.isArray(t) && this.objectListeners.has(r) && "length" !== e)
          ) {
            this.objectListeners.get(r).forEach((t) => {
              const e = this.watchers.get(t);
              e && this.scheduleListener(e);
            });
          }
          return !0;
        }
        return !0;
      }
      if (v(t[e]) && p(n)) return this.foreignProxies.add(n), (t[e] = n), !0;
      if ((v(n) ? (t[e] = n) : (t[e] = lo(n, this)), s !== n)) {
        let r = this.$target,
          i = [];
        if (v(s) && w(t[e])) {
          this.objectListeners.has(t[e]) || this.objectListeners.set(t[e], [e]);
          for (const t of Object.keys(n))
            this.watchers.get(t)?.forEach((t) => i.push(t)), (r = n);
        }
        Array.isArray(t) &&
          this.watchers.get("length")?.forEach((t) => i.push(t)),
          this.watchers.get(e)?.forEach((t) => i.push(t)),
          i.length > 0 &&
            this.scheduleListener(i, (t) =>
              t.filter((t) => {
                if (!t.watchProp) return !0;
                const e = t.watchProp.split(".").slice(0, -1).join("."),
                  n = so(e)(t.originalTarget)?.$handler;
                return r === n?.$target;
              }),
            );
        let o = this.foreignListeners.get(e);
        !o &&
          this.$parent?.foreignListeners &&
          (o = this.$parent.foreignListeners.get(e)),
          o &&
            (this.$target.$$hashKey &&
              (o = o.filter(
                (t) =>
                  !!t.originalTarget.$$hashKey &&
                  t.originalTarget.$$hashKey == this.$target.$$hashKey,
              )),
            this.scheduleListener(o));
      }
      if (this.objectListeners.has(r) && "length" !== e) {
        this.objectListeners.get(r).forEach((t) => {
          const e = this.watchers.get(t);
          e && this.scheduled !== e && this.scheduleListener(e);
        });
      }
      return !0;
    }
    checkeListenersForAllKeys(t) {
      v(t) ||
        Object.keys(t).forEach((e) => {
          const n = this.watchers.get(e);
          n && this.scheduleListener(n),
            w(t[e]) && this.checkeListenersForAllKeys(t[e]);
        });
    }
    get(t, e, n) {
      if ("$$watchersCount" === e)
        return (function (t) {
          const e = po(t).add(t.$id);
          return Array.from(t.watchers.values()).reduce(
            (t, n) => t + n.reduce((t, n) => t + (e.has(n.scopeId) ? 1 : 0), 0),
            0,
          );
        })(this);
      if (e === d) return !0;
      if (
        (t[e] && p(t[e]) ? (this.$proxy = t[e]) : (this.$proxy = n),
        (this.propertyMap = {
          $watch: this.$watch.bind(this),
          $watchGroup: this.$watchGroup.bind(this),
          $watchCollection: this.$watchCollection.bind(this),
          $new: this.$new.bind(this),
          $newIsolate: this.$newIsolate.bind(this),
          $destroy: this.$destroy.bind(this),
          $eval: this.$eval.bind(this),
          $apply: this.$apply.bind(this),
          $evalAsync: this.$evalAsync.bind(this),
          $postUpdate: this.$postUpdate.bind(this),
          $isRoot: this.isRoot.bind(this),
          $target: t,
          $proxy: this.$proxy,
          $digest: this.$digest.bind(this),
          $on: this.$on.bind(this),
          $emit: this.$emit.bind(this),
          $broadcast: this.$broadcast.bind(this),
          $transcluded: this.$transcluded.bind(this),
          $handler: this,
          $parent: this.$parent,
          $root: this.$root,
          $children: this.$children,
          $id: this.$id,
          registerForeignKey: this.registerForeignKey.bind(this),
          notifyListener: this.notifyListener.bind(this),
          $merge: this.$merge.bind(this),
          $getById: this.$getById.bind(this),
        }),
        Array.isArray(t) && ["pop", "shift", "unshift"].includes(e))
      ) {
        if (this.objectListeners.has(n)) {
          this.objectListeners.get(this.$proxy).forEach((t) => {
            const e = this.watchers.get(t);
            e && (this.scheduled = e);
          });
        }
        "unshift" === e && this.scheduleListener(this.scheduled);
      }
      return Object.prototype.hasOwnProperty.call(this.propertyMap, e)
        ? ((this.$target = t), this.propertyMap[e])
        : t[e];
    }
    scheduleListener(t, e = (t) => t) {
      Promise.resolve().then(() => {
        let n = 0,
          r = e(t);
        for (; n < r.length; ) {
          const t = r[n];
          t.foreignListener
            ? t.foreignListener.notifyListener(t, this.$target)
            : this.notifyListener(t, this.$target),
            n++;
        }
      });
    }
    deleteProperty(t, e) {
      if (t[e] && t[e][d]) {
        t[e] = void 0;
        let n = this.watchers.get(e);
        if (
          (n && this.scheduleListener(n), this.objectListeners.has(this.$proxy))
        ) {
          this.objectListeners.get(this.$proxy).forEach((t) => {
            (n = this.watchers.get(t)), n && this.scheduleListener(n);
          });
        }
        return (
          this.scheduled &&
            (this.scheduleListener(this.scheduled), (this.scheduled = [])),
          !0
        );
      }
      if ((delete t[e], this.objectListeners.has(this.$proxy))) {
        this.objectListeners.get(this.$proxy).forEach((t) => {
          const e = this.watchers.get(t);
          e && this.scheduleListener(e);
        });
      } else {
        const n = this.watchers.get(e);
        n && this.scheduleListener(n, t[e]);
      }
      return !0;
    }
    $watch(t, e, n = !1) {
      at(E(t), "Watched property required"), (t = t.trim());
      const r = so(t);
      if (r.constant)
        return (
          e &&
            Promise.resolve().then(() => {
              let t = r();
              for (; k(t); ) t = t();
              e(t, this.$target);
            }),
          () => {}
        );
      const s = {
        originalTarget: this.$target,
        listenerFn: e,
        watchFn: r,
        scopeId: this.$id,
        id: m(),
        property: [],
      };
      let i = r.decoratedNode.body[0].expression.name,
        o = [],
        a = r.decoratedNode.body[0].expression.type;
      switch (a) {
        case Br:
        case Kr:
          throw new Error("Unsupported type " + a);
        case zr:
          if (!e) {
            let t = r(this.$target);
            for (; k(t); ) t = t(this.$target);
            return Promise.resolve().then(t), () => {};
          }
          i = r.decoratedNode.body[0].expression.left.name;
          break;
        case Wr:
          (i = r.decoratedNode.body[0].expression.toWatch[0]?.test?.name),
            s.property.push(i);
          break;
        case Gr: {
          let t = [];
          return (
            t.push(r.decoratedNode.body[0].expression.left.toWatch[0]?.name),
            t.push(r.decoratedNode.body[0].expression.right.toWatch[0]?.name),
            t.forEach((t) => {
              this.registerKey(t, s);
            }),
            () => {
              t.forEach((t) => {
                this.deregisterKey(t, s.id);
              });
            }
          );
        }
        case Qr: {
          let t = r.decoratedNode.body[0].expression.toWatch[0];
          if (((i = t.property ? t.property.name : t.name), !i))
            throw new Error("Unable to determine key");
          s.property.push(i);
          break;
        }
        case Yr: {
          let t = r.decoratedNode.body[0].expression.toWatch[0];
          if (((i = t.property ? t.property.name : t.name), !i))
            throw new Error("Unable to determine key");
          s.property.push(i);
          break;
        }
        case Zr: {
          let t = [];
          return (
            r.decoratedNode.body[0].expression.toWatch.forEach((e) => {
              b(e) && t.push(e.name);
            }),
            t.forEach((t) => {
              this.registerKey(t, s), this.scheduleListener([s]);
            }),
            () => {
              t.forEach((t) => {
                this.deregisterKey(t, s.id);
              });
            }
          );
        }
        case Jr:
          if (
            ((i = r.decoratedNode.body[0].expression.property.name),
            i || (i = r.decoratedNode.body[0].expression.object.name),
            s.property.push(i),
            t !== i)
          ) {
            s.watchProp = t;
            let e = so(t.split(".").slice(0, -1).join("."))(s.originalTarget);
            if (e && this.foreignProxies.has(e))
              return (
                e.$handler.registerForeignKey(i, s),
                e.$handler.scheduleListener([s]),
                () => e.$handler.deregisterKey(i, s.id)
              );
          }
          break;
        case Xr:
          s.property.push(r.decoratedNode.body[0].expression.name);
          break;
        case ts:
          throw new Error("Unsupported type " + a);
        case es: {
          let t = r.decoratedNode.body[0].expression.elements
            .map((t) => (11 === t.type ? t.value : t.toWatch[0].name))
            .filter((t) => !!t);
          return (
            t.forEach((t) => {
              this.registerKey(t, s), this.scheduleListener([s]);
            }),
            () => {
              t.forEach((t) => {
                this.deregisterKey(t, s.id);
              });
            }
          );
        }
        case ns:
          throw new Error("Unsupported type " + a);
        case rs:
          r.decoratedNode.body[0].expression.properties.forEach((t) => {
            !1 === t.key.isPure
              ? (o.push(t.key.name), s.property.push(i))
              : t.value.name
                ? (o.push(t.value.name), s.property.push(i))
                : ((i =
                    r.decoratedNode.body[0].expression.properties[0].key.name),
                  s.property.push(i));
          });
          break;
        case ss:
        case is:
        case os:
          throw new Error("Unsupported type " + a);
      }
      let c = s.watchFn(this.$target);
      return (
        w(c) && this.objectListeners.set(c, [i]),
        o.length > 0
          ? o.forEach((t) => {
              this.registerKey(t, s);
            })
          : this.registerKey(i, s),
        n || this.scheduleListener([s]),
        () => {
          if (o.length > 0) {
            let t = !0;
            return (
              o.forEach((e) => {
                this.deregisterKey(e, s.id) || (t = !1);
              }),
              t
            );
          }
          return this.deregisterKey(i, s.id);
        }
      );
    }
    $watchGroup(t, e) {
      t.forEach((t) => this.$watch(t, e));
    }
    $watchCollection(t, e) {
      return this.$watch(t, e);
    }
    $new(t) {
      let e;
      t
        ? (Object.getPrototypeOf(t) === Object.prototype ||
          Object.getPrototypeOf(t) == this.$target
            ? Object.setPrototypeOf(t, this.$target)
            : Object.setPrototypeOf(
                Object.getPrototypeOf(t) || t,
                this.$target,
              ),
          (e = t))
        : (e = Object.create(this.$target));
      const n = new Proxy(e, new ho(this));
      return this.$children.push(n), n;
    }
    $newIsolate(t) {
      let e = t ? Object.create(t) : Object.create(null);
      const n = new Proxy(e, new ho(this, this.$root));
      return this.$children.push(n), n;
    }
    $transcluded(t) {
      let e = Object.create(this.$target);
      const n = new Proxy(e, new ho(this, t));
      return this.$children.push(n), n;
    }
    registerKey(t, e) {
      this.watchers.has(t)
        ? this.watchers.get(t).push(e)
        : this.watchers.set(t, [e]);
    }
    registerForeignKey(t, e) {
      this.foreignListeners.has(t)
        ? this.foreignListeners.get(t).push(e)
        : this.foreignListeners.set(t, [e]);
    }
    deregisterKey(t, e) {
      const n = this.watchers.get(t);
      if (!n) return !1;
      const r = n.findIndex((t) => t.id === e);
      return (
        -1 !== r &&
        (n.splice(r, 1),
        n.length ? this.watchers.set(t, n) : this.watchers.delete(t),
        !0)
      );
    }
    deregisterForeignKey(t, e) {
      const n = this.foreignListeners.get(t);
      if (!n) return !1;
      const r = n.findIndex((t) => t.id === e);
      return (
        -1 !== r &&
        (n.splice(r, 1),
        n.length
          ? this.foreignListeners.set(t, n)
          : this.foreignListeners.delete(t),
        !0)
      );
    }
    $digest() {
      throw new Error("$Digest is deprecated");
    }
    $eval(t, e) {
      const n = so(t)(this.$target, e);
      return v(n) || null === n || n.name === Object.hasOwnProperty.name
        ? n
        : k(n)
          ? n()
          : Number.isNaN(n)
            ? 0
            : n;
    }
    async $evalAsync(t, e) {
      return await this.$eval(t, e);
    }
    $merge(t) {
      Object.entries(t).forEach(([t, e]) => {
        this.set(this.$target, t, e);
      });
    }
    $apply(t) {
      try {
        return so(t)(this.$proxy);
      } catch (t) {
        io(t);
      }
    }
    $on(t, e) {
      let n = this.$$listeners.get(t);
      return (
        n || ((n = []), this.$$listeners.set(t, n)),
        n.push(e),
        () => {
          const r = n.indexOf(e);
          -1 !== r &&
            (n.splice(r, 1), 0 == n.length && this.$$listeners.delete(t));
        }
      );
    }
    $emit(t, ...e) {
      return this.eventHelper({ name: t, event: void 0, broadcast: !1 }, ...e);
    }
    $broadcast(t, ...e) {
      return this.eventHelper({ name: t, event: void 0, broadcast: !0 }, ...e);
    }
    eventHelper({ name: t, event: e, broadcast: n }, ...r) {
      if (!n && !this.$$listeners.has(t))
        return this.$parent
          ? this.$parent.$handler.eventHelper(
              { name: t, event: e, broadcast: n },
              ...r,
            )
          : void 0;
      e
        ? (e.currentScope = this.$target)
        : (e = e || {
            name: t,
            targetScope: this.$target,
            currentScope: this.$target,
            stopped: !1,
            stopPropagation() {
              e.stopped = !0;
            },
            preventDefault() {
              e.defaultPrevented = !0;
            },
            defaultPrevented: !1,
          });
      const s = Q([e], [e].concat(r), 1);
      let i = this.$$listeners.get(t);
      if (i) {
        let t = i.length;
        for (let e = 0; e < t; e++)
          try {
            i[e].apply(null, s),
              i.length !== t && (i.length < t && e--, (t = i.length));
          } catch (t) {
            io(t);
          }
      }
      return (
        (e.currentScope = null),
        e.stopped
          ? e
          : n
            ? (this.$children.length > 0 &&
                this.$children.forEach((s) => {
                  e = s.$handler.eventHelper(
                    { name: t, event: e, broadcast: n },
                    ...r,
                  );
                }),
              e)
            : this.$parent
              ? this.$parent?.eventHelper(
                  { name: t, event: e, broadcast: n },
                  ...r,
                )
              : e
      );
    }
    isRoot() {
      return this.$root == this;
    }
    async $applyAsync(t) {
      try {
        return so(t)(this.$proxy);
      } catch (t) {
        throw (io(t), t);
      }
    }
    $postUpdate(t) {
      ao.push(t);
    }
    $destroy() {
      if (!this.$$destroyed) {
        if (
          (this.$broadcast("$destroy"),
          Array.from(this.watchers.entries()).forEach(([t, e]) => {
            this.watchers.set(
              t,
              e.filter((t) => t.scopeId !== this.$id),
            );
          }),
          this.isRoot())
        )
          this.watchers.clear();
        else {
          let t = this.$parent.$children.filter((t) => t.$id == this.$id)[0];
          this.$parent.$children.splice(this.$parent.$children.indexOf(t), 1);
        }
        this.$$listeners.clear(), (this.$$destroyed = !0);
      }
    }
    notifyListener(t, e) {
      const { originalTarget: n, listenerFn: r, watchFn: s } = t;
      try {
        let t = s(n);
        for (
          v(t) && (t = s(e)),
            k(t) && (t = t(n)),
            Array.isArray(t) &&
              t.forEach((e, r) => {
                k(e) && (t[r] = e(n));
              }),
            r(t, n),
            this.$$asyncQueue.forEach((t) => {
              t.handler.$id == this.$id &&
                Promise.resolve().then(t.fn(t.handler, t.locals));
            });
          ao.length;

        )
          ao.shift()();
      } catch (t) {
        io(t);
      }
    }
    $getById(t) {
      if ((E(t) && (t = parseInt(t, 10)), this.$id === t)) return this;
      {
        let e;
        for (const n of this.$children) {
          let r = n.$getById(t);
          if (r) {
            e = r;
            break;
          }
        }
        return e;
      }
    }
  }
  function po(t) {
    const e = new Set([t.$id]);
    return (
      t.$children?.forEach((t) => {
        po(t).forEach((t) => e.add(t));
      }),
      e
    );
  }
  class fo {
    $get = ["$log", (t) => new $o(t)];
  }
  class $o {
    constructor(t) {
      (this.log = t),
        (this.taskCounts = {}),
        (this.taskCallbacks = []),
        (this.ALL_TASKS_TYPE = "$$all$$"),
        (this.DEFAULT_TASK_TYPE = "$$default$$");
    }
    completeTask(t, e = this.DEFAULT_TASK_TYPE) {
      try {
        t();
      } finally {
        this.taskCounts[e] &&
          (this.taskCounts[e]--, this.taskCounts[this.ALL_TASKS_TYPE]--);
        const t = this.taskCounts[e],
          n = this.taskCounts[this.ALL_TASKS_TYPE];
        if (!n || !t) {
          const t = n
            ? () => this.getLastCallbackForType(e)
            : this.getLastCallback.bind(this);
          let r;
          for (; (r = t()); )
            try {
              r();
            } catch (t) {
              this.log.error(t);
            }
        }
      }
    }
    incTaskCount(t = this.DEFAULT_TASK_TYPE) {
      (this.taskCounts[t] = (this.taskCounts[t] || 0) + 1),
        (this.taskCounts[this.ALL_TASKS_TYPE] =
          (this.taskCounts[this.ALL_TASKS_TYPE] || 0) + 1);
    }
    notifyWhenNoPendingTasks(t, e = this.ALL_TASKS_TYPE) {
      this.taskCounts[e] ? this.taskCallbacks.push({ type: e, cb: t }) : t();
    }
    getLastCallback() {
      const t = this.taskCallbacks.pop();
      return t ? t.cb : void 0;
    }
    getLastCallbackForType(t) {
      for (let e = this.taskCallbacks.length - 1; e >= 0; --e) {
        const n = this.taskCallbacks[e];
        if (n.type === t) return this.taskCallbacks.splice(e, 1), n.cb;
      }
    }
  }
  var mo = dt("$templateRequest");
  function go() {
    var t;
    (this.httpOptions = function (e) {
      return e ? ((t = e), this) : t;
    }),
      (this.$get = [
        "$exceptionHandler",
        "$templateCache",
        "$http",
        "$sce",
        function (e, n, r, s) {
          function i(o, a) {
            if (
              (i.totalPendingRequests++,
              !((E(o) && n.has(o)) || (o = s.getTrustedResourceUrl(o))))
            )
              return Promise.reject("Template not found");
            var c = r.defaults && r.defaults.transformResponse;
            return (
              Array.isArray(c)
                ? (c = c.filter(function (t) {
                    return t !== Di;
                  }))
                : c === Di && (c = null),
              r
                .get(o, P({ cache: n, transformResponse: c }, t))
                .finally(function () {
                  i.totalPendingRequests--;
                })
                .then(
                  function (t) {
                    return n.set(o, t.data), t.data;
                  },
                  function (t) {
                    a ||
                      ((t = mo(
                        "tpload",
                        "Failed to load template: {0} (HTTP status: {1} {2})",
                        o,
                        t.status,
                        t.statusText,
                      )),
                      e(t));
                    return Promise.reject(t);
                  },
                )
            );
          }
          return (i.totalPendingRequests = 0), i;
        },
      ]);
  }
  function yo() {
    let t = /^\s*(https?|s?ftp|mailto|tel|file):/,
      e = /^\s*((https?|ftp|file|blob):|data:image\/)/;
    (this.aHrefSanitizationTrustedUrlList = function (e) {
      return b(e) ? ((t = e), this) : t;
    }),
      (this.imgSrcSanitizationTrustedUrlList = function (t) {
        return b(t) ? ((e = t), this) : e;
      }),
      (this.$get = function () {
        return function (n, r) {
          const s = r ? e : t,
            i = Le(n && n.trim()).href;
          return "" === i || i.match(s) ? n : `unsafe:${i}`;
        };
      });
  }
  const vo = "ng-active",
    bo = "ng-inactive";
  class wo {
    constructor(t, e, n, r) {
      (this.$element = t),
        (this.$scope = e),
        (this.$attrs = n),
        (this.$animate = r),
        (this.latestKey = 0),
        (this.nextAttachId = 0),
        (this.messages = {}),
        (this.renderLater = !1),
        (this.cachedCollection = null),
        (this.head = void 0),
        (this.default = void 0),
        this.$scope.$watchCollection(
          this.$attrs.ngMessages || this.$attrs.for,
          this.render.bind(this),
        );
    }
    getAttachId() {
      return this.nextAttachId++;
    }
    render(t = {}) {
      (this.renderLater = !1), (this.cachedCollection = t);
      const e =
          Co(this.$scope, this.$attrs.ngMessagesMultiple) ||
          Co(this.$scope, this.$attrs.multiple),
        n = [],
        r = {};
      let s = 0,
        i = this.head,
        o = !1,
        a = 0;
      for (; null != i; ) {
        a++;
        const c = i.message;
        let l = !1;
        o ||
          Object.entries(t).forEach(([t, e]) => {
            if (Oo(e) && !l && (s++, c.test(t))) {
              if (r[t]) return;
              (r[t] = !0), (l = !0), c.attach();
            }
          }),
          l ? (o = !e) : n.push(c),
          (i = i.next);
      }
      n.forEach((t) => {
        t.detach();
      });
      const c = n.length !== a,
        l = this.default && !c && s > 0;
      l ? this.default.attach() : this.default && this.default.detach(),
        c || l
          ? this.$animate.setClass(this.$element, vo, bo)
          : this.$animate.setClass(this.$element, bo, vo);
    }
    reRender() {
      this.renderLater ||
        ((this.renderLater = !0),
        this.$scope.$evalAsync(() => {
          this.renderLater &&
            this.cachedCollection &&
            this.render(this.cachedCollection);
        }));
    }
    register(t, e, n) {
      if (n) this.default = e;
      else {
        const n = this.latestKey.toString();
        (this.messages[n] = { message: e }),
          this.insertMessageNode(this.$element, t, n),
          (t.$$ngMessageNode = n),
          this.latestKey++;
      }
      this.reRender();
    }
    deregister(t, e) {
      if (e) delete this.default;
      else {
        const e = t.$$ngMessageNode;
        delete t.$$ngMessageNode,
          this.removeMessageNode(this.$element, t, e),
          delete this.messages[e];
      }
      this.reRender();
    }
    findPreviousMessage(t, e) {
      let n = e;
      const r = [];
      for (; n && n !== t; ) {
        const t = n.$$ngMessageNode;
        if (t && t.length) return this.messages[t];
        n.childNodes.length && -1 === r.indexOf(n)
          ? (r.push(n), (n = n.childNodes[n.childNodes.length - 1]))
          : n.previousSibling
            ? (n = n.previousSibling)
            : ((n = n.parentNode), r.push(n));
      }
    }
    insertMessageNode(t, e, n) {
      const r = this.messages[n];
      if (this.head) {
        const n = this.findPreviousMessage(t, e);
        n
          ? ((r.next = n.next), (n.next = r))
          : ((r.next = this.head), (this.head = r));
      } else this.head = r;
    }
    removeMessageNode(t, e, n) {
      const r = this.messages[n];
      if (!r) return;
      const s = this.findPreviousMessage(t, e);
      s ? (s.next = r.next) : (this.head = r.next);
    }
  }
  function Eo(t) {
    return {
      require: "ngMessages",
      restrict: "AE",
      controller: (e, n, r) => new wo(e, n, r, t),
    };
  }
  function Co(t, e) {
    return (E(e) && 0 === e.length) || Oo(t.$eval(e));
  }
  function Oo(t) {
    return E(t) ? t.length : !!t;
  }
  function Ao(t, e) {
    return {
      restrict: "AE",
      require: "^^ngMessages",
      link(n, r, s) {
        const i = s.ngMessagesInclude || s.src;
        t(i).then((t) => {
          n.$$destroyed ||
            (E(t) && !t.trim()) ||
            e(t)(n, (t) => {
              r.after(t);
            });
        });
      },
    };
  }
  (Eo.$inject = ["$animate"]), (Ao.$inject = ["$templateRequest", "$compile"]);
  const So = _o(!1),
    xo = _o(!1),
    ko = _o(!0);
  function _o(t) {
    function e(e) {
      return {
        restrict: "AE",
        transclude: "element",
        priority: 1,
        terminal: !0,
        require: "^^ngMessages",
        link(n, r, s, i, o) {
          let a, c, l, u, h, d;
          if (!t) {
            (a = r),
              (l = s.ngMessage || s.when),
              (u = s.ngMessageExp || s.whenExp);
            const t = function (t) {
              (c = t ? (Array.isArray(t) ? t : t.split(/[\s,]+/)) : null),
                i.reRender();
            };
            u ? (t(n.$eval(u)), n.$watchCollection(u, t)) : t(l);
          }
          i.register(
            a,
            (d = {
              test: (t) =>
                (function (t, e) {
                  if (t)
                    return Array.isArray(t)
                      ? t.indexOf(e) >= 0
                      : Object.prototype.hasOwnProperty.call(t, e);
                })(c, t),
              attach() {
                h ||
                  o((n, s) => {
                    e.enter(n, null, r), (h = n);
                    const o = (h.$$attachId = i.getAttachId());
                    h.addEventListener("$destroy", () => {
                      h &&
                        h.$$attachId === o &&
                        (i.deregister(a, t), d.detach()),
                        s.$destroy();
                    });
                  });
              },
              detach() {
                if (h) {
                  const t = h;
                  (h = null), e.leave(t);
                }
              },
            }),
            t,
          ),
            n.$on("$destroy", () => {
              i.deregister(a, t);
            });
        },
      };
    }
    return (e.$inject = ["$animate"]), e;
  }
  const To = "ngAriaDisable",
    jo = ["BUTTON", "A", "INPUT", "TEXTAREA", "SELECT", "DETAILS", "SUMMARY"],
    Ro = function (t, e) {
      if (-1 !== e.indexOf(t.nodeName)) return !0;
    };
  function Lo() {
    let t = {
      ariaHidden: !0,
      ariaChecked: !0,
      ariaReadonly: !0,
      ariaDisabled: !0,
      ariaRequired: !0,
      ariaInvalid: !0,
      ariaValue: !0,
      tabindex: !0,
      bindKeydown: !0,
      bindRoleForClick: !0,
    };
    function e(e, n, r, s) {
      return function (i, o, a) {
        if (Object.prototype.hasOwnProperty.call(a, To)) return;
        const c = a.$normalize(n);
        !t[c] ||
          Ro(o, r) ||
          a[c] ||
          i.$watch(a[e], (t) => {
            (t = s ? !t : !!t), o.setAttribute(n, t);
          });
      };
    }
    (this.config = function (e) {
      t = P(t, e);
    }),
      (this.$get = function () {
        return { config: (e) => t[e], $$watchExpr: e };
      });
  }
  function No(t) {
    return t.$$watchExpr("ngDisabled", "aria-disabled", jo, !1);
  }
  function Vo(t) {
    return t.$$watchExpr("ngShow", "aria-hidden", [], !0);
  }
  function Po() {
    return {
      restrict: "A",
      require: "?ngMessages",
      link(t, e, n) {
        Object.prototype.hasOwnProperty.call(n, To) ||
          e.hasAttribute("aria-live") ||
          e.setAttribute("aria-live", "assertive");
      },
    };
  }
  function Mo(t, e) {
    return {
      restrict: "A",
      compile(n, r) {
        if (Object.prototype.hasOwnProperty.call(r, To)) return;
        const s = e(r.ngClick);
        return function (e, n, r) {
          Ro(n, jo) ||
            (t.config("bindRoleForClick") &&
              !n.hasAttribute("role") &&
              n.setAttribute("role", "button"),
            t.config("tabindex") &&
              !n.hasAttribute("tabindex") &&
              n.setAttribute("tabindex", "0"),
            !t.config("bindKeydown") ||
              r.ngKeydown ||
              r.ngKeypress ||
              r.ngKeyup ||
              n.addEventListener("keydown", (t) => {
                const n = parseInt(t.key, 10);
                (13 !== n && 32 !== n) ||
                  (-1 !== jo.indexOf(t.target.nodeName) ||
                    t.target.isContentEditable ||
                    t.preventDefault(),
                  e.$apply(function () {
                    s(e, { $event: t });
                  }));
              }));
        };
      },
    };
  }
  function Do(t) {
    return t.$$watchExpr("ngRequired", "aria-required", jo, !1);
  }
  function Io(t) {
    return t.$$watchExpr("ngChecked", "aria-checked", jo, !1);
  }
  function Uo(t) {
    return t.$$watchExpr("ngValue", "aria-checked", jo, !1);
  }
  function Ho(t) {
    return t.$$watchExpr("ngHide", "aria-hidden", [], !1);
  }
  function Fo(t) {
    return t.$$watchExpr("ngReadonly", "aria-readonly", jo, !1);
  }
  function qo(t) {
    function e(e, n, r, s) {
      return (
        t.config(n) &&
        !r.getAttribute(e) &&
        (s || !Ro(r, jo)) &&
        ("hidden" !== r.getAttribute("type") || "INPUT" !== r.nodeName)
      );
    }
    function n(t, e) {
      return (
        !e.getAttribute("role") && e.getAttribute("type") === t && !Ro(e, jo)
      );
    }
    return {
      restrict: "A",
      require: "ngModel",
      priority: 200,
      compile(r, s) {
        if (Object.prototype.hasOwnProperty.call(s, To)) return;
        const i = (function (t) {
          const { type: e } = t,
            { role: n } = t;
          return "checkbox" === (e || n) || "menuitemcheckbox" === n
            ? "checkbox"
            : "radio" === (e || n) || "menuitemradio" === n
              ? "radio"
              : "range" === e || "progressbar" === n || "slider" === n
                ? "range"
                : "";
        })(s);
        return {
          post(r, s, o, a) {
            const c = e("tabindex", "tabindex", s, !1);
            switch (i) {
              case "radio":
              case "checkbox":
                n(i, s) && s.setAttribute("role", i),
                  e("aria-checked", "ariaChecked", s, !1) &&
                    a.$watch(
                      "$modelValue",
                      "radio" === i
                        ? function () {
                            s.setAttribute(
                              "aria-checked",
                              (o.value == a.$viewValue).toString(),
                            );
                          }
                        : function () {
                            s.setAttribute(
                              "aria-checked",
                              (!a.$isEmpty(a.$viewValue)).toString(),
                            );
                          },
                    ),
                  c && s.setAttribute("tabindex", 0);
                break;
              case "range":
                if (
                  (n(i, s) && s.setAttribute("role", "slider"),
                  t.config("ariaValue"))
                ) {
                  const t =
                      !s.hasAttribute("aria-valuemin") &&
                      (Object.prototype.hasOwnProperty.call(o, "min") ||
                        Object.prototype.hasOwnProperty.call(o, "ngMin")),
                    e =
                      !s.hasAttribute("aria-valuemax") &&
                      (Object.prototype.hasOwnProperty.call(o, "max") ||
                        Object.prototype.hasOwnProperty.call(o, "ngMax")),
                    n = !s.hasAttribute("aria-valuenow");
                  t &&
                    o.$observe("min", (t) => {
                      s.setAttribute("aria-valuemin", t);
                    }),
                    e &&
                      o.$observe("max", (t) => {
                        s.setAttribute("aria-valuemax", t);
                      }),
                    n &&
                      a.$watch("$modelValue", (t) => {
                        s.setAttribute("aria-valuenow", t);
                      });
                }
                c && s.setAttribute("tabindex", 0);
            }
            !Object.prototype.hasOwnProperty.call(o, "ngRequired") &&
              a.$validators.required &&
              e("aria-required", "ariaRequired", s, !1) &&
              o.$observe("required", () => {
                s.setAttribute("aria-required", (!!o.required).toString());
              }),
              e("aria-invalid", "ariaInvalid", s, !0) &&
                a.$watch("$invalid", (t) => {
                  s.setAttribute("aria-invalid", (!!t).toString());
                });
          },
        };
      },
    };
  }
  function Bo(t) {
    return function (e, n, r) {
      Object.prototype.hasOwnProperty.call(r, To) ||
        !t.config("tabindex") ||
        n.hasAttribute("tabindex") ||
        Ro(n, jo) ||
        n.setAttribute("tabindex", 0);
    };
  }
  (No.$inject = ["$aria"]),
    (Vo.$inject = ["$aria"]),
    (Mo.$inject = ["$aria", "$parse"]),
    (Do.$inject = ["$aria"]),
    (Io.$inject = ["$aria"]),
    (Uo.$inject = ["$aria"]),
    (Ho.$inject = ["$aria"]),
    (Fo.$inject = ["$aria"]),
    (qo.$inject = ["$aria"]),
    (Bo.$inject = ["$aria"]);
  const Ko = "$$animateCss",
    zo = 1e3,
    Wo = {
      transitionDuration: Cs,
      transitionDelay: Es,
      transitionProperty: ds + gs,
      animationDuration: ws,
      animationDelay: bs,
      animationIterationCount: fs + "IterationCount",
    },
    Go = {
      transitionDuration: Cs,
      transitionDelay: Es,
      animationDuration: ws,
      animationDelay: bs,
    };
  function Qo(t, e) {
    return [e ? bs : Es, `${t}s`];
  }
  function Yo(t, e) {
    const n = Object.create(null),
      r = window.getComputedStyle(t) || {};
    return (
      Object.entries(e).forEach(([t, e]) => {
        let s = r[e];
        if (s) {
          const e = s.charAt(0);
          ("-" === e || "+" === e || e >= 0) &&
            (s = (function (t) {
              let e = 0;
              return (
                t.split(/\s*,\s*/).forEach((t) => {
                  "s" === t.charAt(t.length - 1) &&
                    (t = t.substring(0, t.length - 1)),
                    (t = parseFloat(t) || 0),
                    (e = e ? Math.max(t, e) : t);
                }),
                e
              );
            })(s)),
            0 === s && (s = null),
            (n[t] = s);
        }
      }),
      n
    );
  }
  function Zo(t) {
    return 0 === t || null != t;
  }
  function Jo(t, e) {
    let n = ds,
      r = `${t}s`;
    return e ? (n += ms) : (r += " linear all"), [n, r];
  }
  function Xo(t, e, n) {
    n.forEach((n) => {
      t[n] = b(t[n]) ? t[n] : e.style.getPropertyValue(n);
    });
  }
  function ta() {
    this.$get = [
      "$$AnimateRunner",
      "$$animateCache",
      "$$rAFScheduler",
      function (t, e, n) {
        const r = function (t, e) {
          e.addClass &&
            (t.classList.add(...e.addClass.trim().split(" ")),
            (e.addClass = null)),
            e.removeClass &&
              (t.classList.remove(...e.removeClass.trim().split(" ")),
              (e.removeClass = null));
        };
        const s = [];
        function i(t) {
          s.push(t),
            n.waitUntilQuiet(() => {
              e.flush();
              const t = document.body.offsetWidth + 1;
              for (let e = 0; e < s.length; e++) s[e](t);
              s.length = 0;
            });
        }
        function o(t, n, r) {
          const s = (function (t, n, r, s) {
              let i = e.get(n);
              i ||
                ((i = Yo(t, s)),
                "infinite" === i.animationIterationCount &&
                  (i.animationIterationCount = 1));
              const o =
                r || i.transitionDuration > 0 || i.animationDuration > 0;
              return e.put(n, i, o), i;
            })(t, n, r, Wo),
            i = s.animationDelay,
            o = s.transitionDelay;
          return (
            (s.maxDelay = i && o ? Math.max(i, o) : i || o),
            (s.maxDuration = Math.max(
              s.animationDuration * s.animationIterationCount,
              s.transitionDuration,
            )),
            s
          );
        }
        return function (n, s) {
          let a = s || {};
          a.$$prepared || (a = ks(structuredClone(a)));
          const c = {},
            l = n;
          if (!l || !l.parentNode) return q();
          const u = [],
            h = (function (t) {
              const e = {};
              return (
                t && (t.to || t.from) && ((e.to = t.to), (e.from = t.from)), e
              );
            })(a);
          let d, p, f, $, m, g, y, v, b, w;
          const E = [];
          if (0 === a.duration) return q();
          const C =
              a.event && Array.isArray(a.event) ? a.event.join(" ") : a.event,
            O = C && a.structural;
          let A = "",
            S = "";
          O ? (A = Ss(C, "ng-", !0)) : C && (A = C),
            a.addClass && (S += Ss(a.addClass, as)),
            a.removeClass &&
              (S.length && (S += " "), (S += Ss(a.removeClass, cs))),
            a.applyClassesEarly && S.length && r(n, a);
          let x = [A, S].join(" ").trim();
          const k = h.to && Object.keys(h.to).length > 0;
          if (!((a.keyframeStyle || "").length > 0) && !k && !x) return q();
          let _,
            T,
            j = e.cacheKey(l, C, a.addClass, a.removeClass);
          if (e.containsCachedAnimationWithoutDuration(j))
            return (x = null), q();
          if (a.stagger > 0) {
            const t = parseFloat(a.stagger);
            _ = {
              transitionDelay: t,
              animationDelay: t,
              transitionDuration: 0,
              animationDuration: 0,
            };
          } else
            _ = (function (t, n, r, s) {
              let i;
              const o = `stagger-${r}`;
              if (e.count(r) > 0 && ((i = e.get(o)), !i)) {
                const r = Ss(n, "-stagger");
                (t.className += ` ${r}`),
                  (i = Yo(t, s)),
                  (i.animationDuration = Math.max(i.animationDuration, 0)),
                  (i.transitionDuration = Math.max(i.transitionDuration, 0)),
                  t.classList.remove(r),
                  e.put(o, i, !0);
              }
              return i || {};
            })(l, x, j, Go);
          if (
            (a.$$skipPreparationClasses ||
              n.classList.add(...x.split(" ").filter((t) => "" !== t)),
            a.transitionStyle)
          ) {
            const t = [ds, a.transitionStyle];
            Ns(l, t), u.push(t);
          }
          if (a.duration >= 0) {
            T = l.style[ds].length > 0;
            const t = Jo(a.duration, T);
            Ns(l, t), u.push(t);
          }
          if (a.keyframeStyle) {
            const t = [fs, a.keyframeStyle];
            Ns(l, t), u.push(t);
          }
          const R = _ ? (a.staggerIndex >= 0 ? a.staggerIndex : e.count(j)) : 0,
            L = 0 === R;
          L && !a.skipBlocking && ea(l, 9999);
          let N = o(l, j, !O),
            V = N.maxDelay;
          (g = Math.max(V, 0)), (v = N.maxDuration);
          const P = {};
          if (
            ((P.hasTransitions = N.transitionDuration > 0),
            (P.hasAnimations = N.animationDuration > 0),
            (P.hasTransitionAll =
              P.hasTransitions && "all" === N.transitionProperty),
            (P.applyTransitionDuration =
              k &&
              ((P.hasTransitions && !P.hasTransitionAll) ||
                (P.hasAnimations && !P.hasTransitions))),
            (P.applyAnimationDuration = a.duration && P.hasAnimations),
            (P.applyTransitionDelay =
              Zo(a.delay) && (P.applyTransitionDuration || P.hasTransitions)),
            (P.applyAnimationDelay = Zo(a.delay) && P.hasAnimations),
            (P.recalculateTimingStyles = S.length > 0),
            (P.applyTransitionDuration || P.applyAnimationDuration) &&
              ((v = a.duration ? parseFloat(a.duration) : v),
              P.applyTransitionDuration &&
                ((P.hasTransitions = !0),
                (N.transitionDuration = v),
                (T = l.style[ds + gs].length > 0),
                u.push(Jo(v, T))),
              P.applyAnimationDuration &&
                ((P.hasAnimations = !0),
                (N.animationDuration = v),
                u.push([ws, `${v}s`]))),
            0 === v && !P.recalculateTimingStyles)
          )
            return q();
          var M,
            D = Ss(x, ls);
          null != a.delay &&
            ("boolean" != typeof a.delay &&
              ((M = parseFloat(a.delay)), (g = Math.max(M, 0))),
            P.applyTransitionDelay && u.push(Qo(M)),
            P.applyAnimationDelay && u.push(Qo(M, !0)));
          return (
            null == a.duration &&
              N.transitionDuration > 0 &&
              (P.recalculateTimingStyles = P.recalculateTimingStyles || L),
            (y = g * zo),
            (b = v * zo),
            a.skipBlocking ||
              ((P.blockTransition = N.transitionDuration > 0),
              (P.blockKeyframeAnimation =
                N.animationDuration > 0 &&
                _.animationDelay > 0 &&
                0 === _.animationDuration)),
            a.from &&
              (a.cleanupStyles && Xo(c, l, Object.keys(a.from)), Ts(0, a)),
            P.blockTransition || P.blockKeyframeAnimation
              ? F(v)
              : a.skipBlocking || ea(l, !1),
            {
              $$willAnimate: !0,
              end: I,
              start() {
                if (!d)
                  return (
                    (m = { end: I, cancel: U, resume: null, pause: null }),
                    ($ = new t(m)),
                    i(K),
                    $
                  );
              },
            }
          );
          function I() {
            H();
          }
          function U() {
            H(!0);
          }
          function H(t) {
            if (d || (f && p)) return;
            (d = !0),
              (p = !1),
              x &&
                !a.$$skipPreparationClasses &&
                n.classList.remove(...x.split(" ")),
              (D = Ss(x, ls)) && n.classList.remove(...D.split(" ")),
              Ls(l, !1),
              ea(l, !1),
              u.forEach((t) => {
                l.style[t[0]] = "";
              }),
              r(n, a),
              _s(n, a),
              Object.keys(c).length &&
                Object.entries(c).forEach(([t, e]) => {
                  e ? l.style.setProperty(t, e) : l.style.removeProperty(t);
                }),
              a.onDone && a.onDone(),
              E && E.length && n.off(E.join(" "), B);
            const e = Pt(n, Ko);
            e && (clearTimeout(e[0].timer), _t(n, Ko)), $ && $.complete(!t);
          }
          function F(t) {
            P.blockTransition && ea(l, t),
              P.blockKeyframeAnimation && Ls(l, !!t);
          }
          function q() {
            return (
              ($ = new t({ end: I, cancel: U })),
              i(() => {}),
              H(),
              { $$willAnimate: !1, start: () => $, end: I }
            );
          }
          function B(t) {
            t.stopPropagation();
            const e = t.originalEvent || t;
            if (e.target !== l) return;
            const n = e.$manualTimeStamp || Date.now(),
              r = parseFloat(e.elapsedTime.toFixed(3));
            Math.max(n - w, 0) >= y && r >= v && ((f = !0), H());
          }
          function K() {
            if (d) return;
            if (!l.parentNode) return void H();
            const t = function (t) {
                if (f) p && t && ((p = !1), H());
                else if (((p = !t), N.animationDuration)) {
                  const t = Ls(l, p);
                  p
                    ? u.push(t)
                    : (function (t, e) {
                        const n = t.indexOf(e);
                        e >= 0 && t.splice(n, 1);
                      })(u, t);
                }
              },
              s =
                R > 0 &&
                ((N.transitionDuration && 0 === _.transitionDuration) ||
                  (N.animationDuration && 0 === _.animationDuration)) &&
                Math.max(_.animationDelay, _.transitionDelay);
            function i() {
              if (d) return;
              if (
                (F(!1),
                u.forEach((t) => {
                  const e = t[0],
                    n = t[1];
                  l.style[e] = n;
                }),
                r(n, a),
                n.classList.add(...D.split(" ").filter((t) => "" !== t)),
                P.recalculateTimingStyles)
              ) {
                if (
                  ((j = e.cacheKey(l, C, a.addClass, a.removeClass)),
                  (N = o(l, j, !1)),
                  (V = N.maxDelay),
                  (g = Math.max(V, 0)),
                  (v = N.maxDuration),
                  0 === v)
                )
                  return void H();
                (P.hasTransitions = N.transitionDuration > 0),
                  (P.hasAnimations = N.animationDuration > 0);
              }
              if (
                (P.applyAnimationDelay &&
                  ((V =
                    "boolean" != typeof a.delay && Zo(a.delay)
                      ? parseFloat(a.delay)
                      : V),
                  (g = Math.max(V, 0)),
                  (N.animationDelay = V),
                  (M = Qo(V, !0)),
                  u.push(M),
                  (l.style[M[0]] = M[1])),
                (y = g * zo),
                (b = v * zo),
                a.easing)
              ) {
                let t;
                const e = a.easing;
                P.hasTransitions &&
                  ((t = ds + vs), u.push([t, e]), (l.style[t] = e)),
                  P.hasAnimations &&
                    ((t = fs + vs), u.push([t, e]), (l.style[t] = e));
              }
              N.transitionDuration && E.push(ps),
                N.animationDuration && E.push($s),
                (w = Date.now());
              const t = y + 1.5 * b,
                s = w + t,
                i = Pt(n, Ko) || [];
              let p = !0;
              if (i.length) {
                const t = i[0];
                (p = s > t.expectedEndTime),
                  p ? clearTimeout(t.timer) : i.push(H);
              }
              if (p) {
                const e = setTimeout(h, t, !1);
                (i[0] = { timer: e, expectedEndTime: s }),
                  i.push(H),
                  Vt(n, Ko, i);
              }
              E.length &&
                E.forEach((t) => {
                  n.addEventListener(t, B);
                }),
                a.to &&
                  (a.cleanupStyles && Xo(c, l, Object.keys(a.to)), js(0, a));
            }
            function h() {
              const t = Pt(n, Ko);
              if (t) {
                for (let e = 1; e < t.length; e++) t[e]();
                _t(n, Ko);
              }
            }
            s ? setTimeout(i, Math.floor(s * R * zo), !1) : i(),
              (m.resume = function () {
                t(!0);
              }),
              (m.pause = function () {
                t(!1);
              });
          }
        };
      },
    ];
  }
  function ea(t, e) {
    const n = e ? `-${e}s` : "";
    return Ns(t, [Es, n]), [Es, n];
  }
  const na = "data-ng-animate",
    ra = "$ngAnimatePin";
  function sa(t) {
    const e = (this.rules = { skip: [], cancel: [], join: [] });
    function n(t) {
      return {
        addClass: t.addClass,
        removeClass: t.removeClass,
        from: t.from,
        to: t.to,
      };
    }
    function r(t, e) {
      if (t && e) {
        const n = (function (t) {
          if (!t) return null;
          const e = t.split(" "),
            n = Object.create(null);
          return (
            e.forEach((t) => {
              n[t] = !0;
            }),
            n
          );
        })(e);
        return t.split(" ").some((t) => n[t]);
      }
    }
    function s(t, n, r) {
      return e[t].some((t) => t(n, r));
    }
    function i(t, e) {
      const n = (t.addClass || "").length > 0,
        r = (t.removeClass || "").length > 0;
      return e ? n && r : n || r;
    }
    e.join.push((t) => !t.structural && i(t)),
      e.skip.push((t) => !t.structural && !i(t)),
      e.skip.push((t, e) => "leave" === e.event && t.structural),
      e.skip.push((t, e) => e.structural && 2 === e.state && !t.structural),
      e.cancel.push((t, e) => e.structural && t.structural),
      e.cancel.push((t, e) => 2 === e.state && t.structural),
      e.cancel.push((t, e) => {
        if (e.structural) return !1;
        const n = t.addClass,
          s = t.removeClass,
          i = e.addClass,
          o = e.removeClass;
        return !((v(n) && v(s)) || (v(i) && v(o))) && (r(n, o) || r(s, i));
      }),
      (this.$get = [
        "$rootScope",
        "$injector",
        "$$animation",
        "$$AnimateRunner",
        "$templateRequest",
        function (e, r, o, a, c) {
          const l = new Map(),
            u = new Map();
          let h = null;
          function d(t) {
            u.delete(t.target);
          }
          e.templateRequest = c;
          const p = e.$watch(
              "$templateRequest.totalPendingRequests",
              (t) => {
                0 === t &&
                  (p(),
                  (e.$templateRequest = void 0),
                  e.$postUpdate(() => {
                    e.$postUpdate(() => {
                      null === h && (h = !0);
                    });
                  }));
              },
              !0,
            ),
            f = Object.create(null),
            $ = t.customFilter(),
            m = t.classNameFilter(),
            g = function () {
              return !0;
            },
            y = $ || g,
            C = m
              ? function (t, e) {
                  const n = [
                    t.getAttribute("class"),
                    e.addClass,
                    e.removeClass,
                  ].join(" ");
                  return m.test(n);
                }
              : g,
            O = function (t, e) {
              e.addClass &&
                (t.classList.add(...e.addClass.trim().split(" ")),
                (e.addClass = null)),
                e.removeClass &&
                  (t.classList.remove(...e.removeClass.trim().split(" ")),
                  (e.removeClass = null));
            };
          function A(t, e) {
            return Rs(t, e, {});
          }
          const S =
            window.Node.prototype.contains ||
            function (t) {
              return this === t || !!(16 & this.compareDocumentPosition(t));
            };
          function x(t, e, n) {
            const r = xs(e);
            return t.filter((t) => !(t.node === r && (!n || t.callback === n)));
          }
          function k(t, e) {
            "close" !== t || e.parentNode || _.off(e);
          }
          let _ = {
            on(t, e, n) {
              const r = xs(e);
              (f[t] = f[t] || []),
                f[t].push({ node: r, callback: n }),
                e.addEventListener("$destroy", () => {
                  l.get(r) || _.off(t, e, n);
                });
            },
            off(t, e, n) {
              if (1 === arguments.length && !E(arguments[0])) {
                e = arguments[0];
                for (const t in f) f[t] = x(f[t], e);
                return;
              }
              const r = f[t];
              r && (f[t] = 1 === arguments.length ? null : x(r, e, n));
            },
            pin(t, e) {
              As(H(t), "element", "not an element"),
                As(H(e), "parentElement", "not an element"),
                Vt(t, ra, e);
            },
            push: (t, c, h, d) => (
              ((h = h || {}).domOperation = d),
              (function (t, c, h) {
                let d = h,
                  p = Array.isArray(t)
                    ? t.filter((t) => "#comment" !== t.nodeName)[0]
                    : t;
                const $ = p,
                  m = $ && $.parentNode;
                d = ks(d);
                const g = new a(),
                  x = (function () {
                    let t = !1;
                    return function (n) {
                      t
                        ? n()
                        : e.$postUpdate(() => {
                            (t = !0), n();
                          });
                    };
                  })();
                Array.isArray(d.addClass) &&
                  (d.addClass = d.addClass.join(" "));
                d.addClass && !E(d.addClass) && (d.addClass = null);
                Array.isArray(d.removeClass) &&
                  (d.removeClass = d.removeClass.join(" "));
                d.removeClass && !E(d.removeClass) && (d.removeClass = null);
                d.from && !w(d.from) && (d.from = null);
                d.to && !w(d.to) && (d.to = null);
                if (!$ || !y($, c, h) || !C($, d)) return I(), g;
                const _ = ["enter", "move", "leave"].indexOf(c) >= 0;
                let R = document.hidden || u.get($);
                const L = (!R && l.get($)) || {},
                  N = !!L.state;
                R ||
                  (N && 1 === L.state) ||
                  (R = !(function (t, e) {
                    const n = document.body,
                      s = r.get("$rootElement");
                    let i,
                      o = t === n || "HTML" === t.nodeName,
                      a = t === s,
                      c = !1,
                      h = u.get(t),
                      d = Nt(t, ra);
                    d && (e = d);
                    for (
                      ;
                      e &&
                      (a || (a = e === s), e.nodeType === Node.ELEMENT_NODE);

                    ) {
                      const t = l.get(e) || {};
                      if (!c) {
                        const n = u.get(e);
                        if (!0 === n && !1 !== h) {
                          h = !0;
                          break;
                        }
                        !1 === n && (h = !1), (c = t.structural);
                      }
                      if (v(i) || !0 === i) {
                        const t = Nt(e, hs);
                        b(t) && (i = t);
                      }
                      if (c && !1 === i) break;
                      if ((o || (o = e === n), o && a)) break;
                      e = a || ((d = Nt(e, ra)), !d) ? e.parentNode : d;
                    }
                    return (!c || i) && !0 !== h && a && o;
                  })($, m));
                if (R)
                  return (
                    document.hidden && D(g, c, "start", n(d)),
                    I(),
                    document.hidden && D(g, c, "close", n(d)),
                    g
                  );
                _ &&
                  (function (t) {
                    const e = t.querySelectorAll(`[${na}]`);
                    e.forEach((t) => {
                      const e = parseInt(t.getAttribute(na), 10),
                        n = l.get(t);
                      if (n)
                        switch (e) {
                          case 2:
                            n.runner.end();
                          case 1:
                            l.delete(t);
                        }
                    });
                  })($);
                const V = {
                  structural: _,
                  element: p,
                  event: c,
                  addClass: d.addClass,
                  removeClass: d.removeClass,
                  close: I,
                  options: d,
                  runner: g,
                };
                if (N) {
                  if (s("skip", V, L))
                    return 2 === L.state ? (I(), g) : (Rs(p, L, V), L.runner);
                  if (s("cancel", V, L))
                    if (2 === L.state) L.runner.end();
                    else {
                      if (!L.structural) return Rs(p, L, V), L.runner;
                      L.close();
                    }
                  else {
                    if (s("join", V, L)) {
                      if (2 !== L.state)
                        return (
                          (function (t, e, n) {
                            let r = "";
                            e && (r = Ss(e, "ng-", !0)),
                              n.addClass && (r = Vs(r, Ss(n.addClass, as))),
                              n.removeClass &&
                                (r = Vs(r, Ss(n.removeClass, cs))),
                              r.length &&
                                ((n.preparationClasses = r),
                                (t.className += ` ${r}`));
                          })(p, _ ? c : null, d),
                          (c = V.event = L.event),
                          (d = Rs(p, L, V)),
                          L.runner
                        );
                      A(p, V);
                    }
                  }
                } else A(p, V);
                let P = V.structural;
                P ||
                  (P =
                    ("animate" === V.event &&
                      Object.keys(V.options.to || {}).length > 0) ||
                    i(V));
                if (!P) return I(), T($), g;
                const M = (L.counter || 0) + 1;
                return (
                  (V.counter = M),
                  j($, 1, V),
                  e.$postUpdate(() => {
                    p = (function (t) {
                      return t instanceof NodeList
                        ? Array.from(t).filter(
                            (t) => t.nodeType == Node.ELEMENT_NODE,
                          )
                        : t.nodeType === Node.ELEMENT_NODE
                          ? t
                          : void 0;
                    })(t);
                    let e = l.get($);
                    const r = !e;
                    e = e || {};
                    const s =
                      (p.parentElement || []) &&
                      ("animate" === e.event || e.structural || i(e));
                    if (r || e.counter !== M || !s)
                      return (
                        r && (O(p, d), _s(p, d)),
                        (r || (_ && e.event !== c)) &&
                          (d.domOperation(), g.end()),
                        void (s || T($))
                      );
                    (c = !e.structural && i(e, !0) ? "setClass" : e.event),
                      j($, 2);
                    const a = o(p, c, e.options);
                    g.setHost(a),
                      D(g, c, "start", n(d)),
                      a.done((t) => {
                        I(!t);
                        const e = l.get($);
                        e && e.counter === M && T($), D(g, c, "close", n(d));
                      });
                  }),
                  g
                );
                function D(t, e, n, r) {
                  x(() => {
                    const t = (function (t, e, n) {
                      const r = [],
                        s = f[n];
                      return (
                        s &&
                          s.forEach((s) => {
                            (S.call(s.node, e) ||
                              ("leave" === n && S.call(s.node, t))) &&
                              r.push(s.callback);
                          }),
                        r
                      );
                    })(m, $, e);
                    t.length
                      ? (t.forEach((t) => {
                          t(p, n, r);
                        }),
                        k(n, $))
                      : k(n, $);
                  }),
                    t.progress(e, n, r);
                }
                function I(t) {
                  !(function (t, e) {
                    e.preparationClasses &&
                      (e.preparationClasses
                        .split(" ")
                        .forEach((e) => t.classList.remove(e)),
                      (e.preparationClasses = null)),
                      e.activeClasses &&
                        (e.activeClasses
                          .split(" ")
                          .forEach((e) => t.classList.remove(e)),
                        (e.activeClasses = null));
                  })(p, d),
                    O(p, d),
                    _s(p, d),
                    d.domOperation(),
                    g.complete(!t);
                }
              })(t, c, h)
            ),
            enabled(t, e) {
              const n = arguments.length;
              if (0 === n) e = !!h;
              else {
                if (H(t)) {
                  const r = t;
                  1 === n
                    ? (e = !u.get(r))
                    : (u.has(r) || t.addEventListener("$destroy", d),
                      u.set(r, !e));
                } else e = h = !!t;
              }
              return e;
            },
          };
          return _;
          function T(t) {
            t.removeAttribute(na), l.delete(t);
          }
          function j(t, e, n) {
            ((n = n || {}).state = e), t.setAttribute(na, e);
            const r = l.get(t),
              s = r ? P(r, n) : n;
            l.set(t, s);
          }
        },
      ]);
  }
  function ia(t) {
    this.$get = [
      "$injector",
      "$$AnimateRunner",
      function (e, n) {
        const r = function (t, e) {
          e.addClass &&
            (t.classList.add(...e.addClass.trim().split(" ")),
            (e.addClass = null)),
            e.removeClass &&
              (t.classList.remove(...e.removeClass.trim().split(" ")),
              (e.removeClass = null));
        };
        return function (s, i, o, a) {
          let c = !1;
          3 === arguments.length && w(o) && ((a = o), (o = null)),
            (a = ks(a)),
            o ||
              ((o = s.getAttribute("class") || ""),
              a.addClass && (o += ` ${a.addClass}`),
              a.removeClass && (o += ` ${a.removeClass}`));
          const l = a.addClass,
            u = a.removeClass,
            h = (function (n) {
              n = Array.isArray(n) ? n : n.split(" ");
              const r = [],
                s = {};
              for (let i = 0; i < n.length; i++) {
                const o = n[i],
                  a = t.$$registeredAnimations[o];
                a && !s[o] && (r.push(e.get(a)), (s[o] = !0));
              }
              return r;
            })(o);
          let d, p, f;
          if (h.length) {
            let t, e;
            "leave" === i
              ? ((e = "leave"), (t = "afterLeave"))
              : ((e = `before${i.charAt(0).toUpperCase()}${i.substring(1)}`),
                (t = i)),
              "enter" !== i && "move" !== i && (d = y(s, i, a, h, e)),
              (p = y(s, i, a, h, t));
          }
          if (d || p)
            return {
              $$willAnimate: !0,
              end: () => (
                f ? f.end() : (m(), (f = new n()), f.complete(!0)), f
              ),
              start() {
                if (f) return f;
                let t;
                f = new n();
                const e = [];
                return (
                  d &&
                    e.push((e) => {
                      t = d(e);
                    }),
                  e.length
                    ? e.push((t) => {
                        $(), t(!0);
                      })
                    : $(),
                  p &&
                    e.push((e) => {
                      t = p(e);
                    }),
                  f.setHost({
                    end() {
                      s();
                    },
                    cancel() {
                      s(!0);
                    },
                  }),
                  n.chain(e, r),
                  f
                );
                function r(t) {
                  m(), f.complete(t);
                }
                function s(e) {
                  c || ((t || (() => {}))(e), r(e));
                }
              },
            };
          function $() {
            a.domOperation(), r(s, a);
          }
          function m() {
            (c = !0), $(), _s(s, a);
          }
          function g(t, e, r, s, i) {
            const o = [];
            return (
              s.forEach((s) => {
                const a = s[i];
                a &&
                  o.push(() => {
                    let s,
                      i,
                      o = !1;
                    const c = function (t) {
                      o || ((o = !0), (i || (() => {}))(t), s.complete(!t));
                    };
                    return (
                      (s = new n({
                        end() {
                          c();
                        },
                        cancel() {
                          c(!0);
                        },
                      })),
                      (i = (function (t, e, r, s, i) {
                        let o;
                        switch (r) {
                          case "animate":
                            o = [e, s.from, s.to, i];
                            break;
                          case "setClass":
                            o = [e, l, u, i];
                            break;
                          case "addClass":
                            o = [e, l, i];
                            break;
                          case "removeClass":
                            o = [e, u, i];
                            break;
                          default:
                            o = [e, i];
                        }
                        o.push(s);
                        let a = t.apply(t, o);
                        if (a)
                          if ((k(a.start) && (a = a.start()), a instanceof n))
                            a.done(i);
                          else if (k(a)) return a;
                        return () => {};
                      })(a, t, e, r, (t) => {
                        c(!1 === t);
                      })),
                      s
                    );
                  });
              }),
              o
            );
          }
          function y(t, e, r, s, i) {
            let o = g(t, e, r, s, i);
            if (0 === o.length) {
              let e, n;
              "beforeSetClass" === i
                ? ((e = g(t, "removeClass", r, s, "beforeRemoveClass")),
                  (n = g(t, "addClass", r, s, "beforeAddClass")))
                : "setClass" === i &&
                  ((e = g(t, "removeClass", r, s, "removeClass")),
                  (n = g(t, "addClass", r, s, "addClass"))),
                e && (o = o.concat(e)),
                n && (o = o.concat(n));
            }
            if (0 !== o.length)
              return function (t) {
                const e = [];
                return (
                  o.length &&
                    o.forEach((t) => {
                      e.push(t());
                    }),
                  e.length ? n.all(e, t) : t(),
                  function (t) {
                    e.forEach((e) => {
                      t ? e.cancel() : e.end();
                    });
                  }
                );
              };
          }
        };
      },
    ];
  }
  (sa.$inject = ["$animateProvider"]), (ia.$inject = ["$animateProvider"]);
  const oa = "$$animationRunner",
    aa = "$$animatePrepareClasses";
  function ca() {
    const t = "ng-animate-ref",
      e = (this.drivers = []);
    function n(t) {
      !(function (t, e) {
        if (Rt(t)) {
          const n = Tt(t, !1),
            r = n?.data;
          r &&
            Object.prototype.hasOwnProperty.call(r, xt(e)) &&
            delete r[xt(e)];
        }
      })(t, oa);
    }
    function r(t) {
      return Pt(t, oa);
    }
    this.$get = [
      "$rootScope",
      "$injector",
      "$$AnimateRunner",
      "$$rAFScheduler",
      "$$animateCache",
      function (s, i, o, a, c) {
        const l = [],
          u = function (t, e) {
            e.addClass &&
              (t.classList.add(...e.addClass.trim().split(" ")),
              (e.addClass = null)),
              e.removeClass &&
                (t.classList.remove(...e.removeClass.trim().split(" ")),
                (e.removeClass = null));
          };
        return function (h, d, p) {
          p = ks(p);
          const f = ["enter", "move", "leave"].indexOf(d) >= 0,
            $ = new o({
              end() {
                v();
              },
              cancel() {
                v(!0);
              },
            });
          if (!e.length) return v(), $;
          let m = ft(h.getAttribute("class"), ft(p.addClass, p.removeClass)),
            { tempClasses: g } = p;
          return (
            g && ((m += ` ${g}`), (p.tempClasses = null)),
            f && Vt(h, aa, `ng-${d}-prepare`),
            (function (t, e) {
              Vt(t, oa, e);
            })(h, $),
            l.push({
              element: h,
              classes: m,
              event: d,
              structural: f,
              options: p,
              beforeStart: function () {
                (g = (g ? `${g} ` : "") + us), (h.className += ` ${g}`);
                let t = Pt(h, aa);
                t && (h.classList.remove(t), (t = null));
              },
              close: v,
            }),
            h.addEventListener("$destroy", function () {
              const t = r(h);
              !t || ("leave" === d && p.$$domOperationFired) || t.end();
            }),
            l.length > 1 ||
              s.$postUpdate(() => {
                const n = [];
                l.forEach((t) => {
                  r(t.element) ? n.push(t) : t.close();
                }),
                  (l.length = 0);
                const s = (function (e) {
                    const n = [],
                      r = {};
                    e.forEach((e, s) => {
                      const { element: i } = e,
                        o = i,
                        { event: a } = e,
                        c = ["enter", "move"].indexOf(a) >= 0,
                        l = e.structural
                          ? (function (e) {
                              const n = `[${t}]`,
                                r = e.hasAttribute(t)
                                  ? [e]
                                  : e.querySelectorAll(n),
                                s = [];
                              return (
                                r.forEach((e) => {
                                  const n = e.getAttribute(t);
                                  n && n.length && s.push(e);
                                }),
                                s
                              );
                            })(o)
                          : [];
                      if (l.length) {
                        const e = c ? "to" : "from";
                        l.forEach((n) => {
                          const i = n.getAttribute(t);
                          (r[i] = r[i] || {}),
                            (r[i][e] = { animationID: s, element: n });
                        });
                      } else n.push(e);
                    });
                    const s = {},
                      i = {};
                    return (
                      Object.values(r).forEach((t) => {
                        const { from: r } = t,
                          { to: o } = t;
                        if (!r || !o) {
                          const t = r ? r.animationID : o.animationID,
                            i = t.toString();
                          return void (s[i] || ((s[i] = !0), n.push(e[t])));
                        }
                        const a = e[r.animationID],
                          c = e[o.animationID],
                          l = r.animationID.toString();
                        if (!i[l]) {
                          const t = (i[l] = {
                            structural: !0,
                            beforeStart() {
                              a.beforeStart(), c.beforeStart();
                            },
                            close() {
                              a.close(), c.close();
                            },
                            classes: y(a.classes, c.classes),
                            from: a,
                            to: c,
                            anchors: [],
                          });
                          t.classes.length ? n.push(t) : (n.push(a), n.push(c));
                        }
                        i[l].anchors.push({ out: r.element, in: o.element });
                      }),
                      n
                    );
                  })(n),
                  o = [];
                s.forEach((t) => {
                  const n = t.from ? t.from.element : t.element;
                  let s = p.addClass;
                  s = (s ? `${s} ` : "") + us;
                  const a = c.cacheKey(n, t.event, s, p.removeClass);
                  o.push({
                    element: n,
                    domNode: n,
                    fn: function () {
                      let n;
                      const s = t.close;
                      if (c.containsCachedAnimationWithoutDuration(a))
                        return void s();
                      t.beforeStart();
                      if (
                        r(
                          t.anchors
                            ? t.from.element || t.to.element
                            : t.element,
                        )
                      ) {
                        const r = (function (t) {
                          for (let n = e.length - 1; n >= 0; n--) {
                            const r = e[n],
                              s = i.get(r)(t);
                            if (s) return s;
                          }
                        })(t);
                        r && (n = r.start);
                      }
                      if (n) {
                        const e = n();
                        e.done((t) => {
                          s(!t);
                        }),
                          (function (t, e) {
                            t.from && t.to
                              ? (n(t.from.element), n(t.to.element))
                              : n(t.element);
                            function n(t) {
                              const n = r(t);
                              n && n.setHost(e);
                            }
                          })(t, e);
                      } else s();
                    },
                  });
                });
                const u = (function (t) {
                  const e = { children: [] };
                  let n;
                  const r = new Map();
                  for (n = 0; n < t.length; n++) {
                    const e = t[n];
                    r.set(
                      e.domNode,
                      (t[n] = {
                        domNode: e.domNode,
                        element: e.element,
                        fn: e.fn,
                        children: [],
                      }),
                    );
                  }
                  for (n = 0; n < t.length; n++) s(t[n]);
                  return (function (t) {
                    const e = [],
                      n = [];
                    let r;
                    for (r = 0; r < t.children.length; r++)
                      n.push(t.children[r]);
                    let s = n.length,
                      i = 0,
                      o = [];
                    for (r = 0; r < n.length; r++) {
                      const t = n[r];
                      s <= 0 && ((s = i), (i = 0), e.push(o), (o = [])),
                        o.push(t),
                        t.children.forEach((t) => {
                          i++, n.push(t);
                        }),
                        s--;
                    }
                    return o.length && e.push(o), e;
                  })(e);
                  function s(t) {
                    if (t.processed) return t;
                    t.processed = !0;
                    const n = t.domNode;
                    let i,
                      { parentNode: o } = n;
                    for (r.set(n, t); o; ) {
                      if (((i = r.get(o)), i)) {
                        i.processed || (i = s(i));
                        break;
                      }
                      o = o.parentNode;
                    }
                    return (i || e).children.push(t), t;
                  }
                })(o);
                for (let t = 0; t < u.length; t++) {
                  const e = u[t];
                  for (let n = 0; n < e.length; n++) {
                    const r = e[n],
                      { element: s } = r;
                    if (((u[t][n] = r.fn), 0 === t)) {
                      _t(s, aa);
                      continue;
                    }
                    const i = Pt(s, aa);
                    i && s.classList.add(i);
                  }
                }
                a(u);
              }),
            $
          );
          function y(t, e) {
            (t = t.split(" ")), (e = e.split(" "));
            const n = [];
            for (let r = 0; r < t.length; r++) {
              const s = t[r];
              if ("ng-" !== s.substring(0, 3))
                for (let t = 0; t < e.length; t++)
                  if (s === e[t]) {
                    n.push(s);
                    break;
                  }
            }
            return n.join(" ");
          }
          function v(t) {
            n(h),
              u(h, p),
              _s(h, p),
              p.domOperation(),
              g && g.split(" ").forEach((t) => h.classList.remove(t)),
              $.complete(!t);
          }
        };
      },
    ];
  }
  function la() {
    let t = [],
      e = null;
    function n() {
      if (!t.length) return;
      t.shift().forEach((t) => t()),
        e ||
          window.requestAnimationFrame(() => {
            (e = null), n();
          });
    }
    function r(e) {
      (t = t.concat(e)), n();
    }
    (t = r.queue = []),
      (r.waitUntilQuiet = (t) => {
        null !== e && (window.cancelAnimationFrame(e), (e = null)),
          (e = window.requestAnimationFrame(() => {
            (e = null), t(), n();
          }));
      }),
      (this.$get = function () {
        return r;
      });
  }
  const ua = "$animId";
  let ha = 0;
  const da = new Map();
  function pa() {
    return {
      cacheKey(t, e, n, r) {
        const { parentNode: s } = t,
          i = [s[ua] ?? (s[ua] = ++ha), e, t.getAttribute("class")];
        return n && i.push(n), r && i.push(r), i.join(" ");
      },
      containsCachedAnimationWithoutDuration(t) {
        const e = da.get(t);
        return !!e && !e.isValid;
      },
      flush() {
        da.clear();
      },
      count: (t) => da.get(t)?.total ?? 0,
      get: (t) => da.get(t)?.value,
      put(t, e, n) {
        const r = da.get(t);
        r
          ? (r.total++, (r.value = e))
          : da.set(t, { total: 1, value: e, isValid: n });
      },
    };
  }
  function fa() {
    this.$get = [pa];
  }
  const $a = "ng-animate-shim",
    ma = "ng-anchor",
    ga = "ng-anchor-out",
    ya = "ng-anchor-in";
  function va(t) {
    t.drivers.push("$$animateCssDriver"),
      (this.$get = [
        "$animateCss",
        "$$AnimateRunner",
        "$rootElement",
        function (t, e, n) {
          const r = document.body,
            s = n,
            i =
              ((o = s).parentNode && 11 === o.parentNode.nodeType) ||
              r.contains(s)
                ? s
                : r;
          var o;
          return function (n) {
            return n.from && n.to
              ? (function (n, s, o) {
                  const c = a(n),
                    l = a(s),
                    u = [];
                  if (
                    (o.forEach((n) => {
                      const s = (function (n, s) {
                        const o = n.cloneNode(!0),
                          a = ba(p(o));
                        let c;
                        n[0].classList.add($a),
                          s[0].classList.add($a),
                          o.classList.add(ma),
                          i.append(o);
                        const l = d();
                        if (!l && ((c = f()), !c)) return $();
                        const u = l || c;
                        return {
                          start() {
                            let t,
                              n = u.start();
                            return (
                              n.done(() => {
                                if (((n = null), !c && ((c = f()), c)))
                                  return (
                                    (n = c.start()),
                                    n.done(() => {
                                      (n = null), $(), t.complete();
                                    }),
                                    n
                                  );
                                $(), t.complete();
                              }),
                              (t = new e({ end: r, cancel: r })),
                              t
                            );
                            function r() {
                              n && n.end();
                            }
                          },
                        };
                        function h(t) {
                          const e = {},
                            n = t.getBoundingClientRect();
                          return (
                            ["width", "height", "top", "left"].forEach((t) => {
                              let s = n[t];
                              switch (t) {
                                case "top":
                                  s += r.scrollTop;
                                  break;
                                case "left":
                                  s += r.scrollLeft;
                              }
                              e[t] = `${Math.floor(s)}px`;
                            }),
                            e
                          );
                        }
                        function d() {
                          const e = t(o, {
                            addClass: ga,
                            delay: !0,
                            from: h(n),
                          });
                          return e.$$willAnimate ? e : null;
                        }
                        function p(t) {
                          return t.getAttribute("class") || "";
                        }
                        function f() {
                          const e = ba(p(s)),
                            n = wa(e, a),
                            r = wa(a, e),
                            i = t(o, {
                              to: h(s),
                              addClass: `${ya} ${n}`,
                              removeClass: `${ga} ${r}`,
                              delay: !0,
                            });
                          return i.$$willAnimate ? i : null;
                        }
                        function $() {
                          o.remove(),
                            n[0].classList.remove($a),
                            s[0].classList.remove($a);
                        }
                      })(n.out, n.in);
                      s && u.push(s);
                    }),
                    !c && !l && 0 === u.length)
                  )
                    return;
                  return {
                    start() {
                      const t = [];
                      c && t.push(c.start()),
                        l && t.push(l.start()),
                        u.forEach((e) => {
                          t.push(e.start());
                        });
                      const n = new e({ end: r, cancel: r });
                      return (
                        e.all(t, (t) => {
                          n.complete(t);
                        }),
                        n
                      );
                      function r() {
                        t.forEach((t) => {
                          t.end();
                        });
                      }
                    },
                  };
                })(n.from, n.to, n.anchors)
              : a(n);
          };
          function a(e) {
            const n = e.options || {};
            e.structural &&
              ((n.event = e.event),
              (n.structural = !0),
              (n.applyClassesEarly = !0),
              "leave" === e.event && (n.onDone = n.domOperation)),
              n.preparationClasses &&
                (n.event = Vs(n.event, n.preparationClasses));
            const r = t(e.element, n);
            return r.$$willAnimate ? r : null;
          }
        },
      ]);
  }
  function ba(t) {
    return t.replace(/\bng-\S+\b/g, "");
  }
  function wa(t, e) {
    return (
      E(t) && (t = t.split(" ")),
      E(e) && (e = e.split(" ")),
      t.filter((t) => -1 === e.indexOf(t)).join(" ")
    );
  }
  function Ea(t) {
    t.drivers.push("$$animateJsDriver"),
      (this.$get = [
        "$$animateJs",
        "$$AnimateRunner",
        function (t, e) {
          return function (t) {
            if (t.from && t.to) {
              const r = n(t.from),
                s = n(t.to);
              if (!r && !s) return;
              return {
                start() {
                  const t = [];
                  r && t.push(r.start()),
                    s && t.push(s.start()),
                    e.all(t, function (t) {
                      n.complete(t);
                    });
                  const n = new e({ end: i(), cancel: i() });
                  return n;
                  function i() {
                    return function () {
                      t.forEach((t) => {
                        t.end();
                      });
                    };
                  }
                },
              };
            }
            return n(t);
          };
          function n(e) {
            const { element: n, event: r, options: s, classes: i } = e;
            return t(n, r, i, s);
          }
        },
      ]);
  }
  function Ca(t) {
    return {
      restrict: "A",
      transclude: "element",
      terminal: !0,
      priority: 550,
      link(e, n, r, s, i) {
        let o, a;
        e.$watchCollection(r.ngAnimateSwap || r.for, (e) => {
          o && t.leave(o),
            a && (a.$destroy(), (a = null)),
            e &&
              i((e, r) => {
                (o = e), (a = r), t.enter(e, null, n);
              });
        });
      },
    };
  }
  function Oa(t) {
    return {
      link(e, n, r) {
        const s = r.ngAnimateChildren;
        function i(t) {
          Vt(n, hs, (t = "on" === t || "true" === t));
        }
        E(s) && 0 === s.length
          ? Vt(n, hs, !0)
          : (i(t(s)(e)), r.$observe("ngAnimateChildren", i));
      },
    };
  }
  function Aa(t) {
    return function e() {
      if (arguments.length >= t.length) return t.apply(this, arguments);
      const n = Array.prototype.slice.call(arguments);
      return e.bind(this, ...n);
    };
  }
  function Sa() {
    const t = arguments,
      e = t.length - 1;
    return function () {
      let n = e,
        r = t[e].apply(this, arguments);
      for (; n--; ) r = t[n].call(this, r);
      return r;
    };
  }
  function xa() {
    return Sa.apply(null, [].slice.call(arguments).reverse());
  }
  (va.$inject = ["$$animationProvider"]),
    (Ea.$inject = ["$$animationProvider"]),
    (Ca.$inject = ["$animate"]),
    (Oa.$inject = ["$interpolate"]);
  const ka = Aa((t, e, n) => n && n[t] === e),
    _a = (t) =>
      xa.apply(
        null,
        t.split(".").map((t) => (e) => e && e[t]),
      );
  const Ta = (t) => (e) => e.reduce((e, n) => e && !!t(n), !0),
    ja = (t) => (e) => (null != e && e.constructor === t) || e instanceof t,
    Ra = (t) => () => t;
  function La(t) {
    return function (e) {
      for (let n = 0; n < t.length; n++) if (t[n][0](e)) return t[n][1](e);
    };
  }
  function Na(t, e) {
    if (t === e) return !0;
    if (null === t || null === e) return !1;
    if (t != t && e != e) return !0;
    const n = typeof t;
    if (n !== typeof e || "object" !== n) return !1;
    const r = [t, e];
    if (Ta(Array.isArray)(r))
      return (
        (i = e),
        (s = t).length === i.length &&
          Xa(s, i).reduce((t, e) => t && Na(e[0], e[1]), !0)
      );
    var s, i;
    if (Ta(S)(r)) return t.getTime() === e.getTime();
    if (Ta(_)(r)) return t.toString() === e.toString();
    if (Ta(k)(r)) return !0;
    if ([k, Array.isArray, S, _].some((t) => !!t(r))) return !1;
    const o = {};
    for (const n in t) {
      if (!Na(t[n], e[n])) return !1;
      o[n] = !0;
    }
    for (const t in e) if (!o[t]) return !1;
    return !0;
  }
  function Va(t, e, n, r, s = !1) {
    const i = (e) => t()[e].bind(n());
    return (r = r || Object.keys(t())).reduce((t, n) => {
      var r;
      return (
        (t[n] = s
          ? ((r = n),
            function () {
              return (e[r] = i(r)), e[r].apply(null, arguments);
            })
          : i(n)),
        t
      );
    }, e);
  }
  function Pa(t, e) {
    const n = Object.create(t);
    return e && Object.assign(n, e), n;
  }
  const Ma = Aa(function (t, e) {
    const n = t.indexOf(e);
    n >= 0 && t.splice(n, 1);
    return t;
  });
  const Da = Aa((t, e) => (t.push(e), e));
  function Ia(t, ...e) {
    const n = Object.assign({}, ...e.reverse());
    return Object.assign(n, Ua(t || {}, Object.keys(n)));
  }
  function Ua(t, e) {
    const n = {};
    for (const r in t) -1 !== e.indexOf(r) && (n[r] = t[r]);
    return n;
  }
  function Ha(t, e) {
    return Object.keys(t)
      .filter((t) => !e.includes(t))
      .reduce((e, n) => ((e[n] = t[n]), e), {});
  }
  function Fa(t, e) {
    const n = Array.isArray(t),
      r = n ? [] : {},
      s = n ? (t) => r.push(t) : (t, e) => (r[e] = t);
    return (
      Object.entries(t).forEach(([t, n]) => {
        e(n, t) && s(n, t);
      }),
      r
    );
  }
  function qa(t, e) {
    let n;
    return (
      Object.entries(t).forEach(([t, r]) => {
        n || (e(r, t) && (n = r));
      }),
      n
    );
  }
  function Ba(t, e, n) {
    return (
      (n = n || (Array.isArray(t) ? [] : {})),
      Object.entries(t).forEach(([t, r]) => (n[t] = e(r, t))),
      n
    );
  }
  const Ka = (t, e) => t && e,
    za = (t, e) => t || e,
    Wa = (t, e) => t.concat(e),
    Ga = (t, e) => (Array.isArray(e) ? t.concat(e.reduce(Ga, [])) : Qa(t, e));
  function Qa(t, e) {
    return t.push(e), t;
  }
  const Ya = (t, e) => (t.includes(e) ? t : Qa(t, e)),
    Za = (t) => t.reduce(Wa, []),
    Ja = function (t, e = "assert failure") {
      return (n) => {
        const r = t(n);
        if (!r) throw new Error(e);
        return r;
      };
    };
  function Xa(...t) {
    if (0 === t.length) return [];
    const e = t.reduce((t, e) => Math.min(e.length, t), 9007199254740991),
      n = [];
    for (let r = 0; r < e; r++)
      switch (t.length) {
        case 1:
          n.push([t[0][r]]);
          break;
        case 2:
          n.push([t[0][r], t[1][r]]);
          break;
        case 3:
          n.push([t[0][r], t[1][r], t[2][r]]);
          break;
        case 4:
          n.push([t[0][r], t[1][r], t[2][r], t[3][r]]);
          break;
        default:
          n.push(t.map((t) => t[r]));
      }
    return n;
  }
  function tc(t, e) {
    let n, r;
    if ((Array.isArray(e) && ([n, r] = e), !E(n)))
      throw new Error("invalid parameters to applyPairs");
    return (t[n] = r), t;
  }
  function ec(t) {
    return (t.length && t[t.length - 1]) || void 0;
  }
  function nc(t, e) {
    return (
      e && Object.keys(e).forEach((t) => delete e[t]),
      e || (e = {}),
      Object.assign(e, t)
    );
  }
  const rc = (t) => t.catch(() => 0) && t,
    sc = (t) => rc(Promise.reject(t));
  class ic {
    constructor(t) {
      (this.pattern = /.*/),
        (this.inherit = !0),
        Object.assign(this, t),
        (this.name = void 0);
    }
    is(t) {
      return !!t;
    }
    encode(t) {
      return t;
    }
    decode(t) {
      return t;
    }
    equals(t, e) {
      return t == e;
    }
    $subPattern() {
      const t = this.pattern.toString();
      return t.substring(1, t.length - 2);
    }
    toString() {
      return `{ParamType:${this.name}}`;
    }
    $normalize(t) {
      return this.is(t) ? t : this.decode(t);
    }
    $asArray(t, e) {
      if (!t) return this;
      if ("auto" === t && !e)
        throw new Error("'auto' array mode is for query parameters only");
      return new oc(this, t);
    }
  }
  function oc(t, e) {
    function n(t) {
      return Array.isArray(t) ? t : b(t) ? [t] : [];
    }
    function r(t, r) {
      return function (s) {
        if (Array.isArray(s) && 0 === s.length) return s;
        const i = Ba(n(s), t);
        return !0 === r
          ? 0 === Fa(i, (t) => !t).length
          : (function (t) {
              switch (t.length) {
                case 0:
                  return;
                case 1:
                  return "auto" === e ? t[0] : t;
                default:
                  return t;
              }
            })(i);
      };
    }
    function s(t) {
      return function (e, r) {
        const s = n(e),
          i = n(r);
        if (s.length !== i.length) return !1;
        for (let e = 0; e < s.length; e++) if (!t(s[e], i[e])) return !1;
        return !0;
      };
    }
    ["encode", "decode", "equals", "$normalize"].forEach((e) => {
      const n = t[e].bind(t),
        i = "equals" === e ? s : r;
      this[e] = i(n);
    }),
      Object.assign(this, {
        dynamic: t.dynamic,
        name: t.name,
        pattern: t.pattern,
        inherit: t.inherit,
        raw: t.raw,
        is: r(t.is.bind(t), !0),
        $arrayMode: e,
      });
  }
  class ac {
    constructor() {
      (this.enqueue = !0),
        (this.typeQueue = []),
        (this.defaultTypes = Ua(ac.prototype, [
          "hash",
          "string",
          "query",
          "path",
          "int",
          "bool",
          "date",
          "json",
          "any",
        ]));
      this.types = Pa(
        Ba(this.defaultTypes, (t, e) => new ic(Object.assign({ name: e }, t))),
        {},
      );
    }
    type(t, e, n) {
      if (!b(e)) return this.types[t];
      if (Object.prototype.hasOwnProperty.call(this.types, t))
        throw new Error(`A type named '${t}' has already been defined.`);
      return (
        (this.types[t] = new ic(Object.assign({ name: t }, e))),
        n &&
          (this.typeQueue.push({ name: t, def: n }),
          this.enqueue || this._flushTypeQueue()),
        this
      );
    }
    _flushTypeQueue() {
      for (; this.typeQueue.length; ) {
        const t = this.typeQueue.shift();
        if (t.pattern)
          throw new Error("You cannot override a type's .pattern at runtime.");
        Object.assign(
          this.types[t.name],
          window.angular.$injector.invoke(t.def),
        );
      }
    }
  }
  !(function () {
    const t = (t) => {
      const e = (t) => (null != t ? t.toString() : t),
        n = {
          encode: e,
          decode: e,
          is: ja(String),
          pattern: /.*/,
          equals: (t, e) => t == e,
        };
      return Object.assign({}, n, t);
    };
    Object.assign(ac.prototype, {
      string: t({}),
      path: t({ pattern: /[^/]*/ }),
      query: t({}),
      hash: t({ inherit: !1 }),
      int: t({
        decode: (t) => parseInt(t, 10),
        is: function (t) {
          return !O(t) && this.decode(t.toString()) === t;
        },
        pattern: /-?\d+/,
      }),
      bool: t({
        encode: (t) => (t ? 1 : 0),
        decode: (t) => 0 !== parseInt(t, 10),
        is: ja(Boolean),
        pattern: /[01]/,
      }),
      date: t({
        encode: function (t) {
          return this.is(t)
            ? [
                t.getFullYear(),
                ("0" + (t.getMonth() + 1)).slice(-2),
                ("0" + t.getDate()).slice(-2),
              ].join("-")
            : void 0;
        },
        decode: function (t) {
          if (this.is(t)) return t;
          const e = this.capture.exec(t);
          return e ? new Date(e[1], e[2] - 1, e[3]) : void 0;
        },
        is: (t) => t instanceof Date && !isNaN(t.valueOf()),
        equals: (t, e) =>
          ["getFullYear", "getMonth", "getDate"].reduce(
            (n, r) => n && t[r]() === e[r](),
            !0,
          ),
        pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
        capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,
      }),
      json: t({
        encode: JSON.stringify,
        decode: JSON.parse,
        is: ja(Object),
        equals: Na,
        pattern: /[^/]*/,
      }),
      any: t({ encode: (t) => t, decode: (t) => t, is: () => !0, equals: Na }),
    });
  })();
  class cc {
    constructor() {
      (this.paramTypes = new ac()),
        (this._isCaseInsensitive = !1),
        (this._isStrictMode = !0),
        (this._defaultSquashPolicy = !1);
      const t = this.type("path");
      (t.encode = (t) =>
        null != t
          ? t
              .toString()
              .replace(/([~\/])/g, (t) => ({ "~": "~~", "/": "~2F" })[t])
          : t),
        (t.decode = (t) =>
          null != t
            ? t
                .toString()
                .replace(/(~~|~2F)/g, (t) => ({ "~~": "~", "~2F": "/" })[t])
            : t),
        (this.paramTypes.enqueue = !1),
        this.paramTypes._flushTypeQueue();
    }
    $get = [
      function () {
        return this;
      },
    ];
    caseInsensitive(t) {
      return (this._isCaseInsensitive = b(t) ? t : this._isCaseInsensitive);
    }
    defaultSquashPolicy(t) {
      if (b(t) && !0 !== t && !1 !== t && !E(t))
        throw new Error(
          `Invalid squash policy: ${t}. Valid policies: false, true, arbitrary-string`,
        );
      return (this._defaultSquashPolicy = b(t) ? t : this._defaultSquashPolicy);
    }
    strictMode(t) {
      return (this._isStrictMode = b(t) ? t : this._isStrictMode);
    }
    type(t, e, n) {
      const r = this.paramTypes.type(t, e, n);
      return b(e) ? this : r;
    }
  }
  class lc {
    constructor(t = {}) {
      Object.assign(this, t);
    }
    $inherit(t, e, n) {
      const r = (function (t, e) {
          const n = [];
          for (const r in t.path) {
            if (t.path[r] !== e.path[r]) break;
            n.push(t.path[r]);
          }
          return n;
        })(e, n),
        s = {},
        i = [];
      for (const t in r) {
        if (!r[t] || !r[t].params) continue;
        const e = r[t].params,
          n = Object.keys(e);
        if (n.length)
          for (const t in n)
            0 == e[n[t]].inherit ||
              i.indexOf(n[t]) >= 0 ||
              (i.push(n[t]), (s[n[t]] = this[n[t]]));
      }
      return Object.assign({}, s, t);
    }
  }
  class uc {
    constructor(t = [], e = null) {
      (this._items = t),
        (this._limit = e),
        (this._evictListeners = []),
        (this.onEvict = Da(this._evictListeners));
    }
    enqueue(t) {
      const e = this._items;
      return (
        e.push(t), this._limit && e.length > this._limit && this.evict(), t
      );
    }
    evict() {
      const t = this._items.shift();
      return this._evictListeners.forEach((e) => e(t)), t;
    }
    dequeue() {
      if (this.size()) return this._items.splice(0, 1)[0];
    }
    clear() {
      const t = this._items;
      return (this._items = []), t;
    }
    size() {
      return this._items.length;
    }
    remove(t) {
      const e = this._items.indexOf(t);
      return e > -1 && this._items.splice(e, 1)[0];
    }
    peekTail() {
      return this._items[this._items.length - 1];
    }
    peekHead() {
      if (this.size()) return this._items[0];
    }
  }
  class hc {
    constructor() {
      (this.params = new lc()),
        (this.lastStartedTransitionId = -1),
        (this.transitionHistory = new uc([], 1)),
        (this.successfulTransitions = new uc([], 1));
    }
    $get = [() => this];
  }
  function dc(t) {
    if (Array.isArray(t) && t.length) {
      const e = t.slice(0, -1),
        n = t.slice(-1);
      return !(e.filter((t) => !E(t)).length || n.filter((t) => !k(t)).length);
    }
    return k(t);
  }
  function pc(t) {
    return null !== t && "object" == typeof t && "function" == typeof t.then;
  }
  function fc(t, e) {
    return e.length <= t ? e : e.substring(0, t - 3) + "...";
  }
  function $c(t) {
    return t
      .replace(/^([A-Z])/, (t) => t.toLowerCase())
      .replace(/([A-Z])/g, (t) => "-" + t.toLowerCase());
  }
  function mc(t) {
    const e = gc(t),
      n = e.match(/^(function [^ ]+\([^)]*\))/),
      r = n ? n[1] : e,
      s = t.name || "";
    return s && r.match(/function \(/) ? "function " + s + r.substring(9) : r;
  }
  function gc(t) {
    const e = Array.isArray(t) ? t.slice(-1)[0] : t;
    return (e && e.toString()) || "undefined";
  }
  function yc(t) {
    const e = [],
      n = La([
        [v, Ra("undefined")],
        [C, Ra("null")],
        [pc, Ra("[Promise]")],
        [
          (t) =>
            t &&
            "function" == typeof t.then &&
            "Rejection" == t.constructor.name,
          (t) => t._transitionRejection.toString(),
        ],
        [
          (t) =>
            w(t) &&
            !Array.isArray(t) &&
            t.constructor !== Object &&
            k(t.toString),
          (t) => t.toString(),
        ],
        [dc, mc],
        [Ra(!0), (t) => t],
      ]);
    function r(t) {
      if (w(t)) {
        if (-1 !== e.indexOf(t)) return "[circular ref]";
        e.push(t);
      }
      return n(t);
    }
    return v(t) ? r(t) : JSON.stringify(t, (t, e) => r(e)).replace(/\\"/g, '"');
  }
  function vc(t, e) {
    return E(ec(t)) && E(e) ? t.slice(0, -1).concat(ec(t) + e) : Qa(t, e);
  }
  function bc(t) {
    if (!t) return "ng-view (defunct)";
    const e = t.creationContext ? t.creationContext.name || "(root)" : "(none)";
    return `[ng-view#${t.id}:${t.fqn} (${t.name}@${e})]`;
  }
  function wc(t) {
    return A(t) ? Ec[t] : Ec[Ec[t]];
  }
  var Ec;
  !(function (t) {
    (t[(t.RESOLVE = 0)] = "RESOLVE"),
      (t[(t.TRANSITION = 1)] = "TRANSITION"),
      (t[(t.HOOK = 2)] = "HOOK"),
      (t[(t.UIVIEW = 3)] = "UIVIEW"),
      (t[(t.VIEWCONFIG = 4)] = "VIEWCONFIG");
  })(Ec || (Ec = {}));
  const Cc = _a("$id"),
    Oc = _a("router.$id"),
    Ac = (t) => `Transition #${Cc(t)}-${Oc(t)}`;
  const Sc = new (class {
    constructor() {
      (this._enabled = {}), (this.approximateDigests = 0);
    }
    _set(t, e) {
      e.length ||
        (e = Object.keys(Ec)
          .map((t) => parseInt(t, 10))
          .filter((t) => !isNaN(t))
          .map((t) => Ec[t])),
        e.map(wc).forEach((e) => (this._enabled[e] = t));
    }
    enable(...t) {
      this._set(!0, t);
    }
    disable(...t) {
      this._set(!1, t);
    }
    enabled(t) {
      return !!this._enabled[wc(t)];
    }
    traceTransitionStart(t) {
      this.enabled(Ec.TRANSITION) &&
        console.log(`${Ac(t)}: Started  -> ${yc(t)}`);
    }
    traceTransitionIgnored(t) {
      this.enabled(Ec.TRANSITION) &&
        console.log(`${Ac(t)}: Ignored  <> ${yc(t)}`);
    }
    traceHookInvocation(t, e, n) {
      if (!this.enabled(Ec.HOOK)) return;
      const r = _a("traceData.hookType")(n) || "internal",
        s =
          _a("traceData.context.state.name")(n) ||
          _a("traceData.context")(n) ||
          "unknown",
        i = mc(t.registeredHook.callback);
      console.log(`${Ac(e)}:   Hook -> ${r} context: ${s}, ${fc(200, i)}`);
    }
    traceHookResult(t, e) {
      this.enabled(Ec.HOOK) &&
        console.log(`${Ac(e)}:   <- Hook returned: ${fc(200, yc(t))}`);
    }
    traceResolvePath(t, e, n) {
      this.enabled(Ec.RESOLVE) &&
        console.log(`${Ac(n)}:         Resolving ${t} (${e})`);
    }
    traceResolvableResolved(t, e) {
      this.enabled(Ec.RESOLVE) &&
        console.log(
          `${Ac(e)}:               <- Resolved  ${t} to: ${fc(200, yc(t.data))}`,
        );
    }
    traceError(t, e) {
      this.enabled(Ec.TRANSITION) &&
        console.log(`${Ac(e)}: <- Rejected ${yc(e)}, reason: ${t}`);
    }
    traceSuccess(t, e) {
      this.enabled(Ec.TRANSITION) &&
        console.log(`${Ac(e)}: <- Success  ${yc(e)}, final state: ${t.name}`);
    }
    traceUIViewEvent(t, e, n = "") {
      this.enabled(Ec.UIVIEW) &&
        console.log(
          `ng-view: ${(function (t, e) {
            for (; e.length < t; ) e += " ";
            return e;
          })(30, t)} ${bc(e)}${n}`,
        );
    }
    traceUIViewConfigUpdated(t, e) {
      this.enabled(Ec.UIVIEW) &&
        this.traceUIViewEvent(
          "Updating",
          t,
          ` with ViewConfig from context='${e}'`,
        );
    }
    traceUIViewFill(t, e) {
      this.enabled(Ec.UIVIEW) &&
        this.traceUIViewEvent("Fill", t, ` with: ${fc(200, e)}`);
    }
    traceViewSync(t) {
      if (!this.enabled(Ec.VIEWCONFIG)) return;
      const e = "uiview component fqn",
        n = "view config state (view name)",
        r = t
          .map(({ ngView: t, viewConfig: r }) => {
            const s = t && t.fqn,
              i = r && `${r.viewDecl.$context.name}: (${r.viewDecl.$name})`;
            return { [e]: s, [n]: i };
          })
          .sort((t, n) => (t[e] || "").localeCompare(n[e] || ""));
      console.table(r);
    }
    traceViewServiceEvent(t, e) {
      this.enabled(Ec.VIEWCONFIG) &&
        console.log(
          `VIEWCONFIG: ${t} ${((t) => {
            const e = t.viewDecl,
              n = e.$context.name || "(root)";
            return `[View#${t.$id} from '${n}' state]: target ng-view: '${e.$ngViewName}@${e.$ngViewContextAnchor}'`;
          })(e)}`,
        );
    }
    traceViewServiceUIViewEvent(t, e) {
      this.enabled(Ec.VIEWCONFIG) && console.log(`VIEWCONFIG: ${t} ${bc(e)}`);
    }
  })();
  let xc = "LAZY",
    kc = "WAIT";
  class _c {
    constructor(t, e, n, r, s) {
      (this.resolved = !1),
        (this.promise = void 0),
        t instanceof _c
          ? Object.assign(this, t)
          : k(e)
            ? (at(!O(t), "token argument is required"),
              (this.token = t),
              (this.policy = r),
              (this.resolveFn = e),
              (this.deps = n || []),
              (this.data = s),
              (this.resolved = void 0 !== s),
              (this.promise = this.resolved
                ? Promise.resolve(this.data)
                : void 0))
            : w(t) &&
              t.token &&
              (Object.prototype.hasOwnProperty.call(t, "resolveFn") ||
                Object.prototype.hasOwnProperty.call(t, "data")) &&
              ((this.token = t.token),
              (this.resolveFn = t.resolveFn),
              (this.deps = t.deps),
              (this.policy = t.policy),
              (this.data = t.data));
    }
    getPolicy(t) {
      const e = this.policy || {},
        n = (t && t.resolvePolicy) || {};
      return { when: e.when || n.when || xc, async: e.async || n.async || kc };
    }
    resolve(t, e) {
      const n = t.findNode(this),
        r = n && n.state,
        s = this.getPolicy(r).async,
        i = k(s) ? s : (t) => t;
      return (
        (this.promise = Promise.resolve()
          .then(() =>
            Promise.all(t.getDependencies(this).map((n) => n.get(t, e))),
          )
          .then((t) => this.resolveFn.apply(null, t))
          .then(i)
          .then(
            (t) => (
              (this.data = t),
              (this.resolved = !0),
              (this.resolveFn = null),
              Sc.traceResolvableResolved(this, e),
              this.data
            ),
          )),
        this.promise
      );
    }
    get(t, e) {
      return this.promise || this.resolve(t, e);
    }
    toString() {
      return `Resolvable(token: ${yc(this.token)}, requires: [${this.deps.map(yc)}])`;
    }
    clone() {
      return new _c(this);
    }
  }
  _c.fromData = (t, e) => new _c(t, () => e, null, null, e);
  class Tc {
    constructor(t, e, n, r) {
      (this._stateRegistry = t),
        (this._identifier = e),
        (this._identifier = e),
        (this._params = Object.assign({}, n || {})),
        (this._options = Object.assign({}, r || {})),
        (this._definition = t.matcher.find(e, this._options.relative));
    }
    name() {
      return (this._definition && this._definition.name) || this._identifier;
    }
    identifier() {
      return this._identifier;
    }
    params() {
      return this._params;
    }
    $state() {
      return this._definition;
    }
    state() {
      return this._definition && this._definition.self;
    }
    options() {
      return this._options;
    }
    exists() {
      return !(!this._definition || !this._definition.self);
    }
    valid() {
      return !this.error();
    }
    error() {
      const t = this.options().relative;
      if (!this._definition && t) {
        const e = t.name ? t.name : t;
        return `Could not resolve '${this.name()}' from state '${e}'`;
      }
      return this._definition
        ? this._definition.self
          ? void 0
          : `State '${this.name()}' has an invalid definition`
        : `No such state '${this.name()}'`;
    }
    toString() {
      return `'${this.name()}'${yc(this.params())}`;
    }
    withState(t) {
      return new Tc(this._stateRegistry, t, this._params, this._options);
    }
    withParams(t, e = !1) {
      const n = e ? t : Object.assign({}, this._params, t);
      return new Tc(this._stateRegistry, this._identifier, n, this._options);
    }
    withOptions(t, e = !1) {
      const n = e ? t : Object.assign({}, this._options, t);
      return new Tc(this._stateRegistry, this._identifier, this._params, n);
    }
  }
  Tc.isDef = (t) =>
    t && t.state && (E(t.state) || (w(t.state) && E(t.state.name)));
  var jc;
  function Rc(t, e, n) {
    const r = (!1 === n.reloadOnSearch && e === jc.SEARCH) || void 0,
      s = qa([n.dynamic, r], b),
      i = b(s) ? { dynamic: s } : {},
      o = (function (t) {
        function e() {
          return t.value;
        }
        (t = ((t) =>
          0 ===
          ["value", "type", "squash", "array", "dynamic"].filter(
            Object.prototype.hasOwnProperty.bind(t || {}),
          ).length)(t)
          ? { value: t }
          : t),
          (e.__cacheable = !0);
        const n = dc(t.value) ? t.value : e;
        return Object.assign(t, { $$fn: n });
      })(n && n.params && n.params[t]);
    return Object.assign(i, o);
  }
  !(function (t) {
    (t[(t.PATH = 0)] = "PATH"),
      (t[(t.SEARCH = 1)] = "SEARCH"),
      (t[(t.CONFIG = 2)] = "CONFIG");
  })(jc || (jc = {}));
  class Lc {
    constructor(t, e, n, r, s) {
      const i = Rc(t, n, s);
      e = (function (t, e, n, r, s) {
        if (t.type && e && "string" !== e.name)
          throw new Error(`Param '${r}' has two type configurations.`);
        if (t.type && e && "string" === e.name && s.type(t.type))
          return s.type(t.type);
        if (e) return e;
        if (!t.type) {
          const t =
            n === jc.CONFIG
              ? "any"
              : n === jc.PATH
                ? "path"
                : n === jc.SEARCH
                  ? "query"
                  : "string";
          return s.type(t);
        }
        return t.type instanceof ic ? t.type : s.type(t.type);
      })(i, e, n, t, r.paramTypes);
      const o = (function () {
        const e = { array: n === jc.SEARCH && "auto" },
          r = t.match(/\[\]$/) ? { array: !0 } : {};
        return Object.assign(e, r, i).array;
      })();
      e = o ? e.$asArray(o, n === jc.SEARCH) : e;
      const a = void 0 !== i.value || n === jc.SEARCH,
        c = b(i.dynamic) ? !!i.dynamic : !!e.dynamic,
        l = b(i.raw) ? !!i.raw : !!e.raw,
        u = (function (t, e, n) {
          const r = t.squash;
          if (!e || !1 === r) return !1;
          if (!b(r) || null == r) return n;
          if (!0 === r || E(r)) return r;
          throw new Error(
            `Invalid squash policy: '${r}'. Valid policies: false, true, or arbitrary string`,
          );
        })(i, a, r.defaultSquashPolicy()),
        h = (function (t, e, n, r) {
          const s = [
              { from: "", to: n || e ? void 0 : "" },
              { from: null, to: n || e ? void 0 : "" },
            ],
            i = Array.isArray(t.replace) ? t.replace : [];
          E(r) && i.push({ from: r, to: void 0 });
          const o = Ba(i, (t) => t.from);
          return Fa(s, (t) => -1 === o.indexOf(t.from)).concat(i);
        })(i, o, a, u),
        d = b(i.inherit) ? !!i.inherit : !!e.inherit;
      (this.isOptional = a),
        (this.type = e),
        (this.location = n),
        (this.id = t),
        (this.dynamic = c),
        (this.raw = l),
        (this.squash = u),
        (this.replace = h),
        (this.inherit = d),
        (this.array = o),
        (this.config = i);
    }
    isDefaultValue(t) {
      return this.isOptional && this.type.equals(this.value(), t);
    }
    value(t) {
      return (
        (t = ((t) => {
          for (const e of this.replace) if (e.from === t) return e.to;
          return t;
        })(t)),
        v(t)
          ? (() => {
              if (this._defaultValueCache)
                return this._defaultValueCache.defaultValue;
              if (!window.angular.$injector)
                throw new Error(
                  "Injectable functions cannot be called at configuration time",
                );
              const t = window.angular.$injector.invoke(this.config.$$fn);
              if (null != t && !this.type.is(t))
                throw new Error(
                  `Default value (${t}) for parameter '${this.id}' is not an instance of ParamType (${this.type.name})`,
                );
              return (
                this.config.$$fn.__cacheable &&
                  (this._defaultValueCache = { defaultValue: t }),
                t
              );
            })()
          : this.type.$normalize(t)
      );
    }
    isSearch() {
      return this.location === jc.SEARCH;
    }
    validates(t) {
      if ((v(t) || null === t) && this.isOptional) return !0;
      const e = this.type.$normalize(t);
      if (!this.type.is(e)) return !1;
      const n = this.type.encode(e);
      return !(E(n) && !this.type.pattern.exec(n));
    }
    toString() {
      return `{Param:${this.id} ${this.type} squash: '${this.squash}' optional: ${this.isOptional}}`;
    }
    static values(t, e = {}) {
      const n = {};
      for (const r of t) n[r.id] = r.value(e[r.id]);
      return n;
    }
    static changed(t, e = {}, n = {}) {
      return t.filter((t) => !t.type.equals(e[t.id], n[t.id]));
    }
    static equals(t, e = {}, n = {}) {
      return 0 === Lc.changed(t, e, n).length;
    }
    static validates(t, e = {}) {
      return t.map((t) => t.validates(e[t.id])).reduce(Ka, !0);
    }
  }
  class Nc {
    constructor(t) {
      if (t instanceof Nc) {
        const e = t;
        (this.state = e.state),
          (this.paramSchema = e.paramSchema.slice()),
          (this.paramValues = Object.assign({}, e.paramValues)),
          (this.resolvables = e.resolvables.slice()),
          (this.views = e.views && e.views.slice());
      } else {
        const e = t;
        (this.state = e),
          (this.paramSchema = e.parameters({ inherit: !1 })),
          (this.paramValues = {}),
          (this.resolvables = e.resolvables.map((t) => t.clone()));
      }
    }
    clone() {
      return new Nc(this);
    }
    applyRawParams(t) {
      return (
        (this.paramValues = this.paramSchema.reduce((e, n) => {
          return tc(e, [(r = n).id, r.value(t[r.id])]);
          var r;
        }, {})),
        this
      );
    }
    parameter(t) {
      return qa(this.paramSchema, ka("id", t));
    }
    equals(t, e) {
      const n = this.diff(t, e);
      return n && 0 === n.length;
    }
    diff(t, e) {
      if (this.state !== t.state) return !1;
      const n = e ? e(this) : this.paramSchema;
      return Lc.changed(n, this.paramValues, t.paramValues);
    }
  }
  class Vc {
    static buildPath(t) {
      const e = t.params();
      return t.$state().path.map((t) => new Nc(t).applyRawParams(e));
    }
    static buildToPath(t, e) {
      const n = Vc.buildPath(e);
      return e.options().inherit
        ? Vc.inheritParams(t, n, Object.keys(e.params()))
        : n;
    }
    static applyViewConfigs(t, e, n) {
      e.filter((t) => n.includes(t.state)).forEach((n) => {
        const r = Object.values(n.state.views || {}),
          s = Vc.subPath(e, (t) => t === n),
          i = r.map((e) => t.createViewConfig(s, e));
        n.views = i.reduce(Wa, []);
      });
    }
    static inheritParams(t, e, n = []) {
      const r = t
        .map((t) => t.paramSchema)
        .reduce(Wa, [])
        .filter((t) => !t.inherit)
        .map((t) => t.id);
      return e.map(function (e) {
        let s = Object.assign({}, e && e.paramValues);
        const i = Ua(s, n);
        s = Ha(s, n);
        const o = Ha(
            (function (t, e) {
              const n = qa(t, ka("state", e));
              return Object.assign({}, n && n.paramValues);
            })(t, e.state) || {},
            r,
          ),
          a = Object.assign(s, o, i);
        return new Nc(e.state).applyRawParams(a);
      });
    }
    static treeChanges(t, e, n) {
      const r = Math.min(t.length, e.length);
      let s = 0;
      for (
        ;
        s < r &&
        t[s].state !== n &&
        ((i = t[s]), (o = e[s]), i.equals(o, Vc.nonDynamicParams));

      )
        s++;
      var i, o;
      let a, c, l, u, h;
      (a = t), (c = a.slice(0, s)), (l = a.slice(s));
      const d = c.map(function (t, n) {
        const r = t.clone();
        return (r.paramValues = e[n].paramValues), r;
      });
      return (
        (u = e.slice(s)),
        (h = d.concat(u)),
        {
          from: a,
          to: h,
          retained: c,
          retainedWithToParams: d,
          exiting: l,
          entering: u,
        }
      );
    }
    static matching(t, e, n) {
      let r = !1;
      return Xa(t, e).reduce(
        (t, [e, s]) => ((r = r || !e.equals(s, n)), r ? t : t.concat(e)),
        [],
      );
    }
    static equals(t, e, n) {
      return t.length === e.length && Vc.matching(t, e, n).length === t.length;
    }
    static subPath(t, e) {
      const n = qa(t, e),
        r = t.indexOf(n);
      return -1 === r ? void 0 : t.slice(0, r + 1);
    }
    static nonDynamicParams(t) {
      return t.state.parameters({ inherit: !1 }).filter((t) => !t.dynamic);
    }
    static paramValues(t) {
      return t.reduce((t, e) => Object.assign(t, e.paramValues), {});
    }
  }
  function Pc(t, e) {
    return new Tc(
      t,
      e.at(-1).state,
      e.map((t) => t.paramValues).reduce((t, e) => ({ ...t, ...e }), {}),
      {},
    );
  }
  const Mc = { LAZY: "LAZY", EAGER: "EAGER" },
    Dc = [Mc.EAGER, Mc.LAZY],
    Ic = [Mc.EAGER];
  class Uc {
    constructor(t) {
      this._path = t;
    }
    getTokens() {
      return this._path
        .reduce((t, e) => t.concat(e.resolvables.map((t) => t.token)), [])
        .reduce(Ya, []);
    }
    getResolvable(t) {
      return ec(
        this._path
          .map((t) => t.resolvables)
          .reduce(Wa, [])
          .filter((e) => e.token === t),
      );
    }
    getPolicy(t) {
      const e = this.findNode(t);
      return t.getPolicy(e);
    }
    subContext(t) {
      return new Uc(Vc.subPath(this._path, (e) => e.state === t));
    }
    addResolvables(t, e) {
      const n = qa(this._path, ka("state", e)),
        r = t.map((t) => t.token);
      n.resolvables = n.resolvables
        .filter((t) => -1 === r.indexOf(t.token))
        .concat(t);
    }
    resolvePath(t = "LAZY", e) {
      const n = (Dc.includes(t) ? t : "LAZY") === Mc.EAGER ? Ic : Dc;
      Sc.traceResolvePath(this._path, t, e);
      const r = (t, e) => (n) => t.includes(this.getPolicy(n)[e]),
        s = this._path.reduce((t, s) => {
          const i = s.resolvables.filter(r(n, "when")),
            o = i.filter(r(["NOWAIT"], "async")),
            a = i.filter((t) => !r(["NOWAIT"], "async")(t)),
            c = this.subContext(s.state),
            l = (t) => t.get(c, e).then((e) => ({ token: t.token, value: e }));
          return o.forEach(l), t.concat(a.map(l));
        }, []);
      return Promise.all(s);
    }
    injector() {
      return this._injector || (this._injector = new Hc());
    }
    findNode(t) {
      return qa(this._path, (e) => e.resolvables.includes(t));
    }
    getDependencies(t) {
      const e = this.findNode(t),
        n = (Vc.subPath(this._path, (t) => t === e) || this._path)
          .reduce((t, e) => t.concat(e.resolvables), [])
          .filter((e) => e !== t);
      return t.deps.map((t) => {
        const e = n.filter((e) => e.token === t);
        if (e.length) return ec(e);
        const r = window.angular.$injector.get(t);
        if (v(r))
          throw new Error(
            "Could not find Dependency Injection token: " + yc(t),
          );
        return new _c(t, () => r, [], r);
      });
    }
  }
  class Hc {
    constructor() {
      this.native = window.angular.$injector;
    }
    get(t) {
      return window.angular.$injector.get(t);
    }
    getAsync(t) {
      return Promise.resolve(window.angular.$injector.get(t));
    }
    getNative(t) {
      return window.angular.$injector.get(t);
    }
  }
  const Fc = (t, e) => t.reduce((t, n) => t || b(e[n]), !1);
  function qc(t) {
    if (!t.parent) return {};
    const e = ["component", "bindings", "componentProvider"],
      n = [
        "templateProvider",
        "templateUrl",
        "template",
        "notify",
        "async",
      ].concat([
        "controller",
        "controllerProvider",
        "controllerAs",
        "resolveAs",
      ]),
      r = e.concat(n);
    if (b(t.views) && Fc(r, t))
      throw new Error(
        `State '${t.name}' has a 'views' object. It cannot also have "view properties" at the state level.  Move the following properties into a view (in the 'views' object):  ${r.filter((e) => b(t[e])).join(", ")}`,
      );
    const s = {},
      i = t.views || { $default: Ua(t, r) };
    return (
      Object.entries(i).forEach(([r, i]) => {
        if (
          ((r = r || "$default"),
          E(i) && (i = { component: i }),
          (i = Object.assign({}, i)),
          Fc(e, i) && Fc(n, i))
        )
          throw new Error(
            `Cannot combine: ${e.join("|")} with: ${n.join("|")} in stateview: '${r}@${t.name}'`,
          );
        (i.resolveAs = i.resolveAs || "$resolve"),
          (i.$context = t),
          (i.$name = r);
        const o = Kc.normalizeUIViewTarget(i.$context, i.$name);
        (i.$ngViewName = o.ngViewName),
          (i.$ngViewContextAnchor = o.ngViewContextAnchor),
          (s[r] = i);
      }),
      s
    );
  }
  let Bc = 0;
  class Kc {
    constructor(t, e, n) {
      (this.path = t),
        (this.viewDecl = e),
        (this.factory = n),
        (this.component = void 0),
        (this.template = void 0),
        (this.$id = Bc++),
        (this.loaded = !1),
        (this.getTemplate = (t, e) =>
          this.component
            ? this.factory.makeComponentTemplate(
                t,
                e,
                this.component,
                this.viewDecl.bindings,
              )
            : this.template);
    }
    load() {
      const t = new Uc(this.path),
        e = this.path.reduce((t, e) => Object.assign(t, e.paramValues), {}),
        n = [
          Promise.resolve(this.factory.fromConfig(this.viewDecl, e, t)),
          Promise.resolve(this.getController(t)),
        ];
      return Promise.all(n).then(
        (t) => (
          Sc.traceViewServiceEvent("Loaded", this),
          (this.controller = t[1]),
          Object.assign(this, t[0]),
          this
        ),
      );
    }
    getController(t) {
      const e = this.viewDecl.controllerProvider;
      if (!dc(e)) return this.viewDecl.controller;
      const n = Ce(e),
        r = Array.isArray(e) ? ec(e) : e;
      return new _c("", r, n).get(t);
    }
    static normalizeUIViewTarget(t, e = "") {
      const n = e.split("@");
      let r = n[0] || "$default",
        s = E(n[1]) ? n[1] : "^";
      const i = /^(\^(?:\.\^)*)\.(.*$)/.exec(r);
      i && ((s = i[1]), (r = i[2])),
        "!" === r.charAt(0) && ((r = r.substring(1)), (s = ""));
      if (/^(\^(?:\.\^)*)$/.exec(s)) {
        const e = s.split(".").reduce((t) => t.parent, t);
        s = e.name;
      } else "." === s && (s = t.name);
      return { ngViewName: r, ngViewContextAnchor: s };
    }
  }
  class zc {
    constructor() {
      (this._ngViews = []),
        (this._viewConfigs = []),
        (this._viewConfigFactories = {}),
        (this._listeners = []),
        (this._pluginapi = {
          _rootViewContext: this._rootViewContext.bind(this),
          _viewConfigFactory: this._viewConfigFactory.bind(this),
          _registeredUIView: (t) => qa(this._ngViews, (e) => e.id === t),
          _registeredUIViews: () => this._ngViews,
          _activeViewConfigs: () => this._viewConfigs,
          _onSync: (t) => (
            this._listeners.push(t), () => Ma(this._listeners, t)
          ),
        }),
        this._pluginapi._viewConfigFactory(
          (function () {
            let t = null;
            return (e, n) => (
              (t = t || window.angular.$injector.get("$templateFactory")),
              [new Kc(e, n, t)]
            );
          })(),
        );
    }
    $get = [() => this];
    _rootViewContext(t) {
      return (this._rootContext = t || this._rootContext);
    }
    _viewConfigFactory(t) {
      this._viewConfigFactory = t;
    }
    createViewConfig(t, e) {
      const n = this._viewConfigFactory;
      if (!n)
        throw new Error(
          "ViewService: No view config factory registered for type " + e.$type,
        );
      const r = n(t, e);
      return Array.isArray(r) ? r : [r];
    }
    deactivateViewConfig(t) {
      Sc.traceViewServiceEvent("<- Removing", t), Ma(this._viewConfigs, t);
    }
    activateViewConfig(t) {
      Sc.traceViewServiceEvent("-> Registering", t), this._viewConfigs.push(t);
    }
    sync() {
      const t = this._ngViews.map((t) => [t.fqn, t]).reduce(tc, {});
      function e(t) {
        let e = t.viewDecl.$context,
          n = 0;
        for (; ++n && e.parent; ) e = e.parent;
        return n;
      }
      const n = Aa((t, e, n, r) => e * (t(n) - t(r))),
        r = (t) => {
          -1 !== this._ngViews.indexOf(t.ngView) &&
            t.ngView.configUpdated(t.viewConfig);
        },
        s = this._ngViews
          .sort(
            n(function (t) {
              const e = (t) => (t && t.parent ? e(t.parent) + 1 : 1);
              return 1e4 * t.fqn.split(".").length + e(t.creationContext);
            }, 1),
          )
          .map((r) => {
            const s = this._viewConfigs.filter(zc.matches(t, r));
            return (
              s.length > 1 && s.sort(n(e, -1)), { ngView: r, viewConfig: s[0] }
            );
          }),
        i = s.map((t) => t.viewConfig),
        o = this._viewConfigs
          .filter((t) => !i.includes(t))
          .map((t) => ({ ngView: void 0, viewConfig: t }));
      s.forEach((t) => {
        r(t);
      });
      const a = s.concat(o);
      this._listeners.forEach((t) => t(a)), Sc.traceViewSync(a);
    }
    registerUIView(t) {
      Sc.traceViewServiceUIViewEvent("-> Registering", t);
      const e = this._ngViews;
      return (
        e.filter((e) => e.fqn === t.fqn).length &&
          Sc.traceViewServiceUIViewEvent("!!!! duplicate ngView named:", t),
        e.push(t),
        this.sync(),
        () => {
          -1 !== e.indexOf(t)
            ? (Sc.traceViewServiceUIViewEvent("<- Deregistering", t), Ma(e)(t))
            : Sc.traceViewServiceUIViewEvent(
                "Tried removing non-registered ngView",
                t,
              );
        }
      );
    }
    available() {
      return this._ngViews.map((t) => t.fqn);
    }
    active() {
      return this._ngViews.filter((t) => t.$config).map((t) => t.name);
    }
  }
  zc.matches = (t, e) => (n) => {
    if (e.$type !== n.viewDecl.$type) return !1;
    const r = n.viewDecl,
      s = r.$ngViewName.split("."),
      i = e.fqn.split(".");
    if (!Na(s, i.slice(0 - s.length))) return !1;
    const o = 1 - s.length || void 0,
      a = i.slice(0, o).join("."),
      c = t[a].creationContext;
    return r.$ngViewContextAnchor === (c && c.name);
  };
  const Wc = { CREATE: 0, BEFORE: 1, RUN: 2, SUCCESS: 3, ERROR: 4 },
    Gc = { TRANSITION: 0, STATE: 1 },
    Qc = 2,
    Yc = 3,
    Zc = 4,
    Jc = 5,
    Xc = 6;
  let tl = 0;
  class el {
    static superseded(t, e) {
      const n = new el(
        Qc,
        "The transition has been superseded by a different transition",
        t,
      );
      return e && e.redirected && (n.redirected = !0), n;
    }
    static redirected(t) {
      return el.superseded(t, { redirected: !0 });
    }
    static invalid(t) {
      return new el(Zc, "This transition is invalid", t);
    }
    static ignored(t) {
      return new el(Jc, "The transition was ignored", t);
    }
    static aborted(t) {
      return new el(Yc, "The transition has been aborted", t);
    }
    static errored(t) {
      return new el(Xc, "The transition errored", t);
    }
    static normalize(t) {
      return ja(el)(t) ? t : el.errored(t);
    }
    constructor(t, e, n) {
      (this.$id = tl++),
        (this.type = t),
        (this.message = e),
        (this.detail = n),
        (this.redirected = !1);
    }
    toString() {
      const t =
        (e = this.detail) && e.toString !== Object.prototype.toString
          ? e.toString()
          : yc(e);
      var e;
      const { $id: n, type: r, message: s } = this;
      return `Transition Rejection($id: ${n} type: ${r}, message: ${s}, detail: ${t})`;
    }
    toPromise() {
      return Object.assign(sc(this), { _transitionRejection: this });
    }
  }
  class nl {
    constructor(t = !1) {
      (this.disposed = !1),
        (this.key = 1),
        (this.pendingKeys = []),
        (this.publishDepth = 0),
        (this.subscriptions = []),
        (this.topics = {}),
        (this.async_ = Boolean(t));
    }
    subscribe(t, e, n = null) {
      let r = this.topics[t];
      r || (r = this.topics[t] = []);
      const s = this.key;
      return (
        (this.subscriptions[s] = t),
        (this.subscriptions[s + 1] = e),
        (this.subscriptions[s + 2] = n),
        (this.key = s + 3),
        r.push(s),
        s
      );
    }
    subscribeOnce(t, e, n = null) {
      let r = !1;
      const s = this.subscribe(
        t,
        (...t) => {
          r || ((r = !0), this.unsubscribeByKey(s), e.apply(n, t));
        },
        this,
      );
      return s;
    }
    static runAsync_(t, e, n) {
      setTimeout(() => {
        t.apply(e, n);
      }, 0);
    }
    unsubscribe(t, e, n = null) {
      const r = this.topics[t];
      if (r) {
        const t = this.subscriptions,
          s = r.find((r) => t[r + 1] === e && t[r + 2] === n);
        if (void 0 !== s) return this.unsubscribeByKey(s);
      }
      return !1;
    }
    unsubscribeByKey(t) {
      const e = this.subscriptions[t];
      if (e) {
        let n = this.topics[e];
        0 !== this.publishDepth
          ? (this.pendingKeys.push(t), (this.subscriptions[t + 1] = () => {}))
          : (n && (this.topics[e] = n.filter((e) => e !== t)),
            delete this.subscriptions[t],
            delete this.subscriptions[t + 1],
            delete this.subscriptions[t + 2]);
      }
      return !!e;
    }
    publish(t, ...e) {
      const n = this.topics[t];
      if (n) {
        const t = e;
        if (this.async_)
          for (let e = 0; e < n.length; e++) {
            const r = n[e];
            nl.runAsync_(
              this.subscriptions[r + 1],
              this.subscriptions[r + 2],
              t,
            );
          }
        else {
          this.publishDepth++;
          try {
            for (let e = 0, r = n.length; e < r && !this.isDisposed(); e++) {
              const r = n[e];
              this.subscriptions[r + 1].apply(this.subscriptions[r + 2], t);
            }
          } finally {
            if (
              (this.publishDepth--,
              this.pendingKeys.length > 0 && 0 === this.publishDepth)
            ) {
              let t;
              for (; (t = this.pendingKeys.pop()); ) this.unsubscribeByKey(t);
            }
          }
        }
        return !0;
      }
      return !1;
    }
    clear(t) {
      if (t) {
        const e = this.topics[t];
        e && (e.forEach(this.unsubscribeByKey, this), delete this.topics[t]);
      } else (this.subscriptions.length = 0), (this.topics = {});
    }
    getCount(t) {
      if (t) {
        const e = this.topics[t];
        return e ? e.length : 0;
      }
      let e = 0;
      for (const t in this.topics) e += this.getCount(t);
      return e;
    }
    isDisposed() {
      return this.disposed;
    }
    dispose() {
      this.clear(), (this.pendingKeys.length = 0), (this.disposed = !0);
    }
  }
  const rl = new nl(!0),
    sl = { current: () => {}, transition: null, traceData: {}, bind: null };
  class il {
    static chain(t, e) {
      return t.reduce(
        (t, e) => t.then(() => e.invokeHook()),
        e || Promise.resolve(),
      );
    }
    static invokeHooks(t, e) {
      for (let n = 0; n < t.length; n++) {
        const r = t[n].invokeHook();
        if (pc(r)) {
          const s = t.slice(n + 1);
          return il.chain(s, r).then(() => {
            e();
          });
        }
      }
      return e();
    }
    static runAllHooks(t) {
      t.forEach((t) => t.invokeHook());
    }
    constructor(t, e, n, r) {
      (this.transition = t),
        (this.stateContext = e),
        (this.registeredHook = n),
        (this.options = r),
        (this.isSuperseded = () =>
          this.type.hookPhase === Wc.RUN &&
          !this.options.transition.isActive()),
        (this.options = Ia(r, sl)),
        (this.type = n.eventType);
    }
    logError(t) {
      rl.publish("$stateService:defaultErrorHandler", t);
    }
    invokeHook() {
      const t = this.registeredHook;
      if (t._deregistered) return;
      const e = this.getNotCurrentRejection();
      if (e) return e;
      const n = this.options;
      Sc.traceHookInvocation(this, this.transition, n);
      const r = () =>
          t.callback.call(n.bind, this.transition, this.stateContext),
        s = (t) => el.normalize(t).toPromise(),
        i = (e) => t.eventType.getErrorHandler(this)(e),
        o = (e) => t.eventType.getResultHandler(this)(e);
      try {
        const t = r();
        return !this.type.synchronous && pc(t) ? t.catch(s).then(o, i) : o(t);
      } catch (t) {
        return i(el.normalize(t));
      } finally {
        t.invokeLimit && ++t.invokeCount >= t.invokeLimit && t.deregister();
      }
    }
    handleHookResult(t) {
      const e = this.getNotCurrentRejection();
      return (
        e ||
        (pc(t)
          ? t.then((t) => this.handleHookResult(t))
          : (Sc.traceHookResult(t, this.transition),
            !1 === t
              ? el.aborted("Hook aborted transition").toPromise()
              : t instanceof Tc
                ? el.redirected(t).toPromise()
                : void 0))
      );
    }
    getNotCurrentRejection() {
      return this.transition._aborted
        ? el.aborted().toPromise()
        : this.isSuperseded()
          ? el.superseded(this.options.current()).toPromise()
          : void 0;
    }
    toString() {
      const { options: t, registeredHook: e } = this;
      return `${_a("traceData.hookType")(t) || "internal"} context: ${_a("traceData.context.state.name")(t) || _a("traceData.context")(t) || "unknown"}, ${fc(200, gc(e.callback))}`;
    }
  }
  (il.HANDLE_RESULT = (t) => (e) => t.handleHookResult(e)),
    (il.LOG_REJECTED_RESULT = (t) => (e) => {
      pc(e) && e.catch((e) => t.logError(el.normalize(e)));
    }),
    (il.LOG_ERROR = (t) => (e) => t.logError(e)),
    (il.REJECT_ERROR = () => (t) => sc(t)),
    (il.THROW_ERROR = () => (t) => {
      throw t;
    });
  class ol {
    static is(t) {
      return !!/[!,*]+/.exec(t);
    }
    static fromString(t) {
      return ol.is(t) ? new ol(t) : null;
    }
    constructor(t) {
      (this.text = t), (this.glob = t.split("."));
      const e = this.text
        .split(".")
        .map((t) =>
          "**" === t
            ? "(?:|(?:\\.[^.]*)*)"
            : "*" === t
              ? "\\.[^.]*"
              : "\\." + t,
        )
        .join("");
      this.regexp = new RegExp("^" + e + "$");
    }
    matches(t) {
      return this.regexp.test("." + t);
    }
  }
  function al(t, e, n) {
    const r = E(e) ? [e] : e;
    return !!(
      k(r)
        ? r
        : function (t) {
            const e = r;
            for (let n = 0; n < e.length; n++) {
              const r = new ol(e[n]);
              if ((r && r.matches(t.name)) || (!r && e[n] === t.name))
                return !0;
            }
            return !1;
          }
    )(t, n);
  }
  class cl {
    constructor(t, e, n, r, s, i = {}) {
      (this.tranSvc = t),
        (this.eventType = e),
        (this.callback = n),
        (this.matchCriteria = r),
        (this.removeHookFromRegistry = s),
        (this.invokeCount = 0),
        (this._deregistered = !1),
        (this.priority = i.priority || 0),
        (this.bind = i.bind || null),
        (this.invokeLimit = i.invokeLimit);
    }
    _matchingNodes(t, e, n) {
      if (!0 === e) return t;
      const r = t.filter((t) => al(t.state, e, n));
      return r.length ? r : null;
    }
    _getDefaultMatchCriteria() {
      return Ba(this.tranSvc._pluginapi._getPathTypes(), () => !0);
    }
    _getMatchingNodes(t, e) {
      const n = Object.assign(
        this._getDefaultMatchCriteria(),
        this.matchCriteria,
      );
      return Object.values(this.tranSvc._pluginapi._getPathTypes()).reduce(
        (r, s) => {
          const i = s.scope === Gc.STATE,
            o = t[s.name] || [],
            a = i ? o : [ec(o)];
          return (r[s.name] = this._matchingNodes(a, n[s.name], e)), r;
        },
        {},
      );
    }
    matches(t, e) {
      const n = this._getMatchingNodes(t, e);
      return Object.values(n).every((t) => t) ? n : null;
    }
    deregister() {
      this.removeHookFromRegistry(this), (this._deregistered = !0);
    }
  }
  function ll(t, e, n) {
    const r = ((t._registeredHooks = t._registeredHooks || {})[n.name] = []),
      s = Ma(r);
    function i(t, i, o = {}) {
      const a = new cl(e, n, i, t, s, o);
      return r.push(a), a.deregister.bind(a);
    }
    return (t[n.name] = i), i;
  }
  class ul {
    constructor(t) {
      this.transition = t;
    }
    buildHooksForPhase(t) {
      return this.transition.transitionService._pluginapi
        ._getEvents(t)
        .map((t) => this.buildHooks(t))
        .reduce(Wa, [])
        .filter(Boolean);
    }
    buildHooks(t) {
      const e = this.transition,
        n = e.treeChanges(),
        r = this.getMatchingHooks(t, n, e);
      if (!r) return [];
      const s = { transition: e, current: e.options().current };
      return r
        .map((r) =>
          r.matches(n, e)[t.criteriaMatchPath.name].map((n) => {
            const i = Object.assign(
                { bind: r.bind, traceData: { hookType: t.name, context: n } },
                s,
              ),
              o = t.criteriaMatchPath.scope === Gc.STATE ? n.state.self : null,
              a = new il(e, o, r, i);
            return { hook: r, node: n, transitionHook: a };
          }),
        )
        .reduce(Wa, [])
        .sort(
          (function (t = !1) {
            return function (e, n) {
              const r = t ? -1 : 1,
                s = (e.node.state.path.length - n.node.state.path.length) * r;
              return 0 !== s ? s : n.hook.priority - e.hook.priority;
            };
          })(t.reverseSort),
        )
        .map((t) => t.transitionHook);
    }
    getMatchingHooks(t, e, n) {
      const r = t.hookPhase === Wc.CREATE,
        s = this.transition.transitionService;
      return (r ? [s] : [this.transition, s])
        .map((e) => e.getHooks(t.name))
        .filter(Ja(Array.isArray, `broken event named: ${t.name}`))
        .reduce(Wa, [])
        .filter((t) => t.matches(e, n));
    }
  }
  class hl {
    constructor(t, e, n, r) {
      if (
        ((this.globals = r),
        (this.transitionService = n),
        (this._deferred = Promise.withResolvers()),
        (this.promise = this._deferred.promise),
        (this._registeredHooks = {}),
        (this._hookBuilder = new ul(this)),
        (this.isActive = () => this.globals.transition === this),
        (this._targetState = e),
        !e.valid())
      )
        throw new Error(e.error());
      (this._options = Object.assign({ current: Ra(this) }, e.options())),
        (this.$id = n._transitionCount++);
      const s = Vc.buildToPath(t, e);
      (this._treeChanges = Vc.treeChanges(t, s, this._options.reloadState)),
        this.createTransitionHookRegFns();
      const i = this._hookBuilder.buildHooksForPhase(Wc.CREATE);
      il.invokeHooks(i, () => null), this.applyViewConfigs();
    }
    createTransitionHookRegFns() {
      this.transitionService._pluginapi
        ._getEvents()
        .filter((t) => t.hookPhase !== Wc.CREATE)
        .forEach((t) => ll(this, this.transitionService, t));
    }
    getHooks(t) {
      return this._registeredHooks[t];
    }
    applyViewConfigs() {
      const t = this._treeChanges.entering.map((t) => t.state);
      Vc.applyViewConfigs(
        this.transitionService.$view,
        this._treeChanges.to,
        t,
      );
    }
    $from() {
      return ec(this._treeChanges.from).state;
    }
    $to() {
      return ec(this._treeChanges.to).state;
    }
    from() {
      return this.$from().self;
    }
    to() {
      return this.$to().self;
    }
    targetState() {
      return this._targetState;
    }
    is(t) {
      return t instanceof hl
        ? this.is({ to: t.$to().name, from: t.$from().name })
        : !(
            (t.to && !al(this.$to(), t.to, this)) ||
            (t.from && !al(this.$from(), t.from, this))
          );
    }
    params(t = "to") {
      return Object.freeze(
        this._treeChanges[t]
          .map((t) => t.paramValues)
          .reduce((t, e) => ({ ...t, ...e }), {}),
      );
    }
    paramsChanged() {
      const t = this.params("from"),
        e = this.params("to"),
        n = []
          .concat(this._treeChanges.to)
          .concat(this._treeChanges.from)
          .map((t) => t.paramSchema)
          .reduce(Ga, [])
          .reduce(Ya, []);
      return Lc.changed(n, t, e).reduce((t, n) => ((t[n.id] = e[n.id]), t), {});
    }
    injector(t, e = "to") {
      let n = this._treeChanges[e];
      return (
        t && (n = Vc.subPath(n, (e) => e.state === t || e.state.name === t)),
        new Uc(n).injector()
      );
    }
    getResolveTokens(t = "to") {
      return new Uc(this._treeChanges[t]).getTokens();
    }
    addResolvable(t, e) {
      void 0 === e && (e = ""), (t = ja(_c)(t) ? t : new _c(t));
      const n = "string" == typeof e ? e : e.name,
        r = this._treeChanges.to,
        s = qa(r, (t) => t.state.name === n);
      at(!!s, `targetNode not found ${n}`);
      new Uc(r).addResolvables([t], s.state);
    }
    redirectedFrom() {
      return this._options.redirectedFrom || null;
    }
    originalTransition() {
      const t = this.redirectedFrom();
      return (t && t.originalTransition()) || this;
    }
    options() {
      return this._options;
    }
    entering() {
      return Ba(this._treeChanges.entering, (t) => t.state).map((t) => t.self);
    }
    exiting() {
      return Ba(this._treeChanges.exiting, (t) => t.state)
        .map((t) => t.self)
        .reverse();
    }
    retained() {
      return Ba(this._treeChanges.retained, (t) => t.state).map((t) => t.self);
    }
    views(t = "entering", e) {
      let n = this._treeChanges[t];
      return (
        (n = e ? n.filter(ka("state", e)) : n),
        n.map((t) => t.views).reduce(Wa, [])
      );
    }
    treeChanges(t) {
      return t ? this._treeChanges[t] : this._treeChanges;
    }
    redirect(t) {
      let e = 1,
        n = this;
      for (; null != (n = n.redirectedFrom()); )
        if (++e > 20)
          throw new Error("Too many consecutive Transition redirects (20+)");
      const r = { redirectedFrom: this, source: "redirect" };
      "url" === this.options().source &&
        !1 !== t.options().location &&
        (r.location = "replace");
      const s = Object.assign({}, this.options(), t.options(), r);
      t = t.withOptions(s, !0);
      const i = this.transitionService.create(this._treeChanges.from, t),
        o = this._treeChanges.entering,
        a = i._treeChanges.entering;
      return (
        Vc.matching(a, o, Vc.nonDynamicParams)
          .filter((e) => {
            return !((n = t.options().reloadState),
            (t) => n && t.state.includes[n.name])(e);
            var n;
          })
          .forEach((t, e) => {
            t.resolvables = o[e].resolvables;
          }),
        i
      );
    }
    _changedParams() {
      const t = this._treeChanges;
      if (this._options.reload) return;
      if (t.exiting.length || t.entering.length) return;
      if (t.to.length !== t.from.length) return;
      if (
        Xa(t.to, t.from)
          .map((t) => t[0].state !== t[1].state)
          .reduce(za, !1)
      )
        return;
      const e = t.to.map((t) => t.paramSchema),
        [n, r] = [t.to, t.from].map((t) => t.map((t) => t.paramValues));
      return Xa(e, n, r)
        .map(([t, e, n]) => Lc.changed(t, e, n))
        .reduce(Wa, []);
    }
    dynamic() {
      const t = this._changedParams();
      return !!t && t.map((t) => t.dynamic).reduce(za, !1);
    }
    ignored() {
      return !!this._ignoredReason();
    }
    _ignoredReason() {
      const t = this.globals.transition,
        e = this._options.reloadState,
        n = (t, n) => {
          if (t.length !== n.length) return !1;
          const r = Vc.matching(t, n);
          return (
            t.length === r.filter((t) => !e || !t.state.includes[e.name]).length
          );
        },
        r = this.treeChanges(),
        s = t && t.treeChanges();
      return s && n(s.to, r.to) && n(s.exiting, r.exiting)
        ? "SameAsPending"
        : 0 === r.exiting.length && 0 === r.entering.length && n(r.from, r.to)
          ? "SameAsCurrent"
          : void 0;
    }
    run() {
      const t = (t) => this._hookBuilder.buildHooksForPhase(t),
        e = t(Wc.BEFORE);
      return (
        il
          .invokeHooks(e, () => {
            const t = this.globals;
            return (
              (t.lastStartedTransitionId = this.$id),
              (t.transition = this),
              t.transitionHistory.enqueue(this),
              Sc.traceTransitionStart(this),
              Promise.resolve()
            );
          })
          .then(() => {
            const e = t(Wc.RUN),
              n = Promise.resolve();
            return il.invokeHooks(e, () => n);
          })
          .then(
            () => {
              Sc.traceSuccess(this.$to(), this),
                (this.success = !0),
                this._deferred.resolve(this.to());
              this._hookBuilder.buildHooksForPhase(Wc.SUCCESS).forEach((t) => {
                t.invokeHook();
              });
            },
            (e) => {
              Sc.traceError(e, this),
                (this.success = !1),
                this._deferred.reject(e),
                (this._error = e);
              t(Wc.ERROR).forEach((t) => t.invokeHook());
            },
          ),
        this.promise
      );
    }
    valid() {
      return !this.error() || void 0 !== this.success;
    }
    abort() {
      v(this.success) && (this._aborted = !0);
    }
    error() {
      const t = this.$to();
      if (t.self.abstract)
        return el.invalid(`Cannot transition to abstract state '${t.name}'`);
      const e = t.parameters(),
        n = this.params(),
        r = e.filter((t) => !t.validates(n[t.id]));
      if (r.length) {
        const e = r.map((t) => `[${t.id}:${yc(n[t.id])}]`).join(", "),
          s = `The following parameter values are not valid for state '${t.name}': ${e}`;
        return el.invalid(s);
      }
      return !1 === this.success ? this._error : void 0;
    }
    toString() {
      const t = this.from(),
        e = this.to(),
        n = (t) => (null !== t["#"] && void 0 !== t["#"] ? t : Ha(t, ["#"]));
      return `Transition#${this.$id}( '${w(t) ? t.name : t}'${yc(n(this._treeChanges.from.map((t) => t.paramValues).reduce((t, e) => ({ ...t, ...e }), {})))} -> ${this.valid() ? "" : "(X) "}'${w(e) ? e.name : e}'${yc(n(this.params()))} )`;
    }
  }
  hl.diToken = hl;
  const dl = ["$transition$", hl];
  function pl(t) {
    const e = Object.values(t.treeChanges()).reduce(Wa, []).reduce(Ya, []),
      n = (t) => (dl.includes(t.token) ? _c.fromData(t.token, null) : t);
    e.forEach((t) => {
      t.resolvables = t.resolvables.map(n);
    });
  }
  function fl(t) {
    return (e, n) => (0, n.$$state()[t])(e, n);
  }
  const $l = fl("onExit"),
    ml = fl("onRetain"),
    gl = fl("onEnter"),
    yl = 1e3,
    vl = (t) =>
      new Uc(t.treeChanges().to).resolvePath("EAGER", t).then(() => {}),
    bl = (t, e) =>
      new Uc(t.treeChanges().to)
        .subContext(e.$$state())
        .resolvePath("LAZY", t)
        .then(() => {}),
    wl = (t) =>
      new Uc(t.treeChanges().to).resolvePath("LAZY", t).then(() => {}),
    El = (t) => {
      const e = t.views("entering");
      if (e.length)
        return Promise.all(e.map((t) => Promise.resolve(t.load()))).then(
          () => {},
        );
    },
    Cl = (t) => {
      const e = t.globals,
        n = () => {
          e.transition === t && (e.transition = null);
        };
      t.onSuccess(
        {},
        () => {
          e.successfulTransitions.enqueue(t),
            (e.$current = t.$to()),
            (e.current = e.$current.self),
            nc(t.params(), e.params);
        },
        { priority: 1e4 },
      ),
        t.promise.then(n, n);
    };
  function Ol(t, e, n, r) {
    return t.onBefore({ entering: (t) => !!t.lazyLoad }, (t) => {
      const s = t
        .entering()
        .filter((t) => !!t.$$state().lazyLoad)
        .map((e) => Al(t, e, r));
      return Promise.all(s).then(function () {
        if ("url" !== t.originalTransition().options().source) {
          const n = t.targetState();
          return e.target(n.identifier(), n.params(), n.options());
        }
        const r = n.match(n.parts()),
          s = r && r.rule;
        if (s && "STATE" === s.type) {
          const n = s.state,
            i = r.match;
          return e.target(n, i, t.options());
        }
        n.sync();
      });
    });
  }
  function Al(t, e, n) {
    const r = e.$$state().lazyLoad;
    let s = r._promise;
    if (!s) {
      const i = (t) => (
          delete e.lazyLoad, delete e.$$state().lazyLoad, delete r._promise, t
        ),
        o = (t) => (delete r._promise, Promise.reject(t));
      s = r._promise = Promise.resolve(r(t, e))
        .then(function (t) {
          t &&
            Array.isArray(t.states) &&
            t.states.forEach((t) => n.register(t));
          return t;
        })
        .then(i, o);
    }
    return s;
  }
  class Sl {
    constructor(
      t,
      e,
      n,
      r,
      s = !1,
      i = il.HANDLE_RESULT,
      o = il.REJECT_ERROR,
      a = !1,
    ) {
      (this.name = t),
        (this.hookPhase = e),
        (this.hookOrder = n),
        (this.criteriaMatchPath = r),
        (this.reverseSort = s),
        (this.getResultHandler = i),
        (this.getErrorHandler = o),
        (this.synchronous = a);
    }
  }
  function xl(t) {
    const e = t._ignoredReason();
    if (!e) return;
    Sc.traceTransitionIgnored(t);
    const n = t.globals.transition;
    return "SameAsCurrent" === e && n && n.abort(), el.ignored().toPromise();
  }
  function kl(t) {
    if (!t.valid()) throw new Error(t.error().toString());
  }
  let _l = {
    location: !0,
    relative: null,
    inherit: !1,
    notify: !0,
    reload: !1,
    supercede: !0,
    custom: {},
    current: () => null,
    source: "unknown",
  };
  class Tl {
    static $inject = ["$routerGlobalsProvider", "$viewProvider"];
    constructor(t, e) {
      (this._transitionCount = 0),
        (this._eventTypes = []),
        (this._registeredHooks = {}),
        (this._criteriaPaths = {}),
        (this.globals = t),
        (this.$view = e),
        (this._deregisterHookFns = {}),
        (this._pluginapi = Va(Ra(this), {}, Ra(this), [
          "_definePathType",
          "_defineEvent",
          "_getPathTypes",
          "_getEvents",
          "getHooks",
        ])),
        this._defineCorePaths(),
        this._defineCoreEvents(),
        this._registerCoreTransitionHooks(),
        t.successfulTransitions.onEvict(pl);
    }
    $get = [
      "$state",
      "$urlService",
      "$stateRegistry",
      "$view",
      (t, e, n, r) => (
        (this._deregisterHookFns.lazyLoad = Ol(this, t, e, n)),
        (this._deregisterHookFns.updateUrl = ((t, e, n) => {
          t.onSuccess(
            {},
            (t) => {
              const r = t.options(),
                s = e;
              if ("url" !== r.source && r.location && s.$current.navigable) {
                const t = { replace: "replace" === r.location };
                n.push(s.$current.navigable.url, s.globals.params, t);
              }
              n.update(!0);
            },
            { priority: 9999 },
          );
        })(this, t, e)),
        (this._deregisterHookFns.redirectTo = ((t, e) => {
          t.onStart({ to: (t) => !!t.redirectTo }, (t) => {
            const n = t.to().redirectTo;
            if (!n) return;
            const r = e;
            function s(e) {
              if (e)
                return e instanceof Tc
                  ? e
                  : E(e)
                    ? r.target(e, t.params(), t.options())
                    : e.state || e.params
                      ? r.target(
                          e.state || t.to(),
                          e.params || t.params(),
                          t.options(),
                        )
                      : void 0;
            }
            return k(n) ? Promise.resolve(n(t)).then(s) : s(n);
          });
        })(this, t)),
        (this._deregisterHookFns.activateViews = ((t, e) => {
          t.onSuccess({}, (t) => {
            const n = t.views("entering"),
              r = t.views("exiting");
            (n.length || r.length) &&
              (r.forEach((t) => e.deactivateViewConfig(t)),
              n.forEach((t) => {
                e.activateViewConfig(t);
              }),
              e.sync());
          });
        })(this, r)),
        this
      ),
    ];
    create(t, e) {
      return new hl(t, e, this, this.globals);
    }
    _defineCoreEvents() {
      const t = Wc,
        e = il,
        n = this._criteriaPaths,
        r = !1,
        s = !0;
      this._defineEvent(
        "onCreate",
        t.CREATE,
        0,
        n.to,
        r,
        e.LOG_REJECTED_RESULT,
        e.THROW_ERROR,
        s,
      ),
        this._defineEvent("onBefore", t.BEFORE, 0, n.to),
        this._defineEvent("onStart", t.RUN, 0, n.to),
        this._defineEvent("onExit", t.RUN, 100, n.exiting, !0),
        this._defineEvent("onRetain", t.RUN, 200, n.retained),
        this._defineEvent("onEnter", t.RUN, 300, n.entering),
        this._defineEvent("onFinish", t.RUN, 400, n.to),
        this._defineEvent(
          "onSuccess",
          t.SUCCESS,
          0,
          n.to,
          r,
          e.LOG_REJECTED_RESULT,
          e.LOG_ERROR,
          s,
        ),
        this._defineEvent(
          "onError",
          t.ERROR,
          0,
          n.to,
          r,
          e.LOG_REJECTED_RESULT,
          e.LOG_ERROR,
          s,
        );
    }
    _defineCorePaths() {
      const { STATE: t, TRANSITION: e } = Gc;
      this._definePathType("to", e),
        this._definePathType("from", e),
        this._definePathType("exiting", t),
        this._definePathType("retained", t),
        this._definePathType("entering", t);
    }
    _defineEvent(
      t,
      e,
      n,
      r,
      s = !1,
      i = il.HANDLE_RESULT,
      o = il.REJECT_ERROR,
      a = !1,
    ) {
      const c = new Sl(t, e, n, r, s, i, o, a);
      this._eventTypes.push(c), ll(this, this, c);
    }
    _getEvents(t) {
      return (
        b(t)
          ? this._eventTypes.filter((e) => e.hookPhase === t)
          : this._eventTypes.slice()
      ).sort((t, e) => {
        const n = t.hookPhase - e.hookPhase;
        return 0 === n ? t.hookOrder - e.hookOrder : n;
      });
    }
    _definePathType(t, e) {
      this._criteriaPaths[t] = { name: t, scope: e };
    }
    _getPathTypes() {
      return this._criteriaPaths;
    }
    getHooks(t) {
      return this._registeredHooks[t];
    }
    _registerCoreTransitionHooks() {
      const t = this._deregisterHookFns;
      (t.addCoreResolves = void this.onCreate({}, function (t) {
        t.addResolvable(_c.fromData(hl, t), ""),
          t.addResolvable(_c.fromData("$transition$", t), ""),
          t.addResolvable(_c.fromData("$stateParams", t.params()), ""),
          t.entering().forEach((e) => {
            t.addResolvable(_c.fromData("$state$", e), e);
          });
      })),
        (t.ignored = ((t) => t.onBefore({}, xl, { priority: -9999 }))(this)),
        (t.invalid = ((t) => t.onBefore({}, kl, { priority: -1e4 }))(this)),
        (t.onExit = ((t) => t.onExit({ exiting: (t) => !!t.onExit }, $l))(
          this,
        )),
        (t.onRetain = ((t) =>
          t.onRetain({ retained: (t) => !!t.onRetain }, ml))(this)),
        (t.onEnter = ((t) => t.onEnter({ entering: (t) => !!t.onEnter }, gl))(
          this,
        )),
        (t.eagerResolve = ((t) => t.onStart({}, vl, { priority: yl }))(this)),
        (t.lazyResolve = ((t) =>
          t.onEnter({ entering: Ra(!0) }, bl, { priority: yl }))(this)),
        (t.resolveAll = ((t) => t.onFinish({}, wl, { priority: yl }))(this)),
        (t.loadViews = ((t) => t.onFinish({}, El))(this)),
        (t.updateGlobals = ((t) => t.onCreate({}, Cl))(this)),
        (t.lazyLoad = Ol(this));
    }
  }
  const jl = dt("$stateProvider");
  class Rl {
    get params() {
      return this.globals.params;
    }
    get current() {
      return this.globals.current;
    }
    get $current() {
      return this.globals.$current;
    }
    static $inject = ["$routerGlobalsProvider", "$transitionsProvider"];
    constructor(t, e) {
      (this.stateRegistry = void 0),
        (this.urlService = void 0),
        (this.globals = t),
        (this.transitionService = e),
        (this.invalidCallbacks = []),
        (this._defaultErrorHandler = function (t) {
          throw t instanceof Error && t.stack
            ? t
            : t instanceof el
              ? new Error(t.toString())
              : new Error(t);
        });
      const n = ["current", "$current", "params", "transition"],
        r = Object.keys(Rl.prototype).filter((t) => !n.includes(t));
      Va(Ra(Rl.prototype), this, Ra(this), r),
        rl.subscribe("$stateService:defaultErrorHandler", (t) =>
          this.defaultErrorHandler()(t),
        );
    }
    $get = () => this;
    decorator(t, e) {
      return this.stateRegistry.decorator(t, e) || this;
    }
    state(t) {
      if (!t.name) throw jl("stateinvalid", "'name' required");
      try {
        this.stateRegistry.register(t);
      } catch (t) {
        throw jl("stateinvalid", t.message);
      }
      return this;
    }
    _handleInvalidTargetState(t, e) {
      const n = Pc(this.stateRegistry, t),
        r = this.globals,
        s = () => r.transitionHistory.peekTail(),
        i = s(),
        o = new uc(this.invalidCallbacks.slice()),
        a = new Uc(t).injector(),
        c = (t) => {
          if (!(t instanceof Tc)) return;
          let e = t;
          return (
            (e = this.target(e.identifier(), e.params(), e.options())),
            e.valid()
              ? s() !== i
                ? el.superseded().toPromise()
                : this.transitionTo(e.identifier(), e.params(), e.options())
              : el.invalid(e.error()).toPromise()
          );
        };
      return (function t() {
        const r = o.dequeue();
        return void 0 === r
          ? el.invalid(e.error()).toPromise()
          : Promise.resolve(r(e, n, a))
              .then(c)
              .then((e) => e || t());
      })();
    }
    onInvalid(t) {
      return (
        this.invalidCallbacks.push(t),
        function () {
          Ma(this.invalidCallbacks)(t);
        }.bind(this)
      );
    }
    reload(t) {
      return this.transitionTo(this.globals.current, this.globals.params, {
        reload: !b(t) || t,
        inherit: !1,
        notify: !1,
      });
    }
    go(t, e, n) {
      const r = Ia(n, { relative: this.$current, inherit: !0 }, _l);
      return this.transitionTo(t, e, r);
    }
    target(t, e, n = {}) {
      if (w(n.reload) && !n.reload.name)
        throw new Error("Invalid reload state object");
      const r = this.stateRegistry;
      if (
        ((n.reloadState =
          !0 === n.reload ? r.root() : r.matcher.find(n.reload, n.relative)),
        n.reload && !n.reloadState)
      )
        throw new Error(
          `No such reload state '${E(n.reload) ? n.reload : n.reload.name}'`,
        );
      return new Tc(this.stateRegistry, t, e, n);
    }
    getCurrentPath() {
      const t = this.globals.successfulTransitions.peekTail();
      return t
        ? t.treeChanges().to
        : (() => [new Nc(this.stateRegistry.root())])();
    }
    transitionTo(t, e = {}, n = {}) {
      n = Ia(n, _l);
      const r = () => this.globals.transition;
      n = Object.assign(n, { current: r });
      const s = this.target(t, e, n),
        i = this.getCurrentPath();
      if (!s.exists()) return this._handleInvalidTargetState(i, s);
      if (!s.valid()) return sc(s.error());
      if (!1 === n.supercede && r())
        return el
          .ignored(
            "Another transition is in progress and supercede has been set to false in TransitionOptions for the transition. So the transition was ignored in favour of the existing one in progress.",
          )
          .toPromise();
      const o = (t) => (e) => {
          if (e instanceof el) {
            const n = this.globals.lastStartedTransitionId <= t.$id;
            if (e.type === Jc)
              return (
                n && this.urlService.update(),
                Promise.resolve(this.globals.current)
              );
            const r = e.detail;
            if (e.type === Qc && e.redirected && r instanceof Tc) {
              const e = t.redirect(r);
              return e.run().catch(o(e));
            }
            if (e.type === Yc)
              return n && this.urlService.update(), Promise.reject(e);
          }
          return this.defaultErrorHandler()(e), Promise.reject(e);
        },
        a = this.transitionService.create(i, s),
        c = a.run().catch(o(a));
      return rc(c), Object.assign(c, { transition: a });
    }
    is(t, e, n) {
      n = Ia(n, { relative: this.$current });
      const r = this.stateRegistry.matcher.find(t, n.relative);
      if (!b(r)) return;
      if (this.$current !== r) return !1;
      if (!e) return !0;
      const s = r.parameters({ inherit: !0, matchingKeys: e });
      return Lc.equals(s, Lc.values(s, e), this.globals.params);
    }
    includes(t, e, n) {
      n = Ia(n, { relative: this.$current });
      const r = E(t) && ol.fromString(t);
      if (r) {
        if (!r.matches(this.$current.name)) return !1;
        t = this.$current.name;
      }
      const s = this.stateRegistry.matcher.find(t, n.relative),
        i = this.$current.includes;
      if (!b(s)) return;
      if (!b(i[s.name])) return !1;
      if (!e) return !0;
      const o = s.parameters({ inherit: !0, matchingKeys: e });
      return Lc.equals(o, Lc.values(o, e), this.globals.params);
    }
    href(t, e, n) {
      (n = Ia(n, {
        lossy: !0,
        inherit: !0,
        absolute: !1,
        relative: this.$current,
      })),
        (e = e || {});
      const r = this.stateRegistry.matcher.find(t, n.relative);
      if (!b(r)) return null;
      n.inherit && (e = this.globals.params.$inherit(e, this.$current, r));
      const s = r && n.lossy ? r.navigable : r;
      return s && void 0 !== s.url && null !== s.url
        ? this.urlService.href(s.url, e, { absolute: n.absolute })
        : null;
    }
    defaultErrorHandler(t) {
      return (this._defaultErrorHandler = t || this._defaultErrorHandler);
    }
    get(t, e) {
      const n = this.stateRegistry;
      return 0 === arguments.length ? n.get() : n.get(t, e || this.$current);
    }
    lazyLoad(t, e) {
      const n = this.get(t);
      if (!n || !n.lazyLoad) throw new Error("Can not lazy load " + t);
      const r = this.getCurrentPath(),
        s = Pc(this.stateRegistry, r);
      return Al((e = e || this.transitionService.create(r, s)), n);
    }
  }
  class Ll {
    constructor() {
      this.enabled = !1;
    }
    useAnchorScroll() {
      this.enabled = !0;
    }
    $get = [
      "$anchorScroll",
      (t) =>
        this.enabled
          ? t
          : async function (t) {
              setTimeout(() => {
                t.scrollIntoView(!1);
              }, 0);
            },
    ];
  }
  class Nl {
    constructor() {
      this._useHttp = !1;
    }
    $get = [
      "$http",
      "$templateCache",
      "$templateRequest",
      "$injector",
      (t, e, n, r) => (
        (this.$templateRequest = n),
        (this.$http = t),
        (this.$templateCache = e),
        (this.$injector = r),
        this
      ),
    ];
    useHttpService(t) {
      this._useHttp = t;
    }
    fromConfig(t, e, n) {
      const r = (t) => Promise.resolve(t).then((t) => ({ template: t })),
        s = (t) => Promise.resolve(t).then((t) => ({ component: t }));
      switch (
        ((t) =>
          b(t.template)
            ? "template"
            : b(t.templateUrl)
              ? "templateUrl"
              : b(t.templateProvider)
                ? "templateProvider"
                : b(t.component)
                  ? "component"
                  : b(t.componentProvider)
                    ? "componentProvider"
                    : "default")(t)
      ) {
        case "template":
          return r(this.fromString(t.template, e));
        case "templateUrl":
          return r(this.fromUrl(t.templateUrl, e));
        case "templateProvider":
          return r(this.fromProvider(t.templateProvider, e, n));
        case "component":
          return s(t.component);
        case "componentProvider":
          return s(this.fromComponentProvider(t.componentProvider, n));
        default:
          return r("<ng-view></ng-view>");
      }
    }
    fromString(t, e) {
      return k(t) ? t(e) : t;
    }
    fromUrl(t, e) {
      return (
        k(t) && (t = t(e)),
        null == t
          ? null
          : this._useHttp
            ? this.$http
                .get(t, {
                  cache: this.$templateCache,
                  headers: { Accept: "text/html" },
                })
                .then(function (t) {
                  return t.data;
                })
            : this.$templateRequest(t)
      );
    }
    fromProvider(t, e, n) {
      const r = Ce(t),
        s = Array.isArray(t) ? ec(t) : t;
      return new _c("", s, r).get(n);
    }
    fromComponentProvider(t, e) {
      const n = Ce(t),
        r = Array.isArray(t) ? ec(t) : t;
      return new _c("", r, n).get(e);
    }
    makeComponentTemplate(t, e, n, r) {
      r = r || {};
      const s = (t) => {
          const e = $c(t);
          return /^(x|data)-/.exec(e) ? `x-${e}` : e;
        },
        i = (function (t, e) {
          const n = t.get(e + tn);
          if (!n || !n.length)
            throw new Error(`Unable to find component named '${e}'`);
          return n.map(Vl).reduce(Wa, []);
        })(this.$injector, n)
          .map((n) => {
            const { name: i, type: o } = n,
              a = s(i);
            if (t.getAttribute(a) && !r[i])
              return `${a}='${t.getAttribute(a)}'`;
            const c = r[i] || i;
            if ("@" === o) return `${a}='{{s$resolve.${c}}}'`;
            if ("&" === o) {
              const t = e.getResolvable(c),
                n = t && t.data,
                r = (n && Ce(n)) || [];
              return `${a}='$resolve.${c}${Array.isArray(n) ? `[${n.length - 1}]` : ""}(${r.join(",")})'`;
            }
            return `${a}='$resolve.${c}'`;
          })
          .join(" "),
        o = s(n);
      return `<${o} ${i}></${o}>`;
    }
  }
  const Vl = (t) =>
      w(t.bindToController) ? Pl(t.bindToController) : Pl(t.scope),
    Pl = (t) =>
      Object.keys(t || {})
        .map((e) => [e, /^([=<@&])[?]?(.*)/.exec(t[e])])
        .filter((t) => b(t) && Array.isArray(t[1]))
        .map((t) => ({ name: t[1][2] || t[0], type: t[1][1] }));
  function Ml(t, e) {
    let n = ["", ""],
      r = t.replace(/[\\[\]^$*+?.()|{}]/g, "\\$&");
    if (!e) return r;
    switch (e.squash) {
      case !1:
        n = ["(", ")" + (e.isOptional ? "?" : "")];
        break;
      case !0:
        (r = r.replace(/\/$/, "")), (n = ["(?:/(", ")|/)?"]);
        break;
      default:
        n = [`(${e.squash}|`, ")?"];
    }
    return r + n[0] + e.type.pattern.source + n[1];
  }
  const Dl = (function (t) {
      const e = new RegExp("(" + t + ")", "g");
      return (t) => t.split(e).filter(Boolean);
    })("/"),
    Il = { state: { params: {} }, strict: !0, caseInsensitive: !0 };
  class Ul {
    static encodeDashes(t) {
      return encodeURIComponent(t).replace(
        /-/g,
        (t) => `%5C%${t.charCodeAt(0).toString(16).toUpperCase()}`,
      );
    }
    static pathSegmentsAndParams(t) {
      return Xa(
        t._segments,
        t._params.filter((t) => t.location === jc.PATH).concat(void 0),
      )
        .reduce(Wa, [])
        .filter((t) => "" !== t && b(t));
    }
    static queryParams(t) {
      return t._params.filter((t) => t.location === jc.SEARCH);
    }
    static compare(t, e) {
      const n = (t) =>
          (t._cache.weights =
            t._cache.weights ||
            ((t) =>
              (t._cache.segments =
                t._cache.segments ||
                t._cache.path
                  .map(Ul.pathSegmentsAndParams)
                  .reduce(Wa, [])
                  .reduce(vc, [])
                  .map((t) => (E(t) ? Dl(t) : t))
                  .reduce(Wa, [])))(t).map((t) =>
              "/" === t ? 1 : E(t) ? 2 : t instanceof Lc ? 3 : void 0,
            )),
        r = n(t),
        s = n(e);
      ((t, e, n) => {
        const r = Math.max(t.length, e.length);
        for (; t.length < r; ) t.push(n);
        for (; e.length < r; ) e.push(n);
      })(r, s, 0);
      const i = Xa(r, s);
      let o, a;
      for (a = 0; a < i.length; a++)
        if (((o = i[a][0] - i[a][1]), 0 !== o)) return o;
      return 0;
    }
    constructor(t, e, n, r) {
      (this._cache = { path: [this] }),
        (this._children = []),
        (this._params = []),
        (this._segments = []),
        (this._compiled = []),
        (this.config = r = Ia(r, Il)),
        (this.pattern = t);
      const s =
          /([:*])([\w[\]]+)|\{([\w[\]]+)(?::\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
        i =
          /([:]?)([\w[\].-]+)|\{([\w[\].-]+)(?::\s*((?:[^{\\}]+|\\.|{(?:[^{\\}]+|\\.)*})+))?\}/g,
        o = [];
      let a,
        c = 0;
      const l = (e) => {
          if (!Ul.nameValidator.test(e))
            throw new Error(`Invalid parameter name '${e}' in pattern '${t}'`);
          if (qa(this._params, ka("id", e)))
            throw new Error(
              `Duplicate parameter name '${e}' in pattern '${t}'`,
            );
        },
        u = (n, r) => {
          const s = n[2] || n[3],
            i = r ? n[4] : n[4] || ("*" === n[1] ? "[\\s\\S]*" : null);
          return {
            id: s,
            regexp: i,
            segment: t.substring(c, n.index),
            type: i
              ? e.type(i) ||
                ((t) =>
                  Pa(e.type(r ? "query" : "path"), {
                    pattern: new RegExp(
                      t,
                      this.config.caseInsensitive ? "i" : void 0,
                    ),
                  }))(i)
              : null,
          };
        };
      let h, d;
      for (
        ;
        (a = s.exec(t)) && ((h = u(a, !1)), !(h.segment.indexOf("?") >= 0));

      )
        l(h.id),
          this._params.push(n.fromPath(h.id, h.type, r.state)),
          this._segments.push(h.segment),
          o.push([h.segment, ec(this._params)]),
          (c = s.lastIndex);
      d = t.substring(c);
      const p = d.indexOf("?");
      if (p >= 0) {
        const t = d.substring(p);
        if (((d = d.substring(0, p)), t.length > 0))
          for (c = 0; (a = i.exec(t)); )
            (h = u(a, !0)),
              l(h.id),
              this._params.push(n.fromSearch(h.id, h.type, r.state)),
              (c = s.lastIndex);
      }
      this._segments.push(d),
        (this._compiled = o.map((t) => Ml.apply(null, t)).concat(Ml(d)));
    }
    append(t) {
      return (
        this._children.push(t),
        (t._cache = {
          path: this._cache.path.concat(t),
          parent: this,
          pattern: null,
        }),
        t
      );
    }
    isRoot() {
      return this._cache.path[0] === this;
    }
    toString() {
      return this.pattern;
    }
    _getDecodedParamValue(t, e) {
      return b(t) && (t = e.type.decode(t)), e.value(t);
    }
    exec(t, e = {}, n) {
      const r = ((s = this._cache),
      (i = "pattern"),
      (o = () =>
        new RegExp(
          [
            "^",
            Za(this._cache.path.map((t) => t._compiled)).join(""),
            !1 === this.config.strict ? "/?" : "",
            "$",
          ].join(""),
          this.config.caseInsensitive ? "i" : void 0,
        )),
      (s[i] = s[i] || o())).exec(t);
      var s, i, o;
      if (!r) return null;
      const a = this.parameters(),
        c = a.filter((t) => !t.isSearch()),
        l = a.filter((t) => t.isSearch()),
        u = this._cache.path
          .map((t) => t._segments.length - 1)
          .reduce((t, e) => t + e),
        h = {};
      if (u !== r.length - 1)
        throw new Error(`Unbalanced capture group in route '${this.pattern}'`);
      function d(t) {
        const e = (t) => t.split("").reverse().join(""),
          n = Ba(e(t).split(/-(?!\\)/), e);
        return Ba(n, (t) => t.replace(/\\-/g, "-")).reverse();
      }
      for (let t = 0; t < u; t++) {
        const e = c[t];
        let n = r[t + 1];
        for (let t = 0; t < e.replace.length; t++)
          e.replace[t].from === n && (n = e.replace[t].to);
        n && !0 === e.array && (n = d(n)),
          (h[e.id] = this._getDecodedParamValue(n, e));
      }
      return (
        l.forEach((t) => {
          let n = e[t.id];
          for (let e = 0; e < t.replace.length; e++)
            t.replace[e].from === n && (n = t.replace[e].to);
          h[t.id] = this._getDecodedParamValue(n, t);
        }),
        n && (h["#"] = n),
        h
      );
    }
    parameters(t = {}) {
      return !1 === t.inherit
        ? this._params
        : Za(this._cache.path.map((t) => t._params));
    }
    parameter(t, e = {}) {
      const n = this._cache.parent;
      return (
        (() => {
          for (const e of this._params) if (e.id === t) return e;
        })() ||
        (!1 !== e.inherit && n && n.parameter(t, e)) ||
        null
      );
    }
    validates(t) {
      t = t || {};
      return this.parameters()
        .filter((e) => Object.prototype.hasOwnProperty.call(t, e.id))
        .map((e) => ((t, e) => !t || t.validates(e))(e, t[e.id]))
        .reduce(Ka, !0);
    }
    format(t = {}) {
      const e = this._cache.path,
        n = e
          .map(Ul.pathSegmentsAndParams)
          .reduce(Wa, [])
          .map((t) => (E(t) ? t : s(t))),
        r = e.map(Ul.queryParams).reduce(Wa, []).map(s);
      if (n.concat(r).filter((t) => !1 === t.isValid).length) return null;
      function s(e) {
        const n = e.value(t[e.id]),
          r = e.validates(n),
          s = e.isDefaultValue(n),
          i = !!s && e.squash,
          o = e.type.encode(n);
        return {
          param: e,
          value: n,
          isValid: r,
          isDefaultValue: s,
          squash: i,
          encoded: o,
        };
      }
      const i = n.reduce((t, e) => {
          if (E(e)) return t + e;
          const { squash: n, encoded: r, param: s } = e;
          return !0 === n
            ? t.match(/\/$/)
              ? t.slice(0, -1)
              : t
            : E(n)
              ? t + n
              : !1 !== n || null == r
                ? t
                : Array.isArray(r)
                  ? t + Ba(r, Ul.encodeDashes).join("-")
                  : s.raw
                    ? t + r
                    : t + encodeURIComponent(r);
        }, ""),
        o = r
          .map((t) => {
            let { param: e, squash: n, encoded: r, isDefaultValue: s } = t;
            if (
              !(null == r || (s && !1 !== n)) &&
              (Array.isArray(r) || (r = [r]), 0 !== r.length)
            )
              return (
                e.raw || (r = Ba(r, encodeURIComponent)),
                r.map((t) => `${e.id}=${t}`)
              );
          })
          .reduce(Wa, [])
          .join("&");
      return i + (o ? `?${o}` : "") + (t["#"] ? "#" + t["#"] : "");
    }
  }
  Ul.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;
  class Hl {
    name = void 0;
    navigable = void 0;
    parent = void 0;
    params = void 0;
    url = void 0;
    constructor(t) {
      Object.assign(this, t), (this.$$state = () => this), (this.self = t);
      const e = this.name ? ol.fromString(this.name) : null;
      this.__stateObjectCache = { nameGlob: e };
    }
    is(t) {
      return this === t || this.self === t || this.fqn() === t;
    }
    fqn() {
      if (!(this.parent && this.parent instanceof this.constructor))
        return this.name;
      const t = this.parent.fqn();
      return t ? t + "." + this.name : this.name;
    }
    root() {
      return (this.parent && this.parent.root()) || this;
    }
    parameters(t) {
      return (
        ((t = Ia(t, { inherit: !0, matchingKeys: null })).inherit &&
          this.parent &&
          this.parent.parameters()) ||
        []
      )
        .concat(Object.values(this.params))
        .filter(
          (e) =>
            !t.matchingKeys ||
            Object.prototype.hasOwnProperty.call(t.matchingKeys, e.id),
        );
    }
    parameter(t, e = {}) {
      return (
        (this.url && this.url.parameter(t, e)) ||
        qa(Object.values(this.params), ka("id", t)) ||
        (e.inherit && this.parent && this.parent.parameter(t))
      );
    }
    toString() {
      return this.fqn();
    }
  }
  (Hl.isStateDeclaration = (t) => k(t.$$state)),
    (Hl.isState = (t) => w(t.__stateObjectCache));
  class Fl {
    constructor(t, e, n) {
      (this.urlService = t), (this.stateService = e), (this.routerGlobals = n);
    }
    create(t, e) {
      const { isState: n, isStateDeclaration: r } = Hl,
        s = La([
          [E, (t) => s(this.urlService.compile(t))],
          [ja(Ul), (t) => this.fromUrlMatcher(t, e)],
          [
            ((i = n), (o = r), (...t) => i.apply(null, t) || o.apply(null, t)),
            (t) => this.fromState(t, this.stateService, this.routerGlobals),
          ],
          [ja(RegExp), (t) => this.fromRegExp(t, e)],
          [k, (t) => new ql(t, e)],
        ]);
      var i, o;
      const a = s(t);
      if (!a) throw new Error("invalid 'what' in when()");
      return a;
    }
    fromUrlMatcher(t, e) {
      let n = e;
      E(e) && (e = this.urlService.compile(e)),
        ja(Ul)(e) && (n = (t) => e.format(t));
      const r = {
        urlMatcher: t,
        matchPriority: function (e) {
          const n = t.parameters().filter((t) => t.isOptional);
          return n.length ? n.filter((t) => e[t.id]).length / n.length : 1e-6;
        },
        type: "URLMATCHER",
      };
      return Object.assign(
        new ql(function (e) {
          const n = t.exec(e.path, e.search, e.hash);
          return t.validates(n) && n;
        }, n),
        r,
      );
    }
    fromState(t, e, n) {
      const r = Hl.isStateDeclaration(t) ? t.$$state() : t,
        s = { state: r, type: "STATE" };
      return Object.assign(
        this.fromUrlMatcher(r.url, (t) => {
          const s = e;
          s.href(r, t) !== s.href(n.current, n.params) &&
            s.transitionTo(r, t, { inherit: !0, source: "url" });
        }),
        s,
      );
    }
    fromRegExp(t, e) {
      if (t.global || t.sticky)
        throw new Error("Rule RegExp must not be global or sticky");
      const n = E(e)
          ? (t) =>
              e.replace(
                /\$(\$|\d{1,2})/,
                (e, n) => t["$" === n ? 0 : Number(n)],
              )
          : e,
        r = { regexp: t, type: "REGEXP" };
      return Object.assign(new ql((e) => t.exec(e.path), n), r);
    }
  }
  Fl.isUrlRule = (t) => t && ["type", "match", "handler"].every((e) => b(t[e]));
  class ql {
    constructor(t, e) {
      (this.match = t),
        (this.type = "RAW"),
        (this.$id = -1),
        (this._group = void 0),
        (this.handler = e || ((t) => t));
    }
    matchPriority(t) {
      return at(v(t)), 0 - this.$id;
    }
  }
  let Bl;
  function Kl(t) {
    if (!(k(t) || E(t) || ja(Tc)(t) || Tc.isDef(t)))
      throw new Error(
        "'handler' must be a string, function, TargetState, or have a state: 'newtarget' property",
      );
    return k(t) ? t : Ra(t);
  }
  Bl = (t, e) => {
    let n = ((t, e) => (e.priority || 0) - (t.priority || 0))(t, e);
    return 0 !== n
      ? n
      : ((n = ((t, e) => {
          const n = { STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1 };
          return (n[t.type] || 0) - (n[e.type] || 0);
        })(t, e)),
        0 !== n
          ? n
          : ((n = ((t, e) =>
              t.urlMatcher && e.urlMatcher
                ? Ul.compare(t.urlMatcher, e.urlMatcher)
                : 0)(t, e)),
            0 !== n
              ? n
              : ((t, e) => {
                  const n = { STATE: !0, URLMATCHER: !0 };
                  return n[t.type] && n[e.type]
                    ? 0
                    : (t.$id || 0) - (e.$id || 0);
                })(t, e)));
  };
  class zl {
    constructor(t) {
      (this._sortFn = Bl),
        (this._rules = []),
        (this._id = 0),
        (this.urlRuleFactory = t);
    }
    initial(t) {
      const e = Kl(t);
      this.rule(
        this.urlRuleFactory.create(
          (t, e) =>
            0 === e.globals.transitionHistory.size() && !!/^\/?$/.exec(t.path),
          e,
        ),
      );
    }
    otherwise(t) {
      const e = Kl(t);
      (this._otherwiseFn = this.urlRuleFactory.create(Ra(!0), e)),
        (this._sorted = !1);
    }
    removeRule(t) {
      Ma(this._rules, t);
    }
    rule(t) {
      if (!Fl.isUrlRule(t)) throw new Error("invalid rule");
      return (
        (t.$id = this._id++),
        (t.priority = t.priority || 0),
        this._rules.push(t),
        (this._sorted = !1),
        () => this.removeRule(t)
      );
    }
    rules() {
      return (
        this.ensureSorted(),
        this._rules.concat(this._otherwiseFn ? [this._otherwiseFn] : [])
      );
    }
    sort(t) {
      const e = this.stableSort(
        this._rules,
        (this._sortFn = t || this._sortFn),
      );
      let n = 0;
      for (let t = 0; t < e.length; t++)
        (e[t]._group = n),
          t < e.length - 1 && 0 !== this._sortFn(e[t], e[t + 1]) && n++;
      (this._rules = e), (this._sorted = !0);
    }
    ensureSorted() {
      this._sorted || this.sort();
    }
    stableSort(t, e) {
      const n = t.map((t, e) => ({ elem: t, idx: e }));
      return (
        n.sort((t, n) => {
          const r = e(t.elem, n.elem);
          return 0 === r ? t.idx - n.idx : r;
        }),
        n.map((t) => t.elem)
      );
    }
    when(t, e, n) {
      const r = this.urlRuleFactory.create(t, e);
      return b(n && n.priority) && (r.priority = n.priority), this.rule(r), r;
    }
  }
  class Wl {
    constructor(t) {
      this.urlServiceConfig = t;
    }
    fromConfig(t, e, n) {
      return new Lc(t, e, jc.CONFIG, this.urlServiceConfig, n);
    }
    fromPath(t, e, n) {
      return new Lc(t, e, jc.PATH, this.urlServiceConfig, n);
    }
    fromSearch(t, e, n) {
      return new Lc(t, e, jc.SEARCH, this.urlServiceConfig, n);
    }
  }
  class Gl {
    static $inject = [
      "$locationProvider",
      "$stateProvider",
      "$routerGlobalsProvider",
      "$urlConfigProvider",
    ];
    constructor(t, e, n, r) {
      (this.stateService = e),
        (this.stateService.urlService = this),
        (this.$locationProvider = t),
        (this.$location = void 0),
        (this.$browser = void 0),
        (this.urlRuleFactory = new Fl(this, this.stateService, n)),
        (this.rules = new zl(this.urlRuleFactory)),
        (this.config = r),
        (this.paramFactory = new Wl(this.config)),
        (this.path = () => this.$location.path()),
        (this.search = () => this.$location.search()),
        (this.hash = () => this.$location.hash()),
        (this._urlListeners = []);
    }
    $get = [
      "$location",
      "$browser",
      "$rootScope",
      (t, e, n) => (
        (this.$location = t),
        (this.$browser = e),
        n.$on("$locationChangeSuccess", (t) => {
          this._urlListeners.forEach((e) => {
            e(t);
          });
        }),
        this.listen(),
        this
      ),
    ];
    html5Mode() {
      return (
        this.$locationProvider.getHtml5Mode().enabled &&
        "undefined" != typeof history
      );
    }
    baseHref() {
      return (
        this._baseHref ||
        (this._baseHref = this.$browser.baseHref() || window.location.pathname)
      );
    }
    url(t, e = !1, n) {
      return (
        b(t) && this.$location.url(t),
        e && this.$location.replace(),
        n && this.$location.state(n),
        this.$location.url()
      );
    }
    onChange(t) {
      return this._urlListeners.push(t), () => Ma(this._urlListeners)(t);
    }
    parts() {
      return { path: this.path(), search: this.search(), hash: this.hash() };
    }
    sync(t) {
      if (t && t.defaultPrevented) return;
      const e = this.stateService,
        n = { path: this.path(), search: this.search(), hash: this.hash() },
        r = this.match(n);
      La([
        [E, (t) => this.url(t, !0)],
        [Tc.isDef, (t) => e.go(t.state, t.params, t.options)],
        [ja(Tc), (t) => e.go(t.state(), t.params(), t.options())],
      ])(r && r.rule.handler(r.match, n));
    }
    listen(t) {
      if (!1 !== t)
        return (this._stopListeningFn =
          this._stopListeningFn || this.onChange((t) => this.sync(t)));
      this._stopListeningFn && this._stopListeningFn(),
        delete this._stopListeningFn;
    }
    match(t) {
      t = Object.assign({ path: "", search: {}, hash: "" }, t);
      const e = this.rules.rules(),
        n = (e) => {
          const n = e.match(t);
          return n && { match: n, rule: e, weight: e.matchPriority(n) };
        };
      let r;
      for (
        let t = 0;
        t < e.length && (!r || r.rule._group === e[t]._group);
        t++
      ) {
        const s = n(e[t]);
        r = !r || (s && s.weight > r.weight) ? s : r;
      }
      return r;
    }
    update(t) {
      t
        ? (this.location = this.url())
        : this.url() !== this.location && this.url(this.location, !0);
    }
    push(t, e, n) {
      const r = n && !!n.replace;
      this.url(t.format(e || {}), r);
    }
    href(t, e, n) {
      let r = t.format(e);
      if (null == r) return null;
      n = n || { absolute: !1 };
      const s = this.html5Mode();
      if (
        (s ||
          null === r ||
          (r = "#" + this.$locationProvider.getHashPrefix() + r),
        (r = (function (t, e, n, r) {
          return "/" === r
            ? t
            : e
              ? ((t) => t.replace(/\/[^/]*$/, ""))(r) + t
              : n
                ? r.slice(1) + t
                : t;
        })(r, s, n.absolute, this.baseHref())),
        !n.absolute || !r)
      )
        return r;
      const i = !s && r ? "/" : "",
        o = this.$location.port(),
        a = 80 === o || 443 === o ? "" : ":" + o;
      return [
        this.$location.protocol(),
        "://",
        this.$location.host(),
        a,
        i,
        r,
      ].join("");
    }
    compile(t, e) {
      const n = this.config,
        r = e && !e.state && e.params;
      e = r ? Object.assign({ state: { params: r } }, e) : e;
      const s = {
        strict: n._isStrictMode,
        caseInsensitive: n._isCaseInsensitive,
      };
      return new Ul(t, n.paramTypes, this.paramFactory, Object.assign(s, e));
    }
    isMatcher(t) {
      if (!w(t)) return !1;
      let e = !0;
      return (
        Object.entries(Ul.prototype).forEach(([n, r]) => {
          k(r) && (e = e && b(t[n]) && k(t[n]));
        }),
        e
      );
    }
  }
  class Ql {
    constructor(t) {
      this._states = t;
    }
    isRelative(t) {
      return 0 === (t = t || "").indexOf(".") || 0 === t.indexOf("^");
    }
    find(t, e, n = !0) {
      if (!t && "" !== t) return;
      const r = E(t);
      let s = r ? t : t.name;
      this.isRelative(s) && (s = this.resolvePath(s, e));
      const i = this._states[s];
      if (i && (r || !(r || (i !== t && i.self !== t)))) return i;
      if (r && n) {
        const t = Object.values(this._states).filter(
          (t) =>
            t.__stateObjectCache.nameGlob &&
            t.__stateObjectCache.nameGlob.matches(s),
        );
        return (
          t.length > 1 &&
            console.error(
              `stateMatcher.find: Found multiple matches for ${s} using glob: `,
              t.map((t) => t.name),
            ),
          t[0]
        );
      }
    }
    resolvePath(t, e) {
      if (!e) throw new Error(`No reference point given for path '${t}'`);
      const n = this.find(e),
        r = t.split("."),
        s = r.length;
      let i = 0,
        o = n;
      for (; i < s; i++)
        if ("" !== r[i] || 0 !== i) {
          if ("^" !== r[i]) break;
          if (!o.parent)
            throw new Error(`Path '${t}' not valid for state '${n.name}'`);
          o = o.parent;
        } else o = n;
      const a = r.slice(i).join(".");
      return o.name + (o.name && a ? "." : "") + a;
    }
  }
  function Yl(t) {
    return (t.self.$$state = () => t), t.self;
  }
  function Zl(t) {
    return (
      t.parent &&
        t.parent.data &&
        (t.data = t.self.data = Pa(t.parent.data, t.data)),
      t.data
    );
  }
  function Jl(t, e) {
    return function (n) {
      let r = n.self;
      if (r && r.url && r.name && r.name.match(/\.\*\*$/)) {
        const t = {};
        nc(r, t), (t.url += "{remainder:any}"), (r = t);
      }
      const s = n.parent,
        i = (function (t) {
          if (!E(t)) return !1;
          const e = "^" === t.charAt(0);
          return { val: e ? t.substring(1) : t, root: e };
        })(r.url),
        o = i ? t.compile(i.val, { state: r }) : r.url;
      if (!o) return null;
      if (!t.isMatcher(o))
        throw new Error(`Invalid url '${o}' in state '${n}'`);
      return i && i.root ? o : ((s && s.navigable) || e()).url.append(o);
    };
  }
  function Xl(t) {
    return function (e) {
      return !t(e) && e.url ? e : e.parent ? e.parent.navigable : null;
    };
  }
  function tu(t) {
    return t.parent ? t.parent.path.concat(t) : [t];
  }
  function eu(t) {
    const e = t.parent ? Object.assign({}, t.parent.includes) : {};
    return (e[t.name] = !0), e;
  }
  function nu(t) {
    const e = La([
        [
          (t) => t.resolveFn,
          (t) => new _c(iu(t), t.resolveFn, t.deps, t.policy),
        ],
        [
          (t) => t.useFactory,
          (t) =>
            new _c(iu(t), t.useFactory, t.deps || t.dependencies, t.policy),
        ],
        [
          (t) => t.useClass,
          (t) => new _c(iu(t), () => new t.useClass(), [], t.policy),
        ],
        [
          (t) => t.useValue,
          (t) => new _c(iu(t), () => t.useValue, [], t.policy, t.useValue),
        ],
        [
          (t) => t.useExisting,
          (t) => new _c(iu(t), (t) => t, [t.useExisting], t.policy),
        ],
      ]),
      n = La([
        [
          xa((t) => t.val, E),
          (t) => new _c(t.token, (t) => t, [t.val], t.policy),
        ],
        [
          xa((t) => t.val, Array.isArray),
          (t) => new _c(t.token, ec(t.val), t.val.slice(0, -1), t.policy),
        ],
        [
          xa((t) => t.val, k),
          (t) =>
            new _c(
              t.token,
              t.val,
              ((t) => {
                const e = window.angular.$injector;
                return t.$inject || (e && Ce(t, e.strictDi)) || "deferred";
              })(t.val),
              t.policy,
            ),
        ],
      ]),
      r = La([
        [ja(_c), (t) => t],
        [(t) => !(!t.token || !t.resolveFn), e],
        [
          (t) =>
            !!(t && t.val && (E(t.val) || Array.isArray(t.val) || k(t.val))),
          n,
        ],
        [
          Ra(!0),
          (t) => {
            throw new Error("Invalid resolve value: " + yc(t));
          },
        ],
      ]),
      s = t.resolve,
      i = Array.isArray(s)
        ? s
        : ((t, e) =>
            Object.keys(t || {}).map((n) => ({
              token: n,
              val: t[n],
              deps: void 0,
              policy: e[n],
            })))(s, t.resolvePolicy || {});
    return i.map(r);
  }
  class ru {
    constructor(t, e) {
      (this.matcher = t), (this.$injector = void 0);
      const n = this,
        r = () => t.find("");
      var s;
      this.builders = {
        name: [(t) => t.name],
        self: [Yl],
        parent: [
          function (e) {
            return su(e) ? null : t.find(n.parentName(e)) || r();
          },
        ],
        data: [Zl],
        url: [Jl(e, r)],
        navigable: [Xl(su)],
        params: [
          ((s = e.paramFactory),
          function (t) {
            const e = (t.url && t.url.parameters({ inherit: !1 })) || [],
              n = Object.values(
                Ba(
                  Ha(
                    t.params || {},
                    e.map((t) => t.id),
                  ),
                  (e, n) => s.fromConfig(n, null, t.self),
                ),
              );
            return e
              .concat(n)
              .map((t) => [t.id, t])
              .reduce(tc, {});
          }),
        ],
        views: [],
        path: [tu],
        includes: [eu],
        resolvables: [nu],
      };
    }
    builder(t, e) {
      const n = this.builders,
        r = n[t] || [];
      return E(t) && !b(e)
        ? r.length > 1
          ? r
          : r[0]
        : E(t) && k(e)
          ? ((n[t] = r),
            n[t].push(e),
            () => n[t].splice(n[t].indexOf(e, 1)) && null)
          : void 0;
    }
    build(t) {
      const { matcher: e, builders: n } = this,
        r = this.parentName(t);
      if (r && !e.find(r, void 0, !1)) return null;
      for (const e in n) {
        if (!Object.prototype.hasOwnProperty.call(n, e)) continue;
        const r = n[e].reduce(
          (t, e) => (n) => e(n, t),
          () => {},
        );
        t[e] = r(t);
      }
      return t;
    }
    parentName(t) {
      const e = t.name || "",
        n = e.split(".");
      if (("**" === n.pop() && n.pop(), n.length)) {
        if (t.parent)
          throw new Error(
            `States that specify the 'parent:' property should not have a '.' in their name (${e})`,
          );
        return n.join(".");
      }
      return t.parent ? (E(t.parent) ? t.parent : t.parent.name) : "";
    }
    name(t) {
      const e = t.name;
      if (-1 !== e.indexOf(".") || !t.parent) return e;
      const n = E(t.parent) ? t.parent : t.parent.name;
      return n ? n + "." + e : e;
    }
  }
  function su(t) {
    return "" === t.name;
  }
  function iu(t) {
    return t.provide || t.token;
  }
  class ou {
    constructor(t, e, n, r, s) {
      (this.stateRegistry = t),
        (this.urlServiceRules = e),
        (this.states = n),
        (this.builder = r),
        (this.listeners = s),
        (this.queue = []);
    }
    register(t) {
      const e = new Hl(t);
      if (!E(name)) throw new Error("State must have a valid name");
      if (
        Object.prototype.hasOwnProperty.call(this.states, e.name) ||
        this.queue.map((t) => t.name).includes(e.name)
      )
        throw new Error(`State '${e.name}' is already defined`);
      return this.queue.push(e), this.flush(), e;
    }
    flush() {
      const { queue: t, states: e, builder: n } = this,
        r = [],
        s = [],
        i = {},
        o = (t) =>
          Object.prototype.hasOwnProperty.call(this.states, t) &&
          this.states[t],
        a = () => {
          r.length &&
            this.listeners.forEach((t) =>
              t(
                "registered",
                r.map((t) => t.self),
              ),
            );
        };
      for (; t.length > 0; ) {
        const c = t.shift(),
          l = c.name,
          u = n.build(c),
          h = s.indexOf(c);
        if (u) {
          const t = o(l);
          if (t && t.name === l)
            throw new Error(`State '${l}' is already defined`);
          const n = o(l + ".**");
          n && this.stateRegistry.deregister(n),
            (e[l] = c),
            this.attachRoute(c),
            h >= 0 && s.splice(h, 1),
            r.push(c);
          continue;
        }
        const d = i[l];
        if (((i[l] = t.length), h >= 0 && d === t.length))
          return t.push(c), a(), e;
        h < 0 && s.push(c), t.push(c);
      }
      return a(), e;
    }
    attachRoute(t) {
      if (t.abstract || !t.url) return;
      const e = this.urlServiceRules;
      e.rule(e.urlRuleFactory.create(t));
    }
  }
  class au {
    static $inject = [
      "$urlServiceProvider",
      "$stateProvider",
      "$routerGlobalsProvider",
      "$viewProvider",
    ];
    constructor(t, e, n, r) {
      (this.states = {}),
        (e.stateRegistry = this),
        (this.urlService = t),
        (this.urlServiceRules = t.rules),
        (this.$injector = void 0),
        (this.listeners = []),
        (this.matcher = new Ql(this.states)),
        (this.builder = new ru(this.matcher, t)),
        this.builder.builder("views", qc),
        this.builder.builder("onExit", this.getStateHookBuilder("onExit")),
        this.builder.builder("onRetain", this.getStateHookBuilder("onRetain")),
        this.builder.builder("onEnter", this.getStateHookBuilder("onEnter")),
        (this.stateQueue = new ou(
          this,
          this.urlServiceRules,
          this.states,
          this.builder,
          this.listeners,
        )),
        this.registerRoot(),
        r._pluginapi._rootViewContext(this.root()),
        (n.$current = this.root()),
        (n.current = n.$current.self);
    }
    $get = [
      "$injector",
      (t) => ((this.$injector = t), (this.builder.$injector = t), this),
    ];
    getStateHookBuilder(t) {
      let e = this;
      return function (n) {
        const r = n[t],
          s = "onExit" === t ? "from" : "to";
        return r
          ? function (t, n) {
              const i = new Uc(t.treeChanges(s)).subContext(n.$$state()),
                o = Object.assign(cu(i), { $state$: n, $transition$: t });
              return e.$injector.invoke(r, this, o);
            }
          : void 0;
      };
    }
    registerRoot() {
      (this._root = this.stateQueue.register({
        name: "",
        url: "^",
        views: null,
        params: { "#": { value: null, type: "hash", dynamic: !0 } },
        abstract: !0,
      })),
        (this._root.navigable = null);
    }
    onStatesChanged(t) {
      return (
        this.listeners.push(t),
        function () {
          Ma(this.listeners)(t);
        }.bind(this)
      );
    }
    root() {
      return this._root;
    }
    register(t) {
      return this.stateQueue.register(t);
    }
    _deregisterTree(t) {
      const e = this.get().map((t) => t.$$state()),
        n = (t) => {
          const r = e.filter((e) => -1 !== t.indexOf(e.parent));
          return 0 === r.length ? r : r.concat(n(r));
        },
        r = n([t]),
        s = [t].concat(r).reverse();
      return (
        s.forEach((t) => {
          const e = this.urlServiceRules;
          e
            .rules()
            .filter(ka("state", t))
            .forEach((t) => e.removeRule(t)),
            delete this.states[t.name];
        }),
        s
      );
    }
    deregister(t) {
      const e = this.get(t);
      if (!e) throw new Error("Can't deregister state; not found: " + t);
      const n = this._deregisterTree(e.$$state());
      return (
        this.listeners.forEach((t) =>
          t(
            "deregistered",
            n.map((t) => t.self),
          ),
        ),
        n
      );
    }
    get(t, e) {
      if (0 === arguments.length)
        return Object.keys(this.states).map((t) => this.states[t].self);
      const n = this.matcher.find(t, e);
      return (n && n.self) || null;
    }
    decorator(t, e) {
      return this.builder.builder(t, e);
    }
  }
  const cu = (t) =>
    t
      .getTokens()
      .filter(E)
      .map((e) => {
        const n = t.getResolvable(e);
        return [e, "NOWAIT" === t.getPolicy(n).async ? n.promise : n.data];
      })
      .reduce(tc, {});
  function lu(t) {
    const e = t.match(/^\s*({[^}]*})\s*$/);
    e && (t = "(" + e[1] + ")");
    const n = t.replace(/\n/g, " ").match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);
    if (!n || 4 !== n.length) throw new Error("Invalid state ref '" + t + "'");
    return { state: n[1] || null, paramExpr: n[3] || null };
  }
  function uu(t) {
    const e = Ht(t, "$ngView"),
      n = _a("$cfg.path")(e);
    return n ? ec(n).state.name : void 0;
  }
  function hu(t, e, n) {
    const r = n.ngState || t.current.name,
      s = Object.assign(
        (function (t, e) {
          return { relative: uu(t) || e.$current, inherit: !0, source: "sref" };
        })(e, t),
        n.ngStateOpts || {},
      ),
      i = t.href(r, n.ngStateParams, s);
    return {
      ngState: r,
      ngStateParams: n.ngStateParams,
      ngStateOpts: s,
      href: i,
    };
  }
  function du(t) {
    const e =
        "[object SVGAnimatedString]" ===
        Object.prototype.toString.call(t.getAttribute("href")),
      n = "FORM" === t.nodeName;
    return {
      attr: n ? "action" : e ? "xlink:href" : "href",
      isAnchor: "A" === t.nodeName,
      clickable: !n,
    };
  }
  function pu(t, e, n, r, s) {
    return function (i) {
      const o = i.which || i.button,
        a = r();
      if (
        o > 1 ||
        i.ctrlKey ||
        i.metaKey ||
        i.shiftKey ||
        i.altKey ||
        t.getAttribute("target")
      )
        i.preventDefault(), i.stopImmediatePropagation();
      else {
        const r = setTimeout(function () {
          t.getAttribute("disabled") ||
            e.go(a.ngState, a.ngStateParams, a.ngStateOpts).then(() => {
              s.$emit("$updateBrowser");
            });
        });
        i.preventDefault();
        let o = n.isAnchor && !a.href ? 1 : 0;
        i.preventDefault = function () {
          o-- <= 0 && clearTimeout(r);
        };
      }
    };
  }
  function fu(t, e, n, r) {
    let s;
    r && (s = r.events), Array.isArray(s) || (s = ["click"]);
    for (const e of s) t.addEventListener(e, n);
    e.$on("$destroy", function () {
      for (const e of s) t.removeEventListener(e, n);
    });
  }
  function $u(t, e, n) {
    const r = t;
    return {
      restrict: "A",
      require: ["?^ngSrefActive", "?^ngSrefActiveEq"],
      link: (t, s, i, o) => {
        const a = du(s),
          c = o[1] || o[0];
        let l = null;
        const u = {},
          h = () => hu(r, s, u),
          d = lu(i.ngSref);
        function p() {
          u.ngStateParams = Object.assign({}, t.$eval(d.paramExpr));
          const e = h();
          l && l(),
            c && (l = c.$$addStateInfo(e.ngState, e.ngStateParams)),
            null != e.href && i.$set(a.attr, e.href);
        }
        (u.ngState = d.state),
          (u.ngStateOpts = i.ngSrefOpts ? t.$eval(i.ngSrefOpts) : {}),
          d.paramExpr &&
            (t.$watch(
              d.paramExpr,
              function (t) {
                (u.ngStateParams = Object.assign({}, t)), p();
              },
              !0,
            ),
            (u.ngStateParams = Object.assign({}, t.$eval(d.paramExpr)))),
          p(),
          t.$on("$destroy", e.onStatesChanged(p)),
          t.$on("$destroy", n.onSuccess({}, p)),
          a.clickable && fu(s, t, pu(s, r, a, h, t), u.ngStateOpts);
      },
    };
  }
  function mu(t, e, n) {
    return {
      restrict: "A",
      require: ["?^ngSrefActive", "?^ngSrefActiveEq"],
      link: function (r, s, i, o) {
        const a = du(s),
          c = o[1] || o[0];
        let l,
          u = null;
        const h = {},
          d = () => hu(t, s, h),
          p = ["ngState", "ngStateParams", "ngStateOpts"],
          f = p.reduce((t, e) => ((t[e] = () => {}), t), {});
        function $() {
          const t = d();
          u && u(),
            c && (u = c.$$addStateInfo(t.ngState, t.ngStateParams)),
            null != t.href && i.$set(a.attr, t.href);
        }
        p.forEach((t) => {
          (h[t] = i[t] ? r.$eval(i[t]) : null),
            i.$observe(t, (e) => {
              f[t](),
                (f[t] = r.$watch(
                  e,
                  (e) => {
                    (h[t] = e), $();
                  },
                  !0,
                ));
            });
        }),
          $(),
          r.$on("$destroy", e.onStatesChanged($)),
          r.$on("$destroy", n.onSuccess({}, $)),
          a.clickable && ((l = pu(s, t, a, d, r)), fu(s, r, l, h.ngStateOpts));
      },
    };
  }
  function gu(t, e, n, r, s) {
    return {
      restrict: "A",
      controller: function (i, o, a) {
        let c,
          l,
          u = [];
        c = n(a.ngSrefActiveEq || "", !1)(i);
        try {
          l = i.$eval(a.ngSrefActive);
        } catch (t) {}
        function h(t) {
          t.promise.then($, () => {});
        }
        function d() {
          p(l);
        }
        function p(t) {
          w(t) &&
            ((u = []),
            Object.entries(t).forEach(([t, e]) => {
              const n = function (t, e) {
                const n = lu(t);
                f(n.state, i.$eval(n.paramExpr), e);
              };
              E(e)
                ? n(e, t)
                : Array.isArray(e) &&
                  e.forEach((e) => {
                    n(e, t);
                  });
            }));
        }
        function f(e, n, r) {
          const s = {
            state: t.get(e, uu(o)) || { name: e },
            params: n,
            activeClass: r,
          };
          return (
            u.push(s),
            function () {
              Ma(u)(s);
            }
          );
        }
        function $() {
          const e = (t) => t.split(/\s/).filter(Boolean),
            n = (t) =>
              t
                .map((t) => t.activeClass)
                .map(e)
                .reduce(Wa, []),
            r = n(u).concat(e(c)).reduce(Ya, []),
            s = n(u.filter((e) => t.includes(e.state.name, e.params))),
            a = !!u.filter((e) => t.is(e.state.name, e.params)).length
              ? e(c)
              : [],
            l = s.concat(a).reduce(Ya, []),
            h = r.filter((t) => !l.includes(t));
          i.$evalAsync(() => {
            l.forEach((t) => o.classList.add(t)),
              h.forEach((t) => o.classList.remove(t));
          });
        }
        (l = l || n(a.ngSrefActive || "", !1)(i)),
          p(l),
          (this.$$addStateInfo = function (t, e) {
            if (w(l) && u.length > 0) return;
            const n = f(t, e, l);
            return $(), n;
          }),
          i.$on(
            "$destroy",
            (function () {
              const t = r.onStatesChanged(d),
                e = s.onStart({}, h),
                n = i.$on("$stateChangeSuccess", $);
              return function () {
                t(), e(), n();
              };
            })(),
          ),
          e.transition && h(e.transition),
          $();
      },
    };
  }
  ($u.$inject = ["$state", "$stateRegistry", "$transitions"]),
    (mu.$inject = ["$state", "$stateRegistry", "$transitions"]),
    (gu.$inject = [
      "$state",
      "$routerGlobals",
      "$interpolate",
      "$stateRegistry",
      "$transitions",
    ]);
  let yu = [
    "$view",
    "$animate",
    "$ngViewScroll",
    "$interpolate",
    function (t, e, n, r) {
      const s = {
          $cfg: { viewDecl: { $context: t._pluginapi._rootViewContext() } },
          $ngView: {},
        },
        i = {
          count: 0,
          restrict: "EA",
          terminal: !0,
          priority: 400,
          transclude: "element",
          compile: function (o, a, c) {
            return function (o, a, l) {
              const u = l.onload || "",
                h = l.autoscroll,
                d = {
                  enter: function (t, n, r) {
                    mt(t) ? e.enter(t, null, n).then(r) : (n.after(t), r());
                  },
                  leave: function (t, n) {
                    mt(t)
                      ? e.leave(t).then(n)
                      : (t.parentElement.removeChild(t), n());
                  },
                },
                p = Ht(a, "$ngView") || s,
                f = r(l.ngView || l.name || "")(o) || "$default";
              let $, m, g, y;
              const v = {
                id: i.count++,
                name: f,
                fqn: p.$ngView.fqn ? p.$ngView.fqn + "." + f : f,
                config: null,
                configUpdated: function (t) {
                  if (t && !(t instanceof Kc)) return;
                  if (((e = y), (n = t), e === n)) return;
                  var e, n;
                  Sc.traceUIViewConfigUpdated(
                    v,
                    t && t.viewDecl && t.viewDecl.$context,
                  ),
                    (y = t),
                    E(t);
                },
                get creationContext() {
                  const t = _a("$cfg.viewDecl.$context")(p),
                    e = _a("$ngView.creationContext")(p);
                  return t || e;
                },
              };
              Sc.traceUIViewEvent("Linking", v),
                Vt(a, "$ngView", { $ngView: v }),
                E();
              const w = t.registerUIView(v);
              function E(t) {
                const e = o.$new(),
                  r = Promise.withResolvers(),
                  s = Promise.withResolvers(),
                  i = { $cfg: t, $ngView: v },
                  l = {
                    $animEnter: r.promise,
                    $animLeave: s.promise,
                    $$animLeave: s,
                  };
                e.$emit("$viewContentLoading", f);
                const p = c(e, function (t) {
                  Vt(t, "$ngViewAnim", l),
                    Vt(t, "$ngView", i),
                    d.enter(t, a, function () {
                      r.resolve(),
                        g && g.$emit("$viewContentAnimationEnded"),
                        ((b(h) && !h) || o.$eval(h)) && n(t);
                    }),
                    (function () {
                      if (
                        ($ &&
                          (Sc.traceUIViewEvent(
                            "Removing (previous) el",
                            Pt($, "$ngView"),
                          ),
                          $.remove(),
                          ($ = null)),
                        g &&
                          (Sc.traceUIViewEvent("Destroying scope", v),
                          g.$destroy(),
                          (g = null)),
                        m)
                      ) {
                        const t = Pt(m, "$ngViewAnim");
                        Sc.traceUIViewEvent("Animate out", t),
                          d.leave(m, function () {
                            t.$$animLeave.resolve(), ($ = null);
                          }),
                          ($ = m),
                          (m = null);
                      }
                    })();
                });
                (m = p),
                  (g = e),
                  g.$emit("$viewContentLoaded", t || y),
                  g.$eval(u);
              }
              o.$on("$destroy", function () {
                Sc.traceUIViewEvent("Destroying/Unregistering", v), w();
              });
            };
          },
        };
      return i;
    },
  ];
  function vu(t, e, n) {
    const r = _a("viewDecl.controllerAs"),
      s = _a("viewDecl.resolveAs");
    return {
      restrict: "EA",
      priority: -400,
      compile: function (i) {
        const o = i.innerHTML;
        return (
          Lt(i, !0),
          function (i, a) {
            const c = Pt(a, "$ngView");
            if (!c)
              return (
                (a.innerHTML = o), void t(a.contentDocument || a.childNodes)(i)
              );
            const l = c.$cfg || { viewDecl: {}, getTemplate: () => {} },
              u = l.path && new Uc(l.path);
            (a.innerHTML = l.getTemplate(a, u) || o),
              Sc.traceUIViewFill(c.$ngView, a.innerHTML);
            const h = t(a.contentDocument || a.childNodes),
              d = l.controller,
              p = r(l),
              f = s(l),
              $ = u && cu(u);
            if ((f && (i.$target[f] = $), d)) {
              const t = e(d, Object.assign({}, $, { $scope: i, $element: a }));
              p && ((i.$target[p] = t), (i.$target[p][f] = $)),
                Vt(a, "$ngControllerController", t),
                Array.from(a.children).forEach((e) => {
                  Vt(e, "$ngControllerController", t);
                }),
                wu(n, t, i, l);
            }
            if (E(l.component)) {
              const t = $c(l.component),
                e = new RegExp(`^(x-|data-)?${t}$`, "i"),
                r = () => {
                  const t = [].slice
                    .call(a.children)
                    .filter((t) => t && t.tagName && e.exec(t.tagName));
                  return t && Pt(t, `$${l.component}Controller`);
                },
                s = i.$watch(r, function (t) {
                  t && (wu(n, t, i, l), s());
                });
            }
            h(i);
          }
        );
      },
    };
  }
  vu.$inject = ["$compile", "$controller", "$transitions"];
  let bu = 0;
  function wu(t, e, n, r) {
    !k(e.$onInit) ||
      r.viewDecl.component ||
      r.viewDecl.componentProvider ||
      e.$onInit();
    const s = ec(r.path).state.self,
      i = { bind: e };
    if (k(e.uiOnParamsChanged)) {
      const o = new Uc(r.path).getResolvable("$transition$").data,
        a = (t) => {
          if (t === o || -1 !== t.exiting().indexOf(s)) return;
          const n = t.params("to"),
            r = t.params("from"),
            i = (t) => t.paramSchema,
            a = t.treeChanges("to").map(i).reduce(Wa, []),
            c = t.treeChanges("from").map(i).reduce(Wa, []),
            l = a.filter((t) => {
              const e = c.indexOf(t);
              return -1 === e || !c[e].type.equals(n[t.id], r[t.id]);
            });
          if (l.length) {
            const r = l.map((t) => t.id),
              s = Fa(n, (t, e) => -1 !== r.indexOf(e));
            e.uiOnParamsChanged(s, t);
          }
        };
      n.$on("$destroy", t.onSuccess({}, a, i));
    }
    if (k(e.uiCanExit)) {
      const r = bu++,
        o = "_uiCanExitIds",
        a = (t) => !!t && ((t[o] && !0 === t[o][r]) || a(t.redirectedFrom())),
        c = (t) => {
          let n;
          const s = (t[o] = t[o] || {});
          return (
            a(t) ||
              ((n = Promise.resolve(e.uiCanExit(t))),
              n.then((t) => (s[r] = !1 !== t))),
            n
          );
        },
        l = { exiting: s.name };
      n.$on("$destroy", t.onBefore(l, c, i));
    }
  }
  function Eu() {
    return {
      restrict: "EA",
      link: (t, e, n) => {
        const r = e.childNodes.length > 0,
          s = n.ngChannel,
          i = rl.subscribe(s, async (n) => {
            r ? w(n) && t.$merge(n) : (e.innerHTML = n);
          });
        t.$on("$destroy", () => {
          rl.unsubscribeByKey(i);
        });
      },
    };
  }
  function Cu(t) {
    return {
      restrict: "A",
      link(e, n, r) {
        const s = r.ngSetter;
        if (!s)
          return void console.warn(
            "ngSetter: Model expression is not provided.",
          );
        const i = t(s).assign;
        if (!i) return void console.warn("ngSetter: Invalid model expression.");
        const o = (t) => {
            i(e, t);
          },
          a = new MutationObserver((t) => {
            let e = !1;
            for (const n of t)
              if ("childList" === n.type || "characterData" === n.type) {
                e = !0;
                break;
              }
            e && o(n.innerHTML);
          });
        n && n
          ? (a.observe(n, { childList: !0, subtree: !0, characterData: !0 }),
            e.$on("$destroy", () => a.disconnect()),
            o(n.innerHTML))
          : console.warn("ngSetter: Element is not a valid DOM node.");
      },
    };
  }
  Cu.$inject = ["$parse"];
  const Ou = "0.7.0";
  const Au = dt("ng"),
    Su = dt("$injector"),
    xu = {};
  const ku = new (class {
    constructor() {
      vt.clear(),
        (this.Cache = vt),
        (this.EventBus = rl),
        (this.version = Ou),
        (this.bootsrappedModules = []),
        (this.getController = Ut),
        (this.getInjector = Wt),
        (this.getScope = Mt),
        (this.errorHandlingConfig = ht),
        (window.angular = this),
        (function (t) {
          t.module(
            "ng",
            [],
            [
              "$provide",
              (t) => {
                t.provider({ $$sanitizeUri: yo }),
                  t
                    .provider("$compile", en)
                    .directive({
                      input: Bn,
                      textarea: Bn,
                      form: ln,
                      script: Gn,
                      select: Yn,
                      option: Zn,
                      ngBind: Jn,
                      ngBindHtml: tr,
                      ngBindTemplate: Xn,
                      ngClass: ir,
                      ngClassEven: ar,
                      ngClassOdd: or,
                      ngCloak: cr,
                      ngController: lr,
                      ngDisabled: No,
                      ngForm: un,
                      ngHide: pr,
                      ngIf: fr,
                      ngInclude: $r,
                      ngInit: gr,
                      ngMessages: Eo,
                      ngMessage: So,
                      ngMessageExp: xo,
                      ngMessagesInclude: Ao,
                      ngMessageDefault: ko,
                      ngNonBindable: yr,
                      ngRef: br,
                      ngRepeat: Or,
                      ngSetter: Cu,
                      ngShow: dr,
                      ngStyle: Ar,
                      ngSwitch: Sr,
                      ngSwitchWhen: xr,
                      ngSwitchDefault: kr,
                      ngOptions: jr,
                      ngTransclude: Lr,
                      ngModel: vn,
                      ngChange: Nr,
                      pattern: Dr,
                      ngPattern: Dr,
                      required: Mr,
                      ngRequired: Mr,
                      ngMinlength: Ur,
                      minlength: Ur,
                      ngMaxlength: Ir,
                      maxlength: Ir,
                      ngValue: Wn,
                      ngModelOptions: $n,
                    })
                    .directive({
                      input: Kn,
                      ngAnimateSwap: Ca,
                      ngAnimateChildren: Oa,
                      ngChecked: Io,
                      ngClick: Mo,
                      ngDblclick: Bo,
                      ngInclude: mr,
                      ngHide: Ho,
                      ngShow: Vo,
                      ngMessages: Po,
                      ngModel: qo,
                      ngReadonly: Fo,
                      ngRequired: Do,
                      ngValue: Uo,
                      ngSref: $u,
                      ngSrefActive: gu,
                      ngSrefActiveEq: gu,
                      ngState: mu,
                      ngView: yu,
                      ngChannel: Eu,
                    })
                    .directive({ ngView: vu })
                    .directive(Pr)
                    .directive(He),
                  t.provider({
                    $aria: Lo,
                    $anchorScroll: qr,
                    $animate: Is,
                    $$animation: ca,
                    $animateCss: ta,
                    $$animateCssDriver: va,
                    $$animateJs: ia,
                    $$animateJsDriver: Ea,
                    $$animateCache: fa,
                    $$animateQueue: sa,
                    $$AnimateRunner: zs,
                    $$animateAsyncRun: qs,
                    $browser: Fs,
                    $controller: _e,
                    $exceptionHandler: Ys,
                    $filter: oi,
                    $interpolate: Si,
                    $http: qi,
                    $httpParamSerializer: Mi,
                    $httpBackend: Bi,
                    $location: Zi,
                    $log: ro,
                    $parse: yi,
                    $$rAFScheduler: la,
                    $rootScope: co,
                    $routerGlobals: hc,
                    $sce: Ue,
                    $sceDelegate: Ie,
                    $$taskTrackerFactory: fo,
                    $templateCache: Gs,
                    $templateRequest: go,
                    $urlConfig: cc,
                    $view: zc,
                    $transitions: Tl,
                    $state: Rl,
                    $ngViewScroll: Ll,
                    $templateFactory: Nl,
                    $urlService: Gl,
                    $stateRegistry: au,
                  });
              },
            ],
          )
            .factory("$stateParams", [
              "$routerGlobals",
              function (t) {
                return t.params;
              },
            ])
            .value("$trace", Sc)
            .info({ version: Ou });
        })(this);
    }
    bootstrap(t, e, n) {
      if (
        ((n = n || { strictDi: !1 }),
        (t instanceof Element || t instanceof Document) && Wt(t))
      )
        throw Au("btstrpd", "App already bootstrapped");
      Array.isArray(e) && (this.bootsrappedModules = e),
        this.bootsrappedModules.unshift([
          "$provide",
          (e) => {
            e.value("$rootElement", t);
          },
        ]),
        this.bootsrappedModules.unshift("ng");
      const r = we(this.bootsrappedModules, n.strictDi);
      return (
        r.invoke([
          "$rootScope",
          "$rootElement",
          "$compile",
          "$injector",
          (t, e, n, r) => {
            (this.$injector = r), Vt(e, "$injector", r);
            if ((n(e)(t), !Object.prototype.hasOwnProperty.call(r, "strictDi")))
              try {
                r.invoke(() => {});
              } catch (t) {
                r.strictDi = !!/strict mode/.exec(t && t.toString());
              }
            r.get("$stateRegistry")
              .get()
              .map((t) => t.$$state().resolvables)
              .reduce(Wa, [])
              .filter((t) => "deferred" === t.deps)
              .forEach((t) => (t.deps = Ce(t.resolveFn, r.strictDi)));
          },
        ]),
        r
      );
    }
    injector(t, e) {
      return we(t, e);
    }
    init(t) {
      let e, n;
      const r = {};
      it.forEach((r) => {
        const s = `${r}app`;
        t.hasAttribute &&
          t.hasAttribute(s) &&
          ((e = t), (n = t.getAttribute(s)));
      }),
        it.forEach((r) => {
          const s = `${r}app`;
          let i;
          !e &&
            (i = t.querySelector(`[${s.replace(":", "\\:")}]`)) &&
            ((e = i), (n = i.getAttribute(s)));
        }),
        e &&
          ((r.strictDi =
            null !==
            (function (t, e) {
              let n, r;
              const s = it.length;
              for (r = 0; r < s; ++r)
                if (((n = it[r] + e), E((n = t.getAttribute(n))))) return n;
              return null;
            })(e, "strict-di")),
          this.bootstrap(e, n ? [n] : [], r));
    }
    module(t, e, n) {
      return (
        W(t, "module"),
        e && Object.prototype.hasOwnProperty.call(xu, t) && (xu[t] = null),
        (function (t, e, n) {
          return t[e] || (t[e] = n());
        })(xu, t, () => {
          if (!e)
            throw Su(
              "nomod",
              "Module '{0}' is not available. Possibly misspelled or not loaded",
              t,
            );
          return new ee(t, e, n);
        })
      );
    }
  })();
  document.addEventListener("DOMContentLoaded", () => ku.init(document), {
    once: !0,
  }),
    (t.angular = ku);
});
