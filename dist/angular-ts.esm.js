/* Version: 0.7.0 - June 2, 2025 00:44:52 */
const VALID_CLASS = "ng-valid";
const INVALID_CLASS = "ng-invalid";
const PRISTINE_CLASS = "ng-pristine";
const DIRTY_CLASS = "ng-dirty";
const UNTOUCHED_CLASS = "ng-untouched";
const TOUCHED_CLASS = "ng-touched";
const EMPTY_CLASS = "ng-empty";
const NOT_EMPTY_CLASS = "ng-not-empty";

// x prefix is being kept for view-directive.spec lines 1550, 565
const PREFIX_REGEXP = /^((?:x|data)[-])/i;
const SPECIAL_CHARS_REGEXP = /[-]+(.)/g;

const ALIASED_ATTR = {
  ngMinlength: "minlength",
  ngMaxlength: "maxlength",
  ngMin: "min",
  ngMax: "max",
  ngPattern: "pattern",
  ngStep: "step",
};

const isProxySymbol = Symbol("isProxy");

/**
 *
 * @param {*} value
 * @returns {boolean}
 */
function isProxy(value) {
  if (value && value[isProxySymbol]) {
    return true;
  }
  return false;
}

const ngMinErr$2 = minErr("ng");

/**
 * @type {number}
 */
let uid$1 = 0;

/**
 * @returns {number} an unique alpha-numeric string
 */
function nextUid() {
  uid$1 += 1;
  return uid$1;
}

/**
 *
 * @description Converts the specified string to lowercase.
 * @param {string} string String to be converted to lowercase.
 * @returns {string} Lowercased string.
 */
function lowercase(string) {
  return isString(string) ? string.toLowerCase() : string;
}

/**
 *
 * @description Converts the specified string to uppercase.
 * @param {string} string String to be converted to uppercase.
 * @returns {string} Uppercased string.
 */
function uppercase(string) {
  return isString(string) ? string.toUpperCase() : string;
}

/**
 * @param {*} obj
 * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
 *                   String ...)
 */
function isArrayLike(obj) {
  // `null`, `undefined` and `window` are not array-like
  if (obj == null || isWindow(obj)) return false;

  // arrays, strings and jQuery/jqLite objects are array like
  // * we have to check the existence of JQLite first as this method is called
  //   via the forEach method when constructing the JQLite object in the first place
  if (Array.isArray(obj) || obj instanceof Array || isString(obj)) return true;

  // Support: iOS 8.2 (not reproducible in simulator)
  // "length" in obj used to prevent JIT error (gh-11508)
  const length = "length" in Object(obj) && obj.length;

  // NodeList objects (with `item` method) and
  // other objects with suitable length characteristics are array-like
  return (
    isNumber(length) &&
    ((length >= 0 && length - 1 in obj) || typeof obj.item === "function")
  );
}

/**
 * Determines if a reference is undefined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is undefined.
 */
function isUndefined(value) {
  return typeof value === "undefined";
}

/**
 * Determines if a reference is defined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is defined.
 */
function isDefined(value) {
  return typeof value !== "undefined";
}

/**
 * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
 * considered to be objects. Note that JavaScript arrays are objects.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is an `Object` but not `null`.
 */
function isObject(value) {
  // http://jsperf.com/isobject4
  return value !== null && typeof value === "object";
}

/**
 * Determines if a reference is a `String`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `String`.
 */
function isString(value) {
  return typeof value === "string";
}

/**
 * Determines if a reference is a null.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a null.
 */
function isNull(value) {
  return value === null;
}

/**
 * Determines if a reference is null or undefined.
 *
 * @param {*} obj Reference to check.
 * @returns {boolean} True if `value` is null or undefined.
 */
function isNullOrUndefined(obj) {
  return obj === null || typeof obj === "undefined";
}

/**
 * Determines if a reference is a `Number`.
 *
 * This includes the "special" numbers `NaN`, `+Infinity` and `-Infinity`.
 *
 * If you wish to exclude these then you can use the native
 * [`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)
 * method.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Number`.
 */
function isNumber(value) {
  return typeof value === "number";
}

/**
 * @module angular
 * @function isDate
 *
 * @description
 * Determines if a value is a date.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Date`.
 */
function isDate(value) {
  return toString.call(value) === "[object Date]";
}

/**
 * Determines if a reference is an `Error`.
 * Loosely based on https://www.npmjs.com/package/iserror
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is an `Error`.
 */
function isError(value) {
  const tag = toString.call(value);
  switch (tag) {
    case "[object Error]":
      return true;
    case "[object Exception]":
      return true;
    case "[object DOMException]":
      return true;
    default:
      return value instanceof Error;
  }
}

/**
 * Determines if a reference is a `Function`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Function`.
 */
function isFunction(value) {
  return typeof value === "function";
}

/**
 * Determines if a value is a regular expression object.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `RegExp`.
 */
function isRegExp(value) {
  return toString.call(value) === "[object RegExp]";
}

/**
 * Checks if `obj` is a window object.
 *
 * @param {*} obj Object to check
 * @returns {boolean} True if `obj` is a window obj.
 */
function isWindow(obj) {
  return obj && obj.window === obj;
}

/**
 * @param {*} obj
 * @returns {boolean}
 */
function isScope(obj) {
  return obj && obj.$evalAsync && obj.$watch;
}

/**
 * @param {*} obj
 * @returns {boolean}
 */
function isFile(obj) {
  return toString.call(obj) === "[object File]";
}

/**
 * @param {*} obj
 * @returns {boolean}
 */
function isFormData(obj) {
  return toString.call(obj) === "[object FormData]";
}

/**
 * @param {*} obj
 * @returns {boolean}
 */
function isBlob(obj) {
  return toString.call(obj) === "[object Blob]";
}

/**
 * @param {*} value
 * @returns {boolean}
 */
function isBoolean(value) {
  return typeof value === "boolean";
}

/**
 * @param {*} obj
 * @returns {boolean}
 */
function isPromiseLike(obj) {
  return obj && isFunction(obj.then);
}

/**
 * @param {*} value
 * @returns {string | *}
 */
function trim(value) {
  return isString(value) ? value.trim() : value;
}

function snakeCase(name, separator) {
  const modseparator = separator;
  return name.replace(
    /[A-Z]/g,
    (letter, pos) => (pos ? modseparator : "") + letter.toLowerCase(),
  );
}

/**
 * Set or clear the hashkey for an object.
 * @param obj object
 * @param h the hashkey (!truthy to delete the hashkey)
 */
function setHashKey(obj, h) {
  if (h) {
    obj.$$hashKey = h;
  } else {
    delete obj.$$hashKey;
  }
}

function baseExtend(dst, objs, deep) {
  const h = dst.$$hashKey;

  for (let i = 0, ii = objs.length; i < ii; ++i) {
    const obj = objs[i];
    if (!isObject(obj) && !isFunction(obj)) continue;
    const keys = Object.keys(obj);
    for (let j = 0, jj = keys.length; j < jj; j++) {
      const key = keys[j];
      const src = obj[key];

      {
        dst[key] = src;
      }
    }
  }

  setHashKey(dst, h);
  return dst;
}

/**
 * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)
 * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so
 * by passing an empty object as the target: `let object = angular.extend({}, object1, object2)`.
 *
 * **Note:** Keep in mind that `angular.extend` does not support recursive merge (deep copy). Use
 * {@link angular.merge} for this.
 *
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
function extend(dst, ...src) {
  return baseExtend(dst, src);
}

/**
 * @param {string} str
 * @returns {number}
 */
function toInt(str) {
  return parseInt(str, 10);
}

/**
 * @param {any} num
 * @returns {boolean}
 */
function isNumberNaN(num) {
  return Number.isNaN(num);
}

/**
 * @param {Object} parent
 * @param {Object} extra
 * @returns {Object}
 */
function inherit$1(parent, extra) {
  return extend(Object.create(parent), extra);
}

function hasCustomToString(obj) {
  return isFunction(obj.toString) && obj.toString !== toString;
}

/**
 * @module angular
 * @function isElement

 * @function
 *
 * @description
 * Determines if a reference is a DOM element (or wrapped jQuery element).
 *
 * @param {*} node Reference to check.
 * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).
 */
function isElement(node) {
  return !!(
    node &&
    (node.nodeName || // We are a direct element.
      (node.attr && node.find))
  ); // We have an on and find method part of jQuery API.
}

/**
 * Returns a string appropriate for the type of node.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Node/nodeName)
 *
 * @param {Element} element
 * @returns
 */
function getNodeName(element) {
  return lowercase(element.nodeName);
}

function includes(array, obj) {
  return Array.prototype.indexOf.call(array, obj) !== -1;
}

/**
 * Removes the first occurrence of a specified value from an array.
 *
 * @template T
 * @param {Array<T>} array - The array from which to remove the value.
 * @param {T} value - The value to remove.
 * @returns {number} - The index of the removed value, or -1 if the value was not found.
 */
function arrayRemove(array, value) {
  const index = array.indexOf(value);
  if (index >= 0) {
    array.splice(index, 1);
  }
  return index;
}

function simpleCompare(a, b) {
  return a === b || (a !== a && b !== b);
}

/**
 * Determines if two objects or two values are equivalent. Supports value types, regular
 * expressions, arrays and objects.
 *
 * Two objects or values are considered equivalent if at least one of the following is true:
 *
 * * Both objects or values pass `===` comparison.
 * * Both objects or values are of the same type and all of their properties are equal by
 *   comparing them with `angular.equals`.
 * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)
 * * Both values represent the same regular expression (In JavaScript,
 *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
 *   representation matches).
 *
 * During a property comparison, properties of `function` type and properties with names
 * that begin with `$` are ignored.
 *
 * Scope and DOMWindow objects are being compared only by identify (`===`).
 *
 * @param {*} o1 Object or value to compare.
 * @param {*} o2 Object or value to compare.
 * @returns {boolean} True if arguments are equal.
 *
 * @example
   <example module="equalsExample" name="equalsExample">
     <file name="index.html">
      <div ng-controller="ExampleController">
        <form novalidate>
          <h3>User 1</h3>
          Name: <input type="text" ng-model="user1.name">
          Age: <input type="number" ng-model="user1.age">

          <h3>User 2</h3>
          Name: <input type="text" ng-model="user2.name">
          Age: <input type="number" ng-model="user2.age">

          <div>
            <br/>
            <input type="button" value="Compare" ng-click="compare()">
          </div>
          User 1: <pre>{{user1 | json}}</pre>
          User 2: <pre>{{user2 | json}}</pre>
          Equal: <pre>{{result}}</pre>
        </form>
      </div>
    </file>
    <file name="script.js">
        angular.module('equalsExample', []).controller('ExampleController', ['$scope', function($scope) {
          $scope.user1 = {};
          $scope.user2 = {};
          $scope.compare = function() {
            $scope.result = angular.equals($scope.user1, $scope.user2);
          };
        }]);
    </file>
  </example>
 */
function equals$1(o1, o2) {
  if (o1 === o2) return true;
  if (o1 === null || o2 === null) return false;

  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
  const t1 = typeof o1;
  const t2 = typeof o2;
  let length;
  let key;
  let keySet;
  if (t1 === t2 && t1 === "object") {
    if (Array.isArray(o1)) {
      if (!Array.isArray(o2)) return false;
      if ((length = o1.length) === o2.length) {
        for (key = 0; key < length; key++) {
          if (!equals$1(o1[key], o2[key])) return false;
        }
        return true;
      }
    } else if (isDate(o1)) {
      if (!isDate(o2)) return false;
      return simpleCompare(o1.getTime(), o2.getTime());
    } else if (isRegExp(o1)) {
      if (!isRegExp(o2)) return false;
      return o1.toString() === o2.toString();
    } else {
      if (
        isScope(o1) ||
        isScope(o2) ||
        isWindow(o1) ||
        isWindow(o2) ||
        Array.isArray(o2) ||
        isDate(o2) ||
        isRegExp(o2)
      )
        return false;
      keySet = Object.create(null);
      for (key in o1) {
        if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
        if (!equals$1(o1[key], o2[key])) return false;
        keySet[key] = true;
      }
      for (key in o2) {
        if (
          !(key in keySet) &&
          key.charAt(0) !== "$" &&
          isDefined(o2[key]) &&
          !isFunction(o2[key])
        )
          return false;
      }
      return true;
    }
  }
  return false;
}

/**
 * throw error if the name given is hasOwnProperty
 * @param  {string} name    the name to test
 * @param  {string} context the context in which the name is used, such as module or directive
 */
function assertNotHasOwnProperty(name, context) {
  if (name === "hasOwnProperty") {
    throw ngMinErr$2(
      "badname",
      "hasOwnProperty is not a valid {0} name",
      context,
    );
  }
}

function stringify$1(value) {
  if (value == null) {
    // null || undefined
    return "";
  }
  switch (typeof value) {
    case "string":
      break;
    case "number":
      value = `${value}`;
      break;
    default:
      if (hasCustomToString(value) && !Array.isArray(value) && !isDate(value)) {
        value = value.toString();
      } else {
        value = toJson(value);
      }
  }

  return value;
}

/**
 * @param {Number} maxDepth
 * @return {boolean}
 */
function isValidObjectMaxDepth(maxDepth) {
  return isNumber(maxDepth) && maxDepth > 0;
}

function concat(array1, array2, index) {
  return array1.concat(Array.prototype.slice.call(array2, index));
}

function sliceArgs(args, startIndex) {
  return Array.prototype.slice.call(args, startIndex);
}

/**
 * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
 * `fn`). You can supply optional `args` that are prebound to the function. This feature is also
 * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as
 * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).
 *
 * @param {Object} context Context which `fn` should be evaluated in.
 * @param {*} fn Function to be bound.
 * @returns {Function} Function that wraps the `fn` with all the specified bindings.
 */
function bind(context, fn) {
  const curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
  if (isFunction(fn) && !(fn instanceof RegExp)) {
    return curryArgs.length
      ? function () {
          return arguments.length
            ? fn.apply(context, concat(curryArgs, arguments, 0))
            : fn.apply(context, curryArgs);
        }
      : function () {
          return arguments.length
            ? fn.apply(context, arguments)
            : fn.call(context);
        };
  }
  // In IE, native methods are not functions so they cannot be bound (note: they don't need to be).
  return fn;
}

function toJsonReplacer(key, value) {
  let val = value;

  if (
    typeof key === "string" &&
    key.charAt(0) === "$" &&
    key.charAt(1) === "$"
  ) {
    val = undefined;
  } else if (isWindow(value)) {
    val = "$WINDOW";
  } else if (value && window.document === value) {
    val = "$DOCUMENT";
  } else if (isScope(value)) {
    val = "$SCOPE";
  }

  return val;
}

/**
 * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be
 * stripped since AngularJS uses this notation internally.
 *
 * @param {Object|Array|Date|string|number|boolean} obj Input to be serialized into JSON.
 * @param {boolean|number} [pretty=2] If set to true, the JSON output will contain newlines and whitespace.
 *    If set to an integer, the JSON output will contain that many spaces per indentation.
 * @returns {string|undefined} JSON-ified string representing `obj`.
 * @knownIssue
 *
 * The Safari browser throws a `RangeError` instead of returning `null` when it tries to stringify a `Date`
 * object with an invalid date value. The only reliable way to prevent this is to monkeypatch the
 * `Date.prototype.toJSON` method as follows:
 *
 * ```
 * let _DatetoJSON = Date.prototype.toJSON;
 * Date.prototype.toJSON = function() {
 *   try {
 *     return _DatetoJSON.call(this);
 *   } catch(e) {
 *     if (e instanceof RangeError) {
 *       return null;
 *     }
 *     throw e;
 *   }
 * };
 * ```
 *
 * See https://github.com/angular/angular.js/pull/14221 for more information.
 */
function toJson(obj, pretty) {
  if (isUndefined(obj)) return undefined;
  if (!isNumber(pretty)) {
    pretty = pretty ? 2 : null;
  }
  return JSON.stringify(obj, toJsonReplacer, /** @type {Number} */ (pretty));
}

/**
 * Deserializes a JSON string.
 *
 * @param {string} json JSON string to deserialize.
 * @returns {Object|Array|string|number} Deserialized JSON string.
 */
function fromJson(json) {
  return isString(json) ? JSON.parse(json) : json;
}

function timezoneToOffset(timezone, fallback) {
  const requestedTimezoneOffset =
    Date.parse(`Jan 01, 1970 00:00:00 ${timezone}`) / 60000;
  return isNumberNaN(requestedTimezoneOffset)
    ? fallback
    : requestedTimezoneOffset;
}

function addDateMinutes(date, minutes) {
  const newDate = new Date(date.getTime());
  newDate.setMinutes(newDate.getMinutes() + minutes);
  return newDate;
}

function convertTimezoneToLocal(date, timezone, reverse) {
  const doReverse = 1;
  const dateTimezoneOffset = date.getTimezoneOffset();
  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
  return addDateMinutes(
    date,
    doReverse * (timezoneOffset - dateTimezoneOffset),
  );
}

/**
 * Parses an escaped url query string into key-value pairs.
 * @param {string} keyValue
 * @returns {Object.<string,boolean|Array>}
 */
function parseKeyValue(keyValue) {
  const obj = {};
  (keyValue || "").split("&").forEach((keyValue) => {
    let splitPoint;
    let key;
    let val;
    if (keyValue) {
      key = keyValue = keyValue.replace(/\+/g, "%20");
      splitPoint = keyValue.indexOf("=");
      if (splitPoint !== -1) {
        key = keyValue.substring(0, splitPoint);
        val = keyValue.substring(splitPoint + 1);
      }
      key = tryDecodeURIComponent(key);
      if (isDefined(key)) {
        val = isDefined(val) ? tryDecodeURIComponent(val) : true;
        if (!Object.hasOwnProperty.call(obj, key)) {
          obj[key] = val;
        } else if (Array.isArray(obj[key])) {
          obj[key].push(val);
        } else {
          obj[key] = [obj[key], val];
        }
      }
    }
  });
  return /** @type {Object.<string,boolean|Array>} */ (obj);
}

function toKeyValue(obj) {
  const parts = [];
  obj &&
    Object.entries(obj).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((arrayValue) => {
          parts.push(
            encodeUriQuery(key, true) +
              (arrayValue === true
                ? ""
                : `=${encodeUriQuery(arrayValue, true)}`),
          );
        });
      } else {
        parts.push(
          encodeUriQuery(key, true) +
            (value === true ? "" : `=${encodeUriQuery(value, true)}`),
        );
      }
    });
  return parts.length ? parts.join("&") : "";
}

/**
 * Tries to decode the URI component without throwing an exception.
 *
 * @param  {string} value potential URI component to check.
 * @returns {string}
 */
function tryDecodeURIComponent(value) {
  try {
    return decodeURIComponent(value);
  } catch (e) {
  }
}

/**
 * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
 * segments:
 *    segment       = *pchar
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriSegment(val) {
  return encodeUriQuery(val, true)
    .replace(/%26/gi, "&")
    .replace(/%3D/gi, "=")
    .replace(/%2B/gi, "+");
}

/**
 * This method is intended for encoding *key* or *value* parts of query component. We need a custom
 * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
 * encoded per http://tools.ietf.org/html/rfc3986:
 *    query         = *( pchar / "/" / "?" )
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriQuery(val, pctEncodeSpaces) {
  return encodeURIComponent(val)
    .replace(/%40/gi, "@")
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",")
    .replace(/%3B/gi, ";")
    .replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
}

const ngAttrPrefixes = ["ng-", "data-ng-"];

function getNgAttribute(element, ngAttr) {
  let attr;
  let i;
  const ii = ngAttrPrefixes.length;
  for (i = 0; i < ii; ++i) {
    attr = ngAttrPrefixes[i] + ngAttr;
    if (isString((attr = element.getAttribute(attr)))) {
      return attr;
    }
  }
  return null;
}

/**
 * Creates a shallow copy of an object, an array or a primitive.
 *
 * Assumes that there are no proto properties for objects.
 */
function shallowCopy(src, dst) {
  if (Array.isArray(src)) {
    dst = dst || [];

    for (let i = 0, ii = src.length; i < ii; i++) {
      dst[i] = src[i];
    }
  } else if (isObject(src)) {
    dst = dst || {};

    for (const key in src) {
      if (!(key.startsWith("$") && key.charAt(1) === "$")) {
        dst[key] = src[key];
      }
    }
  }

  return dst || src;
}

/**
 * Throw error if the argument is false
 * @param {boolean} argument
 * @param {string} errorMsg
 */
function assert(argument, errorMsg = "Assertion failed") {
  if (!argument) throw new Error(errorMsg);
}

/**
 * Throw error if the argument is falsy.
 */
function assertArg$1(arg, name, reason) {
  if (!arg) {
    throw ngMinErr$2(
      "areq",
      "Argument '{0}' is {1}",
      name || "?",
      reason || "required",
    );
  }
  return arg;
}

function assertArgFn(arg, name, acceptArrayAnnotation) {
  if (acceptArrayAnnotation && Array.isArray(arg)) {
    arg = arg[arg.length - 1];
  }

  assertArg$1(
    isFunction(arg),
    name,
    `not a function, got ${
      arg && typeof arg === "object"
        ? arg.constructor.name || "Object"
        : typeof arg
    }`,
  );
  return arg;
}

/**
 * @typedef {Object} ErrorHandlingConfig
 * Error configuration object. May only contain the options that need to be updated.
 * @property {number=} objectMaxDepth - The max depth for stringifying objects. Setting to a
 *   non-positive or non-numeric value removes the max depth limit. Default: 5.
 * @property {boolean=} urlErrorParamsEnabled - Specifies whether the generated error URL will
 *   contain the parameters of the thrown error. Default: true. When used without argument, it returns the current value.
 */

/** @type {ErrorHandlingConfig} */
const minErrConfig = {
  objectMaxDepth: 5,
  urlErrorParamsEnabled: true,
};

/**
 * Configure several aspects of error handling if used as a setter or return the
 * current configuration if used as a getter.
 *
 * Omitted or undefined options will leave the corresponding configuration values unchanged.
 *
 * @param {ErrorHandlingConfig} [config]
 * @returns {ErrorHandlingConfig}
 */
function errorHandlingConfig(config) {
  if (isObject(config)) {
    if (isDefined(config.objectMaxDepth)) {
      minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth)
        ? config.objectMaxDepth
        : NaN;
    }
    if (
      isDefined(config.urlErrorParamsEnabled) &&
      isBoolean(config.urlErrorParamsEnabled)
    ) {
      minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled;
    }
  }
  return minErrConfig;
}

/**
 * This object provides a utility for producing rich Error messages within
 * AngularJS. It can be called as follows:
 *
 * let exampleMinErr = minErr('example');
 * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);
 *
 * The above creates an instance of minErr in the example namespace. The
 * resulting error will have a namespaced error code of example.one.  The
 * resulting error will replace {0} with the value of foo, and {1} with the
 * value of bar. The object is not restricted in the number of arguments it can
 * take.
 *
 * If fewer arguments are specified than necessary for interpolation, the extra
 * interpolation markers will be preserved in the final string.
 *
 * Since data will be parsed statically during a build step, some restrictions
 * are applied with respect to how minErr instances are created and called.
 * Instances should have names of the form namespaceMinErr for a minErr created
 * using minErr('namespace'). Error codes, namespaces and template strings
 * should all be static strings, not variables or general expressions.
 *
 * @param {string} module The namespace to use for the new minErr instance.
 * @returns {function(string, ...*): Error} minErr instance
 */
function minErr(module) {
  const url = 'https://errors.angularjs.org/"NG_VERSION_FULL"/';
  const regex = `${url.replace(".", "\\.")}[\\s\\S]*`;
  const errRegExp = new RegExp(regex, "g");

  return function (...args) {
    const code = args[0];
    const template = args[1];
    let message = `[${module ? `${module}:` : ""}${code}] `;
    const templateArgs = sliceArgs(args, 2).map((arg) => toDebugString(arg));
    let paramPrefix;
    let i;

    // A minErr message has two parts: the message itself and the url that contains the
    // encoded message.
    // The message's parameters can contain other error messages which also include error urls.
    // To prevent the messages from getting too long, we strip the error urls from the parameters.

    message += template.replace(/\{\d+\}/g, (match) => {
      const index = +match.slice(1, -1);

      if (index < templateArgs.length) {
        return templateArgs[index].replace(errRegExp, "");
      }

      return match;
    });

    message += `\n${url}${module ? `${module}/` : ""}${code}`;

    if (errorHandlingConfig().urlErrorParamsEnabled) {
      for (
        i = 0, paramPrefix = "?";
        i < templateArgs.length;
        i++, paramPrefix = "&"
      ) {
        message += `${paramPrefix}p${i}=${encodeURIComponent(templateArgs[i])}`;
      }
    }
    return new Error(message);
  };
}

function toDebugString(obj) {
  if (typeof obj === "function") {
    return obj.toString().replace(/ \{[\s\S]*$/, "");
  }
  if (isUndefined(obj)) {
    return "undefined";
  }
  if (typeof obj !== "string") {
    const seen = [];
    let copyObj = structuredClone(isProxy(obj) ? obj.$target : obj);
    return JSON.stringify(copyObj, (key, val) => {
      const replace = toJsonReplacer(key, val);
      if (isObject(replace)) {
        if (seen.indexOf(replace) >= 0) return "...";

        seen.push(replace);
      }
      return replace;
    });
  }
  return obj;
}

/**
 * Computes a hash of an 'obj'.
 * Hash of a:
 *  string is string
 *  number is number as string
 *  object is either result of calling $$hashKey function on the object or uniquely generated id,
 *         that is also assigned to the $$hashKey property of the object.
 *
 * @param {*} obj
 * @returns {string} hash string such that the same input will have the same hash string.
 *         The resulting string key is in 'type:hashKey' format.
 */
function hashKey(obj) {
  const key = obj && obj.$$hashKey;

  if (key) {
    if (typeof key === "function") {
      return obj.$$hashKey();
    }
    return key;
  }

  const objType = typeof obj;
  if (objType === "function" || (objType === "object" && obj !== null)) {
    obj.$$hashKey = `${objType}:${nextUid()}`;
    return obj.$$hashKey;
  }

  if (objType === "undefined") {
    return `${objType}:${nextUid()}`;
  }
  // account for primitives
  return `${objType}:${obj}`;
}

function mergeClasses$1(a, b) {
  if (!a && !b) return "";
  if (!a) return b;
  if (!b) return a;
  if (Array.isArray(a)) a = a.join(" ");
  if (Array.isArray(b)) b = b.join(" ");
  return a + " " + b;
}

/**
 * Converts all accepted directives format into proper directive name.
 * @param {string} name Name to normalize
 * @returns {string}
 */

function directiveNormalize(name) {
  return name
    .replace(PREFIX_REGEXP, "")
    .replace(SPECIAL_CHARS_REGEXP, (_, letter, offset) =>
      offset ? letter.toUpperCase() : letter,
    );
}

/**
 * Whether element should be animated
 * @param {Node} node
 * @returns {boolean}
 */
function hasAnimate(node) {
  return hasCustomOrDataAttribute(node, "animate");
}

/**
 * @param {Node} node
 * @param {string} attr
 * @returns {boolean}
 */
function hasCustomOrDataAttribute(node, attr) {
  if (node.nodeType !== Node.ELEMENT_NODE) return false;
  const element = /** @type {HTMLElement} */ (node);
  return (
    element.dataset[attr] === "true" || element.getAttribute(attr) === "true"
  );
}

/**
 * @param {Object|null|undefined} obj
 * @returns {boolean}
 */
function isObjectEmpty(obj) {
  if (!obj) return true;
  return !Object.keys(obj).length;
}

/**
 * @typedef {Object} ExpandoStore
 *
 * @property {!Object<string, any>} data
 * @property {!Object} events
 * @property {?Function} handle
 *
 */

const EXPANDO = "ng";

/**
 * Expando cache for adding properties to DOM nodes with JavaScript.
 * This used to be an Object in JQLite decorator, but swapped out for a Map
 * for performance reasons and convenience methods. A proxy is available for
 * additional logic handling.
 *
 * @type {Map<number, ExpandoStore>}
 */
const Cache = new Map();

/**
 * Key for storing scope data, attached to an element
 */
const SCOPE_KEY = "$scope";

/**
 * Key for storing isolate scope data, attached to an element
 */
const ISOLATE_SCOPE_KEY = "$isolateScope";

/** @type {number} */
let jqId = 1;

const DASH_LOWERCASE_REGEXP = /-([a-z])/g;
const UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;

/**
 * A list of boolean attributes in HTML.
 * @type {string[]}
 */
const BOOLEAN_ATTR = [
  "multiple",
  "selected",
  "checked",
  "disabled",
  "readonly",
  "required",
  "open",
];

/**
 * A list of boolean attributes in HTML
 * @type {string[]}
 */
const BOOLEAN_ELEMENTS = [
  "INPUT",
  "SELECT",
  "OPTION",
  "TEXTAREA",
  "BUTTON",
  "FORM",
  "DETAILS",
];

///////////////////////////////////////////////////////////////////
////////////        HELPER FUNCTIONS      /////////////////////////
///////////////////////////////////////////////////////////////////

/**
 *
 * @returns {number} Next unique JQInstance id
 */
function jqNextId() {
  return ++jqId;
}

/**
 * @param {string} _all
 * @param {string} letter
 * @returns {string}
 */
function fnCamelCaseReplace(_all, letter) {
  return letter.toUpperCase();
}

/**
 * Converts kebab-case to camelCase.
 * @param {string} name Name to normalize
 * @returns {string}
 */
function kebabToCamel(name) {
  return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
}

/**
 * Converts sname to camelCase.
 * @param {string} name
 * @returns {string}
 */
function snakeToCamel(name) {
  return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
}

/**
 * Removes expando data from this element. If key is provided, only
 * its field is removed. If data is empty, also removes `ExpandoStore`
 * from cache.
 * @param {Element} element
 * @param {string} [name] - key of field to remove
 */
function removeElementData(element, name) {
  const expandoId = element[EXPANDO];
  const expandoStore = expandoId && Cache.get(expandoId);

  if (expandoStore) {
    if (name) {
      delete expandoStore.data[name];
    } else {
      expandoStore.data = {};
    }

    removeIfEmptyData(element);
  }
}

/**
 * Stores data associated with an element inside the expando property of the DOM element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Expando MDN Glossary: Expando}
 *
 * @param {Element} element
 * @param {boolean} [createIfNecessary=false]
 * @returns {import("../core/cache/cache.js").ExpandoStore}
 */
function getExpando(element, createIfNecessary = false) {
  let expandoId = element[EXPANDO];
  let expandoStore = expandoId && Cache.get(expandoId);

  if (createIfNecessary && !expandoStore) {
    element[EXPANDO] = expandoId = jqNextId();
    expandoStore = {
      events: {},
      data: {},
      handle: null,
    };
    Cache.set(expandoId, expandoStore);
  }

  return expandoStore;
}

/**
 * Checks if the string contains HTML tags or entities.
 * @param {string} html
 * @returns {boolean} True if the string is plain text, false if it contains HTML tags or entities.
 */
function isTextNode(html) {
  return !/<|&#?\w+;/.test(html);
}

/**
 * Check if element can accept expando data
 * @param {Element} node
 * @returns {boolean}
 */
function elementAcceptsData(node) {
  // The window object can accept data but has no nodeType
  // Otherwise we are only interested in elements (1) and documents (9)
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
    case Node.DOCUMENT_NODE:
    case Node.COMMENT_NODE:
    case undefined: // window.object
      return true;
    default:
      return false;
  }
}

/**
 * @param {Element} element
 * @param {boolean} [onlyDescendants]
 * @returns {void}
 */
function dealoc(element, onlyDescendants) {
  if (!element) return;
  if (Array.isArray(element)) {
    element.forEach((x) => dealoc(x, onlyDescendants));
  } else {
    if (!onlyDescendants && elementAcceptsData(element)) {
      cleanElementData([element]);
    }

    if (elementAcceptsData(element)) {
      cleanElementData(element.querySelectorAll("*"));
    }
  }
  delete element[EXPANDO];
  element.innerHTML = "";
}

/**
 * If `ExpandoStore.data` and `ExpandoStore.events` are empty,
 * then delete element's `ExpandoStore` and set its `ExpandoId`
 * to undefined.
 * @param {Element} element
 */
function removeIfEmptyData(element) {
  const expandoId = element[EXPANDO];
  const { events, data } = Cache.get(expandoId);

  if (
    (!data || !Object.keys(data).length) &&
    (!events || !Object.keys(events).length)
  ) {
    Cache.delete(expandoId);
    element[EXPANDO] = undefined; // don't delete DOM expandos. Chrome don't like it
  }
}

/**
 * Gets or sets cache data for a given element.
 *
 * @param {Element} element - The DOM element to get or set data on.
 * @param {string|Object} key - The key (as a string) to get/set or an object for mass-setting.
 * @param {*} [value] - The value to set. If not provided, the function acts as a getter.
 * @returns {*} - The retrieved data if acting as a getter. Otherwise, returns undefined.
 */
function getOrSetCacheData(element, key, value) {
  if (elementAcceptsData(element)) {
    let prop;

    const isSimpleSetter = isDefined(value);
    const isSimpleGetter = !isSimpleSetter && key && !isObject(key);
    const massGetter = !key;
    const expandoStore = getExpando(element, !isSimpleGetter);
    const data = expandoStore && expandoStore.data;

    if (isSimpleSetter) {
      data[kebabToCamel(key)] = value;
    } else {
      if (massGetter) {
        return data;
      }
      if (isSimpleGetter) {
        // don't force creation of expandoStore if it doesn't exist yet
        return data && data[kebabToCamel(key)];
      }
      // mass-setter: data({key1: val1, key2: val2})
      for (prop in key) {
        data[kebabToCamel(prop)] = key[prop];
      }
    }
  }
}

/**
 * Sets cache data for a given element.
 *
 * @param {Element|Node} element - The DOM element to get or set data on.
 * @param {string} key - The key (as a string) to get/set or an object for mass-setting.
 * @param {*} [value] - The value to set. If not provided, the function acts as a getter.
 * @returns
 */
function setCacheData(element, key, value) {
  if (elementAcceptsData(element)) {
    const expandoStore = getExpando(element, true);
    const data = expandoStore && expandoStore.data;
    data[kebabToCamel(key)] = value;
  } else {
    if (element.parentElement) {
      // TODO: check should occur perhaps prior at compilation level that this is a valid element
      setCacheData(element.parentElement, key, value);
    }
  }
}

/**
 * Gets cache data for a given element.
 *
 * @param {Element} element - The DOM element to get data from.
 * @param {string} [key] - The key (as a string) to retrieve. If not provided, returns all data.
 * @returns {*} - The retrieved data for the given key or all data if no key is provided.
 */
function getCacheData(element, key) {
  if (elementAcceptsData(element)) {
    const expandoStore = getExpando(element, false); // Don't create if it doesn't exist
    const data = expandoStore && expandoStore.data;
    if (!key) {
      return undefined;
    }
    return data && data[kebabToCamel(key)];
  }
  return undefined;
}

/**
 * Deletes cache data for a given element for a particular key.
 *
 * @param {Element} element - The DOM element to delete data from.
 * @param {string} key - The key (as a string) to delete.
 * @returns void
 */
function deleteCacheData(element, key) {

  if (elementAcceptsData(element)) {
    const expandoStore = getExpando(element, false); // Don't create if it doesn't exist
    const data = expandoStore?.data;

    if (data && Object.prototype.hasOwnProperty.call(data, kebabToCamel(key))) {
      delete data[kebabToCamel(key)];
    }
  }
}
/**
 * Gets scope for a given element.
 *
 * @param {Element} element - The DOM element to get data from.
 * @returns {*} - The retrieved data for the given key or all data if no key is provided.
 */
function getScope(element) {
  return getCacheData(element, SCOPE_KEY);
}

/**
 * Set scope for a given element.
 *
 * @param {Element|Node|ChildNode} element - The DOM element to set data on.
 * @param {import("../core/scope/scope.js").Scope} scope - The Scope attached to this element
 */
function setScope(element, scope) {
  return setCacheData(element, SCOPE_KEY, scope);
}

/**
 * Set isolate scope for a given element.
 *
 * @param {Element} element - The DOM element to set data on.
 * @param {import("../core/scope/scope.js").Scope} scope - The Scope attached to this element
 */
function setIsolateScope(element, scope) {
  return setCacheData(element, ISOLATE_SCOPE_KEY, scope);
}

/**
 * Gets the controller instance for a given element, if exists. Defaults to "ngControllerController"
 *
 * @param {Element} element - The DOM element to get data from.
 * @param {string} [name] - The DOM element to get data from.
 * @returns {import("../core/scope/scope.js").Scope|undefined} - The retrieved data
 */
function getController(element, name) {
  return getInheritedData(element, `$${name || "ngController"}Controller`);
}

/**
 *
 * @param {Node} element
 * @param {string} name
 * @returns
 */
function getInheritedData(element, name) {
  // if element is the document object work with the html element instead
  // this makes $(document).scope() possible
  if (element.nodeType === Node.DOCUMENT_NODE) {
    element = /** @type {Document} */ (element).documentElement;
  }

  let value;
  while (element) {
    if (
      isDefined((value = getCacheData(/** @type {Element} */ (element), name)))
    )
      return value;

    // If dealing with a document fragment node with a host element, and no parent, use the host
    // element as the parent. This enables directives within a Shadow DOM or polyfilled Shadow DOM
    // to lookup parent controllers.
    element =
      element.parentNode ||
      (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&
        /** @type {ShadowRoot} */ (element).host);
  }
}

/**
 *
 * @param {Element} element
 * @param {boolean} keepData
 */
function removeElement(element, keepData = false) {
  if (!keepData) {
    dealoc(element);
  }
  const parent = element.parentNode;
  if (parent) parent.removeChild(element);
}

/**
 * Extracts the starting tag from an HTML string or DOM element.
 *
 * @param {string|Element|Node} elementOrStr - The HTML string or DOM element to process.
 * @returns {string} The starting tag or processed result.
 */
function startingTag(elementOrStr) {
  let clone;

  if (typeof elementOrStr === "string") {
    const parser = new DOMParser();
    const doc = parser.parseFromString(elementOrStr, "text/html");
    clone = doc.body.firstChild.cloneNode(true);
  } else if (elementOrStr instanceof Element || elementOrStr instanceof Node) {
    clone = elementOrStr.cloneNode(true);
  } else {
    throw new Error("Input must be an HTML string or a DOM element.");
  }

  while (clone.firstChild) {
    clone.removeChild(clone.firstChild);
  }

  const divWrapper = document.createElement("div");
  divWrapper.appendChild(clone);
  const elemHtml = divWrapper.innerHTML;

  try {
    if (clone.nodeType === Node.TEXT_NODE) {
      return elemHtml.toLowerCase();
    } else if (clone.nodeType === Node.COMMENT_NODE) {
      return `<!--${/** @type {Comment} **/ (clone).data.trim()}-->`;
    } else {
      const match = elemHtml.match(/^(<[^>]+>)/);
      if (match) {
        return match[1].replace(/^<([\w-]+)/, (_match, nodeName) => {
          return "<" + nodeName.toLowerCase();
        });
      }
    }
  } catch (e) {
    return elemHtml.toLowerCase();
  }

  return elemHtml.toLowerCase();
}

/**
 * Return the DOM siblings between the first and last node in the given array.
 * @param {Array<Node>} nodes An array-like object
 * @returns {Element} the inputted object or a JQLite collection containing the nodes
 */
function getBlockNodes(nodes) {
  // TODO(perf): update `nodes` instead of creating a new object?
  let node = nodes[0];
  const endNode = nodes[nodes.length - 1];
  let blockNodes;

  for (let i = 1; node !== endNode && (node = node.nextSibling); i++) {
    if (blockNodes || nodes[i] !== node) {
      if (!blockNodes) {
        // use element to avoid circular dependency
        blockNodes = Array.prototype.slice.call(nodes, 0, i);
      }
      blockNodes.push(node);
    }
  }

  return blockNodes || nodes;
}

/**
 * Gets the name of a boolean attribute if it exists on a given element.
 *
 * @param {Element} element - The DOM element to check.
 * @param {string} name - The name of the attribute.
 * @returns {string|false} - The attribute name if valid, otherwise false.
 */
function getBooleanAttrName(element, name) {
  const normalizedName = name.toLowerCase();
  const isBooleanAttr = BOOLEAN_ATTR.includes(normalizedName);
  return isBooleanAttr && BOOLEAN_ELEMENTS.includes(element.nodeName)
    ? normalizedName
    : false;
}

/**
 * Takes an array of elements, calls any `$destroy` event handlers, removes any data in cache, and finally removes any
 * listeners.
 * @param {NodeListOf<Element>|Element[]} nodes
 */
function cleanElementData(nodes) {
  for (let i = 0, ii = nodes.length; i < ii; i++) {
    const events = (Cache.get(nodes[i][EXPANDO]) || {}).events;
    if (events && events.$destroy) {
      nodes[i].dispatchEvent(new Event("$destroy"));
    }
    removeElementData(nodes[i]);
  }
}

/**
 * Return instance of InjectorService attached to element
 * @param {Element} element
 * @returns {import('../core/di/internal-injector.js').InjectorService}
 */
function getInjector(element) {
  return getInheritedData(element, "$injector");
}

/**
 * Creates a DOM element from an HTML string.
 * @param {string} htmlString - A string representing the HTML to parse. Must have only one root element.
 * @returns {Element} - The parsed DOM element.
 */
function createElementFromHTML(htmlString) {
  const template = document.createElement("template");
  template.innerHTML = htmlString.trim();
  return /** @type {Element} */ (template.content.firstChild);
}

/**
 * Creates a DOM element from an HTML string.
 * @param {string} htmlString - A string representing the HTML to parse.
 * @returns {NodeList} - The parsed DOM element.
 */
function createNodelistFromHTML(htmlString) {
  const template = document.createElement("template");
  template.innerHTML = htmlString.trim();
  return template.content.childNodes;
}

/**
 * Remove element from the DOM and clear Cache data, associated with the node.
 * @param {Element} element
 */
function emptyElement(element) {
  dealoc(element, true);
  switch (element.nodeType) {
    case Node.ELEMENT_NODE:
    case Node.DOCUMENT_NODE:
    case Node.DOCUMENT_FRAGMENT_NODE:
      element.replaceChildren();
      break;
  }
}

function domInsert(element, parentElement, afterElement) {
  // if for some reason the previous element was removed
  // from the dom sometime before this code runs then let's
  // just stick to using the parent element as the anchor
  if (afterElement) {
    const afterNode = extractElementNode$1(afterElement);
    if (
      afterNode &&
      !afterNode.parentNode &&
      !afterNode.previousElementSibling
    ) {
      afterElement = null;
    }
  }
  if (afterElement) {
    afterElement.after(element);
  } else {
    parentElement.prepend(element);
  }
}

function extractElementNode$1(element) {
  const { length } = element;
  for (let i = 0; i < length; i++) {
    const elm = element[i];
    if (elm.nodeType === Node.ELEMENT_NODE) {
      return elm;
    }
  }
}

const PROVIDE_LITERAL = "$provide";
const INJECTOR_LITERAL = "$injector";
const COMPILE_LITERAL = "$compileProvider";
const ANIMATION_LITERAL = "$animateProvider";
const FILTER_LITERAL = "$filterProvider";
const CONTROLLER_LITERAL = "$controllerProvider";

/**
 * Modules are collections of application configuration information for components:
 * controllers, directives, filters, etc. They provide recipes for the injector
 * to do the actual instantiation. A module itself has no behaviour but only state.
 * A such, it acts as a data structure between the Angular instance and the injector service.
 *
 * Since this is an internal structure that is exposed only via the Angular instance,
 * it contains no validation of the items it receives. It is up to the instantiator on
 * modules to do the actual validation.
 */
class NgModule {
  /**
   * @param {string} name - Name of the module
   * @param {Array<string>} requires - List of modules which the injector will load before the current module
   * @param {Function} [configFn]
   */
  constructor(name, requires, configFn) {
    assert(isString(name), "name required");
    assert(Array.isArray(requires), "requires array required");
    /**
     * @type {string}
     * Name of the module.
     */
    this.name = name;
    /**
     * Holds the list of modules which the injector will load before the current module is
     * loaded.
     */
    this.requires = requires;

    /**
     * Holds a collection of tasks, required to instantiate an angular component
     * @type {!Array<Array<*>>}
     */
    this.invokeQueue = [];

    /** @type {!Array<Array<*>>} */
    this.configBlocks = [];

    /** @type {!Array.<Function>} */
    this.runBlocks = [];

    /** @type {Object} */
    this.infoState = {};

    if (configFn) {
      this.config(configFn);
    }
  }

  /**
   * @param {Object} value
   * @returns
   */
  info(value) {
    if (isDefined(value)) {
      assert(isObject(value), "module info value must be an object");
      this.infoState = value;
      return this;
    }
    return this.infoState;
  }

  /**
   * @param {string} name
   * @param {any} object
   * @returns {NgModule}
   */
  value(name, object) {
    this.invokeQueue.push([PROVIDE_LITERAL, "value", [name, object]]);
    return this;
  }

  /**
   * @param {string} name
   * @param {any} object
   * @returns {NgModule}
   */
  constant(name, object) {
    this.invokeQueue.unshift([PROVIDE_LITERAL, "constant", [name, object]]);
    return this;
  }

  /**
   *
   * @param {Function} configFn
   * @returns {NgModule}
   */
  config(configFn) {
    this.configBlocks.push([INJECTOR_LITERAL, "invoke", [configFn]]);
    return this;
  }

  /**
   * @param {Function} block
   * @returns {NgModule}
   */
  run(block) {
    this.runBlocks.push(block);
    return this;
  }

  /**
   * @param {string} name
   * @param {*} options
   * @returns {NgModule}
   */
  component(name, options) {
    if (options && isFunction(options)) {
      options.$$moduleName = name;
    }
    this.invokeQueue.push([COMPILE_LITERAL, "component", [name, options]]);
    return this;
  }

  /**
   * @param {string} name
   * @param {*} providerFunction
   * @returns {NgModule}
   */
  factory(name, providerFunction) {
    if (providerFunction && isFunction(providerFunction)) {
      providerFunction.$$moduleName = name;
    }
    this.invokeQueue.push([
      PROVIDE_LITERAL,
      "factory",
      [name, providerFunction],
    ]);
    return this;
  }

  /**
   * @param {string} name
   * @param {*} serviceFunction
   * @returns {NgModule}
   */
  service(name, serviceFunction) {
    if (serviceFunction && isFunction(serviceFunction)) {
      serviceFunction.$$moduleName = name;
    }
    this.invokeQueue.push([
      PROVIDE_LITERAL,
      "service",
      [name, serviceFunction],
    ]);
    return this;
  }

  /**
   * @param {string} name
   * @param {*} providerType
   * @returns {NgModule}
   */
  provider(name, providerType) {
    if (providerType && isFunction(providerType)) {
      providerType.$$moduleName = name;
    }
    this.invokeQueue.push([PROVIDE_LITERAL, "provider", [name, providerType]]);
    return this;
  }

  /**
   * @param {string} name
   * @param {*} decorFn
   * @returns {NgModule}
   */
  decorator(name, decorFn) {
    if (decorFn && isFunction(decorFn)) {
      decorFn.$$moduleName = name;
    }
    this.configBlocks.push([PROVIDE_LITERAL, "decorator", [name, decorFn]]);
    return this;
  }

  /**
   * @param {string} name
   * @param {*} directiveFactory
   * @returns {NgModule}
   */
  directive(name, directiveFactory) {
    if (directiveFactory && isFunction(directiveFactory)) {
      directiveFactory.$$moduleName = name;
    }
    this.invokeQueue.push([
      COMPILE_LITERAL,
      "directive",
      [name, directiveFactory],
    ]);
    return this;
  }

  /**
   * @param {string} name
   * @param {*} animationFactory
   * @returns {NgModule}
   */
  animation(name, animationFactory) {
    if (animationFactory && isFunction(animationFactory)) {
      animationFactory.$$moduleName = name;
    }
    this.invokeQueue.push([
      ANIMATION_LITERAL,
      "register",
      [name, animationFactory],
    ]);
    return this;
  }

  filter(name, filterFn) {
    if (filterFn && isFunction(filterFn)) {
      filterFn.$$moduleName = name;
    }
    this.invokeQueue.push([FILTER_LITERAL, "register", [name, filterFn]]);
    return this;
  }

  /**
   * @param {string} name
   * @param {*} ctlFn
   * @returns {NgModule}
   */
  controller(name, ctlFn) {
    if (ctlFn && isFunction(ctlFn)) {
      ctlFn.$$moduleName = name;
    }
    this.invokeQueue.push([CONTROLLER_LITERAL, "register", [name, ctlFn]]);
    return this;
  }
}

const ARROW_ARG$1 = /^([^(]+?)=>/;
const FN_ARGS$1 = /^[^(]*\(\s*([^)]*)\)/m;
const FN_ARG_SPLIT$1 = /,/;
const FN_ARG$1 = /^\s*(_?)(\S+?)\1\s*$/;
const STRIP_COMMENTS$1 = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
const $injectorMinErr$2 = minErr(INJECTOR_LITERAL);

const providerSuffix$1 = "Provider";
const INSTANTIATING = true;

class AbstractInjector {
  /**
   * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.
   */
  constructor(strictDi) {
    /**
     * @type {Object<String, Function>}
     */
    this.cache = {};
    /** @type {boolean} */
    this.strictDi = strictDi;
    this.path = [];
    /** @type {Object.<string, import("../../types").Module>} */
    this.modules = {};
  }

  /**
   * Get a service by name.
   *
   * @param {string} serviceName
   * @returns {any}
   */
  get(serviceName) {
    if (Object.prototype.hasOwnProperty.call(this.cache, serviceName)) {
      if (this.cache[serviceName] === INSTANTIATING) {
        throw $injectorMinErr$2(
          "cdep",
          "Circular dependency found: {0}",
          `${serviceName} <- ${this.path.join(" <- ")}`,
        );
      }
      return this.cache[serviceName];
    }

    this.path.unshift(serviceName);
    this.cache[serviceName] = INSTANTIATING;
    try {
      // this goes to line 60
      this.cache[serviceName] = this.factory(serviceName);
    } catch (err) {
      // this is for the error handling being thrown by the providerCache multiple times
      delete this.cache[serviceName];
      throw err;
    }
    return this.cache[serviceName];
  }

  /**
   * Get the injection arguments for a function.
   *
   * @param {Function|Array} fn
   * @param {Object} locals
   * @param {string} serviceName
   * @returns
   */
  injectionArgs(fn, locals, serviceName) {
    const args = [];
    const $inject = annotate$1(fn, this.strictDi, serviceName);

    for (let i = 0, { length } = $inject; i < length; i++) {
      const key = $inject[i];
      if (typeof key !== "string") {
        throw $injectorMinErr$2(
          "itkn",
          "Incorrect injection token! Expected service name as string, got {0}",
          key,
        );
      }
      args.push(
        locals && Object.prototype.hasOwnProperty.call(locals, key)
          ? locals[key]
          : this.get(key),
      );
    }
    return args;
  }

  /**
   * Invoke a function with optional context and locals.
   *
   * @param {Function|String|Array<any>} fn
   * @param {*} [self]
   * @param {Object} [locals]
   * @param {string} [serviceName]
   * @returns
   */
  invoke(fn, self, locals, serviceName) {
    if (typeof locals === "string") {
      serviceName = locals;
      locals = null;
    }

    const args = this.injectionArgs(
      /** @type {Function} */ (fn),
      locals,
      serviceName,
    );
    if (Array.isArray(fn)) {
      fn = fn[fn.length - 1];
    }

    if (isClass(/** @type {string} */ (fn))) {
      args.unshift(null);
      const res = new (Function.prototype.bind.apply(fn, args))();
      return res;
    } else {
      return /** @type {Function} */ (fn).apply(self, args);
    }
  }

  /**
   * Instantiate a type constructor with optional locals.
   * @param {Function|Array} type
   * @param {*} [locals]
   * @param {string} [serviceName]
   */
  instantiate(type, locals, serviceName) {
    // Check if type is annotated and use just the given function at n-1 as parameter
    // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);
    const ctor = Array.isArray(type) ? type[type.length - 1] : type;
    const args = this.injectionArgs(type, locals, serviceName);
    // Empty object at position 0 is ignored for invocation with `new`, but required.
    args.unshift(null);
    return new (Function.prototype.bind.apply(ctor, args))();
  }

  /**
   * @abstract
   */
  loadNewModules() {}

  /**
   * @abstract
   * @param {string} _serviceName
   */
  factory(_serviceName) {
    console.error(`Unhandled ${_serviceName}`);
  }
}

/**
 * Injector for providers
 * @extends AbstractInjector
 */
class ProviderInjector extends AbstractInjector {
  /**
   * @param {Object} cache
   * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.
   */
  constructor(cache, strictDi) {
    super(strictDi);
    this.cache = cache;
  }

  /**
   * Factory method for creating services.
   * @param {string} caller - The name of the caller requesting the service.
   * @throws {Error} If the provider is unknown.
   */
  factory(caller) {
    this.path.push(caller);
    // prevents lookups to providers through get
    throw $injectorMinErr$2(
      "unpr",
      "Unknown provider: {0}",
      this.path.join(" <- "),
    );
  }
}

/**
 * Injector for factories and services
 * @extends AbstractInjector
 */
class InjectorService extends AbstractInjector {
  /**
   *
   * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.
   * @param {ProviderInjector} providerInjector
   */
  constructor(strictDi, providerInjector) {
    super(strictDi);
    this.providerInjector = providerInjector;
    this.modules = this.providerInjector.modules;
  }

  factory(serviceName) {
    const provider = this.providerInjector.get(serviceName + providerSuffix$1);
    const res = this.invoke(provider.$get, provider, undefined, serviceName);
    return res;
  }

  /**
   *
   * @param {string} name
   * @returns {boolean}
   */
  has(name) {
    const hasProvider = Object.prototype.hasOwnProperty.call(
      this.providerInjector.cache,
      name + providerSuffix$1,
    );
    const hasCache = Object.prototype.hasOwnProperty.call(this.cache, name);
    return hasProvider || hasCache;
  }
}

// Helpers

/**
 * @param {string} fn
 * @returns {string}
 */
function stringifyFn$1(fn) {
  return Function.prototype.toString.call(fn);
}

/**
 * @param {string} fn
 * @returns {Array<any>}
 */
function extractArgs$1(fn) {
  const fnText = stringifyFn$1(fn).replace(STRIP_COMMENTS$1, "");
  const args = fnText.match(ARROW_ARG$1) || fnText.match(FN_ARGS$1);
  return args;
}

/**
 * @param {string} func
 * @returns {boolean}
 */
function isClass(func) {
  return /^class\b/.test(stringifyFn$1(func));
}

/**
 *
 * @param {any} fn
 * @param {boolean} strictDi
 * @param {string} name
 * @returns {Array<string>}
 */
function annotate$1(fn, strictDi, name) {
  let $inject, argDecl, last;

  if (typeof fn === "function") {
    if (!($inject = fn.$inject)) {
      $inject = [];
      if (fn.length) {
        if (strictDi) {
          throw $injectorMinErr$2(
            "strictdi",
            "{0} is not using explicit annotation and cannot be invoked in strict mode",
            name,
          );
        }
        argDecl = extractArgs$1(/** @type {string} */ (fn));
        argDecl[1].split(FN_ARG_SPLIT$1).forEach(function (arg) {
          arg.replace(FN_ARG$1, function (_all, _underscore, name) {
            $inject.push(name);
          });
        });
      }
      fn.$inject = $inject;
    }
  } else if (Array.isArray(fn)) {
    last = /** @type {Array} */ (fn).length - 1;
    assertArgFn(fn[last], "fn");
    $inject = /** @type {Array} */ (fn).slice(0, last);
  } else {
    assertArgFn(fn, "fn", true);
  }
  return $inject;
}

const ARROW_ARG = /^([^(]+?)=>/;
const FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
const FN_ARG_SPLIT = /,/;
const FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
const $injectorMinErr$1 = minErr(INJECTOR_LITERAL);

const providerSuffix = "Provider";

/**
 *
 * @param {Array<String|Function>} modulesToLoad
 * @param {boolean} [strictDi]
 * @returns {InjectorService}
 */
function createInjector(modulesToLoad, strictDi = false) {
  assert(Array.isArray(modulesToLoad), "modules required");

  /** @type {Map<String|Function, boolean>} */
  const loadedModules = new Map(); // Keep track of loaded modules to avoid circular dependencies

  const providerCache = {
    $provide: {
      provider: supportObject(provider),
      factory: supportObject(factory),
      service: supportObject(service),
      value: supportObject(value),
      constant: supportObject(constant),
      decorator,
    },
  };

  const providerInjector = (providerCache.$injector = new ProviderInjector(
    providerCache,
    strictDi,
  ));

  const protoInstanceInjector = new InjectorService(strictDi, providerInjector);

  providerCache.$injectorProvider = {
    // $injectionProvider return instance injector
    $get: () => protoInstanceInjector,
  };

  let instanceInjector = protoInstanceInjector;
  const runBlocks = loadModules(modulesToLoad);
  instanceInjector = protoInstanceInjector.get(INJECTOR_LITERAL);

  runBlocks.forEach((fn) => {
    if (fn) instanceInjector.invoke(fn);
  });

  instanceInjector.loadNewModules = function (mods) {
    loadModules(mods).forEach((fn) => {
      if (fn) instanceInjector.invoke(fn);
    });
  };

  return instanceInjector;

  ////////////////////////////////////
  // $provider
  ////////////////////////////////////

  /**
   *
   * @param {string} name
   * @param {import('../../types.js').ServiceProvider} provider
   * @returns
   */
  function provider(name, provider) {
    assertNotHasOwnProperty(name, "service");
    let newProvider;
    if (isFunction(provider) || Array.isArray(provider)) {
      newProvider = providerInjector.instantiate(
        /** @type {Function} */ (provider),
      );
    } else {
      newProvider = provider;
    }
    if (!newProvider.$get) {
      throw $injectorMinErr$1(
        "pget",
        "Provider '{0}' must define $get factory method.",
        name,
      );
    }
    providerCache[name + providerSuffix] = newProvider;
    return newProvider;
  }

  function factory(name, factoryFn) {
    return provider(name, {
      $get: () => {
        const result = instanceInjector.invoke(factoryFn, this);
        if (isUndefined(result)) {
          throw $injectorMinErr$1(
            "undef",
            "Provider '{0}' must return a value from $get factory method.",
            name,
          );
        }
        return result;
      },
    });
  }

  function service(name, constructor) {
    return factory(name, [
      INJECTOR_LITERAL,
      ($injector) => $injector.instantiate(constructor),
    ]);
  }

  /**
   * @param {String} name
   * @param {any} val
   * @returns {import('../../types.js').ServiceProvider}
   */
  function value(name, val) {
    return (providerCache[name + providerSuffix] = { $get: () => val });
  }

  function constant(name, value) {
    assertNotHasOwnProperty(name, "constant");
    providerInjector.cache[name] = value;
    protoInstanceInjector.cache[name] = value;
  }

  function decorator(serviceName, decorFn) {
    const origProvider = providerInjector.get(serviceName + providerSuffix);
    const origGet = origProvider.$get;

    origProvider.$get = function () {
      const origInstance = instanceInjector.invoke(origGet, origProvider);
      return instanceInjector.invoke(decorFn, null, {
        $delegate: origInstance,
      });
    };
  }

  /**
   *
   * @param {Array<String|Function>} modulesToLoad
   * @returns
   */
  function loadModules(modulesToLoad) {
    assertArg$1(
      isUndefined(modulesToLoad) || Array.isArray(modulesToLoad),
      "modulesToLoad",
      "not an array",
    );
    let runBlocks = [];

    modulesToLoad.forEach((module) => {
      if (loadedModules.get(module)) return;
      loadedModules.set(module, true);

      try {
        if (isString(module)) {
          /** @type {import('./ng-module').NgModule} */
          const moduleFn = window["angular"].module(module);
          instanceInjector.modules[/** @type {string } */ (module)] = moduleFn;
          runBlocks = runBlocks
            .concat(loadModules(moduleFn.requires))
            .concat(moduleFn.runBlocks);

          const invokeQueue = moduleFn.invokeQueue.concat(
            moduleFn.configBlocks,
          );
          invokeQueue.forEach((invokeArgs) => {
            const provider = providerInjector.get(invokeArgs[0]);
            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
          });
        } else if (isFunction(module)) {
          runBlocks.push(providerInjector.invoke(module));
        } else if (Array.isArray(module)) {
          runBlocks.push(providerInjector.invoke(module));
        } else {
          assertArgFn(module, "module");
        }
      } catch (e) {
        if (Array.isArray(module)) {
          module = module[module.length - 1];
        }
        if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {
          // Safari & FF's stack traces don't contain error.message content
          // unlike those of Chrome and IE
          // So if stack doesn't contain message, we create a new string that contains both.
          // Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.

          e.message = `${e.message}\n${e.stack}`;
        }
        throw $injectorMinErr$1(
          "modulerr",
          "Failed to instantiate module {0} due to:\n{1}",
          module,
          e.stack || e.message || e,
        );
      }
    });
    return runBlocks;
  }
}

// Helpers

/**
 * @param {String} fn
 * @returns {String}
 */
function stringifyFn(fn) {
  return Function.prototype.toString.call(fn);
}

/**
 * @param {String} fn
 * @returns {Array<any>}
 */
function extractArgs(fn) {
  const fnText = stringifyFn(fn).replace(STRIP_COMMENTS, "");
  const args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
  return args;
}

/**
 *
 * @param {any} fn
 * @param {boolean} [strictDi]
 * @param {String} [name]
 * @returns {Array<string>}
 */
function annotate(fn, strictDi, name) {
  let $inject, argDecl, last;

  if (typeof fn === "function") {
    if (!($inject = fn.$inject)) {
      $inject = [];
      if (fn.length) {
        if (strictDi) {
          throw $injectorMinErr$1(
            "strictdi",
            "{0} is not using explicit annotation and cannot be invoked in strict mode",
            name,
          );
        }
        argDecl = extractArgs(/** @type {String} */ (fn));
        argDecl[1].split(FN_ARG_SPLIT).forEach(function (arg) {
          arg.replace(FN_ARG, function (all, underscore, name) {
            $inject.push(name);
          });
        });
      }
      fn.$inject = $inject;
    }
  } else if (Array.isArray(fn)) {
    last = /** @type {Array} */ (fn).length - 1;
    assertArgFn(fn[last], "fn");
    $inject = /** @type {Array} */ (fn).slice(0, last);
  } else {
    assertArgFn(fn, "fn", true);
  }
  return $inject;
}

/**
 * @param {function(string, any):any} delegate
 * @returns
 */
function supportObject(delegate) {
  return function (key, value) {
    if (isObject(key)) {
      Object.entries(key).forEach(([k, v]) => {
        delegate(k, v);
      });
    } else {
      return delegate(key, value);
    }
  };
}

/**
 * A type-safe wrapper around a DOM Node, HTMLElement, HTML string, NodeList, or an array of Nodes.
 * Provides guarantees around presence and access.
 */
class NodeRef {
  /**
   * @param {Node | Element | string | NodeList | Node[]} element - The DOM node(s) or HTML string to wrap.
   * @throws {Error} If the argument is invalid or cannot be wrapped properly.
   */
  constructor(element) {
    assertArg$1(element, "element");
    this.initial = null;

    /** @private @type {Node | ChildNode | null} */
    this._node = null;

    /** @private @type {Element | undefined} */
    this._element = undefined;

    /** @private @type {Array<Node>} a stable list on nodes */
    this._nodes = undefined;

    /** @type {boolean} */
    this.linked = false;

    /** @type {boolean} */
    this.isList = false;

    // Handle HTML string
    if (isString(element)) {
      this.initial = element;
      let res = createElementFromHTML(/** @type {string} */ (element));
      switch (true) {
        case res instanceof Element:
          this.element = res;
          break;
        case res instanceof Node:
          this.node = res;
          break;
      }
    }

    // Handle NodeList
    else if (element instanceof NodeList) {
      this.initial = Array.from(element).map((e) => e.cloneNode(true));
      if (element.length == 1) {
        this.node = element[0];
      } else {
        this._nodes = Array.from(element);
        this.isList = true;
      }
    }

    // Handle single Element
    else if (element instanceof Element) {
      this.initial = element.cloneNode(true);
      this.element = /** @type {Element} */ element;
    }

    // Handle single Node
    else if (element instanceof Node) {
      this.initial = element.cloneNode(true);
      this._node = element;
    }

    // Nandle array of elements
    else if (element instanceof Array) {
      if (element.length == 1) {
        this.initial = element[0].cloneNode(true);
        this.node = element[0];
      } else {
        this.initial = Array.from(element).map((e) => e.cloneNode(true));
        this.nodes = element;
      }
    } else {
      throw new Error("Invalid element passed to NodeRef");
    }
  }

  /** @returns {Element} */
  get element() {
    assertArg$1(this._element, "element");
    return this._element;
  }

  /** @param {Element} el */
  set element(el) {
    assertArg$1(el instanceof Element, "element");
    this._element = el;
    this._nodes = undefined;
    this.isList = false;
  }

  /** @returns {Node | ChildNode} */
  get node() {
    assertArg$1(this._node || this._element, "node");
    return this._node || this._element;
  }

  /** @param {Node | ChildNode} node */
  set node(node) {
    assertArg$1(node instanceof Node, "node");
    this._node = node;
    if (node.nodeType === Node.ELEMENT_NODE) {
      this._element = /** @type {Element} */ (node);
    } else {
      this._element = undefined;
    }
    // this._nodes = undefined;
    // this.isList = false;
  }

  /** @param {Array<Node>} nodes */
  set nodes(nodes) {
    assertArg$1(
      Array.isArray(nodes) && nodes.every((n) => n instanceof Node),
      "nodes",
    );
    this._nodes = nodes;
    this.isList = true;
  }

  /** @returns {Array<Node>} */
  get nodes() {
    assertArg$1(this._nodes, "nodes");
    return this._nodes;
  }

  /** @returns {NodeList|Node[]} */
  get nodelist() {
    assertArg$1(this.isList, "nodes");
    if (this._nodes.length === 0) {
      return this._nodes;
    }
    if (this._nodes[0].parentElement) {
      return this._nodes[0].parentElement.childNodes;
    } else {
      const fragment = document.createDocumentFragment();
      this._nodes.forEach((el) => {
        fragment.appendChild(el);
      });
      return fragment.childNodes;
    }
  }

  /** @returns {Element | Node | ChildNode | NodeList | Node[]} */
  get dom() {
    if (this.isList) return this.nodelist;
    else return this.node;
  }

  /** @returns {number} */
  get size() {
    return this.isList ? this._nodes.length : 1;
  }

  /** @returns {Element | Node | ChildNode} */
  getAny() {
    if (this.isList) {
      return this._nodes[0];
    } else {
      return this._element || this._node;
    }
  }

  /** @returns {Element | Array<Node> | Node | ChildNode} */
  getAll() {
    if (this.isList) {
      return this._nodes;
    } else {
      return this._element || this._node;
    }
  }

  /** @returns {Array<Element> | Array<Node>} */
  collection() {
    if (this.isList) {
      return Array.from(this._nodes);
    } else {
      return [this._element || this._node];
    }
  }

  setAll(update) {
    assertArg$1(update, "nodes");
    if (update instanceof NodeList) {
      return (this._nodes = Array.from(update));
    } else {
      if (Array.isArray(update)) {
        return (this.nodes = update);
      } else {
        return (this.node = update);
      }
    }
  }

  /**
   * @param {number} index
   * @returns {Element | Node | ChildNode}
   */
  getIndex(index) {
    if (this.isList) {
      return this._nodes[index];
    } else {
      return this.node;
    }
  }

  /**
   * @param {number} index
   * @param {Element | Node | ChildNode} node
   */
  setIndex(index, node) {
    assertArg$1(index !== null, "index");
    assertArg$1(node, "node");
    if (this.isList) {
      this._nodes[index] = node;
    } else {
      this.node = node;
    }
  }

  /**
   * @returns {NodeRef}
   */
  clone() {
    const cloned = this.isList
      ? this.nodes.map((el) => el.cloneNode(true))
      : this.node.cloneNode(true);

    return new NodeRef(cloned);
  }

  isElement() {
    return this._element !== undefined;
  }
}

const $controllerMinErr = minErr("$controller");

const CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
function identifierForController(controller, ident) {
  if (isString(controller)) {
    const match = CNTRL_REG.exec(controller);
    if (match) return match[3];
  }
}

/**
 * The {@link ng.$controller $controller service} is used by AngularJS to create new
 * controllers.
 *
 * This provider allows controller registration via the
 * {@link ng.$controllerProvider#register register} method.
 */
class ControllerProvider {
  constructor() {
    /**
     * @type {Map<string, Function|Object>}
     * @private
     */
    this.controllers = new Map();
  }

  /**
   * Check if a controller with a given name exists.
   *
   * @param {string} name Controller name to check.
   * @returns {boolean} True if the controller exists, false otherwise.
   */
  has(name) {
    return this.controllers.has(name);
  }

  /**
   * Register a controller.
   *
   * @param {string|Object} name Controller name, or an object map of controllers where the keys are
   *    the names and the values are the constructors.
   * @param {Function|Array} constructor Controller constructor function (optionally decorated with DI
   *    annotations in the array notation).
   */
  register(name, constructor) {
    assertNotHasOwnProperty(name, "controller");
    if (isObject(name)) {
      Object.entries(name).forEach(([key, value]) => {
        this.controllers.set(key, value);
      });
    } else {
      this.controllers.set(name, constructor);
    }
  }

  /**
   * $get method for dependency injection.
   */
  $get = [
    "$injector",

    /**
     * @param {import("../../core/di/internal-injector.js").InjectorService} $injector
     * @returns {Function} A service function that creates controllers.
     */
    ($injector) => {
      return (expression, locals, later, ident) => {
        let instance;
        let match;
        let constructor;
        let identifier = ident && isString(ident) ? ident : null;
        later = later === true;

        if (isString(expression)) {
          match = expression.match(CNTRL_REG);
          if (!match) {
            throw $controllerMinErr(
              "ctrlfmt",
              "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.",
              expression,
            );
          }
          constructor = match[1];
          identifier = identifier || match[3];
          expression = this.controllers.get(constructor);

          if (!expression) {
            throw $controllerMinErr(
              "ctrlreg",
              "The controller with the name '{0}' is not registered.",
              constructor,
            );
          }

          assertArgFn(expression, constructor, true);
        }

        if (later) {
          const controllerPrototype = (
            Array.isArray(expression)
              ? expression[expression.length - 1]
              : expression
          ).prototype;
          instance = Object.create(controllerPrototype || null);

          if (identifier) {
            instance["$controllerIdentifier"] = identifier;
            this.addIdentifier(
              locals,
              identifier,
              instance,
              constructor || expression.name,
            );
          }

          return function () {
            const result = $injector.invoke(
              expression,
              instance,
              locals,
              constructor,
            );

            if (
              result !== instance &&
              (isObject(result) || isFunction(result))
            ) {
              instance = result;
              if (identifier) {
                instance["$controllerIdentifier"] = identifier;
                this.addIdentifier(
                  locals,
                  identifier,
                  instance,
                  constructor || expression.name,
                );
              }
            }

            return instance;
          }.bind(this, { instance, identifier });
        }

        instance = $injector.instantiate(expression, locals, constructor);

        if (identifier) {
          this.addIdentifier(
            locals,
            identifier,
            instance,
            constructor || expression.name,
          );
        }

        return instance;
      };
    },
  ];

  /**
   * Adds an identifier to the controller instance in the given locals' scope.
   *
   * @param {Object} locals The locals object containing the scope.
   * @param {string} identifier The identifier to assign.
   * @param {Object} instance The controller instance.
   * @param {string} name The name of the controller.
   */
  addIdentifier(locals, identifier, instance, name) {
    if (!(locals && isObject(locals.$scope))) {
      throw minErr("$controller")(
        "noscp",
        "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
        name,
        identifier,
      );
    }
    locals.$scope[identifier] = instance;
  }
}

/**
 * HTTP protocol
 * @typedef {"http"|"https"} HttpProtocol
 */

const urlParsingNode = document.createElement("a");
const originUrl = urlResolve(window.location.href);
let baseUrlParsingNode;

urlParsingNode.href = "http://[::1]";

function urlResolve(url) {
  if (!isString(url)) return url;

  const href = url;

  urlParsingNode.setAttribute("href", href);

  let { hostname } = urlParsingNode;
  // Support: IE 9-11 only, Edge 16-17 only (fixed in 18 Preview)
  // IE/Edge don't wrap IPv6 addresses' hostnames in square brackets
  // when parsed out of an anchor element.
  const ipv6InBrackets = urlParsingNode.hostname === "[::1]";
  if (!ipv6InBrackets && hostname.indexOf(":") > -1) {
    hostname = `[${hostname}]`;
  }

  return {
    href: urlParsingNode.href,
    protocol: urlParsingNode.protocol
      ? urlParsingNode.protocol.replace(/:$/, "")
      : "",
    host: urlParsingNode.host,
    search: urlParsingNode.search
      ? urlParsingNode.search.replace(/^\?/, "")
      : "",
    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
    hostname,
    port: urlParsingNode.port,
    pathname:
      urlParsingNode.pathname.charAt(0) === "/"
        ? urlParsingNode.pathname
        : `/${urlParsingNode.pathname}`,
  };
}

/**
 * Parse a request URL and determine whether this is a same-origin request as the application
 * document.
 *
 * @param {string|object} requestUrl The url of the request as a string that will be resolved
 * or a parsed URL object.
 * @returns {boolean} Whether the request is for the same origin as the application document.
 */
function urlIsSameOrigin(requestUrl) {
  return urlsAreSameOrigin(requestUrl, originUrl);
}

/**
 * Parse a request URL and determine whether it is same-origin as the current document base URL.
 *
 * Note: The base URL is usually the same as the document location (`location.href`) but can
 * be overriden by using the `<base>` tag.
 *
 * @param {string|object} requestUrl The url of the request as a string that will be resolved
 * or a parsed URL object.
 * @returns {boolean} Whether the URL is same-origin as the document base URL.
 */
function urlIsSameOriginAsBaseUrl(requestUrl) {
  return urlsAreSameOrigin(requestUrl, getBaseUrl());
}

/**
 * Create a function that can check a URL's origin against a list of allowed/trusted origins.
 * The current location's origin is implicitly trusted.
 *
 * @param {string[]} trustedOriginUrls - A list of URLs (strings), whose origins are trusted.
 *
 * @returns {Function} - A function that receives a URL (string or parsed URL object) and returns
 *     whether it is of an allowed origin.
 */
function urlIsAllowedOriginFactory(trustedOriginUrls) {
  const parsedAllowedOriginUrls = [originUrl].concat(
    trustedOriginUrls.map(urlResolve),
  );

  /**
   * Check whether the specified URL (string or parsed URL object) has an origin that is allowed
   * based on a list of trusted-origin URLs. The current location's origin is implicitly
   * trusted.
   *
   * @param {string|Object} requestUrl - The URL to be checked (provided as a string that will be
   *     resolved or a parsed URL object).
   *
   * @returns {boolean} - Whether the specified URL is of an allowed origin.
   */
  return function urlIsAllowedOrigin(requestUrl) {
    const parsedUrl = urlResolve(requestUrl);
    return parsedAllowedOriginUrls.some(
      urlsAreSameOrigin.bind(null, parsedUrl),
    );
  };
}

/**
 * Determine if two URLs share the same origin.
 *
 * @param {string|Object} url1 - First URL to compare as a string or a normalized URL in the form of
 *     a dictionary object returned by `urlResolve()`.
 * @param {string|object} url2 - Second URL to compare as a string or a normalized URL in the form
 *     of a dictionary object returned by `urlResolve()`.
 *
 * @returns {boolean} - True if both URLs have the same origin, and false otherwise.
 */
function urlsAreSameOrigin(url1, url2) {
  url1 = urlResolve(url1);
  url2 = urlResolve(url2);

  return url1.protocol === url2.protocol && url1.host === url2.host;
}

/**
 * Returns the current document base URL.
 * @returns {string}
 */
function getBaseUrl() {
  if (document.baseURI) {
    return document.baseURI;
  }

  // `document.baseURI` is available everywhere except IE
  if (!baseUrlParsingNode) {
    baseUrlParsingNode = document.createElement("a");
    baseUrlParsingNode.href = ".";

    // Work-around for IE bug described in Implementation Notes. The fix in `urlResolve()` is not
    // suitable here because we need to track changes to the base URL.
    baseUrlParsingNode = baseUrlParsingNode.cloneNode(false);
  }
  return baseUrlParsingNode.href;
}

const $sceMinErr = minErr("$sce");

const SCE_CONTEXTS = {
  // HTML is used when there's HTML rendered (e.g. ng-bind-html, iframe srcdoc binding).
  HTML: "html",

  // Style statements or stylesheets. Currently unused in AngularJS.
  CSS: "css",

  // An URL used in a context where it refers to the source of media, which are not expected to be run
  // as scripts, such as an image, audio, video, etc.
  MEDIA_URL: "mediaUrl",

  // An URL used in a context where it does not refer to a resource that loads code.
  // A value that can be trusted as a URL can also trusted as a MEDIA_URL.
  URL: "url",

  // RESOURCE_URL is a subtype of URL used where the referred-to resource could be interpreted as
  // code. (e.g. ng-include, script src binding, templateUrl)
  // A value that can be trusted as a RESOURCE_URL, can also trusted as a URL and a MEDIA_URL.
  RESOURCE_URL: "resourceUrl",

  // Script. Currently unused in AngularJS.
  JS: "js",
};

// Copied from:
// http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021
// Prereq: s is a string.
function escapeForRegexp(s) {
  return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1");
}

function adjustMatcher(matcher) {
  if (matcher === "self") {
    return matcher;
  }
  if (isString(matcher)) {
    // Strings match exactly except for 2 wildcards - '*' and '**'.
    // '*' matches any character except those from the set ':/.?&'.
    // '**' matches any character (like .* in a RegExp).
    // More than 2 *'s raises an error as it's ill defined.
    if (matcher.indexOf("***") > -1) {
      throw $sceMinErr(
        "iwcard",
        "Illegal sequence *** in string matcher.  String: {0}",
        matcher,
      );
    }
    matcher = escapeForRegexp(matcher)
      .replace(/\\\*\\\*/g, ".*")
      .replace(/\\\*/g, "[^:/.?&;]*");
    return new RegExp(`^${matcher}$`);
  }
  if (isRegExp(matcher)) {
    // The only other type of matcher allowed is a Regexp.
    // Match entire URL / disallow partial matches.
    // Flags are reset (i.e. no global, ignoreCase or multiline)
    return new RegExp(`^${matcher.source}$`);
  }
  throw $sceMinErr(
    "imatcher",
    'Matchers may only be "self", string patterns or RegExp objects',
  );
}

/**
 * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict
 * Contextual Escaping (SCE)} services to AngularJS.
 *
 * For an overview of this service and the functionnality it provides in AngularJS, see the main
 * page for {@link ng.$sce SCE}. The current page is targeted for developers who need to alter how
 * SCE works in their application, which shouldn't be needed in most cases.
 *
 * <div class="alert alert-danger">
 * AngularJS strongly relies on contextual escaping for the security of bindings: disabling or
 * modifying this might cause cross site scripting (XSS) vulnerabilities. For libraries owners,
 * changes to this service will also influence users, so be extra careful and document your changes.
 * </div>
 *
 * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of
 * the `$sce` service to customize the way Strict Contextual Escaping works in AngularJS.  This is
 * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to
 * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things
 * work because `$sce` delegates to `$sceDelegate` for these operations.
 *
 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.
 *
 * The default instance of `$sceDelegate` should work out of the box with little pain.  While you
 * can override it completely to change the behavior of `$sce`, the common case would
 * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting
 * your own trusted and banned resource lists for trusting URLs used for loading AngularJS resources
 * such as templates.  Refer {@link ng.$sceDelegateProvider#trustedResourceUrlList
 * $sceDelegateProvider.trustedResourceUrlList} and {@link
 * ng.$sceDelegateProvider#bannedResourceUrlList $sceDelegateProvider.bannedResourceUrlList}
 */

/**
 *
 * The `$sceDelegateProvider` provider allows developers to configure the {@link ng.$sceDelegate
 * $sceDelegate service}, used as a delegate for {@link ng.$sce Strict Contextual Escaping (SCE)}.
 *
 * The `$sceDelegateProvider` allows one to get/set the `trustedResourceUrlList` and
 * `bannedResourceUrlList` used to ensure that the URLs used for sourcing AngularJS templates and
 * other script-running URLs are safe (all places that use the `$sce.RESOURCE_URL` context). See
 * {@link ng.$sceDelegateProvider#trustedResourceUrlList
 * $sceDelegateProvider.trustedResourceUrlList} and
 * {@link ng.$sceDelegateProvider#bannedResourceUrlList $sceDelegateProvider.bannedResourceUrlList},
 *
 * For the general details about this service in AngularJS, read the main page for {@link ng.$sce
 * Strict Contextual Escaping (SCE)}.
 *
 * **Example**:  Consider the following case. <a name="example"></a>
 *
 * - your app is hosted at url `http://myapp.example.com/`
 * - but some of your templates are hosted on other domains you control such as
 *   `http://srv01.assets.example.com/`, `http://srv02.assets.example.com/`, etc.
 * - and you have an open redirect at `http://myapp.example.com/clickThru?...`.
 *
 * Here is what a secure configuration for this scenario might look like:
 *
 * ```
 *  angular.module('myApp', []).config(function($sceDelegateProvider) {
 *    $sceDelegateProvider.trustedResourceUrlList([
 *      // Allow same origin resource loads.
 *      'self',
 *      // Allow loading from our assets domain.  Notice the difference between * and **.
 *      'http://srv*.assets.example.com/**'
 *    ]);
 *
 *    // The banned resource URL list overrides the trusted resource URL list so the open redirect
 *    // here is blocked.
 *    $sceDelegateProvider.bannedResourceUrlList([
 *      'http://myapp.example.com/clickThru**'
 *    ]);
 *  });
 * ```
 * Note that an empty trusted resource URL list will block every resource URL from being loaded, and will require
 * you to manually mark each one as trusted with `$sce.trustAsResourceUrl`. However, templates
 * requested by {@link ng.$templateRequest $templateRequest} that are present in
 * {@link ng.$templateCache $templateCache} will not go through this check. If you have a mechanism
 * to populate your templates in that cache at config time, then it is a good idea to remove 'self'
 * from the trusted resource URL lsit. This helps to mitigate the security impact of certain types
 * of issues, like for instance attacker-controlled `ng-includes`.
 */

function SceDelegateProvider() {
  this.SCE_CONTEXTS = SCE_CONTEXTS;

  // Resource URLs can also be trusted by policy.
  let trustedResourceUrlList = ["self"];
  let bannedResourceUrlList = [];

  /**
   *
   * @param {Array=} trustedResourceUrlList When provided, replaces the trustedResourceUrlList with
   *     the value provided.  This must be an array or null.  A snapshot of this array is used so
   *     further changes to the array are ignored.
   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
   *     allowed in this array.
   *
   * @return {Array} The currently set trusted resource URL array.
   *
   * @description
   * Sets/Gets the list trusted of resource URLs.
   *
   * The **default value** when no `trustedResourceUrlList` has been explicitly set is `['self']`
   * allowing only same origin resource requests.
   *
   * <div class="alert alert-warning">
   * **Note:** the default `trustedResourceUrlList` of 'self' is not recommended if your app shares
   * its origin with other apps! It is a good idea to limit it to only your application's directory.
   * </div>
   */
  this.trustedResourceUrlList = function (value) {
    if (arguments.length) {
      trustedResourceUrlList = value.map((v) => adjustMatcher(v));
    }
    return trustedResourceUrlList;
  };

  /**
   *
   * @param {Array=} bannedResourceUrlList When provided, replaces the `bannedResourceUrlList` with
   *     the value provided. This must be an array or null. A snapshot of this array is used so
   *     further changes to the array are ignored.</p><p>
   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
   *     allowed in this array.</p><p>
   *     The typical usage for the `bannedResourceUrlList` is to **block
   *     [open redirects](http://cwe.mitre.org/data/definitions/601.html)** served by your domain as
   *     these would otherwise be trusted but actually return content from the redirected domain.
   *     </p><p>
   *     Finally, **the banned resource URL list overrides the trusted resource URL list** and has
   *     the final say.
   *
   * @return {Array} The currently set `bannedResourceUrlList` array.
   *
   * @description
   * Sets/Gets the `bannedResourceUrlList` of trusted resource URLs.
   *
   * The **default value** when no trusted resource URL list has been explicitly set is the empty
   * array (i.e. there is no `bannedResourceUrlList`.)
   */
  this.bannedResourceUrlList = function (value) {
    if (arguments.length) {
      bannedResourceUrlList = value.map((v) => adjustMatcher(v));
    }
    return bannedResourceUrlList;
  };

  this.$get = [
    "$injector",
    "$$sanitizeUri",
    /**
     *
     * @param {import("../../core/di/internal-injector").InjectorService} $injector
     * @param {*} $$sanitizeUri
     * @returns
     */
    function ($injector, $$sanitizeUri) {
      let htmlSanitizer = function () {
        throw $sceMinErr(
          "unsafe",
          "Attempting to use an unsafe value in a safe context.",
        );
      };

      if ($injector.has("$sanitize")) {
        htmlSanitizer = $injector.get("$sanitize");
      }

      function matchUrl(matcher, parsedUrl) {
        if (matcher === "self") {
          return (
            urlIsSameOrigin(parsedUrl) || urlIsSameOriginAsBaseUrl(parsedUrl)
          );
        }
        // definitely a regex.  See adjustMatchers()
        return !!matcher.exec(parsedUrl.href);
      }

      function isResourceUrlAllowedByPolicy(url) {
        const parsedUrl = urlResolve(url.toString());
        let i;
        let n;
        let allowed = false;
        // Ensure that at least one item from the trusted resource URL list allows this url.
        for (i = 0, n = trustedResourceUrlList.length; i < n; i++) {
          if (matchUrl(trustedResourceUrlList[i], parsedUrl)) {
            allowed = true;
            break;
          }
        }
        if (allowed) {
          // Ensure that no item from the banned resource URL list has blocked this url.
          for (i = 0, n = bannedResourceUrlList.length; i < n; i++) {
            if (matchUrl(bannedResourceUrlList[i], parsedUrl)) {
              allowed = false;
              break;
            }
          }
        }
        return allowed;
      }

      function generateHolderType(Base) {
        const holderType = function TrustedValueHolderType(trustedValue) {
          this.$$unwrapTrustedValue = function () {
            return trustedValue;
          };
        };
        if (Base) {
          holderType.prototype = new Base();
        }
        holderType.prototype.valueOf = function sceValueOf() {
          return this.$$unwrapTrustedValue();
        };
        holderType.prototype.toString = function sceToString() {
          return this.$$unwrapTrustedValue().toString();
        };
        return holderType;
      }

      const trustedValueHolderBase = generateHolderType();
      const byType = {};

      byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(
        trustedValueHolderBase,
      );
      byType[SCE_CONTEXTS.URL] = generateHolderType(
        byType[SCE_CONTEXTS.MEDIA_URL],
      );
      byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(
        byType[SCE_CONTEXTS.URL],
      );

      /**
       * Returns a trusted representation of the parameter for the specified context. This trusted
       * object will later on be used as-is, without any security check, by bindings or directives
       * that require this security context.
       * For instance, marking a string as trusted for the `$sce.HTML` context will entirely bypass
       * the potential `$sanitize` call in corresponding `$sce.HTML` bindings or directives, such as
       * `ng-bind-html`. Note that in most cases you won't need to call this function: if you have the
       * sanitizer loaded, passing the value itself will render all the HTML that does not pose a
       * security risk.
       *
       * See {@link ng.$sceDelegate#getTrusted getTrusted} for the function that will consume those
       * trusted values, and {@link ng.$sce $sce} for general documentation about strict contextual
       * escaping.
       *
       * @param {string} type The context in which this value is safe for use, e.g. `$sce.URL`,
       *     `$sce.RESOURCE_URL`, `$sce.HTML`, `$sce.JS` or `$sce.CSS`.
       *
       * @param {*} trustedValue The value that should be considered trusted.
       * @return {*} A trusted representation of value, that can be used in the given context.
       */
      function trustAs(type, trustedValue) {
        const Constructor = Object.prototype.hasOwnProperty.call(byType, type)
          ? byType[type]
          : null;
        if (!Constructor) {
          throw $sceMinErr(
            "icontext",
            "Attempted to trust a value in invalid context. Context: {0}; Value: {1}",
            type,
            trustedValue,
          );
        }
        if (
          trustedValue === null ||
          isUndefined(trustedValue) ||
          trustedValue === ""
        ) {
          return trustedValue;
        }
        // All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting
        // mutable objects, we ensure here that the value passed in is actually a string.
        if (typeof trustedValue !== "string") {
          throw $sceMinErr(
            "itype",
            "Attempted to trust a non-string value in a content requiring a string: Context: {0}",
            type,
          );
        }
        return new Constructor(trustedValue);
      }

      /**
       * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs
       * `$sceDelegate.trustAs`}, returns the value that had been passed to {@link
       * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.
       *
       * If the passed parameter is not a value that had been returned by {@link
       * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, it must be returned as-is.
       *
       * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}
       *     call or anything else.
       * @return {*} The `value` that was originally provided to {@link ng.$sceDelegate#trustAs
       *     `$sceDelegate.trustAs`} if `value` is the result of such a call.  Otherwise, returns
       *     `value` unchanged.
       */
      function valueOf(maybeTrusted) {
        if (maybeTrusted instanceof trustedValueHolderBase) {
          return maybeTrusted.$$unwrapTrustedValue();
        }
        return maybeTrusted;
      }

      /**
       * @description
       * Given an object and a security context in which to assign it, returns a value that's safe to
       * use in this context, which was represented by the parameter. To do so, this function either
       * unwraps the safe type it has been given (for instance, a {@link ng.$sceDelegate#trustAs
       * `$sceDelegate.trustAs`} result), or it might try to sanitize the value given, depending on
       * the context and sanitizer availablility.
       *
       * The contexts that can be sanitized are $sce.MEDIA_URL, $sce.URL and $sce.HTML. The first two are available
       * by default, and the third one relies on the `$sanitize` service (which may be loaded through
       * the `ngSanitize` module). Furthermore, for $sce.RESOURCE_URL context, a plain string may be
       * accepted if the resource url policy defined by {@link ng.$sceDelegateProvider#trustedResourceUrlList
       * `$sceDelegateProvider.trustedResourceUrlList`} and {@link ng.$sceDelegateProvider#bannedResourceUrlList
       * `$sceDelegateProvider.bannedResourceUrlList`} accepts that resource.
       *
       * This function will throw if the safe type isn't appropriate for this context, or if the
       * value given cannot be accepted in the context (which might be caused by sanitization not
       * being available, or the value not being recognized as safe).
       *
       * <div class="alert alert-danger">
       * Disabling auto-escaping is extremely dangerous, it usually creates a Cross Site Scripting
       * (XSS) vulnerability in your application.
       * </div>
       *
       * @param {string} type The context in which this value is to be used (such as `$sce.HTML`).
       * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs
       *     `$sceDelegate.trustAs`} call, or anything else (which will not be considered trusted.)
       * @return {*} A version of the value that's safe to use in the given context, or throws an
       *     exception if this is impossible.
       */
      function getTrusted(type, maybeTrusted) {
        if (
          maybeTrusted === null ||
          isUndefined(maybeTrusted) ||
          maybeTrusted === ""
        ) {
          return maybeTrusted;
        }
        const constructor = Object.prototype.hasOwnProperty.call(byType, type)
          ? byType[type]
          : null;
        // If maybeTrusted is a trusted class instance or subclass instance, then unwrap and return
        // as-is.
        if (constructor && maybeTrusted instanceof constructor) {
          return maybeTrusted.$$unwrapTrustedValue();
        }

        // If maybeTrusted is a trusted class instance but not of the correct trusted type
        // then unwrap it and allow it to pass through to the rest of the checks
        if (isFunction(maybeTrusted.$$unwrapTrustedValue)) {
          maybeTrusted = maybeTrusted.$$unwrapTrustedValue();
        }

        // If we get here, then we will either sanitize the value or throw an exception.
        if (type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) {
          // we attempt to sanitize non-resource URLs
          return $$sanitizeUri(
            maybeTrusted.toString(),
            type === SCE_CONTEXTS.MEDIA_URL,
          );
        }
        if (type === SCE_CONTEXTS.RESOURCE_URL) {
          if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
            return maybeTrusted;
          }
          throw $sceMinErr(
            "insecurl",
            "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}",
            maybeTrusted.toString(),
          );
        } else if (type === SCE_CONTEXTS.HTML) {
          // htmlSanitizer throws its own error when no sanitizer is available.
          return htmlSanitizer();
        }
        // Default error when the $sce service has no way to make the input safe.
        throw $sceMinErr(
          "unsafe",
          "Attempting to use an unsafe value in a safe context.",
        );
      }

      return { trustAs, getTrusted, valueOf };
    },
  ];
}

function SceProvider() {
  let enabled = true;

  /**
   * @param {boolean=} value If provided, then enables/disables SCE application-wide.
   * @return {boolean} True if SCE is enabled, false otherwise.
   *
   * @description
   * Enables/disables SCE and returns the current value.
   */
  this.enabled = function (value) {
    if (arguments.length) {
      enabled = !!value;
    }
    return enabled;
  };

  this.$get = [
    "$parse",
    "$sceDelegate",
    "$exceptionHandler",
    function ($parse, $sceDelegate, $exceptionHandler) {
      const sce = shallowCopy(SCE_CONTEXTS);

      /**
       * @return {Boolean} True if SCE is enabled, false otherwise.  If you want to set the value, you
       *     have to do it at module config time on {@link ng.$sceProvider $sceProvider}.
       *
       * @description
       * Returns a boolean indicating if SCE is enabled.
       */
      sce.isEnabled = function () {
        return enabled;
      };
      sce.trustAs = $sceDelegate.trustAs;
      sce.getTrusted = $sceDelegate.getTrusted;
      sce.valueOf = $sceDelegate.valueOf;

      if (!enabled) {
        sce.trustAs = sce.getTrusted = function (type, value) {
          return value;
        };
        sce.valueOf = function ($) {
          return $;
        };
      }

      /**
       * Converts AngularJS {@link guide/expression expression} into a function.  This is like {@link
       * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it
       * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,
       * *result*)}
       *
       * @param {string} type The SCE context in which this result will be used.
       * @param {string} expr String expression to compile.
       * @return {function(context, locals)} A function which represents the compiled expression:
       *
       *    * `context`  `{object}`  an object against which any expressions embedded in the
       *      strings are evaluated against (typically a scope object).
       *    * `locals`  `{object=}`  local variables context object, useful for overriding values
       *      in `context`.
       */
      sce.parseAs = function sceParseAs(type, expr) {
        const parsed = $parse(expr);
        if (parsed.literal && parsed.constant) {
          return parsed;
        }
        return $parse(expr, (value) => sce.getTrusted(type, value));
      };

      /**
       * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}. As such, returns a
       * wrapped object that represents your value, and the trust you have in its safety for the given
       * context. AngularJS can then use that value as-is in bindings of the specified secure context.
       * This is used in bindings for `ng-bind-html`, `ng-include`, and most `src` attribute
       * interpolations. See {@link ng.$sce $sce} for strict contextual escaping.
       *
       * @param {string} type The context in which this value is safe for use, e.g. `$sce.URL`,
       *     `$sce.RESOURCE_URL`, `$sce.HTML`, `$sce.JS` or `$sce.CSS`.
       *
       * @param {*} value The value that that should be considered trusted.
       * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`
       *     in the context you specified.
       */

      /**
       * Shorthand method.  `$sce.trustAsHtml(value)` 
       *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}
       *
       * @param {*} value The value to mark as trusted for `$sce.HTML` context.
       * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`
       *     in `$sce.HTML` context (like `ng-bind-html`).
       */

      /**
       * Shorthand method.  `$sce.trustAsCss(value)` 
       *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.CSS, value)`}
       *
       * @param {*} value The value to mark as trusted for `$sce.CSS` context.
       * @return {*} A wrapped version of value that can be used as a trusted variant
       *     of your `value` in `$sce.CSS` context. This context is currently unused, so there are
       *     almost no reasons to use this function so far.
       */

      /**
       * Shorthand method.  `$sce.trustAsUrl(value)` 
       *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}
       *
       * @param {*} value The value to mark as trusted for `$sce.URL` context.
       * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`
       *     in `$sce.URL` context. That context is currently unused, so there are almost no reasons
       *     to use this function so far.
       */

      /**
       * Shorthand method.  `$sce.trustAsResourceUrl(value)` 
       *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}
       *
       * @param {*} value The value to mark as trusted for `$sce.RESOURCE_URL` context.
       * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`
       *     in `$sce.RESOURCE_URL` context (template URLs in `ng-include`, most `src` attribute
       *     bindings, ...)
       */

      /**
       * Shorthand method.  `$sce.trustAsJs(value)` 
       *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, value)`}
       *
       * @param {*} value The value to mark as trusted for `$sce.JS` context.
       * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`
       *     in `$sce.JS` context. That context is currently unused, so there are almost no reasons to
       *     use this function so far.
       */

      /**
       * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such,
       * takes any input, and either returns a value that's safe to use in the specified context,
       * or throws an exception. This function is aware of trusted values created by the `trustAs`
       * function and its shorthands, and when contexts are appropriate, returns the unwrapped value
       * as-is. Finally, this function can also throw when there is no way to turn `maybeTrusted` in a
       * safe value (e.g., no sanitization is available or possible.)
       *
       * @param {string} type The context in which this value is to be used.
       * @param {*} maybeTrusted The result of a prior {@link ng.$sce#trustAs
       *     `$sce.trustAs`} call, or anything else (which will not be considered trusted.)
       * @return {*} A version of the value that's safe to use in the given context, or throws an
       *     exception if this is impossible.
       */

      /**
       * Shorthand method.  `$sce.getTrustedHtml(value)` 
       *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}
       *
       * @param {*} value The value to pass to `$sce.getTrusted`.
       * @return {*} The return value of `$sce.getTrusted($sce.HTML, value)`
       */

      /**
       * Shorthand method.  `$sce.getTrustedCss(value)` 
       *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}
       *
       * @param {*} value The value to pass to `$sce.getTrusted`.
       * @return {*} The return value of `$sce.getTrusted($sce.CSS, value)`
       */

      /**
       * Shorthand method.  `$sce.getTrustedUrl(value)` 
       *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}
       *
       * @param {*} value The value to pass to `$sce.getTrusted`.
       * @return {*} The return value of `$sce.getTrusted($sce.URL, value)`
       */

      /**
       * Shorthand method.  `$sce.getTrustedResourceUrl(value)` 
       *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}
       *
       * @param {*} value The value to pass to `$sceDelegate.getTrusted`.
       * @return {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`
       */

      /**
       * Shorthand method.  `$sce.getTrustedJs(value)` 
       *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}
       *
       * @param {*} value The value to pass to `$sce.getTrusted`.
       * @return {*} The return value of `$sce.getTrusted($sce.JS, value)`
       */

      /**
       * Shorthand method.  `$sce.parseAsHtml(expression string)` 
       *     {@link ng.$sce#parseAs `$sce.parseAs($sce.HTML, value)`}
       *
       * @param {string} expression String expression to compile.
       * @return {function(context, locals)} A function which represents the compiled expression:
       *
       *    * `context`  `{object}`  an object against which any expressions embedded in the
       *      strings are evaluated against (typically a scope object).
       *    * `locals`  `{object=}`  local variables context object, useful for overriding values
       *      in `context`.
       */

      /**
       * Shorthand method.  `$sce.parseAsCss(value)` 
       *     {@link ng.$sce#parseAs `$sce.parseAs($sce.CSS, value)`}
       *
       * @param {string} expression String expression to compile.
       * @return {function(context, locals)} A function which represents the compiled expression:
       *
       *    * `context`  `{object}`  an object against which any expressions embedded in the
       *      strings are evaluated against (typically a scope object).
       *    * `locals`  `{object=}`  local variables context object, useful for overriding values
       *      in `context`.
       */

      /**
       * Shorthand method.  `$sce.parseAsUrl(value)` 
       *     {@link ng.$sce#parseAs `$sce.parseAs($sce.URL, value)`}
       *
       * @param {string} expression String expression to compile.
       * @return {function(context, locals)} A function which represents the compiled expression:
       *
       *    * `context`  `{object}`  an object against which any expressions embedded in the
       *      strings are evaluated against (typically a scope object).
       *    * `locals`  `{object=}`  local variables context object, useful for overriding values
       *      in `context`.
       */

      /**
       * Shorthand method.  `$sce.parseAsResourceUrl(value)` 
       *     {@link ng.$sce#parseAs `$sce.parseAs($sce.RESOURCE_URL, value)`}
       *
       * @param {string} expression String expression to compile.
       * @return {function(context, locals)} A function which represents the compiled expression:
       *
       *    * `context`  `{object}`  an object against which any expressions embedded in the
       *      strings are evaluated against (typically a scope object).
       *    * `locals`  `{object=}`  local variables context object, useful for overriding values
       *      in `context`.
       */

      /**
       * Shorthand method.  `$sce.parseAsJs(value)` 
       *     {@link ng.$sce#parseAs `$sce.parseAs($sce.JS, value)`}
       *
       * @param {string} expression String expression to compile.
       * @return {function(context, locals)} A function which represents the compiled expression:
       *
       *    * `context`  `{object}`  an object against which any expressions embedded in the
       *      strings are evaluated against (typically a scope object).
       *    * `locals`  `{object=}`  local variables context object, useful for overriding values
       *      in `context`.
       */

      // Shorthand delegations.
      const parse = sce.parseAs;
      const { getTrusted } = sce;
      const { trustAs } = sce;

      Object.entries(SCE_CONTEXTS).forEach(([name, enumValue]) => {
        const lName = lowercase(name);
        sce[snakeToCamel(`parse_as_${lName}`)] = function (expr) {
          return parse(enumValue, expr);
        };
        sce[snakeToCamel(`get_trusted_${lName}`)] = function (value) {
          try {
            return getTrusted(enumValue, value);
          } catch (e) {
            $exceptionHandler(e);
          }
        };
        sce[snakeToCamel(`trust_as_${lName}`)] = function (value) {
          return trustAs(enumValue, value);
        };
      });

      return sce;
    },
  ];
}

/*
 * A collection of directives that allows creation of custom event handlers that are defined as
 * AngularTS expressions and are compiled and executed within the current scope.
 */
const ngEventDirectives = {};

"click copy cut dblclick focus blur keydown keyup keypress load mouseover mousein mouseout mouseleave paste submit touchstart touchend touchmove"
  .split(" ")
  .forEach(
    /** @param { string } eventName */
    (eventName) => {
      const directiveName = directiveNormalize(`ng-${eventName}`);
      ngEventDirectives[directiveName] = [
        "$parse",
        "$exceptionHandler",
        /**
         * @param {import("../../core/parse/parse.js").ParseService} $parse
         * @param {import('../../core/exception-handler.js').ErrorHandler} $exceptionHandler
         * @returns
         */
        ($parse, $exceptionHandler) => {
          return createEventDirective(
            $parse,
            $exceptionHandler,
            directiveName,
            eventName,
          );
        },
      ];
    },
  );

/**
 *
 * @param {import("../../core/parse/parse.js").ParseService} $parse
 * @param {import('../../core/exception-handler.js').ErrorHandler} $exceptionHandler
 * @param {string} directiveName
 * @param {string} eventName
 * @returns {import("../../types.js").Directive}
 */
function createEventDirective(
  $parse,
  $exceptionHandler,
  directiveName,
  eventName,
) {
  return {
    restrict: "A",
    compile(_element, attr) {
      const fn = $parse(attr[directiveName]);
      return function ngEventHandler(scope, element) {
        element.addEventListener(eventName, (event) => {
          try {
            fn(scope, { $event: event });
          } catch (error) {
            $exceptionHandler(error);
          }
        });
      };
    },
  };
}

const $compileMinErr$1 = minErr("$compile");
const SIMPLE_ATTR_NAME = /^\w/;
const specialAttrHolder = document.createElement("div");

class Attributes {
  static $nonscope = true;

  /**
   * @param {import('../scope/scope.js').Scope} $rootScope
   * @param {*} $animate
   * @param {import("../exception-handler.js").ErrorHandler} $exceptionHandler
   * @param {*} $sce
   * @param {import("../../shared/noderef.js").NodeRef} [nodeRef]
   * @param {*} [attributesToCopy]
   */
  constructor(
    $rootScope,
    $animate,
    $exceptionHandler,
    $sce,
    nodeRef,
    attributesToCopy,
  ) {
    this.$rootScope = $rootScope;
    this.$animate = $animate;
    this.$exceptionHandler = $exceptionHandler;
    this.$sce = $sce;
    if (attributesToCopy) {
      const keys = Object.keys(attributesToCopy);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        this[key] = attributesToCopy[key];
      }
    } else {
      this.$attr = {};
    }

    /** @type {import("../../shared/noderef.js").NodeRef} */
    this.$nodeRef = nodeRef;
  }

  /** @type {Node} */
  get $$element() {
    return this.$nodeRef.node;
  }

  /**
   * Converts an attribute name (e.g. dash/colon/underscore-delimited string, optionally prefixed with `x-` or
   * `data-`) to its normalized, camelCase form.
   *
   * Also there is special case for Moz prefix starting with upper case letter.
   *
   * For further information check out the guide on {@link guide/directive#matching-directives Matching Directives}
   *
   * @param {string} name Name to normalize
   */
  $normalize = directiveNormalize;

  /**
   * Adds the CSS class value specified by the classVal parameter to the element. If animations
   * are enabled then an animation will be triggered for the class addition.
   *
   * @param {string} classVal The className value that will be added to the element
   */
  $addClass(classVal) {
    if (classVal && classVal.length > 0) {
      if (hasAnimate(this.$$element)) {
        this.$animate.addClass(this.$$element, classVal);
      } else {
        this.$nodeRef.element.classList.add(classVal);
      }
    }
  }

  /**
   * Removes the CSS class value specified by the classVal parameter from the element. If
   * animations are enabled then an animation will be triggered for the class removal.
   *
   * @param {string} classVal The className value that will be removed from the element
   */
  $removeClass(classVal) {
    if (classVal && classVal.length > 0) {
      if (hasAnimate(this.$$element)) {
        this.$animate.removeClass(this.$$element, classVal);
      } else {
        this.$nodeRef.element.classList.remove(classVal);
      }
    }
  }

  /**
   * Adds and removes the appropriate CSS class values to the element based on the difference
   * between the new and old CSS class values (specified as newClasses and oldClasses).
   *
   * @param {string} newClasses The current CSS className value
   * @param {string} oldClasses The former CSS className value
   */
  $updateClass(newClasses, oldClasses) {
    const toAdd = tokenDifference(newClasses, oldClasses);
    if (toAdd && toAdd.length) {
      if (hasAnimate(this.$$element)) {
        this.$animate.addClass(this.$$element, toAdd);
      } else {
        this.$nodeRef.element.classList.add(...toAdd.trim().split(/\s+/));
      }
    }
    const toRemove = tokenDifference(oldClasses, newClasses);
    if (toRemove && toRemove.length) {
      if (hasAnimate(this.$$element)) {
        this.$animate.removeClass(this.$$element, toRemove);
      } else {
        this.$nodeRef.element.classList.remove(...toRemove.trim().split(/\s+/));
      }
    }
  }

  /**
   * Set a normalized attribute on the element in a way such that all directives
   * can share the attribute. This function properly handles boolean attributes.
   * @param {string} key Normalized key. (ie ngAttribute)
   * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
   * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
   *     Defaults to true.
   * @param {string=} attrName Optional none normalized name. Defaults to key.
   */
  $set(key, value, writeAttr, attrName) {
    // TODO: decide whether or not to throw an error if "class"
    // is set through this function since it may cause $updateClass to
    // become unstable.

    const node = this.$$element;
    const booleanKey = getBooleanAttrName(node, key);
    const aliasedKey = ALIASED_ATTR[key];
    let observer = key;

    if (booleanKey) {
      this.$$element[key] = value;
      attrName = booleanKey;
    } else if (aliasedKey) {
      this[aliasedKey] = value;
      observer = aliasedKey;
    }

    this[key] = value;

    // translate normalized key to actual key
    if (attrName) {
      this.$attr[key] = attrName;
    } else {
      attrName = this.$attr[key];
      if (!attrName) {
        this.$attr[key] = attrName = snakeCase(key, "-");
      }
    }

    let nodeName = this.$nodeRef.node.nodeName.toLowerCase();

    // Sanitize img[srcset] values.
    if (nodeName === "img" && key === "srcset") {
      this[key] = value = this.sanitizeSrcset(value, "$set('srcset', value)");
    }

    if (writeAttr !== false) {
      let elem = isProxy(this.$$element)
        ? this.$$element["$target"]
        : this.$$element;
      if (value === null || isUndefined(value)) {
        elem.removeAttribute(attrName);
        //
      } else if (SIMPLE_ATTR_NAME.test(attrName)) {
        // jQuery skips special boolean attrs treatment in XML nodes for
        // historical reasons and hence AngularJS cannot freely call
        // `.getAttribute(attrName, false) with such attributes. To avoid issues
        // in XHTML, call `removeAttr` in such cases instead.
        // See https://github.com/jquery/jquery/issues/4249
        if (booleanKey && value === false) {
          elem.removeAttribute(attrName);
        } else {
          if (booleanKey) {
            elem.toggleAttribute(attrName, value);
          } else {
            elem.setAttribute(attrName, value);
          }
        }
      } else {
        this.setSpecialAttr(this.$$element, attrName, value);
      }
    }

    // fire observers
    const { $$observers } = this;
    if ($$observers && $$observers[observer]) {
      $$observers[observer].forEach((fn) => {
        try {
          fn(value);
        } catch (e) {
          this.$exceptionHandler(e);
        }
      });
    }
  }

  /**
 * Observes an interpolated attribute.
 *
 * The observer function will be invoked once during the next `$digest` following
 * compilation. The observer is then invoked whenever the interpolated value
 * changes.
 *
 * @param {string} key Normalized key. (ie ngAttribute) .
 * @param {any} fn Function that will be called whenever
          the interpolated value of the attribute changes.
 *        See the {@link guide/interpolation#how-text-and-attribute-bindings-work Interpolation
 *        guide} for more info.
 * @returns {function()} Returns a deregistration function for this observer.
 */
  $observe(key, fn) {
    const $$observers =
      this.$$observers || (this.$$observers = Object.create(null));
    const listeners = $$observers[key] || ($$observers[key] = []);

    listeners.push(fn);
    if (
      !listeners.$$inter &&
      Object.prototype.hasOwnProperty.call(this, key) &&
      !isUndefined(this[key])
    ) {
      // no one registered attribute interpolation function, so lets call it manually
      fn(this[key]);
    }

    return function () {
      arrayRemove(listeners, fn);
    };
  }

  setSpecialAttr(element, attrName, value) {
    // Attributes names that do not start with letters (such as `(click)`) cannot be set using `setAttribute`
    // so we have to jump through some hoops to get such an attribute
    // https://github.com/angular/angular.js/pull/13318
    specialAttrHolder.innerHTML = `<span ${attrName}>`;
    const { attributes } = /** @type {Element} */ (
      specialAttrHolder.firstChild
    );
    const attribute = attributes[0];
    // We have to remove the attribute from its container element before we can add it to the destination element
    attributes.removeNamedItem(attribute.name);
    attribute.value = value;
    element.attributes.setNamedItem(attribute);
  }

  sanitizeSrcset(value, invokeType) {
    if (!value) {
      return value;
    }
    if (!isString(value)) {
      throw $compileMinErr$1(
        "srcset",
        'Can\'t pass trusted values to `{0}`: "{1}"',
        invokeType,
        value.toString(),
      );
    }

    // Such values are a bit too complex to handle automatically inside $sce.
    // Instead, we sanitize each of the URIs individually, which works, even dynamically.

    // It's not possible to work around this using `$sce.trustAsMediaUrl`.
    // If you want to programmatically set explicitly trusted unsafe URLs, you should use
    // `$sce.trustAsHtml` on the whole `img` tag and inject it into the DOM using the
    // `ng-bind-html` directive.

    var result = "";

    // first check if there are spaces because it's not the same pattern
    var trimmedSrcset = trim(value);
    //                (   999x   ,|   999w   ,|   ,|,   )
    var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
    var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;

    // split srcset into tuple of uri and descriptor except for the last item
    var rawUris = trimmedSrcset.split(pattern);

    // for each tuples
    var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
    for (var i = 0; i < nbrUrisWith2parts; i++) {
      var innerIdx = i * 2;
      // sanitize the uri
      result += this.$sce.getTrustedMediaUrl(trim(rawUris[innerIdx]));
      // add the descriptor
      result += " " + trim(rawUris[innerIdx + 1]);
    }

    // split the last item into uri and descriptor
    var lastTuple = trim(rawUris[i * 2]).split(/\s/);

    // sanitize the last uri
    result += this.$sce.getTrustedMediaUrl(trim(lastTuple[0]));

    // and add the last descriptor if any
    if (lastTuple.length === 2) {
      result += " " + trim(lastTuple[1]);
    }
    return result;
  }
}

/**
 * Computes the difference between two space-separated token strings.
 *
 * @param {string} str1 - The first string containing space-separated tokens.
 * @param {string} str2 - The second string containing space-separated tokens.
 * @returns {string} A string containing tokens that are in str1 but not in str2, separated by spaces.
 *
 */
function tokenDifference(str1, str2) {
  const tokens1 = new Set(str1.split(/\s+/));
  const tokens2 = new Set(str2.split(/\s+/));

  const difference = [...tokens1].filter((token) => !tokens2.has(token));
  return difference.join(" ");
}

/**
 * @param {string} source - the name of the attribute to be observed
 * @param {string} prop - the scope property to be updated with attribute value
 * @returns {import("../../types.js").Directive}
 */
function ngObserveDirective(source, prop) {
  return {
    restrict: "A",
    compile: () => (scope, element) => {
      const targetElement = element;
      if (prop === "") {
        prop = source;
      }
      const normalized = kebabToCamel(prop);
      if (!scope[normalized]) {
        scope[normalized] = targetElement.getAttribute(source);
      }

      const observer = new MutationObserver((mutations) => {
        const mutation = mutations[0];
        const newValue = /** @type {HTMLElement} */ (
          mutation.target
        ).getAttribute(source);
        if (scope[normalized] !== newValue) {
          scope[normalized] = newValue;
        }
      });

      observer.observe(targetElement, {
        attributes: true,
        attributeFilter: [source],
      });

      scope.$on("$destroy", () => {
        observer.disconnect();
      });
    },
  };
}

/**
 * A function passed as the fifth argument to a {@type PublicLinkFn} link function.
 * It behaves like a linking function, with the `scope` argument automatically created
 * as a new child of the transcluded parent scope.
 *
 * The function returns the DOM content to be injected (transcluded) into the directive.
 *
 * @callback TranscludeFn
 * @param {Element|Node} [clone] - The DOM node to be inserted into the transcluded directive.
 * @param {import("../scope/scope.js").Scope} [scope] - The new child scope created from the transcluded parent.
 * @returns void

/**
 * A specialized version of {@link TranscludeFn} with the scope argument already bound.
 * This function requires no parameters and returns the same result as {@link TranscludeFn}.
 *
 * @typedef {() => Element|Node} BoundTranscludeFn
 */

/**
 * @typedef {Object} SimpleChange
 * @property {any} currentValue
 * @property {boolean} firstChange
 */

/**
 * @description A function returned by the '$compile' service that links a compiled template to a scope.
 *
 * @callback PublicLinkFn
 * @param {import('../scope/scope.js').Scope} scope - Scope to link with element
 * @param {TranscludeFn} [cloneConnectFn]
 * @param {*} [options]
 * @return {Element|Node|ChildNode} The nodes to be linked.
 */

/**
 * @description Entry point for the '$compile' service.
 *
 * @callback CompileFn
 * @param {string|Element|Node|ChildNode|NodeList} compileNode - The node to be compiled.
 * @param {TranscludeFn} [transcludeFn] - An optional transclusion function to be used during compilation.
 * @param {number} [maxPriority] - An optional maximum priority for directives.
 * @param {string} [ignoreDirective] - An optional directive to ignore during compilation.
 * @param {*} [previousCompileContext] - An optional context from a previous compilation. TODO
 * @returns {PublicLinkFn} A public link function.
 */

/**
 * @typedef {Object} LinkFnMapping
 * @property {number} index
 * @property {NodeLinkFn} [nodeLinkFn]
 * @property {CompositeLinkFn} [childLinkFn]
 */

/**
 * @typedef {function(): CompositeLinkFn} CompileNodesFn
 */

/**
 * @callback NodeLinkFn
 * @param {CompositeLinkFn} childLinkFn
 * @returns {Node|Element|NodeList}
 */

/**
 * @typedef {function(): NodeLinkFn} ApplyDirectivesToNodeFn
 */

/**
 * @description Function that aggregates all linking fns for a compilation root (nodeList)
 * @callback CompositeLinkFn
 * @param {import('../scope/scope.js').Scope} scope - The scope to be linked to the template
 * @param {NodeRef} $linkNode - wrapper around a nodeList
 * @param {Function} [parentBoundTranscludeFn]
 */

const $compileMinErr = minErr("$compile");
const EXCLUDED_DIRECTIVES = ["ngIf", "ngRepeat"];
const ALL_OR_NOTHING_ATTRS = ["ngSrc", "ngSrcset", "src", "srcset"];
const REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
// Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
// The assumption is that future DOM event attribute names will begin with
// 'on' and be composed of only English letters.
const EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
const DirectiveSuffix = "Directive";

CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"];
function CompileProvider($provide, $$sanitizeUriProvider) {
  const hasDirectives = {};

  const bindingCache = Object.create(null);

  /**
   *
   * @param {import("../scope/scope.js").Scope} scope
   * @param {string} directiveName
   * @param {boolean} isController
   * @returns {Object} a configuartion object for attribute bindings
   */
  function parseIsolateBindings(scope, directiveName, isController) {
    const LOCAL_REGEXP = /^([@&]|[=<]())(\??)\s*([\w$]*)$/;

    const bindings = Object.create(null);

    Object.entries(scope).forEach(([scopeName, definition]) => {
      definition = definition.trim();

      if (definition in bindingCache) {
        bindings[scopeName] = bindingCache[definition];
        return;
      }
      const match = definition.match(LOCAL_REGEXP);

      if (!match) {
        throw $compileMinErr(
          "iscp",
          "Invalid {3} for directive '{0}'." +
            " Definition: {... {1}: '{2}' ...}",
          directiveName,
          scopeName,
          definition,
          isController
            ? "controller bindings definition"
            : "isolate scope definition",
        );
      }

      bindings[scopeName] = {
        mode: match[1][0],
        collection: match[2] === "*",
        optional: match[3] === "?",
        attrName: match[4] || scopeName,
      };
      if (match[4]) {
        bindingCache[definition] = bindings[scopeName];
      }
    });

    return bindings;
  }

  function parseDirectiveBindings(directive, directiveName) {
    const bindings = {
      isolateScope: null,
      bindToController: null,
    };
    if (isObject(directive.scope)) {
      if (directive.bindToController === true) {
        bindings.bindToController = parseIsolateBindings(
          directive.scope,
          directiveName,
          true,
        );
        bindings.isolateScope = {};
      } else {
        bindings.isolateScope = parseIsolateBindings(
          directive.scope,
          directiveName,
          false,
        );
      }
    }
    if (isObject(directive.bindToController)) {
      bindings.bindToController = parseIsolateBindings(
        directive.bindToController,
        directiveName,
        true,
      );
    }
    if (bindings.bindToController && !directive.controller) {
      // There is no controller
      throw $compileMinErr(
        "noctrl",
        "Cannot bind to controller without directive '{0}'s controller.",
        directiveName,
      );
    }
    return bindings;
  }

  function getDirectiveRequire(directive) {
    const require =
      directive.require || (directive.controller && directive.name);

    if (!Array.isArray(require) && isObject(require)) {
      Object.entries(require).forEach(([key, value]) => {
        const match = value.match(REQUIRE_PREFIX_REGEXP);
        const name = value.substring(match[0].length);
        if (!name) require[key] = match[0] + key;
      });
    }

    return require;
  }

  function getDirectiveRestrict(restrict, name) {
    if (restrict && !(isString(restrict) && /[EA]/.test(restrict))) {
      throw $compileMinErr(
        "badrestrict",
        "Restrict property '{0}' of directive '{1}' is invalid",
        restrict,
        name,
      );
    }
    // Default is element or attribute
    return restrict || "EA";
  }

  /**
   * Register a new directive with the compiler.
   *
   * @param {string|Object} name Name of the directive in camel-case (i.e. `ngBind` which will match
   *    as `ng-bind`), or an object map of directives where the keys are the names and the values
   *    are the factories.
   * @param {Function|Array} directiveFactory An injectable directive factory function. See the
   *    {@link guide/directive directive guide} and the {@link $compile compile API} for more info.
   * @returns {CompileProvider} Self for chaining.
   */
  this.directive = function registerDirective(name, directiveFactory) {
    assertArg$1(name, "name");
    assertNotHasOwnProperty(name, "directive");
    if (isString(name)) {
      assertValidDirectiveName(name);
      assertArg$1(directiveFactory, "directiveFactory");
      if (!Object.prototype.hasOwnProperty.call(hasDirectives, name)) {
        hasDirectives[name] = [];
        $provide.factory(name + DirectiveSuffix, [
          "$injector",
          "$exceptionHandler",
          /**
           *
           * @param {import("../../core/di/internal-injector").InjectorService} $injector
           * @param {import('../exception-handler').ErrorHandler} $exceptionHandler
           * @returns
           */
          function ($injector, $exceptionHandler) {
            const directives = [];
            hasDirectives[name].forEach((directiveFactory, index) => {
              try {
                let directive = $injector.invoke(directiveFactory);
                const valueFn = (value) => () => value;
                if (isFunction(directive)) {
                  directive = { compile: valueFn(directive) };
                } else if (!directive.compile && directive.link) {
                  directive.compile = valueFn(directive.link);
                }

                directive.priority = directive.priority || 0;
                directive.index = index;
                directive.name = directive.name || name;
                directive.require = getDirectiveRequire(directive);
                directive.restrict = getDirectiveRestrict(
                  directive.restrict,
                  name,
                );
                directive.$$moduleName = directiveFactory.$$moduleName;
                directives.push(directive);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
            return directives;
          },
        ]);
      }
      hasDirectives[name].push(directiveFactory);
    } else {
      Object.entries(name).forEach(([k, v]) => registerDirective(k, v));
    }
    return this;
  };

  /**
   * @param {string|Object} name Name of the component in camelCase (i.e. `myComp` which will match `<my-comp>`),
   *    or an object map of components where the keys are the names and the values are the component definition objects.
   * @param {Object} options Component definition object (a simplified
   *    {directive definition object}),
   *    with the following properties (all optional):
   *
   *    - `controller`  `{(string|function()=}`  controller constructor function that should be
   *      associated with newly created scope or the name of a {controller} if passed as a string. An empty `noop` function by default.
   *    - `controllerAs`  `{string=}`  identifier name for to reference the controller in the component's scope.
   *      If present, the controller will be published to scope under the `controllerAs` name.
   *      If not present, this will default to be `$ctrl`.
   *    - `template`  `{string=|function()=}`  html template as a string or a function that
   *      returns an html template as a string which should be used as the contents of this component.
   *      Empty string by default.
   *
   *      If `template` is a function, then it is {injected} with
   *      the following locals:
   *
   *      - `$element` - Current element
   *      - `$attrs` - Current attributes object for the element
   *
   *    - `templateUrl`  `{string=|function()=}`  path or function that returns a path to an html
   *      template that should be used  as the contents of this component.
   *
   *      If `templateUrl` is a function, then it is {injected} with
   *      the following locals:
   *
   *      - `$element` - Current element
   *      - `$attrs` - Current attributes object for the element
   *
   *    - `bindings`  `{object=}`  defines bindings between DOM attributes and component properties.
   *      Component properties are always bound to the component controller and not to the scope.
   *      See {`bindToController`}.
   *    - `transclude`  `{boolean=}`  whether {content transclusion} is enabled.
   *      Disabled by default.
   *    - `require` - `{Object<string, string>=}` - requires the controllers of other directives and binds them to
   *      this component's controller. The object keys specify the property names under which the required
   *      controllers (object values) will be bound. See {`require`}.
   *    - `$...`  additional properties to attach to the directive factory function and the controller
   *      constructor function. (This is used by the component router to annotate)
   *
   * @returns {CompileProvider} the compile provider itself, for chaining of function calls.
   */
  this.component = function (name, options) {
    if (!isString(name)) {
      Object.entries(name).forEach(([key, val]) => this.component(key, val));
      return this;
    }

    const controller = options.controller || function () {};

    function factory($injector) {
      function makeInjectable(fn) {
        if (isFunction(fn) || Array.isArray(fn)) {
          return function (tElement, tAttrs) {
            return $injector.invoke(fn, this, {
              $element: tElement,
              $attrs: tAttrs,
            });
          };
        }
        return fn;
      }

      const template =
        !options.template && !options.templateUrl ? "" : options.template;
      const ddo = {
        controller,
        controllerAs:
          identifierForController(options.controller) ||
          options.controllerAs ||
          "$ctrl",
        template: makeInjectable(template),
        templateUrl: makeInjectable(options.templateUrl),
        transclude: options.transclude,
        scope: {},
        bindToController: options.bindings || {},
        restrict: "E",
        require: options.require,
      };

      // Copy annotations (starting with $) over to the DDO
      Object.entries(options).forEach(([key, val]) => {
        if (key.charAt(0) === "$") ddo[key] = val;
      });

      return ddo;
    }

    // Copy any annotation properties (starting with $) over to the factory and controller constructor functions
    // These could be used by libraries such as the new component router
    Object.entries(options).forEach(([key, val]) => {
      if (key.charAt(0) === "$") {
        factory[key] = val;
        // Don't try to copy over annotations to named controller
        if (isFunction(controller)) controller[key] = val;
      }
    });

    factory.$inject = ["$injector"];

    return this.directive(name, factory);
  };

  /**
   * Retrieves or overrides the default regular expression that is used for determining trusted safe
   * urls during a[href] sanitization.
   *
   * The sanitization is a security measure aimed at preventing XSS attacks via html links.
   *
   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationTrustedUrlList`
   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to trust urls with.
   * @returns {RegExp|CompileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.aHrefSanitizationTrustedUrlList = function (regexp) {
    if (isDefined(regexp)) {
      $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList(regexp);
      return this;
    }
    return $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList();
  };

  /**
   * Retrieves or overrides the default regular expression that is used for determining trusted safe
   * urls during img[src] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
   *
   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into
   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationTrustedUrlList`
   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to trust urls with.
   * @returns {RegExp|CompileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.imgSrcSanitizationTrustedUrlList = function (regexp) {
    if (isDefined(regexp)) {
      $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList(regexp);
      return this;
    }
    return $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList();
  };

  /**
   * @param {boolean=} enabled update the strictComponentBindingsEnabled state if provided,
   * otherwise return the current strictComponentBindingsEnabled state.
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   *
   * Call this method to enable / disable the strict component bindings check. If enabled, the
   * compiler will enforce that all scope / controller bindings of a
   * {@link $compileProvider#directive directive} / {@link $compileProvider#component component}
   * that are not set as optional with `?`, must be provided when the directive is instantiated.
   * If not provided, the compiler will throw the
   * {@link error/$compile/missingattr $compile:missingattr error}.
   *
   * The default value is false.
   */
  let strictComponentBindingsEnabled = false;
  this.strictComponentBindingsEnabled = function (enabled) {
    if (isDefined(enabled)) {
      strictComponentBindingsEnabled = enabled;
      return this;
    }
    return strictComponentBindingsEnabled;
  };

  /**
   * The security context of DOM Properties.
   */
  const PROP_CONTEXTS = Object.create(null);

  /**
   * Defines the security context for DOM properties bound by ng-prop-*.
   *
   * @param {string} elementName The element name or '*' to match any element.
   * @param {string} propertyName The DOM property name.
   * @param {string} ctx The {@link $sce} security context in which this value is safe for use, e.g. `$sce.URL`
   * @returns {object} `this` for chaining
   */
  this.addPropertySecurityContext = function (elementName, propertyName, ctx) {
    const key = `${elementName.toLowerCase()}|${propertyName.toLowerCase()}`;

    if (key in PROP_CONTEXTS && PROP_CONTEXTS[key] !== ctx) {
      throw $compileMinErr(
        "ctxoverride",
        "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.",
        elementName,
        propertyName,
        PROP_CONTEXTS[key],
        ctx,
      );
    }

    PROP_CONTEXTS[key] = ctx;
    return this;
  };

  /* Default property contexts.
   *
   * Copy of https://github.com/angular/angular/blob/6.0.6/packages/compiler/src/schema/dom_security_schema.ts#L31-L58
   * Changing:
   * - SecurityContext.* => SCE_CONTEXTS/$sce.*
   * - STYLE => CSS
   * - various URL => MEDIA_URL
   * - *|formAction, form|action URL => RESOURCE_URL (like the attribute)
   */
  (function registerNativePropertyContexts() {
    function registerContext(ctx, values) {
      values.forEach((v) => {
        PROP_CONTEXTS[v.toLowerCase()] = ctx;
      });
    }

    registerContext(SCE_CONTEXTS.HTML, [
      "iframe|srcdoc",
      "*|innerHTML",
      "*|outerHTML",
    ]);
    registerContext(SCE_CONTEXTS.CSS, ["*|style"]);
    registerContext(SCE_CONTEXTS.URL, [
      "area|href",
      "area|ping",
      "a|href",
      "a|ping",
      "blockquote|cite",
      "body|background",
      "del|cite",
      "input|src",
      "ins|cite",
      "q|cite",
    ]);
    registerContext(SCE_CONTEXTS.MEDIA_URL, [
      "audio|src",
      "img|src",
      "img|srcset",
      "source|src",
      "source|srcset",
      "track|src",
      "video|src",
      "video|poster",
    ]);
    registerContext(SCE_CONTEXTS.RESOURCE_URL, [
      "*|formAction",
      "applet|code",
      "applet|codebase",
      "base|href",
      "embed|src",
      "frame|src",
      "form|action",
      "head|profile",
      "html|manifest",
      "iframe|src",
      "link|href",
      "media|src",
      "object|codebase",
      "object|data",
      "script|src",
    ]);
  })();

  this.$get = [
    "$injector",
    "$interpolate",
    "$exceptionHandler",
    "$templateRequest",
    "$parse",
    "$controller",
    "$rootScope",
    "$sce",
    "$animate",
    /**
     * @param {import("../../core/di/internal-injector.js").InjectorService} $injector
     * @param {*} $interpolate
     * @param {import("../exception-handler.js").ErrorHandler} $exceptionHandler
     * @param {*} $templateRequest
     * @param {import("../parse/parse.js").ParseService} $parse
     * @param {*} $controller
     * @param {import('../scope/scope.js').Scope} $rootScope
     * @param {*} $sce
     * @param {*} $animate
     * @returns
     */
    function (
      $injector,
      $interpolate,
      $exceptionHandler,
      $templateRequest,
      $parse,
      $controller,
      $rootScope,
      $sce,
      $animate,
    ) {
      // The onChanges hooks should all be run together in a single digest
      // When changes occur, the call to trigger their hooks will be added to this queue
      let onChangesQueue;

      // This function is called in a $postUpdate to trigger all the onChanges hooks in a single digest
      function flushOnChangesQueue() {
        for (let i = 0, ii = onChangesQueue.length; i < ii; ++i) {
          try {
            onChangesQueue[i]();
          } catch (e) {
            $exceptionHandler(e);
          }
        }
        // Reset the queue to trigger a new schedule next time there is a change
        onChangesQueue = undefined;
      }

      const startSymbol = $interpolate.startSymbol();
      const endSymbol = $interpolate.endSymbol();
      /** @type {(string) => string} */
      const denormalizeTemplate =
        startSymbol === "{{" && endSymbol === "}}"
          ? (x) => x
          : (x) => x.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);

      const NG_PREFIX_BINDING = /^ng(Attr|Prop|On|Observe)([A-Z].*)$/;
      return compile;

      //= ===============================

      /**
       * @type {CompileFn}
       */
      function compile(
        element,
        transcludeFn,
        maxPriority,
        ignoreDirective,
        previousCompileContext,
      ) {
        /** @type {NodeRef | null } */
        let nodeRef = new NodeRef(element);
        /**
         * The composite link function is a composite of individual node linking functions.
         * It will be invoke by the public link function below.
         * @type {CompositeLinkFn}
         */
        let compositeLinkFn = compileNodes(
          nodeRef,
          transcludeFn,
          maxPriority,
          ignoreDirective,
          previousCompileContext,
        );

        let namespace = null;
        return publicLinkFn;

        /** @type {PublicLinkFn} */
        function publicLinkFn(scope, cloneConnectFn, options) {
          if (!nodeRef) {
            throw $compileMinErr(
              "multilink",
              "This element has already been linked.",
            );
          }

          assertArg$1(scope, "scope");
          // could be empty nodelist
          if (nodeRef.getAny()) {
            setScope(nodeRef.getAny(), scope);
          }

          if (previousCompileContext && previousCompileContext.needsNewScope) {
            // A parent directive did a replace and a directive on this element asked
            // for transclusion, which caused us to lose a layer of element on which
            // we could hold the new transclusion scope, so we will create it manually
            // here.
            scope = scope.$parent.$new();
          }

          options = options || {};
          let {
            transcludeControllers,
            parentBoundTranscludeFn,
            futureParentElement,
          } = options;

          // When `parentBoundTranscludeFn` is passed, it is a
          // `controllersBoundTransclude` function (it was previously passed
          // as `transclude` to directive.link) so we must unwrap it to get
          // its `boundTranscludeFn`
          if (
            parentBoundTranscludeFn &&
            parentBoundTranscludeFn.$$boundTransclude
          ) {
            parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
          }

          if (!namespace) {
            namespace = detectNamespaceForChildElements(futureParentElement);
          }
          /** @type {NodeRef} */
          let $linkNode;

          if (namespace !== "html") {
            // When using a directive with replace:true and templateUrl the jqCompileNodes
            // (or a child element inside of them)
            // might change, so we need to recreate the namespace adapted compileNodes
            // for call to the link function.
            // Note: This will already clone the nodes...
            const fragment = createElementFromHTML("<div></div>");
            fragment.append(nodeRef.node);
            const wrappedTemplate = wrapTemplate(namespace, fragment.innerHTML);
            $linkNode = new NodeRef(wrappedTemplate[0]);
          } else if (cloneConnectFn) {
            $linkNode = nodeRef.clone();
          } else {
            $linkNode = nodeRef;
          }

          if (transcludeControllers) {
            for (const controllerName in transcludeControllers) {
              assertArg$1($linkNode.element, "element");
              setCacheData(
                $linkNode.element,
                `$${controllerName}Controller`,
                transcludeControllers[controllerName].instance,
              );
            }
          }
          if (cloneConnectFn) {
            cloneConnectFn($linkNode.dom, scope);
          }

          if (compositeLinkFn) {
            compositeLinkFn(scope, $linkNode, parentBoundTranscludeFn);
          }

          if (!cloneConnectFn) {
            nodeRef = compositeLinkFn = null;
          }

          $linkNode.linked = true;

          return $linkNode.getAll();
        }
      }

      function detectNamespaceForChildElements(parentElement) {
        // TODO: Make this detect MathML as well...
        const node = parentElement;
        if (!node) {
          return "html";
        }
        return getNodeName(node) !== "foreignobject" &&
          toString.call(node).match(/SVG/)
          ? "svg"
          : "html";
      }

      /**
       * Compile function matches each node in nodeList against the directives. Once all directives
       * for a particular node are collected their compile functions are executed. The compile
       * functions return values - the linking functions - are combined into a composite linking
       * function, which is a linking function for the node.
       *
       * @param {NodeRef} nodeRefList a node or an array of nodes or NodeList to compile
       * @param {*} transcludeFn A linking function, where the
       *        scope argument is auto-generated to the new child of the transcluded parent scope.
       * @param {number=} [maxPriority] Max directive priority.
       * @param {*} [ignoreDirective]
       * @param {*} [previousCompileContext]
       * @returns {CompositeLinkFn} A composite linking function of all of the matched directives or null.
       */
      function compileNodes(
        nodeRefList,
        transcludeFn,
        maxPriority,
        ignoreDirective,
        previousCompileContext,
      ) {
        /**
         * Aggregates for the composite linking function, where a node in a node list is mapped
         * to a corresponding link function. For single elements, the node should be mapped to
         * a single node link function.
         * @type {LinkFnMapping[]}
         */
        const linkFnsList = []; // An array to hold node indices and their linkFns
        let nodeLinkFnFound;
        let linkFnFound = false;
        for (let i = 0; i < nodeRefList.size; i++) {
          const attrs = new Attributes(
            $rootScope,
            $animate,
            $exceptionHandler,
            $sce,
          );

          const directives = collectDirectives(
            /** @type Element */ (nodeRefList.getIndex(i)),
            attrs,
            i === 0 ? maxPriority : undefined,
            ignoreDirective,
          );

          /** @type {NodeLinkFn} */
          let nodeLinkFn;
          if (directives.length) {
            nodeLinkFn = applyDirectivesToNode(
              directives,
              nodeRefList.getIndex(i),
              attrs,
              transcludeFn,
              null,
              [],
              [],
              Object.assign({}, previousCompileContext, {
                index: i,
                parentNodeRef: nodeRefList,
                ctxNodeRef: nodeRefList,
              }),
            );
          } else {
            nodeLinkFn = null;
          }

          let childLinkFn;
          let childNodes;

          if (
            (nodeLinkFn && nodeLinkFn.terminal) ||
            !(childNodes = nodeRefList.getIndex(i).childNodes) ||
            !childNodes.length
          ) {
            childLinkFn = null;
          } else {
            let transcluded = nodeLinkFn
              ? (nodeLinkFn.transcludeOnThisElement ||
                  !nodeLinkFn.templateOnThisElement) &&
                nodeLinkFn.transclude
              : transcludeFn;
            // recursive call
            const childNodeRef = new NodeRef(childNodes);
            childLinkFn = compileNodes(childNodeRef, transcluded);
          }

          if (nodeLinkFn || childLinkFn) {
            linkFnsList.push({
              index: i,
              nodeLinkFn: nodeLinkFn,
              childLinkFn: childLinkFn,
            });
            linkFnFound = true;
            nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
          }

          // use the previous context only for the first element in the virtual group
          previousCompileContext = null;
        }

        // return a composite linking function if we have found anything, null otherwise
        return linkFnFound ? compositeLinkFn : null;

        /**
         * The composite link function links all the individual nodes
         *
         * @param {import("../scope/scope.js").Scope} scope
         * @param {NodeRef} nodeRef
         * @param {*} [parentBoundTranscludeFn]
         */
        function compositeLinkFn(scope, nodeRef, parentBoundTranscludeFn) {
          assertArg$1(nodeRef, "nodeRef");
          let stableNodeList = [];
          if (nodeLinkFnFound) {
            // create a stable copy of the nodeList, only copying elements with linkFns
            const stableLength = nodeRef.isList ? nodeRef.nodes.length : 1;
            stableNodeList = new Array(stableLength);
            // create a sparse array by only copying the elements which have a linkFn
            linkFnsList.forEach((val) => {
              let idx = val.index;
              if (idx === 0) {
                stableNodeList[idx] = nodeRef.isList
                  ? nodeRef.nodes[idx]
                  : nodeRef.node;
              } else {
                if (nodeRefList.getIndex(idx)) {
                  stableNodeList[idx] = nodeRef.nodes[idx];
                }
              }
            });
          } else {
            if (nodeRef.isList) {
              nodeRef.nodes.forEach((elem) => stableNodeList.push(elem));
            } else {
              stableNodeList.push(nodeRef.node);
            }
          }

          linkFnsList.forEach(({ index, nodeLinkFn, childLinkFn }) => {
            const node = stableNodeList[index];
            node.stable = true;
            let childScope;
            let childBoundTranscludeFn;

            if (nodeLinkFn) {
              childScope = nodeLinkFn.scope ? scope.$new() : scope;

              if (nodeLinkFn.transcludeOnThisElement) {
                // bind proper scope for the translusion function
                childBoundTranscludeFn = createBoundTranscludeFn(
                  scope,
                  nodeLinkFn.transclude,
                  parentBoundTranscludeFn,
                );
              } else if (
                !nodeLinkFn.templateOnThisElement &&
                parentBoundTranscludeFn
              ) {
                childBoundTranscludeFn = parentBoundTranscludeFn;
              } else if (!parentBoundTranscludeFn && transcludeFn) {
                childBoundTranscludeFn = createBoundTranscludeFn(
                  scope,
                  transcludeFn,
                );
              } else {
                childBoundTranscludeFn = null;
              }

              // attach new scope to element
              if (nodeLinkFn.scope) {
                setScope(node, childScope);
              }
              nodeLinkFn(childLinkFn, childScope, node, childBoundTranscludeFn);
            } else if (childLinkFn) {
              childLinkFn(
                scope,
                new NodeRef(node.childNodes),
                parentBoundTranscludeFn,
              );
            }
          });
        }
      }

      /**
       * Prebinds the transclusion function to a scope
       * @param {import("../scope/scope.js").Scope} scope
       * @param {*} transcludeFn
       * @param {*} previousBoundTranscludeFn
       * @returns {BoundTranscludeFn}
       */
      function createBoundTranscludeFn(
        scope,
        transcludeFn,
        previousBoundTranscludeFn,
      ) {
        function boundTranscludeFn(
          transcludedScope,
          cloneFn,
          controllers,
          futureParentElement,
          containingScope,
        ) {
          if (!transcludedScope) {
            transcludedScope = scope.$transcluded(containingScope);
            transcludedScope.$$transcluded = true;
          }

          const transcludeRes = transcludeFn(transcludedScope, cloneFn, {
            parentBoundTranscludeFn: previousBoundTranscludeFn,
            transcludeControllers: controllers,
            futureParentElement,
          });

          return transcludeRes;
        }

        // We need  to attach the transclusion slots onto the `boundTranscludeFn`
        // so that they are available inside the `controllersBoundTransclude` function
        const boundSlots = (boundTranscludeFn.$$slots = Object.create(null));
        for (const slotName in transcludeFn.$$slots) {
          if (transcludeFn.$$slots[slotName]) {
            boundSlots[slotName] = createBoundTranscludeFn(
              scope,
              transcludeFn.$$slots[slotName],
              previousBoundTranscludeFn,
            );
          } else {
            boundSlots[slotName] = null;
          }
        }

        return boundTranscludeFn;
      }

      /**
       * Looks for directives on the given node and adds them to the directive collection which is
       * sorted.
       *
       * @param {Element} node Node to search.
       * @param {Attributes|import("./attributes.js").Attributes} attrs The shared attrs object which is used to populate the normalized attributes.
       * @param {number=} maxPriority Max directive priority.
       * @param {string} [ignoreDirective]
       * @return {import('../../types.js').Directive[]} An array to which the directives are added to. This array is sorted before the function returns.
       */
      function collectDirectives(node, attrs, maxPriority, ignoreDirective) {
        /**
         * @type {import('../../types.js').Directive[]}
         */
        const directives = [];
        const { nodeType } = node;
        const attrsMap = attrs.$attr;
        let nodeName;

        switch (nodeType) {
          case Node.ELEMENT_NODE /* Element */:
            nodeName = node.nodeName.toLowerCase();
            if (ignoreDirective !== directiveNormalize(nodeName)) {
              // use the node name: <directive>
              addDirective(
                directives,
                directiveNormalize(nodeName),
                "E",
                maxPriority,
              );
            }

            // iterate over the attributes
            for (let j = 0; j < node.attributes?.length; j++) {
              let isNgAttr = false;
              let isNgProp = false;
              let isNgEvent = false;
              let isNgObserve = false;

              let attr = node.attributes[j];
              let name = attr.name;
              let value = attr.value;
              let nName = directiveNormalize(name.toLowerCase());

              // Support ng-attr-*, ng-prop-* and ng-on-*
              const ngPrefixMatch = nName.match(NG_PREFIX_BINDING);
              if (ngPrefixMatch) {
                isNgAttr = ngPrefixMatch[1] === "Attr";
                isNgProp = ngPrefixMatch[1] === "Prop";
                isNgEvent = ngPrefixMatch[1] === "On";
                isNgObserve = ngPrefixMatch[1] === "Observe";

                // Normalize the non-prefixed name
                name = name
                  .replace(PREFIX_REGEXP, "")
                  .toLowerCase()
                  .substring(4 + ngPrefixMatch[1].length)
                  .replace(/_(.)/g, (match, letter) => letter.toUpperCase());
              }

              if (isNgProp || isNgEvent) {
                attrs[nName] = value;
                attrsMap[nName] = attr.name;

                if (isNgProp) {
                  addPropertyDirective(node, directives, nName, name);
                } else {
                  directives.push(
                    createEventDirective(
                      $parse,
                      $exceptionHandler,
                      nName,
                      name,
                    ),
                  );
                }
              } else if (isNgObserve) {
                directives.push(ngObserveDirective(name, value));
              } else {
                // Update nName for cases where a prefix was removed
                // NOTE: the .toLowerCase() is unnecessary and causes https://github.com/angular/angular.js/issues/16624 for ng-attr-*
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;

                if (
                  isNgAttr ||
                  !Object.prototype.hasOwnProperty.call(attrs, nName)
                ) {
                  attrs[nName] = value;
                  if (getBooleanAttrName(node, nName)) {
                    attrs[nName] = true; // presence means true
                  }
                }

                addAttrInterpolateDirective(
                  node,
                  directives,
                  value,
                  nName,
                  isNgAttr,
                );

                if (nName !== ignoreDirective) {
                  addDirective(directives, nName, "A", maxPriority);
                }
              }
            }

            if (
              nodeName === "input" &&
              node.getAttribute("type") === "hidden"
            ) {
              // Hidden input elements can have strange behaviour when navigating back to the page
              // This tells the browser not to try to cache and reinstate previous values
              node.setAttribute("autocomplete", "off");
            }

            break;
          case Node.TEXT_NODE:
            addTextInterpolateDirective(directives, node.nodeValue);
            break;
        }

        directives.sort(byPriority);
        return directives;
      }

      /**
       * A function generator that is used to support both eager and lazy compilation
       * linking function.
       * @param eager
       * @param {NodeList|Node} compileNodes
       * @param transcludeFn
       * @param maxPriority
       * @param ignoreDirective
       * @param previousCompileContext
       * @returns {PublicLinkFn|TranscludeFn}
       */
      function compilationGenerator(
        eager,
        compileNodes,
        transcludeFn,
        maxPriority,
        ignoreDirective,
        previousCompileContext,
      ) {
        let compiled;
        if (eager) {
          return compile(
            compileNodes,
            transcludeFn,
            maxPriority,
            ignoreDirective,
            previousCompileContext,
          );
        }

        return function lazyCompilation() {
          if (!compiled) {
            compiled = compile(
              compileNodes,
              transcludeFn,
              maxPriority,
              ignoreDirective,
              previousCompileContext,
            );

            // Null out all of these references for garbage collection
            compileNodes = transcludeFn = previousCompileContext = null;
          }
          const linked = compiled.apply(this, arguments);
          return linked;
        };
      }

      /**
       * Once the directives have been collected, their compile functions are executed. This method
       * is responsible for inlining directive templates as well as terminating the application
       * of the directives if the terminal directive has been reached.
       *
       * @param {Array} directives Array of collected directives to execute their compile function.
       *        this needs to be pre-sorted by priority order.
       * @param {Node | Element} compileNode  DOM node to apply the compile functions to
       * @param {Attributes} templateAttrs The shared attribute function
       * @param {TranscludeFn} transcludeFn
       * @param {Object=} originalReplaceDirective An optional directive that will be ignored when
       *                                           compiling the transclusion.
       * @param {Array.<Function>} [preLinkFns]
       * @param {Array.<Function>} [postLinkFns]
       * @param {Object} [previousCompileContext] Context used for previous compilation of the current
       *                                        node
       * @returns {NodeLinkFn} node link function
       */
      function applyDirectivesToNode(
        directives,
        compileNode,
        templateAttrs,
        transcludeFn,
        originalReplaceDirective,
        preLinkFns,
        postLinkFns,
        previousCompileContext,
      ) {
        previousCompileContext = previousCompileContext || {};

        let terminalPriority = -Number.MAX_VALUE;
        let {
          newScopeDirective,
          controllerDirectives,
          newIsolateScopeDirective,
          templateDirective,
          nonTlbTranscludeDirective,
          hasElementTranscludeDirective,
          ctxNodeRef,
          parentNodeRef,
        } = previousCompileContext;
        let hasTranscludeDirective = false;
        let hasTemplate = false;
        let compileNodeRef = new NodeRef(compileNode);
        const index = previousCompileContext.index;
        templateAttrs.$nodeRef = compileNodeRef;
        let directive;
        let directiveName;
        let $template;
        let replaceDirective = originalReplaceDirective;
        /** @type {TranscludeFn} */
        let childTranscludeFn = transcludeFn;

        let didScanForMultipleTransclusion = false;
        let mightHaveMultipleTransclusionError = false;
        let directiveValue;

        /**
         * Links all the directives of a single node.
         * @type {NodeLinkFn}
         */
        let nodeLinkFn = function (
          childLinkFn,
          scope,
          linkNode,
          boundTranscludeFn,
        ) {
          let i;
          let ii;
          let isolateScope;
          let controllerScope;
          let elementControllers;
          let transcludeFn;

          /** @type {NodeRef} */
          let $element;
          /** @type {Attributes} */
          let attrs;
          let scopeBindingInfo;

          if (compileNode === linkNode) {
            attrs = templateAttrs;
            $element = templateAttrs.$nodeRef;
          } else {
            $element = new NodeRef(linkNode);
            attrs = new Attributes(
              $rootScope,
              $animate,
              $exceptionHandler,
              $sce,
              $element,
              templateAttrs,
            );
          }

          controllerScope = scope;
          if (newIsolateScopeDirective) {
            isolateScope = scope.$newIsolate();
          } else if (newScopeDirective) {
            controllerScope = scope.$parent;
          }

          if (boundTranscludeFn) {
            // track `boundTranscludeFn` so it can be unwrapped if `transcludeFn`
            // is later passed as `parentBoundTranscludeFn` to `publicLinkFn`
            transcludeFn = controllersBoundTransclude;
            transcludeFn.$$boundTransclude = boundTranscludeFn;
            // expose the slots on the `$transclude` function
            transcludeFn.isSlotFilled = function (slotName) {
              return !!boundTranscludeFn.$$slots[slotName];
            };
          }

          if (controllerDirectives) {
            elementControllers = setupControllers(
              $element,
              attrs,
              transcludeFn,
              controllerDirectives,
              isolateScope,
              scope,
              newIsolateScopeDirective,
            );
          }

          if (newIsolateScopeDirective) {
            isolateScope.$target.$$isolateBindings =
              newIsolateScopeDirective.$$isolateBindings;
            scopeBindingInfo = initializeDirectiveBindings(
              scope,
              attrs,
              isolateScope,
              isolateScope.$$isolateBindings,
              newIsolateScopeDirective,
            );
            if (scopeBindingInfo.removeWatches) {
              isolateScope.$on("$destroy", scopeBindingInfo.removeWatches);
            }
          }

          // Initialize bindToController bindings
          for (const name in elementControllers) {
            const controllerDirective = controllerDirectives[name];
            const controller = elementControllers[name];
            const bindings = controllerDirective.$$bindings.bindToController;

            // Controller instance is bound to the scope
            const controllerInstance = controller();
            controller.instance = controllerScope.$new(controllerInstance);
            setCacheData(
              $element.node,
              `$${controllerDirective.name}Controller`,
              controller.instance,
            );
            controller.bindingInfo = initializeDirectiveBindings(
              controllerScope,
              attrs,
              controller.instance,
              bindings,
              controllerDirective,
            );
          }

          // Bind the required controllers to the controller, if `require` is an object and `bindToController` is truthy
          if (controllerDirectives) {
            Object.entries(controllerDirectives).forEach(
              ([name, controllerDirective]) => {
                const { require } = controllerDirective;
                if (
                  controllerDirective.bindToController &&
                  !Array.isArray(require) &&
                  isObject(require)
                ) {
                  extend(
                    elementControllers[name].instance,
                    getControllers(
                      name,
                      require,
                      $element.element,
                      elementControllers,
                    ),
                  );
                }
              },
            );
          }

          // Handle the init and destroy lifecycle hooks on all controllers that have them
          if (elementControllers) {
            Object.values(elementControllers).forEach((controller) => {
              const controllerInstance = controller.instance;
              if (isFunction(controllerInstance.$onChanges)) {
                try {
                  controllerInstance.$onChanges(
                    controller.bindingInfo.initialChanges,
                  );
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (isFunction(controllerInstance.$onInit)) {
                try {
                  controllerInstance.$target.$onInit();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (isFunction(controllerInstance.$onDestroy)) {
                controllerScope.$on("$destroy", () => {
                  controllerInstance.$onDestroy();
                });
              }
            });
          }

          // PRELINKING
          for (i = 0, ii = preLinkFns.length; i < ii; i++) {
            let preLinkFn = preLinkFns[i];
            const controllers =
              preLinkFn.require &&
              getControllers(
                preLinkFn.directiveName,
                preLinkFn.require,
                $element.element,
                elementControllers,
              );

            // invoke link function
            try {
              preLinkFn(
                preLinkFn.isolateScope ? isolateScope : scope,
                $element.node, // Prelink functions accept a Node
                attrs,
                controllers,
                transcludeFn,
              );
            } catch (e) {
              console.error(e);
              $exceptionHandler(e, startingTag($element.getAny()));
            }
          }

          // RECURSION
          // We only pass the isolate scope, if the isolate directive has a template,
          // otherwise the child elements do not belong to the isolate directive.
          var scopeToChild = scope;
          if (
            newIsolateScopeDirective &&
            (newIsolateScopeDirective.template ||
              newIsolateScopeDirective.templateUrl === null)
          ) {
            scopeToChild = isolateScope;
          }
          if (
            childLinkFn &&
            linkNode &&
            linkNode.childNodes &&
            linkNode.childNodes.length
          ) {
            childLinkFn(
              scopeToChild,
              new NodeRef(linkNode.childNodes),
              boundTranscludeFn,
            );
          }
          // POSTLINKING
          for (i = postLinkFns.length - 1; i >= 0; i--) {
            let postLinkFn = postLinkFns[i];
            const controllers =
              postLinkFn.require &&
              getControllers(
                postLinkFn.directiveName,
                postLinkFn.require,
                $element.node,
                elementControllers,
              );

            // invoke link function
            try {
              if (postLinkFn.isolateScope) {
                setIsolateScope($element.node, isolateScope);
              }

              postLinkFn(
                postLinkFn.isolateScope ? isolateScope : scope,
                $element.node,
                attrs,
                controllers,
                transcludeFn,
              );
            } catch (e) {
              console.error(e);
              $exceptionHandler(e, startingTag($element.getAny()));
            }
          }

          if (elementControllers) {
            // Trigger $postLink lifecycle hooks
            Object.values(elementControllers).forEach((controller) => {
              const controllerInstance = controller.instance;
              if (isFunction(controllerInstance.$postLink)) {
                controllerInstance.$postLink();
              }
            });
          }

          // This is the function that is injected as `$transclude` or
          // the fifth parameter to the link function.
          // Example: function link (scope, element, attrs, ctrl, transclude) {}
          // Note: all arguments are optional!
          function controllersBoundTransclude(
            scope,
            cloneAttachFn,
            futureParentElement,
            slotName,
          ) {
            let transcludeControllers;
            // No scope passed in:
            if (!isScope(scope)) {
              slotName = futureParentElement;
              futureParentElement = cloneAttachFn;
              cloneAttachFn = scope;
              scope = undefined;
            }
            if (hasElementTranscludeDirective) {
              transcludeControllers = elementControllers;
            }
            if (!futureParentElement) {
              futureParentElement = hasElementTranscludeDirective
                ? $element.node.parentElement
                : $element.node;
            }
            if (slotName) {
              // slotTranscludeFn can be one of three things:
              //  * a transclude function - a filled slot
              //  * `null` - an optional slot that was not filled
              //  * `undefined` - a slot that was not declared (i.e. invalid)
              const slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
              if (slotTranscludeFn) {
                const slotTranscludeRes = slotTranscludeFn(
                  scope,
                  cloneAttachFn,
                  transcludeControllers,
                  futureParentElement,
                  scopeToChild,
                );
                return slotTranscludeRes;
              }

              if (isUndefined(slotTranscludeFn)) {
                throw $compileMinErr(
                  "noslot",
                  'No parent directive that requires a transclusion with slot name "{0}". ' +
                    "Element: {1}",
                  slotName,
                  startingTag($element.element),
                );
              }
            } else {
              const boundTranscludeRes = boundTranscludeFn(
                scope,
                cloneAttachFn,
                transcludeControllers,
                futureParentElement,
                scopeToChild,
              );
              return boundTranscludeRes;
            }
          }
        };

        // executes all directives on the current element
        for (let i = 0, ii = directives.length; i < ii; i++) {
          directive = directives[i];
          $template = undefined;

          if (terminalPriority > directive.priority) {
            break; // prevent further processing of directives
          }

          directiveValue = directive.scope;

          if (directiveValue) {
            // skip the check for directives with async templates, we'll check the derived sync
            // directive when the template arrives
            if (!directive.templateUrl) {
              if (isObject(directiveValue)) {
                // This directive is trying to add an isolated scope.
                // Check that there is no scope of any kind already
                assertNoDuplicate(
                  "new/isolated scope",
                  newIsolateScopeDirective || newScopeDirective,
                  directive,
                  compileNodeRef,
                );
                newIsolateScopeDirective = directive;
              } else {
                // This directive is trying to add a child scope.
                // Check that there is no isolated scope already
                assertNoDuplicate(
                  "new/isolated scope",
                  newIsolateScopeDirective,
                  directive,
                  compileNodeRef,
                );
              }
            }

            newScopeDirective = newScopeDirective || directive;
          }

          directiveName = directive.name;

          // If we encounter a condition that can result in transclusion on the directive,
          // then scan ahead in the remaining directives for others that may cause a multiple
          // transclusion error to be thrown during the compilation process.  If a matching directive
          // is found, then we know that when we encounter a transcluded directive, we need to eagerly
          // compile the `transclude` function rather than doing it lazily in order to throw
          // exceptions at the correct time
          const hasReplacedTemplate =
            directive.replace && (directive.templateUrl || directive.template);
          const shouldTransclude =
            directive.transclude &&
            !EXCLUDED_DIRECTIVES.includes(directive.name);
          if (
            !didScanForMultipleTransclusion &&
            (hasReplacedTemplate || shouldTransclude)
          ) {
            let candidateDirective;

            for (
              let scanningIndex = i + 1;
              (candidateDirective = directives[scanningIndex++]);

            ) {
              if (
                (candidateDirective.transclude &&
                  !EXCLUDED_DIRECTIVES.includes(candidateDirective.name)) ||
                (candidateDirective.replace &&
                  (candidateDirective.templateUrl ||
                    candidateDirective.template))
              ) {
                mightHaveMultipleTransclusionError = true;
                break;
              }
            }

            didScanForMultipleTransclusion = true;
          }

          if (!directive.templateUrl && directive.controller) {
            controllerDirectives = controllerDirectives || Object.create(null);
            assertNoDuplicate(
              `'${directiveName}' controller`,
              controllerDirectives[directiveName],
              directive,
              compileNodeRef,
            );
            controllerDirectives[directiveName] = directive;
          }

          directiveValue = directive.transclude;

          if (directiveValue) {
            hasTranscludeDirective = true;

            // Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.
            // This option should only be used by directives that know how to safely handle element transclusion,
            // where the transcluded nodes are added or replaced after linking.
            if (!EXCLUDED_DIRECTIVES.includes(directive.name)) {
              assertNoDuplicate(
                "transclusion",
                nonTlbTranscludeDirective,
                directive,
                compileNodeRef,
              );
              nonTlbTranscludeDirective = directive;
            }

            if (directiveValue === "element") {
              hasElementTranscludeDirective = true;
              terminalPriority = directive.priority;
              $template = compileNodeRef;
              compileNodeRef = new NodeRef(document.createComment(""));
              templateAttrs.$nodeRef = compileNodeRef;
              compileNode = compileNodeRef.node;
              ctxNodeRef.node = compileNode;
              replaceWith(new NodeRef($template.getAny()), compileNode, index);

              childTranscludeFn = compilationGenerator(
                mightHaveMultipleTransclusionError,
                $template.getAny(),
                transcludeFn,
                terminalPriority,
                replaceDirective && replaceDirective.name,
                {
                  // Don't pass in:
                  // - controllerDirectives - otherwise we'll create duplicates controllers
                  // - newIsolateScopeDirective or templateDirective - combining templates with
                  //   element transclusion doesn't make sense.
                  //
                  // We need only nonTlbTranscludeDirective so that we prevent putting transclusion
                  // on the same element more than once.
                  nonTlbTranscludeDirective,
                },
              );
            } else {
              const slots = Object.create(null);

              if (!isObject(directiveValue)) {
                //
                // Clone childnodes before clearing contents on transcluded directives
                $template = compileNode.cloneNode(true).childNodes;
              } else {
                // We have transclusion slots,
                // collect them up, compile them and store their transclusion functions
                $template = document.createDocumentFragment();

                const slotMap = Object.create(null);
                const filledSlots = Object.create(null);

                // Parse the element selectors
                Object.entries(directiveValue).forEach(
                  ([slotName, elementSelector]) => {
                    // If an element selector starts with a ? then it is optional
                    const optional = elementSelector.charAt(0) === "?";
                    elementSelector = optional
                      ? elementSelector.substring(1)
                      : elementSelector;

                    slotMap[elementSelector] = slotName;

                    // We explicitly assign `null` since this implies that a slot was defined but not filled.
                    // Later when calling boundTransclusion functions with a slot name we only error if the
                    // slot is `undefined`
                    slots[slotName] = null;

                    // filledSlots contains `true` for all slots that are either optional or have been
                    // filled. This is used to check that we have not missed any required slots
                    filledSlots[slotName] = optional;
                  },
                );

                // Add the matching elements into their slot
                compileNodeRef.element.childNodes.forEach((node) => {
                  const slotName =
                    slotMap[directiveNormalize(getNodeName(node))];
                  if (slotName) {
                    filledSlots[slotName] = true;
                    slots[slotName] =
                      slots[slotName] || document.createDocumentFragment();
                    slots[slotName].appendChild(node);
                  } else {
                    $template.appendChild(node);
                  }
                });

                // Check for required slots that were not filled
                Object.entries(filledSlots).forEach(([slotName, filled]) => {
                  if (!filled) {
                    throw $compileMinErr(
                      "reqslot",
                      "Required transclusion slot `{0}` was not filled.",
                      slotName,
                    );
                  }
                });

                for (const slotName in slots) {
                  if (slots[slotName]) {
                    // Only define a transclusion function if the slot was filled
                    const slotCompileNodes = slots[slotName].childNodes;
                    slots[slotName] = compilationGenerator(
                      mightHaveMultipleTransclusionError,
                      slotCompileNodes,
                      transcludeFn,
                    );
                  }
                }

                $template = $template.childNodes;
              }

              emptyElement(compileNode); // clear contents on transcluded directives

              // lazily compile transcluded template and generate a transcluded link function
              childTranscludeFn = compilationGenerator(
                mightHaveMultipleTransclusionError,
                $template,
                transcludeFn,
                undefined,
                undefined,
                {
                  needsNewScope:
                    directive.$$isolateScope || directive.$$newScope,
                },
              );
              childTranscludeFn.$$slots = slots;
            }
          }

          if (directive.template) {
            hasTemplate = true;
            assertNoDuplicate(
              "template",
              templateDirective,
              directive,
              compileNodeRef,
            );
            templateDirective = directive;

            directiveValue = isFunction(directive.template)
              ? directive.template(compileNodeRef.node, templateAttrs)
              : directive.template;

            directiveValue = denormalizeTemplate(directiveValue);
            if (directive.replace) {
              replaceDirective = directive;
              if (isTextNode(directiveValue)) {
                $template = [];
              } else {
                $template = removeComments(
                  wrapTemplate(
                    directive.templateNamespace,
                    trim(directiveValue),
                  ),
                );
              }

              if (isString($template)) {
                $template = Array.from(
                  createNodelistFromHTML($template),
                ).filter((x) => x.nodeType === Node.ELEMENT_NODE);
              }
              compileNode = $template[0];

              if (
                $template.length !== 1 ||
                compileNode.nodeType !== Node.ELEMENT_NODE
              ) {
                throw $compileMinErr(
                  "tplrt",
                  "Template for directive '{0}' must have exactly one root element. {1}",
                  directiveName,
                  "",
                );
              }

              replaceWith(compileNodeRef, compileNode);

              if (parentNodeRef) {
                parentNodeRef.setIndex(index, compileNode);
              }

              const newTemplateAttrs = { $attr: {} };

              // combine directives from the original node and from the template:
              // - take the array of directives for this element
              // - split it into two parts, those that already applied (processed) and those that weren't (unprocessed)
              // - collect directives from the template and sort them by priority
              // - combine directives as: processed + template + unprocessed
              const templateDirectives = collectDirectives(
                /** @type {Element} */ (compileNode),
                newTemplateAttrs,
              );
              const unprocessedDirectives = directives.splice(
                i + 1,
                directives.length - (i + 1),
              );

              if (newIsolateScopeDirective || newScopeDirective) {
                // The original directive caused the current element to be replaced but this element
                // also needs to have a new scope, so we need to tell the template directives
                // that they would need to get their scope from further up, if they require transclusion
                markDirectiveScope(
                  templateDirectives,
                  newIsolateScopeDirective,
                  newScopeDirective,
                );
              }
              directives = directives
                .concat(templateDirectives)
                .concat(unprocessedDirectives);

              mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

              ii = directives.length;
            } else {
              compileNodeRef.getAny().innerHTML = directiveValue;
            }
          }

          if (directive.templateUrl) {
            hasTemplate = true;
            assertNoDuplicate(
              "template",
              templateDirective,
              directive,
              compileNodeRef,
            );
            templateDirective = directive;

            if (directive.replace) {
              replaceDirective = directive;
            }
            nodeLinkFn = compileTemplateUrl(
              directives.splice(i, directives.length - i),
              compileNodeRef,
              templateAttrs,
              compileNode,
              hasTranscludeDirective && childTranscludeFn,
              preLinkFns,
              postLinkFns,
              {
                index,
                controllerDirectives,
                newScopeDirective:
                  newScopeDirective !== directive && newScopeDirective,
                newIsolateScopeDirective,
                templateDirective,
                nonTlbTranscludeDirective,
                futureParentElement: previousCompileContext.futureParentElement,
              },
            );
            ii = directives.length;
          } else if (directive.compile) {
            try {
              /** @type {PublicLinkFn} */
              const linkFn = directive.compile(
                compileNodeRef.getAny(),
                templateAttrs,
                childTranscludeFn,
              );
              const context = directive.$$originalDirective || directive;
              if (isFunction(linkFn)) {
                addLinkFns(null, bind(context, linkFn));
              } else if (linkFn) {
                addLinkFns(
                  bind(context, linkFn.pre),
                  bind(context, linkFn.post),
                );
              }
            } catch (e) {
              $exceptionHandler(e, startingTag(compileNodeRef.getAny()));
            }
          }

          if (directive.terminal) {
            nodeLinkFn.terminal = true;
            terminalPriority = Math.max(terminalPriority, directive.priority);
          }
        }

        nodeLinkFn.scope =
          newScopeDirective && newScopeDirective.scope === true;

        // track trancluded scope
        nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
        nodeLinkFn.templateOnThisElement = hasTemplate;
        nodeLinkFn.transclude = childTranscludeFn;

        previousCompileContext.hasElementTranscludeDirective =
          hasElementTranscludeDirective;

        // might be normal or delayed nodeLinkFn depending on if templateUrl is present
        return nodeLinkFn;

        /// /////////////////

        function addLinkFns(pre, post) {
          if (pre) {
            pre.require = directive.require;
            pre.directiveName = directiveName;
            if (
              newIsolateScopeDirective === directive ||
              directive.$$isolateScope
            ) {
              pre = cloneAndAnnotateFn(pre, { isolateScope: true });
            }
            preLinkFns.push(pre);
          }
          if (post) {
            post.require = directive.require;
            post.directiveName = directiveName;
            if (
              newIsolateScopeDirective === directive ||
              directive.$$isolateScope
            ) {
              post = cloneAndAnnotateFn(post, { isolateScope: true });
            }
            postLinkFns.push(post);
          }
        }
      }

      /**
       *
       * @param {*} directiveName
       * @param {*} require
       * @param {Element} $element
       * @param {*} elementControllers
       * @returns
       */
      function getControllers(
        directiveName,
        require,
        $element,
        elementControllers,
      ) {
        let value;

        if (isString(require)) {
          const match = require.match(REQUIRE_PREFIX_REGEXP);
          const name = require.substring(match[0].length);
          const inheritType = match[1] || match[3];
          const optional = match[2] === "?";

          // If only parents then start at the parent element
          if (inheritType === "^^") {
            if ($element.parentElement) {
              $element = $element.parentElement;
            } else {
              $element = undefined;
            }
            // Otherwise attempt getting the controller from elementControllers in case
            // the element is transcluded (and has no data) and to avoid .data if possible
          } else {
            value = elementControllers && elementControllers[name];
            value = value && value.instance;
          }

          if (!value) {
            const dataName = `$${name}Controller`;
            if (
              inheritType === "^^" &&
              $element &&
              $element.nodeType === Node.DOCUMENT_NODE
            ) {
              // inheritedData() uses the documentElement when it finds the document, so we would
              // require from the element itself.
              value = null;
            } else {
              value = $element
                ? inheritType
                  ? getInheritedData($element, dataName)
                  : getCacheData($element, dataName)
                : undefined;
            }
          }
          if (!value && !optional) {
            throw $compileMinErr(
              "ctreq",
              "Controller '{0}', required by directive '{1}', can't be found!",
              name,
              directiveName,
            );
          }
        } else if (Array.isArray(require)) {
          value = [];
          for (let i = 0, ii = require.length; i < ii; i++) {
            value[i] = getControllers(
              directiveName,
              require[i],
              $element,
              elementControllers,
            );
          }
        } else if (isObject(require)) {
          value = {};
          Object.entries(require).forEach(([property, controller]) => {
            value[property] = getControllers(
              directiveName,
              controller,
              $element,
              elementControllers,
            );
          });
        }

        return value || null;
      }

      /**
       * @param {NodeRef} $element
       * @param attrs
       * @param transcludeFn
       * @param controllerDirectives
       * @param isolateScope
       * @param scope
       * @param newIsolateScopeDirective
       * @returns {any}
       */
      function setupControllers(
        $element,
        attrs,
        transcludeFn,
        controllerDirectives,
        isolateScope,
        scope,
        newIsolateScopeDirective,
      ) {
        const elementControllers = Object.create(null);
        for (const controllerKey in controllerDirectives) {
          const directive = controllerDirectives[controllerKey];
          const locals = {
            $scope:
              directive === newIsolateScopeDirective || directive.$$isolateScope
                ? isolateScope
                : scope,
            $element: $element.node,
            $attrs: attrs,
            $transclude: transcludeFn,
          };

          let { controller } = directive;
          if (controller === "@") {
            controller = attrs[directive.name];
          }

          const controllerInstance = $controller(
            controller,
            locals,
            true,
            directive.controllerAs,
          );

          // For directives with element transclusion the element is a comment.
          // In this case .data will not attach any data.
          // Instead, we save the controllers for the element in a local hash and attach to .data
          // later, once we have the actual element.
          elementControllers[directive.name] = controllerInstance;
          setCacheData(
            $element,
            `$${directive.name}Controller`,
            controllerInstance.instance,
          );
        }
        return elementControllers;
      }

      // Depending upon the context in which a directive finds itself it might need to have a new isolated
      // or child scope created. For instance:
      // * if the directive has been pulled into a template because another directive with a higher priority
      // asked for element transclusion
      // * if the directive itself asks for transclusion but it is at the root of a template and the original
      // element was replaced. See https://github.com/angular/angular.js/issues/12936
      function markDirectiveScope(directives, isolateScope, newScope) {
        for (let j = 0, jj = directives.length; j < jj; j++) {
          directives[j] = inherit$1(directives[j], {
            $$isolateScope: isolateScope,
            $$newScope: newScope,
          });
        }
      }

      /**
       * looks up the directive and decorates it with exception handling and proper parameters. We
       * call this the boundDirective.
       *
       * @param {string} name name of the directive to look up.
       * @param {string} location The directive must be found in specific format.
       *   String containing any of these characters:
       *
       *   * `E`: element name
       *   * `A': attribute
       * @returns {boolean} true if directive was added.
       */
      function addDirective(tDirectives, name, location, maxPriority) {
        let match = false;
        if (Object.prototype.hasOwnProperty.call(hasDirectives, name)) {
          for (
            let directive,
              directives = $injector.get(name + DirectiveSuffix),
              i = 0,
              ii = directives.length;
            i < ii;
            i++
          ) {
            directive = directives[i];
            if (
              (isUndefined(maxPriority) || maxPriority > directive.priority) &&
              directive.restrict.indexOf(location) !== -1
            ) {
              if (!directive.$$bindings) {
                const bindings = (directive.$$bindings = parseDirectiveBindings(
                  directive,
                  directive.name,
                ));
                if (isObject(bindings.isolateScope)) {
                  directive.$$isolateBindings = bindings.isolateScope;
                }
              }
              tDirectives.push(directive);
              match = directive;
            }
          }
        }
        return match;
      }

      /**
       * When the element is replaced with HTML template then the new attributes
       * on the template need to be merged with the existing attributes in the DOM.
       * The desired effect is to have both of the attributes present.
       *
       * @param {object} dst destination attributes (original DOM)
       * @param {object} src source attributes (from the directive template)
       */
      function mergeTemplateAttributes(dst, src) {
        const srcAttr = src.$attr;
        const dstAttr = dst.$attr;

        // reapply the old attributes to the new element
        Object.entries(dst).forEach(([key, value]) => {
          if (key.charAt(0) !== "$") {
            if (src[key] && src[key] !== value) {
              if (value.length) {
                value += (key === "style" ? ";" : " ") + src[key];
              } else {
                value = src[key];
              }
            }
            dst.$set(key, value, true, srcAttr[key]);
          }
        });

        // copy the new attributes on the old attrs object
        Object.entries(src).forEach(([key, value]) => {
          // Check if we already set this attribute in the loop above.
          // `dst` will never contain hasOwnProperty as DOM parser won't let it.
          // You will get an "InvalidCharacterError: DOM Exception 5" error if you
          // have an attribute like "has-own-property" or "data-has-own-property", etc.
          if (
            !Object.prototype.hasOwnProperty.call(dst, key) &&
            key.charAt(0) !== "$"
          ) {
            dst[key] = value;

            if (key !== "class" && key !== "style") {
              dstAttr[key] = srcAttr[key];
            }
          }
        });
      }

      /**
       *
       * @param {import("../../types.js").Directive[]} directives
       * @param {NodeRef} $compileNode
       * @param {Attributes} tAttrs
       * @param {Element} $rootElement
       * @param {*} childTranscludeFn
       * @param {Array} preLinkFns
       * @param {Array} postLinkFns
       * @param {*} previousCompileContext
       * @returns
       */
      function compileTemplateUrl(
        directives,
        $compileNode,
        tAttrs,
        $rootElement,
        childTranscludeFn,
        preLinkFns,
        postLinkFns,
        previousCompileContext,
      ) {
        let linkQueue = [];
        /** @type {any} */
        let afterTemplateNodeLinkFn;
        let afterTemplateChildLinkFn;
        const beforeTemplateCompileNode = $compileNode.getAny();
        const origAsyncDirective = directives.shift();
        const derivedSyncDirective = inherit$1(origAsyncDirective, {
          templateUrl: null,
          transclude: null,
          replace: null,
          $$originalDirective: origAsyncDirective,
        });
        const templateUrl = isFunction(origAsyncDirective.templateUrl)
          ? origAsyncDirective.templateUrl($compileNode.getAny(), tAttrs)
          : origAsyncDirective.templateUrl;
        const { templateNamespace } = origAsyncDirective;

        emptyElement($compileNode.getAny());

        $templateRequest(templateUrl)
          .then((content) => {
            /** @type {Element} */
            let compileNode;
            let tempTemplateAttrs;
            let $template;
            let childBoundTranscludeFn;

            content = denormalizeTemplate(content);

            if (origAsyncDirective.replace) {
              if (isTextNode(content)) {
                $template = [];
              } else if (isString(content)) {
                $template = Array.from(createNodelistFromHTML(content)).filter(
                  (node) =>
                    node.nodeType !== Node.COMMENT_NODE &&
                    node.nodeType !== Node.TEXT_NODE,
                );
              } else {
                $template = removeComments(
                  wrapTemplate(templateNamespace, trim(content)),
                );
              }
              compileNode = $template[0];
              if (
                $template.length !== 1 ||
                compileNode.nodeType !== Node.ELEMENT_NODE
              ) {
                throw $compileMinErr(
                  "tplrt",
                  "Template for directive '{0}' must have exactly one root element. {1}",
                  origAsyncDirective.name,
                  templateUrl,
                );
              }

              tempTemplateAttrs = { $attr: {} };

              replaceWith(
                $compileNode,
                compileNode,
                previousCompileContext.index,
              );

              const templateDirectives = collectDirectives(
                compileNode,
                tempTemplateAttrs,
              );

              if (isObject(origAsyncDirective.scope)) {
                // the original directive that caused the template to be loaded async required
                // an isolate scope
                markDirectiveScope(templateDirectives, true);
              }
              directives = templateDirectives.concat(directives);

              mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
            } else {
              compileNode = beforeTemplateCompileNode;
              $compileNode.getAny().innerHTML = content;
            }

            directives.unshift(derivedSyncDirective);
            afterTemplateNodeLinkFn = applyDirectivesToNode(
              directives,
              compileNode,
              tAttrs,
              childTranscludeFn,
              origAsyncDirective,
              preLinkFns,
              postLinkFns,
              { ...previousCompileContext, ctxNodeRef: $compileNode },
            );
            if ($rootElement) {
              Object.entries($rootElement).forEach(([i, node]) => {
                if (node === compileNode) {
                  $rootElement[i] = $compileNode;
                }
              });
            }
            afterTemplateChildLinkFn = compileNodes(
              new NodeRef($compileNode.getAny().childNodes),
              childTranscludeFn,
            );

            while (linkQueue.length) {
              const scope = linkQueue.shift();
              const beforeTemplateLinkNode = linkQueue.shift();
              const boundTranscludeFn = linkQueue.shift();
              let linkNode = $compileNode.getAny();

              if (scope.$$destroyed) continue;

              if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                const oldClasses = beforeTemplateLinkNode.className;

                if (
                  !(
                    previousCompileContext.hasElementTranscludeDirective &&
                    origAsyncDirective.replace
                  )
                ) {
                  // it was cloned therefore we have to clone as well.
                  linkNode = compileNode.cloneNode(true);
                  beforeTemplateLinkNode.appendChild(linkNode);
                }
                // Copy in CSS classes from original node
                try {
                  if (oldClasses !== "") {
                    beforeTemplateLinkNode.classList.add(...linkNode.classList);
                  }
                } catch (e) {
                  // ignore, since it means that we are trying to set class on
                  // SVG element, where class name is read-only.
                }
              }
              if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                childBoundTranscludeFn = createBoundTranscludeFn(
                  scope,
                  afterTemplateNodeLinkFn.transclude,
                  boundTranscludeFn,
                );
              } else {
                childBoundTranscludeFn = boundTranscludeFn;
              }

              afterTemplateNodeLinkFn(
                afterTemplateChildLinkFn,
                scope,
                linkNode,
                childBoundTranscludeFn,
              );
            }
            linkQueue = null;
          })
          .catch((error) => {
            if (isError(error)) {
              $exceptionHandler(error);
            }
          });

        return function delayedNodeLinkFn(
          _ignoreChildLinkFn,
          scope,
          node,
          rootElement,
          boundTranscludeFn,
        ) {
          let childBoundTranscludeFn = boundTranscludeFn;
          if (scope.$$destroyed) return;
          if (linkQueue) {
            linkQueue.push(scope, node, rootElement);
          } else {
            if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
              childBoundTranscludeFn = createBoundTranscludeFn(
                scope,
                afterTemplateNodeLinkFn.transclude,
                boundTranscludeFn,
              );
            }
            afterTemplateNodeLinkFn(
              afterTemplateChildLinkFn,
              scope,
              node,
              rootElement,
              childBoundTranscludeFn,
            );
          }
        };
      }

      /**
       * Sorting function for bound directives.
       */
      function byPriority(a, b) {
        const diff = b.priority - a.priority;
        if (diff !== 0) return diff;
        if (a.name !== b.name) return a.name < b.name ? -1 : 1;
        return a.index - b.index;
      }

      function assertNoDuplicate(what, previousDirective, directive, element) {
        function wrapModuleNameIfDefined(moduleName) {
          return moduleName ? ` (module: ${moduleName})` : "";
        }

        if (previousDirective) {
          throw $compileMinErr(
            "multidir",
            "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}",
            previousDirective.name,
            wrapModuleNameIfDefined(previousDirective.$$moduleName),
            directive.name,
            wrapModuleNameIfDefined(directive.$$moduleName),
            what,
            startingTag(element.getAny()),
          );
        }
      }

      function addTextInterpolateDirective(directives, text) {
        const interpolateFn = $interpolate(text, true);
        if (interpolateFn) {
          directives.push({
            priority: 0,
            compile: () => (scope, node) => {
              interpolateFn.expressions.forEach((x) => {
                scope.$watch(x, () => {
                  const res = interpolateFn(
                    isProxy(scope) ? scope.$target : scope,
                  );
                  switch (node.nodeType) {
                    case 1:
                      node.innerHTML = res;
                      break;
                    default:
                      node.nodeValue = res;
                  }
                });
              });
            },
          });
        }
      }

      /**
       * @param {string} type
       * @param {string} template
       * @returns
       */
      function wrapTemplate(type, template) {
        type = (type || "html").toLowerCase();
        switch (type) {
          case "svg":
          case "math":
            /** @type {HTMLDivElement} */
            var wrapper = document.createElement("div");
            wrapper.innerHTML = `<${type}>${template}</${type}>`;
            return wrapper.childNodes[0].childNodes;
          default:
            return template;
        }
      }

      function getTrustedAttrContext(nodeName, attrNormalizedName) {
        if (attrNormalizedName === "srcdoc") {
          return $sce.HTML;
        }
        // All nodes with src attributes require a RESOURCE_URL value, except for
        // img and various html5 media nodes, which require the MEDIA_URL context.
        if (attrNormalizedName === "src" || attrNormalizedName === "ngSrc") {
          if (
            ["img", "video", "audio", "source", "track"].indexOf(nodeName) ===
            -1
          ) {
            return $sce.RESOURCE_URL;
          }
          return $sce.MEDIA_URL;
        }
        if (attrNormalizedName === "xlinkHref") {
          // Some xlink:href are okay, most aren't
          if (nodeName === "image") return $sce.MEDIA_URL;
          if (nodeName === "a") return $sce.URL;
          return $sce.RESOURCE_URL;
        }
        if (
          // Formaction
          (nodeName === "form" && attrNormalizedName === "action") ||
          // If relative URLs can go where they are not expected to, then
          // all sorts of trust issues can arise.
          (nodeName === "base" && attrNormalizedName === "href") ||
          // links can be stylesheets or imports, which can run script in the current origin
          (nodeName === "link" && attrNormalizedName === "href")
        ) {
          return $sce.RESOURCE_URL;
        }
        if (
          nodeName === "a" &&
          (attrNormalizedName === "href" || attrNormalizedName === "ngHref")
        ) {
          return $sce.URL;
        }
      }

      function getTrustedPropContext(nodeName, propNormalizedName) {
        const prop = propNormalizedName.toLowerCase();
        return (
          PROP_CONTEXTS[`${nodeName}|${prop}`] || PROP_CONTEXTS[`*|${prop}`]
        );
      }

      function sanitizeSrcset(value, invokeType) {
        if (!value) {
          return value;
        }
        if (!isString(value)) {
          throw $compileMinErr(
            "srcset",
            'Can\'t pass trusted values to `{0}`: "{1}"',
            invokeType,
            value.toString(),
          );
        }

        // Such values are a bit too complex to handle automatically inside $sce.
        // Instead, we sanitize each of the URIs individually, which works, even dynamically.

        // It's not possible to work around this using `$sce.trustAsMediaUrl`.
        // If you want to programmatically set explicitly trusted unsafe URLs, you should use
        // `$sce.trustAsHtml` on the whole `img` tag and inject it into the DOM using the
        // `ng-bind-html` directive.

        var result = "";

        // first check if there are spaces because it's not the same pattern
        var trimmedSrcset = trim(value);
        //                (   999x   ,|   999w   ,|   ,|,   )
        var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
        var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;

        // split srcset into tuple of uri and descriptor except for the last item
        var rawUris = trimmedSrcset.split(pattern);

        // for each tuples
        var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
        for (var i = 0; i < nbrUrisWith2parts; i++) {
          var innerIdx = i * 2;
          // sanitize the uri
          result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx]));
          // add the descriptor
          result += " " + trim(rawUris[innerIdx + 1]);
        }

        // split the last item into uri and descriptor
        var lastTuple = trim(rawUris[i * 2]).split(/\s/);

        // sanitize the last uri
        result += $sce.getTrustedMediaUrl(trim(lastTuple[0]));

        // and add the last descriptor if any
        if (lastTuple.length === 2) {
          result += " " + trim(lastTuple[1]);
        }
        return result;
      }

      function addPropertyDirective(node, directives, attrName, propName) {
        if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) {
          throw $compileMinErr(
            "nodomevents",
            "Property bindings for HTML DOM event properties are disallowed",
          );
        }

        const nodeName = getNodeName(node);
        const trustedContext = getTrustedPropContext(nodeName, propName);

        let sanitizer = (x) => x;
        // Sanitize img[srcset] + source[srcset] values.
        if (
          propName === "srcset" &&
          (nodeName === "img" || nodeName === "source")
        ) {
          sanitizer = (value) =>
            sanitizeSrcset($sce.valueOf(value), "ng-prop-srcset");
        } else if (trustedContext) {
          sanitizer = $sce.getTrusted.bind($sce, trustedContext);
        }

        directives.push({
          priority: 100,
          compile: function ngPropCompileFn(_, attr) {
            const ngPropGetter = $parse(attr[attrName]);
            return {
              pre: function ngPropPreLinkFn(scope, $element) {
                function applyPropValue() {
                  const propValue = ngPropGetter(scope);
                  $element[propName] = sanitizer(propValue);
                }
                applyPropValue();
                scope.$watch(propName, applyPropValue);
                scope.$watch(attr[attrName], (val) => {
                  $sce.valueOf(val);
                  applyPropValue();
                });
              },
            };
          },
        });
      }

      function addAttrInterpolateDirective(
        node,
        directives,
        value,
        name,
        isNgAttr,
      ) {
        const nodeName = getNodeName(node);
        const trustedContext = getTrustedAttrContext(nodeName, name);
        const mustHaveExpression = !isNgAttr;
        const allOrNothing = ALL_OR_NOTHING_ATTRS.includes(name) || isNgAttr;

        let interpolateFn = $interpolate(
          value,
          mustHaveExpression,
          trustedContext,
          allOrNothing,
        );

        // no interpolation found -> ignore
        if (!interpolateFn) return;

        if (name === "multiple" && nodeName === "select") {
          throw $compileMinErr(
            "selmulti",
            "Binding to the 'multiple' attribute is not supported. Element: {0}",
            startingTag(node.outerHTML),
          );
        }

        if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
          throw $compileMinErr(
            "nodomevents",
            "Interpolations for HTML DOM event attributes are disallowed",
          );
        }

        directives.push({
          priority: 100,
          compile() {
            return {
              pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                const $$observers =
                  attr.$$observers || (attr.$$observers = Object.create(null));

                // If the attribute has changed since last $interpolate()ed
                const newValue = attr[name];
                if (newValue !== value) {
                  // we need to interpolate again since the attribute value has been updated
                  // (e.g. by another directive's compile function)
                  // ensure unset/empty values make interpolateFn falsy

                  interpolateFn =
                    newValue &&
                    $interpolate(newValue, true, trustedContext, allOrNothing);
                  value = newValue;
                }

                // if attribute was updated so that there is no interpolation going on we don't want to
                // register any observers
                if (!interpolateFn) return;

                // initialize attr object so that it's ready in case we need the value for isolate
                // scope initialization, otherwise the value would not be available from isolate
                // directive's linking fn during linking phase

                attr[name] = interpolateFn(scope);

                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                interpolateFn.expressions.forEach((x) => {
                  const targetScope =
                    (attr.$$observers && attr.$$observers[name].$$scope) ||
                    scope;
                  targetScope.$watch(x, () => {
                    let newValue = interpolateFn(scope);
                    // special case for class attribute addition + removal
                    // so that class changes can tap into the animation
                    // hooks provided by the $animate service. Be sure to
                    // skip animations when the first digest occurs (when
                    // both the new and the old values are the same) since
                    // the CSS classes are the non-interpolated values
                    if (name === "class") {
                      attr.$updateClass(
                        newValue,
                        attr.$$element.classList.value,
                      );
                    } else {
                      attr.$set(name, newValue);
                    }
                  });
                });

                if (interpolateFn.expressions.length == 0) {
                  // if there is nothing to watch, its a constant
                  attr.$set(name, newValue);
                }
              },
            };
          },
        });
      }

      /**
       *
       * @param {NodeRef} elementsToRemove The JQLite element which we are going to replace. We keep
       *                                  the shell, but replace its DOM node reference.
       * @param {Node} newNode The new DOM node.
       * @param {number} [index] Parent node index.
       */
      function replaceWith(elementsToRemove, newNode, index) {
        const firstElementToRemove = elementsToRemove.getAny();
        // const removeCount = elementsToRemove.length;
        const parent = firstElementToRemove.parentNode;

        if (parent) {
          if (isDefined(index)) {
            const oldChild = parent.childNodes[index];
            if (oldChild) {
              parent.replaceChild(newNode, oldChild);
            }
          } else {
            parent.insertBefore(newNode, parent.firstChild);
            //parent.append(newNode);
          }
        }

        // Append all the `elementsToRemove` to a fragment. This will...
        // - remove them from the DOM
        // - allow them to still be traversed with .nextSibling
        // - allow a single fragment.qSA to fetch all elements being removed
        const fragment = document.createDocumentFragment();
        elementsToRemove.collection().forEach((element) => {
          fragment.appendChild(element);
        });

        elementsToRemove.node = newNode;
      }

      function cloneAndAnnotateFn(fn, annotation) {
        return extend(
          function () {
            return fn.apply(null, arguments);
          },
          fn,
          annotation,
        );
      }

      function strictBindingsCheck(attrName, directiveName) {
        if (strictComponentBindingsEnabled) {
          throw $compileMinErr(
            "missingattr",
            "Attribute '{0}' of '{1}' is non-optional and must be set!",
            attrName,
            directiveName,
          );
        }
      }

      // Set up $watches for isolate scope and controller bindings.
      /**
       *
       * @param {import('../scope/scope.js').Scope} scope
       * @param {*} attrs
       * @param {import('../scope/scope.js').Scope}  destination - child scope or isolate scope
       * @param {*} bindings
       * @param {*} directive
       * @returns
       */
      function initializeDirectiveBindings(
        scope,
        attrs,
        destination,
        bindings,
        directive,
      ) {
        const removeWatchCollection = [];
        const initialChanges = {};
        let changes;

        if (bindings) {
          Object.entries(bindings).forEach(([scopeName, definition]) => {
            const {
              attrName,
              optional,
              mode, // @, =, <, or &
            } = definition;
            let lastValue;
            let parentGet;
            let parentSet;
            let compare;
            let removeWatch;
            let firstCall = true;
            let firstChange = true;

            switch (mode) {
              case "@":
                if (!optional && !Object.hasOwnProperty.call(attrs, attrName)) {
                  strictBindingsCheck(attrName, directive.name);
                  destination[scopeName] = attrs[attrName] = undefined;
                }

                removeWatch = attrs.$observe(attrName, (value) => {
                  if (isString(value) || isBoolean(value)) {
                    recordChanges(scopeName, value, firstChange);

                    destination[scopeName] = value;
                    if (firstCall) {
                      firstCall = false;
                    } else {
                      triggerOnChangesHook();
                      firstChange = false;
                    }
                  }
                });
                attrs.$$observers[attrName].$$scope = scope;
                lastValue = attrs[attrName];
                if (isString(lastValue)) {
                  // If the attribute has been provided then we trigger an interpolation to ensure
                  // the value is there for use in the link fn

                  destination[scopeName] = $interpolate(lastValue)(scope);
                } else if (isBoolean(lastValue)) {
                  // If the attributes is one of the BOOLEAN_ATTR then AngularJS will have converted
                  // the value to boolean rather than a string, so we special case this situation
                  destination[scopeName] = lastValue;
                }

                /**
                 * @type {SimpleChange}
                 */
                initialChanges[scopeName] = {
                  currentValue: destination[scopeName],
                  firstChange: true,
                };
                removeWatchCollection.push(removeWatch);
                break;

              case "=":
                if (!Object.hasOwnProperty.call(attrs, attrName)) {
                  if (optional) break;
                  strictBindingsCheck(attrName, directive.name);
                  attrs[attrName] = undefined;
                }
                if (optional && !attrs[attrName]) break;

                parentGet = $parse(attrs[attrName]);
                var complexExpression = !!parentGet.inputs;
                if (parentGet.literal) {
                  compare = equals$1;
                } else {
                  compare = simpleCompare;
                }

                parentSet =
                  parentGet.assign ||
                  function () {
                    // reset the change, or we will throw this exception on every $digest
                    lastValue = destination.$target[scopeName] =
                      parentGet(scope);
                    throw $compileMinErr(
                      "nonassign",
                      "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                      attrs[attrName],
                      attrName,
                      directive.name,
                    );
                  };
                // store the value that the parent scope had after the last check:
                lastValue = destination.$target[scopeName] = parentGet(
                  scope.$target,
                );
                var parentValueWatch = function parentValueWatch(parentValue) {
                  if (!compare(parentValue, destination[scopeName])) {
                    // we are out of sync and need to copy
                    if (!compare(parentValue, lastValue)) {
                      // parent changed and it has precedence
                      destination[scopeName] = parentValue;
                    } else {
                      // if the parent can be assigned then do so
                      parentSet(scope, (parentValue = destination[scopeName]));
                    }
                  }
                  lastValue = parentValue;
                  return lastValue;
                };
                parentValueWatch.$stateful = true;
                if (definition.collection) {
                  removeWatch = scope.$watch(attrs[attrName], parentValueWatch);
                } else {
                  if (attrs[attrName]) {
                    let expr = attrs[attrName];
                    // make it lazy as we dont want to trigger the two way data binding at this point
                    scope.$watch(
                      expr,
                      (val) => {
                        var res = $parse(attrs[attrName], parentValueWatch);
                        if (val) {
                          if (parentGet.literal) {
                            scope.$target[attrName] = val;
                          } else {
                            scope[attrName] = val;
                          }
                          res(scope);
                        } else {
                          scope[attrName] = scope[attrs[attrName]];
                        }
                      },
                      true,
                    );
                  }

                  removeWatch = destination.$watch(
                    attrName,
                    (val) => {
                      if (val === lastValue && !isUndefined(attrs[attrName])) {
                        return;
                      }
                      if (
                        (complexExpression && !parentGet.literal) ||
                        (isUndefined(attrs[attrName]) && isDefined(val))
                      ) {
                        destination.$target[attrName] = lastValue;
                        throw $compileMinErr(
                          "nonassign",
                          "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                          attrs[attrName],
                          attrName,
                          directive.name,
                        );
                      } else {
                        // manually set the handler to avoid watch cycles
                        if (isObject(val)) {
                          Object.entries(val).forEach(([key, value]) => {
                            scope.$target[key] = value;
                          });
                        } else {
                          parentSet(scope.$target, (lastValue = val));
                          scope.$handler.watchers
                            .get(attrs[attrName])
                            ?.forEach((watchFn) => {
                              watchFn.listenerFn(val);
                            });
                        }
                      }
                    },
                    true,
                  );
                }
                removeWatchCollection.push(removeWatch);
                break;

              case "<":
                if (!Object.hasOwnProperty.call(attrs, attrName)) {
                  if (optional) break;
                  strictBindingsCheck(attrName, directive.name);
                  attrs[attrName] = undefined;
                }
                if (optional && !attrs[attrName]) break;

                parentGet = $parse(attrs[attrName]);

                destination.$target[scopeName] = parentGet(scope.$target);
                /** @type {SimpleChange} */
                initialChanges[scopeName] = {
                  currentValue: destination.$target[scopeName],
                  firstChange: firstChange,
                };
                scope.$target.attrs = attrs;

                if (attrs[attrName]) {
                  removeWatch = scope.$watch(
                    attrs[attrName],
                    (val) => {
                      destination.$target[scopeName] = val;
                      recordChanges(scopeName, val, firstChange);
                      if (firstChange) {
                        firstChange = false;
                      }
                    },
                    true,
                  );
                  removeWatchCollection.push(removeWatch);
                }
                break;

              case "&":
                if (!optional && !Object.hasOwnProperty.call(attrs, attrName)) {
                  strictBindingsCheck(attrName, directive.name);
                }
                // Don't assign Object.prototype method to scope
                parentGet = Object.prototype.hasOwnProperty.call(
                  attrs,
                  attrName,
                )
                  ? $parse(attrs[attrName])
                  : () => {};

                // Don't assign noop to destination if expression is not valid
                if (
                  parentGet.toString() === (() => {}).toString() &&
                  optional
                ) {
                  break;
                }

                destination.$target[scopeName] = function (locals) {
                  return parentGet(scope.$target, locals);
                };

                break;
            }
          });
        }
        function recordChanges(key, currentValue, initial) {
          if (isFunction(destination.$onChanges)) {
            // If we have not already scheduled the top level onChangesQueue handler then do so now
            if (!onChangesQueue) {
              scope.$postUpdate(flushOnChangesQueue);
              onChangesQueue = [];
            }
            // If we have not already queued a trigger of onChanges for this controller then do so now
            if (!changes) {
              changes = {};
              onChangesQueue.push(triggerOnChangesHook);
            }
            // Store this change
            changes[key] = { currentValue: currentValue, firstChange: initial };
          }
        }

        function triggerOnChangesHook() {
          destination.$onChanges && destination.$onChanges(changes);
          // Now clear the changes so that we schedule onChanges when more changes arrive
          changes = undefined;
        }

        return {
          initialChanges,
          removeWatches:
            removeWatchCollection.length &&
            function removeWatches() {
              for (let i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                removeWatchCollection[i]();
              }
            },
        };
      }
    },
  ];
}

function removeComments(jqNodes) {
  let i = jqNodes.length;

  if (i <= 1) {
    return jqNodes;
  }

  while (i--) {
    const node = jqNodes[i];
    if (
      node.nodeType === Node.COMMENT_NODE ||
      (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() === "")
    ) {
      [].splice.call(jqNodes, i, 1);
    }
  }
  return jqNodes;
}

/**
 * @param {String} name
 * @returns {void}
 */
function assertValidDirectiveName(name) {
  const letter = name.charAt(0);
  if (!letter || letter !== lowercase(letter)) {
    throw $compileMinErr(
      "baddir",
      "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter",
      name,
    );
  }
  if (name !== name.trim()) {
    throw $compileMinErr(
      "baddir",
      "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces",
      name,
    );
  }
}

const nullFormCtrl = {
  $nonscope: true,
  $addControl: () => {},
  $getControls: () => [],
  $$renameControl: (control, name) => {
    control.$name = name;
  },
  $removeControl: () => {},
  $setValidity: () => {},
  $setDirty: () => {},
  $setPristine: () => {},
  $setSubmitted: () => {},
  $$setSubmitted: () => {},
};

const PENDING_CLASS = "ng-pending";
const SUBMITTED_CLASS = "ng-submitted";

/**
 * @property {boolean} $dirty True if user has already interacted with the form.
 * @property {boolean} $valid True if all of the containing forms and controls are valid.
 * @property {boolean} $invalid True if at least one containing control or form is invalid.
 * @property {boolean} $submitted True if user has submitted the form even if its invalid.
 *
 * @property {Object} $pending An object hash, containing references to controls or forms with
 *  pending validators, where:
 *
 *  - keys are validations tokens (error names).
 *  - values are arrays of controls or forms that have a pending validator for the given error name.
 *
 * See {@link form.FormController#$error $error} for a list of built-in validation tokens.
 *
 * @property {Object} $error An object hash, containing references to controls or forms with failing
 *  validators, where:
 *
 *  - keys are validation tokens (error names),
 *  - values are arrays of controls or forms that have a failing validator for the given error name.
 *
 *  Built-in validation tokens:
 *  - `email`
 *  - `max`
 *  - `maxlength`
 *  - `min`
 *  - `minlength`
 *  - `number`
 *  - `pattern`
 *  - `required`
 *  - `url`
 *  - `date`
 *  - `datetimelocal`
 *  - `time`
 *  - `week`
 *  - `month`
 *
 * @description
 * `FormController` keeps track of all its controls and nested forms as well as the state of them,
 * such as being valid/invalid or dirty/pristine.
 *
 * Each {@link ng.directive:form form} directive creates an instance
 * of `FormController`.
 *
 */
// asks for $scope to fool the BC controller module

class FormController {
  static $nonscope = true;
  static $inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"];

  /**
   * @param {Element} $element
   * @param {import("../../core/compile/attributes.js").Attributes} $attrs
   * @param {import("../../core/scope/scope.js").Scope} $scope
   * @param {*} $animate
   * @param {*} $interpolate
   */
  constructor($element, $attrs, $scope, $animate, $interpolate) {
    this.$$controls = [];

    this.$name = $interpolate($attrs["name"] || $attrs["ngForm"] || "")($scope);

    /**
     * @property {boolean} $dirty True if user has already interacted with the form.
     */
    this.$dirty = false;

    /**
     * @propertys {boolean} $pristine - True if user has not interacted with the form yet.s
     */
    this.$pristine = true;
    this.$valid = true;
    this.$invalid = false;
    this.$submitted = false;
    /** @type {FormController|Object} */
    this.$$parentForm = nullFormCtrl;

    this.$$element = $element;
    this.$$animate = $animate;
    this.$error = {};
    this.$$success = {};
    this.$pending = undefined;
    this.$$classCache = {};
    const isValid = this.$$element.classList.contains(VALID_CLASS);
    this.$$classCache[VALID_CLASS] = isValid;
    this.$$classCache[INVALID_CLASS] = !isValid;
  }

  /**
   * Rollback all form controls pending updates to the `$modelValue`.
   *
   * Updates may be pending by a debounced event or because the input is waiting for a some future
   * event defined in `ng-model-options`. This method is typically needed by the reset button of
   * a form that uses `ng-model-options` to pend updates.
   */
  $rollbackViewValue() {
    this.$$controls.forEach((control) => {
      control.$rollbackViewValue();
    });
  }

  /**
   * Commit all form controls pending updates to the `$modelValue`.
   *
   * Updates may be pending by a debounced event or because the input is waiting for a some future
   * event defined in `ng-model-options`. This method is rarely needed as `NgModelController`
   * usually handles calling this in response to input events.
   */
  $commitViewValue() {
    this.$$controls.forEach((control) => {
      control.$commitViewValue();
    });
  }

  /**
   * Register a control with the form. Input elements using ngModelController do this automatically
   * when they are linked.
   *
   * Note that the current state of the control will not be reflected on the new parent form. This
   * is not an issue with normal use, as freshly compiled and linked controls are in a `$pristine`
   * state.
   *
   * However, if the method is used programmatically, for example by adding dynamically created controls,
   * or controls that have been previously removed without destroying their corresponding DOM element,
   * it's the developers responsibility to make sure the current state propagates to the parent form.
   *
   * For example, if an input control is added that is already `$dirty` and has `$error` properties,
   * calling `$setDirty()` and `$validate()` afterwards will propagate the state to the parent form.
   */
  $addControl(control) {
    // Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored
    // and not added to the scope.  Now we throw an error.
    assertNotHasOwnProperty(control.$name, "input");
    this.$$controls.push(control);

    if (control.$name) {
      this[control.$name] = control;
    }
    control.$target.$$parentForm = this;
  }

  /**
   * This method returns a **shallow copy** of the controls that are currently part of this form.
   * The controls can be instances of {@link form.FormController `FormController`}
   * ({@link ngForm "child-forms"}) and of {@link ngModel.NgModelController `NgModelController`}.
   * If you need access to the controls of child-forms, you have to call `$getControls()`
   * recursively on them.
   * This can be used for example to iterate over all controls to validate them.
   *
   * The controls can be accessed normally, but adding to, or removing controls from the array has
   * no effect on the form. Instead, use {@link form.FormController#$addControl `$addControl()`} and
   * {@link form.FormController#$removeControl `$removeControl()`} for this use-case.
   * Likewise, adding a control to, or removing a control from the form is not reflected
   * in the shallow copy. That means you should get a fresh copy from `$getControls()` every time
   * you need access to the controls.
   */
  $getControls() {
    return shallowCopy(this.$$controls);
  }

  // Private API: rename a form control
  $$renameControl(control, newName) {
    const oldName = control.$name;

    if (this[oldName] === control) {
      delete this[oldName];
    }
    this[newName] = control;
    control.$name = newName;
  }

  /**
   * Deregister a control from the form.
   *
   * Input elements using ngModelController do this automatically when they are destroyed.
   *
   * Note that only the removed control's validation state (`$errors`etc.) will be removed from the
   * form. `$dirty`, `$submitted` states will not be changed, because the expected behavior can be
   * different from case to case. For example, removing the only `$dirty` control from a form may or
   * may not mean that the form is still `$dirty`.
   */
  $removeControl(control) {
    if (control.$name && this[control.$name] === control) {
      delete this[control.$name];
    }
    this.$pending &&
      Object.keys(this.$pending).forEach((name) => {
        this.$setValidity(name, null, control);
      });
    this.$error &&
      Object.keys(this.$error).forEach((name) => {
        this.$setValidity(name, null, control);
      });
    this.$$success &&
      Object.keys(this.$$success).forEach((name) => {
        this.$setValidity(name, null, control);
      });

    arrayRemove(this.$$controls, control);

    control.$target["$$parentForm"] = nullFormCtrl;
  }

  /**
   * Sets the form to a dirty state.
   *
   * This method can be called to add the 'ng-dirty' class and set the form to a dirty
   * state (ng-dirty class). This method will also propagate to parent forms.
   */
  $setDirty() {
    this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
    this.$$animate.addClass(this.$$element, DIRTY_CLASS);
    this.$dirty = true;
    this.$pristine = false;
    this.$$parentForm.$setDirty();
  }

  /**
   * Sets the form to its pristine state.
   *
   * This method sets the form's `$pristine` state to true, the `$dirty` state to false, removes
   * the `ng-dirty` class and adds the `ng-pristine` class. Additionally, it sets the `$submitted`
   * state to false.
   *
   * This method will also propagate to all the controls contained in this form.
   *
   * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after
   * saving or resetting it.
   */
  $setPristine() {
    this.$$animate.setClass(
      this.$$element,
      PRISTINE_CLASS,
      `${DIRTY_CLASS} ${SUBMITTED_CLASS}`,
    );
    this.$dirty = false;
    this.$pristine = true;
    this.$submitted = false;
    this.$$controls.forEach((control) => {
      control.$setPristine();
    });
  }

  /**
   * Sets the form to its untouched state.
   *
   * This method can be called to remove the 'ng-touched' class and set the form controls to their
   * untouched state (ng-untouched class).
   *
   * Setting a form controls back to their untouched state is often useful when setting the form
   * back to its pristine state.
   */
  $setUntouched() {
    this.$$controls.forEach((control) => {
      control.$setUntouched();
    });
  }

  /**
   * Sets the form to its `$submitted` state. This will also set `$submitted` on all child and
   * parent forms of the form.
   */
  $setSubmitted() {
    /** @type {FormController} */
    let rootForm = this;
    while (rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl) {
      rootForm = rootForm.$$parentForm;
    }
    rootForm.$$setSubmitted();
  }

  $$setSubmitted() {
    this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);
    this.$submitted = true;
    this.$$controls.forEach((control) => {
      if (control.$$setSubmitted) {
        control.$$setSubmitted();
      }
    });
  }

  set(object, property, controller) {
    const list = object[property];
    if (!list) {
      if (isProxy(object)) {
        object = object.$target;
      }
      object[property] = [controller];
    } else {
      const index = list.indexOf(controller);
      if (index === -1) {
        list.push(controller);
      }
    }
  }

  unset(object, property, controller) {
    const list = object[property];
    if (!list) {
      return;
    }
    const index = arrayRemove(list, controller);
    if (index === -1) {
      arrayRemove(list, controller.$target);
    }
    if (list.length === 0) {
      delete object[property];
    }
  }

  /**
   * Change the validity state of the form, and notify the parent form (if any).
   *
   * Application developers will rarely need to call this method directly. It is used internally, by
   * {@link ngModel.NgModelController#$setValidity NgModelController.$setValidity()}, to propagate a
   * control's validity state to the parent `FormController`.
   *
   * @param {string} validationErrorKey Name of the validator. The `validationErrorKey` will be
   *        assigned to either `$error[validationErrorKey]` or `$pending[validationErrorKey]` (for
   *        unfulfilled `$asyncValidators`), so that it is available for data-binding. The
   *        `validationErrorKey` should be in camelCase and will get converted into dash-case for
   *        class name. Example: `myError` will result in `ng-valid-my-error` and
   *        `ng-invalid-my-error` classes and can be bound to as `{{ someForm.$error.myError }}`.
   * @param {boolean} state Whether the current state is valid (true), invalid (false), pending
   *        (undefined),  or skipped (null). Pending is used for unfulfilled `$asyncValidators`.
   *        Skipped is used by AngularJS when validators do not run because of parse errors and when
   *        `$asyncValidators` do not run because any of the `$validators` failed.
   * @param {import("../model/model.js").NgModelController | FormController} controller - The controller whose validity state is
   *        triggering the change.
   */
  $setValidity(validationErrorKey, state, controller) {
    let that = this;
    if (isUndefined(state)) {
      createAndSet(this, "$pending", validationErrorKey, controller);
    } else {
      unsetAndCleanup(this, "$pending", validationErrorKey, controller);
    }
    if (!isBoolean(state)) {
      this.unset(this.$error, validationErrorKey, controller);
      this.unset(this.$$success, validationErrorKey, controller);
    } else if (state) {
      this.unset(this.$error, validationErrorKey, controller);
      this.set(this.$$success, validationErrorKey, controller);
    } else {
      this.set(this.$error, validationErrorKey, controller);
      this.unset(this.$$success, validationErrorKey, controller);
    }
    if (this.$pending) {
      cachedToggleClass(this, PENDING_CLASS, true);
      this.$valid = this.$invalid = undefined;
      toggleValidationCss(this, "", null);
    } else {
      cachedToggleClass(this, PENDING_CLASS, false);
      this.$valid = isObjectEmpty(this.$error);
      this.$invalid = !this.$valid;
      toggleValidationCss(this, "", this.$valid);
    }

    // re-read the state as the set/unset methods could have
    // combined state in this.$error[validationError] (used for forms),
    // where setting/unsetting only increments/decrements the value,
    // and does not replace it.
    let combinedState;
    if (this.$pending && this.$pending[validationErrorKey]) {
      combinedState = undefined;
    } else if (this.$error[validationErrorKey]) {
      combinedState = false;
    } else if (this.$$success[validationErrorKey]) {
      combinedState = true;
    } else {
      combinedState = null;
    }

    toggleValidationCss(this, validationErrorKey, combinedState);
    this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
    function createAndSet(ctrl, name, value, controller) {
      if (!ctrl[name]) {
        ctrl[name] = {};
      }
      that.set(ctrl[name], value, controller);
    }

    function unsetAndCleanup(ctrl, name, value, controller) {
      if (ctrl[name]) {
        that.unset(ctrl[name], value, controller);
      }
      if (isObjectEmpty(ctrl[name])) {
        ctrl[name] = undefined;
      }
    }

    function cachedToggleClass(ctrl, className, switchValue) {
      if (switchValue && !ctrl.$$classCache[className]) {
        ctrl.$$animate.addClass(ctrl.$$element, className);
        ctrl.$$classCache[className] = true;
      } else if (!switchValue && ctrl.$$classCache[className]) {
        ctrl.$$animate.removeClass(ctrl.$$element, className);
        ctrl.$$classCache[className] = false;
      }
    }

    function toggleValidationCss(ctrl, validationErrorKey, isValid) {
      validationErrorKey = validationErrorKey
        ? `-${snakeCase(validationErrorKey, "-")}`
        : "";

      cachedToggleClass(
        ctrl,
        VALID_CLASS + validationErrorKey,
        isValid === true,
      );
      cachedToggleClass(
        ctrl,
        INVALID_CLASS + validationErrorKey,
        isValid === false,
      );
    }
  }
}

/**
 * Helper directive that makes it possible to create control groups inside a
 * {@link ng.directive:form `form`} directive.
 * These "child forms" can be used, for example, to determine the validity of a sub-group of
 * controls.
 *
 * <div class="alert alert-danger">
 * **Note**: `ngForm` cannot be used as a replacement for `<form>`, because it lacks its
 * [built-in HTML functionality](https://html.spec.whatwg.org/#the-form-element).
 * Specifically, you cannot submit `ngForm` like a `<form>` tag. That means,
 * you cannot send data to the server with `ngForm`, or integrate it with
 * {@link ng.directive:ngSubmit `ngSubmit`}.
 * </div>
 *
 * @param {string=} ngForm|name Name of the form. If specified, the form controller will
 *                              be published into the related scope, under this name.
 *
 */

/**
 * Directive that instantiates
 * {@link form.FormController FormController}.
 *
 * If the `name` attribute is specified, the form controller is published onto the current scope under
 * this name.
 *
 * ## Alias: {@link ng.directive:ngForm `ngForm`}
 *
 * In AngularJS, forms can be nested. This means that the outer form is valid when all of the child
 * forms are valid as well. However, browsers do not allow nesting of `<form>` elements, so
 * AngularJS provides the {@link ng.directive:ngForm `ngForm`} directive, which behaves identically to
 * `form` but can be nested. Nested forms can be useful, for example, if the validity of a sub-group
 * of controls needs to be determined.
 *
 * ## CSS classes
 *  - `ng-valid` is set if the form is valid.
 *  - `ng-invalid` is set if the form is invalid.
 *  - `ng-pending` is set if the form is pending.
 *  - `ng-pristine` is set if the form is pristine.
 *  - `ng-dirty` is set if the form is dirty.
 *  - `ng-submitted` is set if the form was submitted.
 *
 * Keep in mind that ngAnimate can detect each of these classes when added and removed.
 *
 *
 * ## Submitting a form and preventing the default action
 *
 * Since the role of forms in client-side AngularJS applications is different than in classical
 * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
 * page reload that sends the data to the server. Instead some javascript logic should be triggered
 * to handle the form submission in an application-specific way.
 *
 * For this reason, AngularJS prevents the default action (form submission to the server) unless the
 * `<form>` element has an `action` attribute specified.
 *
 * You can use one of the following two ways to specify what javascript method should be called when
 * a form is submitted:
 *
 * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element
 * - {@link ng.directive:ngClick ngClick} directive on the first
 *  button or input field of type submit (input[type=submit])
 *
 * To prevent double execution of the handler, use only one of the {@link ng.directive:ngSubmit ngSubmit}
 * or {@link ng.directive:ngClick ngClick} directives.
 * This is because of the following form submission rules in the HTML specification:
 *
 * - If a form has only one input field then hitting enter in this field triggers form submit
 * (`ngSubmit`)
 * - if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter
 * doesn't trigger submit
 * - if a form has one or more input fields and one or more buttons or input[type=submit] then
 * hitting enter in any of the input fields will trigger the click handler on the *first* button or
 * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
 *
 * Any pending `ngModelOptions` changes will take place immediately when an enclosing form is
 * submitted. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`
 * to have access to the updated model.
 *
 * @animations
 * Animations in ngForm are triggered when any of the associated CSS classes are added and removed.
 * These classes are: `.ng-pristine`, `.ng-dirty`, `.ng-invalid` and `.ng-valid` as well as any
 * other validations that are performed within the form. Animations in ngForm are similar to how
 * they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well
 * as JS animations.
 *
 * @param {string=} isNgForm Name of the form. If specified, the form controller will be published into
 *                       related scope, under this name.
 */
const formDirectiveFactory = function (isNgForm) {
  return [
    "$parse",
    function ($parse) {
      const formDirective = {
        name: "form",
        restrict: isNgForm ? "EA" : "E",
        require: ["form", "^^?form"], // first is the form's own ctrl, second is an optional parent form
        controller: FormController,
        compile: function ngFormCompile(formElement, attr) {
          // Setup initial state of the control
          formElement.classList.add(PRISTINE_CLASS, VALID_CLASS);

          const nameAttr = attr.name
            ? "name"
            : isNgForm && attr.ngForm
              ? "ngForm"
              : false;

          return {
            pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
              const controller = ctrls[0];

              // if `action` attr is not present on the form, prevent the default action (submission)
              if (!("action" in attr)) {
                // we can't use jq events because if a form is destroyed during submission the default
                // action is not prevented. see #1238
                //
                // IE 9 is not affected because it doesn't fire a submit event and try to do a full
                // page reload if the form was destroyed by submission of the form via a click handler
                // on a button in the form. Looks like an IE9 specific bug.
                const handleFormSubmission = function (event) {
                  controller.$commitViewValue();
                  controller.$setSubmitted();
                  event.preventDefault();
                };

                formElement.addEventListener("submit", handleFormSubmission);

                // unregister the preventDefault listener so that we don't not leak memory but in a
                // way that will achieve the prevention of the default action.
                formElement.addEventListener("$destroy", () => {
                  setTimeout(
                    () => {
                      formElement.removeEventListener(
                        "submit",
                        handleFormSubmission,
                      );
                    },
                    0,
                    false,
                  );
                });
              }

              const parentFormCtrl = ctrls[1] || controller.$$parentForm;
              parentFormCtrl.$addControl(controller);

              let setter = nameAttr ? getSetter(controller.$name) : () => {};

              if (nameAttr) {
                setter(scope, controller);
                attr.$observe(nameAttr, (newValue) => {
                  if (controller.$name === newValue) return;
                  scope.$target[controller.$name] = undefined;
                  controller.$$parentForm.$$renameControl(controller, newValue);
                  if (
                    scope.$target !== controller.$$parentForm &&
                    controller.$$parentForm !== nullFormCtrl
                  ) ; else {
                    scope.$target[newValue] = controller;
                  }
                });
              }
              formElement.addEventListener("$destroy", () => {
                controller.$target.$$parentForm.$removeControl(controller);
                setter(scope, undefined);
                extend(controller, nullFormCtrl); // stop propagating child destruction handlers upwards
              });
            },
          };
        },
      };

      return formDirective;

      function getSetter(expression) {
        if (expression === "") {
          // create an assignable expression, so forms with an empty name can be renamed later
          return $parse('this[""]').assign;
        }
        return $parse(expression).assign || (() => {});
      }
    },
  ];
};

const formDirective = formDirectiveFactory();
const ngFormDirective = formDirectiveFactory("ngForm");

const DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;

/**
 * @typedef {Object} ModelOptionsConfig
 * @property {string} [updateOn] - A string specifying which events the input should be bound to. Multiple events can be set using a space-delimited list. The special event 'default' matches the default events belonging to the control.
 * @property {number|Object.<string, number>} [debounce] - An integer specifying the debounce time in milliseconds. A value of 0 triggers an immediate update. If an object is supplied, custom debounce values can be set for each event.
 * @property {boolean} [allowInvalid] - Indicates whether the model can be set with values that did not validate correctly. Defaults to false, which sets the model to undefined on validation failure.
 * @property {boolean} [getterSetter] - Determines whether to treat functions bound to `ngModel` as getters/setters. Defaults to false.
 * @property {boolean} [updateOnDefault]
 */

class NgModelOptionsController {
  static $nonscope = true;
  static $inject = ["$attrs", "$scope"];

  /**
   * @param {import('../../types.js').Attributes} $attrs
   * @param {import('../../core/scope/scope.js').Scope} $scope
   */
  constructor($attrs, $scope) {
    this.$$attrs = $attrs;
    this.$$scope = $scope;
    /** @type {NgModelOptionsController?} */
    this.parentCtrl;
  }

  $onInit() {
    const parentOptions = this.parentCtrl
      ? this.parentCtrl.$options
      : defaultModelOptions;
    const modelOptionsDefinition = this.$$scope.$eval(
      this.$$attrs.ngModelOptions,
    );

    this.$options = parentOptions.createChild(modelOptionsDefinition);
  }
}

/**
 * @description
 * A container for the options set by the {@link ngModelOptions} directive
 */
class ModelOptions {
  static $nonscope = true;

  /**
   * @param {ModelOptionsConfig} options
   */
  constructor(options) {
    /** @type {ModelOptionsConfig} */
    this.$$options = options;
  }

  /**
   * Returns the value of the given option
   * @param {string} name the name of the option to retrieve
   * @returns {string|boolean|number|Object.<string, number>} the value of the option   *
   */
  getOption(name) {
    return this.$$options[name];
  }

  /**
   * @param {ModelOptionsConfig} options a hash of options for the new child that will override the parent's options
   * @return {ModelOptions} a new `ModelOptions` object initialized with the given options.
   */
  createChild(options) {
    let inheritAll = false;

    // make a shallow copy
    options = Object.assign({}, options);

    // Inherit options from the parent if specified by the value `"$inherit"`
    Object.entries(options).forEach(([key, option]) => {
      if (option === "$inherit") {
        if (key === "*") {
          inheritAll = true;
        } else {
          options[key] = this.$$options[key];
          // `updateOn` is special so we must also inherit the `updateOnDefault` option
          if (key === "updateOn") {
            options.updateOnDefault = this.$$options.updateOnDefault;
          }
        }
      } else if (key === "updateOn") {
        // If the `updateOn` property contains the `default` event then we have to remove
        // it from the event list and set the `updateOnDefault` flag.
        options.updateOnDefault = false;
        options[key] = trim(
          /** @type {string} */ (option).replace(DEFAULT_REGEXP, () => {
            options.updateOnDefault = true;
            return " ";
          }),
        );
      }
    }, this);

    if (inheritAll) {
      // We have a property of the form: `"*": "$inherit"`
      delete options["*"];
      defaults$1(options, this.$$options);
    }

    // Finally add in any missing defaults
    defaults$1(options, defaultModelOptions.$$options);

    return new ModelOptions(options);
  }
}

const defaultModelOptions = new ModelOptions({
  updateOn: "",
  updateOnDefault: true,
  debounce: 0,
  getterSetter: false,
  allowInvalid: false,
  //timezone: null,
});

/**
 * @returns {import('../../types.js').Directive}
 */
const ngModelOptionsDirective = function () {
  return {
    restrict: "A",
    // ngModelOptions needs to run before ngModel and input directives
    priority: 10,
    require: { parentCtrl: "?^^ngModelOptions" },
    bindToController: true,
    controller: NgModelOptionsController,
  };
};

// shallow copy over values from `src` that are not already specified on `dst`
function defaults$1(dst, src) {
  Object.keys(src).forEach((key) => {
    if (!isDefined(dst[key])) {
      dst[key] = src[key];
    }
  });
}

const ngModelMinErr = minErr("ngModel");

/**
 * 
 * @property {*} $viewValue The actual value from the control's view.
 *
 * @property {*} $modelValue The value in the model that the control is bound to.
 * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever
 *  the control updates the ngModelController with a new `$viewValue` from the DOM, usually via user input.
 *
 * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever
    the bound ngModel expression changes programmatically. The `$formatters` are not called when the
    value of the control is changed by user interaction.
 *
 * @property {Object.<string, (string, string) => boolean>} $validators A collection of validators that are applied whenever the model value changes. 
 * The key value within the object refers to the name of the validator while the function refers to the validation operation. 
 * The validation operation is provided with the model value as an argument and must return a true or false value depending on the response of that validation.
 *
 * @property {Object.<string, function(string, string) => Promise>} $asyncValidators A collection of validations that are expected to perform an asynchronous validation (e.g. a HTTP request).
 *  The validation function that is provided is expected to return a promise when it is run during the model validation process
 *
 * @property {Array.<Function>} $viewChangeListeners Array of functions to execute whenever
 *     a change to {@link ngModel.NgModelController#$viewValue `$viewValue`} has caused a change
 *     to {@link ngModel.NgModelController#$modelValue `$modelValue`}.
 *     It is called with no arguments, and its return value is ignored.
 *     This can be used in place of additional $watches against the model value.
 *
 * @property {Object} $error An object hash with all failing validator ids as keys.
 * @property {Object} $pending An object hash with all pending validator ids as keys.
 *
 * @property {boolean} $untouched True if control has not lost focus yet.
 * @property {boolean} $touched True if control has lost focus.
 * @property {boolean} $pristine True if user has not interacted with the control yet.
 * @property {boolean} $dirty True if user has already interacted with the control.
 * @property {boolean} $valid True if there is no error.
 * @property {boolean} $invalid True if at least one error on the control.
 * @property {string} $name The name attribute of the control.
 */

class NgModelController {
  static $nonscope = true;
  static $inject = [
    "$scope",
    "$exceptionHandler",
    "$attrs",
    "$element",
    "$parse",
    "$animate",
    "$interpolate",
  ];

  /**
   * @param {import('../../core/scope/scope.js').Scope} $scope
   * @param {import('../../core/exception-handler.js').ErrorHandler} $exceptionHandler
   * @param {import('../../core/compile/attributes.js').Attributes} $attr
   * @param {Element} $element
   * @param {import("../../core/parse/parse.js").ParseService} $parse
   * @param {*} $animate
   * @param {*} $interpolate
   */
  constructor(
    $scope,
    $exceptionHandler,
    $attr,
    $element,
    $parse,
    $animate,
    $interpolate,
  ) {
    /** @type {any} The actual value from the control's view  */
    this.$viewValue = Number.NaN;

    /** @type {any} The value in the model that the control is bound to. */
    this.$modelValue = Number.NaN;
    /** @type {any} */
    this.$$rawModelValue = undefined; // stores the parsed modelValue / model set from scope regardless of validity.

    this.$validators = {};
    this.$asyncValidators = {};
    this.$parsers = [];
    this.$formatters = [];
    this.$viewChangeListeners = [];
    this.$untouched = true;

    /** @type {boolean} */
    this.$touched = false;

    /** @type {boolean} */
    this.$pristine = true;

    /** @type {boolean} */
    this.$dirty = false;

    /** @type {boolean} */
    this.$valid = true;

    /** @type {boolean} */
    this.$invalid = false;

    this.$error = {}; // keep invalid keys here
    this.$$success = {}; // keep valid keys here
    this.$pending = undefined; // keep pending keys here
    this.$name = $interpolate($attr["name"] || "", false)($scope);
    this.$$parentForm = nullFormCtrl;
    this.$options = defaultModelOptions;
    this.$$updateEvents = "";
    // Attach the correct context to the event handler function for updateOn
    this.$$updateEventHandler = this.$$updateEventHandler.bind(this);

    this.$$parsedNgModel = $parse($attr["ngModel"]);
    this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;

    /** @type {import("../../core/parse/parse").CompiledExpression|((Scope) => any)} */
    this.$$ngModelGet = this.$$parsedNgModel;
    this.$$ngModelSet = this.$$parsedNgModelAssign;
    this.$$pendingDebounce = null;
    this.$$parserValid = undefined;

    /** @type {string} */
    this.$$parserName = "parse";

    /** @type {number} */
    this.$$currentValidationRunId = 0;

    /** @type {import('../../core/scope/scope.js').Scope} */
    this.$$scope = $scope; // attempt to bind to nearest controller if present

    /** @type {import('../../core/scope/scope.js').Scope} */
    this.$$rootScope = $scope.$root;
    this.$$attr = $attr;
    this.$$element = $element;
    this.$$animate = $animate;
    this.$$parse = $parse;
    this.$$exceptionHandler = $exceptionHandler;

    this.$$hasNativeValidators = false;

    this.$$classCache = {};
    const isValid = this.$$element.classList.contains(VALID_CLASS);
    this.$$classCache[VALID_CLASS] = isValid;
    this.$$classCache[INVALID_CLASS] = !isValid;

    this.$$eventRemovers = new Set();

    setupModelWatcher(this);
  }

  set(object, property) {
    object[property] = true;
  }
  unset(object, property) {
    delete object[property];
  }

  $setValidity(validationErrorKey, state) {
    let that = this;

    function createAndSet(ctrl, name, value) {
      if (!ctrl[name]) {
        ctrl[name] = {};
      }
      that.set(ctrl[name], value);
    }

    function unsetAndCleanup(ctrl, name, value) {
      if (ctrl[name]) {
        that.unset(ctrl[name], value);
      }
      if (isObjectEmpty(ctrl[name])) {
        ctrl[name] = undefined;
      }
    }

    function cachedToggleClass(ctrl, className, switchValue) {
      if (switchValue && !ctrl.$$classCache[className]) {
        ctrl.$$animate.addClass(ctrl.$$element, className);
        ctrl.$$classCache[className] = true;
      } else if (!switchValue && ctrl.$$classCache[className]) {
        ctrl.$$animate.removeClass(ctrl.$$element, className);
        ctrl.$$classCache[className] = false;
      }
    }

    function toggleValidationCss(ctrl, validationErrorKey, isValid) {
      validationErrorKey = validationErrorKey
        ? `-${snakeCase(validationErrorKey, "-")}`
        : "";

      cachedToggleClass(
        ctrl,
        VALID_CLASS + validationErrorKey,
        isValid === true,
      );
      cachedToggleClass(
        ctrl,
        INVALID_CLASS + validationErrorKey,
        isValid === false,
      );
    }

    if (isUndefined(state)) {
      createAndSet(this, "$pending", validationErrorKey);
    } else {
      unsetAndCleanup(this, "$pending", validationErrorKey);
    }
    if (!isBoolean(state)) {
      delete this.$error[validationErrorKey];
      delete this.$$success[validationErrorKey];
    } else if (state) {
      delete this.$error[validationErrorKey];
      this.set(this.$$success, validationErrorKey);
    } else {
      this.set(this.$error, validationErrorKey);
      delete this.$$success[validationErrorKey];
    }
    if (this.$pending) {
      cachedToggleClass(this, PENDING_CLASS, true);
      this.$valid = this.$invalid = undefined;
      toggleValidationCss(this, "", null);
    } else {
      cachedToggleClass(this, PENDING_CLASS, false);
      this.$valid = isObjectEmpty(this.$error);
      this.$invalid = !this.$valid;
      toggleValidationCss(this, "", this.$valid);
    }

    // re-read the state as the set/unset methods could have
    // combined state in this.$error[validationError] (used for forms),
    // where setting/unsetting only increments/decrements the value,
    // and does not replace it.
    let combinedState;
    if (this.$pending && this.$pending[validationErrorKey]) {
      combinedState = undefined;
    } else if (this.$error[validationErrorKey]) {
      combinedState = false;
    } else if (this.$$success[validationErrorKey]) {
      combinedState = true;
    } else {
      combinedState = null;
    }

    toggleValidationCss(this, validationErrorKey, combinedState);
    this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
  }

  $$initGetterSetters() {
    if (this.$options.getOption("getterSetter")) {
      const invokeModelGetter = this.$$parse(`${this.$$attr["ngModel"]}()`);
      const invokeModelSetter = this.$$parse(`${this.$$attr["ngModel"]}($$$p)`);

      this.$$ngModelGet = ($scope) => {
        let modelValue = this.$$parsedNgModel($scope);
        if (isFunction(modelValue)) {
          modelValue = invokeModelGetter($scope);
        }
        return modelValue;
      };
      this.$$ngModelSet = ($scope, newValue) => {
        if (isFunction(this.$$parsedNgModel($scope))) {
          invokeModelSetter($scope, { $$$p: newValue });
        } else {
          this.$$parsedNgModelAssign($scope, newValue);
        }
      };
    } else if (!this.$$parsedNgModel.assign) {
      throw ngModelMinErr(
        "nonassign",
        "Expression '{0}' is non-assignable. Element: {1}",
        this.$$attr["ngModel"],
        startingTag(this.$$element),
      );
    }
  }

  /**
   * Called when the view needs to be updated. It is expected that the user of the ng-model
   * directive will implement this method.
   *
   * The `$render()` method is invoked in the following situations:
   *
   * * `$rollbackViewValue()` is called.  If we are rolling back the view value to the last
   *   committed value then `$render()` is called to update the input control.
   * * The value referenced by `ng-model` is changed programmatically and both the `$modelValue` and
   *   the `$viewValue` are different from last time.
   *
   * Since `ng-model` does not do a deep watch, `$render()` is only invoked if the values of
   * `$modelValue` and `$viewValue` are actually different from their previous values. If `$modelValue`
   * or `$viewValue` are objects (rather than a string or number) then `$render()` will not be
   * invoked if you only change a property on the objects.
   */
  $render() {}

  /**
   * This is called when we need to determine if the value of an input is empty.
   *
   * For instance, the required directive does this to work out if the input has data or not.
   *
   * The default `$isEmpty` function checks whether the value is `undefined`, `''`, `null` or `NaN`.
   *
   * You can override this for input directives whose concept of being empty is different from the
   * default. The `checkboxInputType` directive does this because in its case a value of `false`
   * implies empty.
   *
   * @param {*} value The value of the input to check for emptiness.
   * @returns {boolean} True if `value` is "empty".
   */
  $isEmpty(value) {
    return (
      isUndefined(value) || value === "" || value === null || value !== value
    );
  }

  $$updateEmptyClasses(value) {
    if (this.$isEmpty(value)) {
      if (hasAnimate(this.$$element)) {
        this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);
        this.$$animate.addClass(this.$$element, EMPTY_CLASS);
      } else {
        this.$$element.classList.remove(NOT_EMPTY_CLASS);
        this.$$element.classList.add(EMPTY_CLASS);
      }
    } else {
      if (hasAnimate(this.$$element)) {
        this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
        this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);
      } else {
        this.$$element.classList.remove(EMPTY_CLASS);
        this.$$element.classList.add(NOT_EMPTY_CLASS);
      }
    }
  }

  /**
   * Sets the control to its pristine state.
   *
   * This method can be called to remove the `ng-dirty` class and set the control to its pristine
   * state (`ng-pristine` class). A model is considered to be pristine when the control
   * has not been changed from when first compiled.
   */
  $setPristine() {
    this.$dirty = false;
    this.$pristine = true;
    if (!this.$$element) return;
    if (hasAnimate(this.$$element)) {
      this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
      this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
    } else {
      this.$$element.classList.remove(EMPTY_CLASS);
      this.$$element.classList.add(PRISTINE_CLASS);
    }
  }

  /**
   * Sets the control to its dirty state.
   *
   * This method can be called to remove the `ng-pristine` class and set the control to its dirty
   * state (`ng-dirty` class). A model is considered to be dirty when the control has been changed
   * from when first compiled.
   */
  $setDirty() {
    this.$dirty = true;
    this.$pristine = false;
    if (hasAnimate(this.$$element)) {
      this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
      this.$$animate.addClass(this.$$element, DIRTY_CLASS);
    } else {
      this.$$element.classList.remove(PRISTINE_CLASS);
      this.$$element.classList.add(DIRTY_CLASS);
    }
    this.$$parentForm.$setDirty();
  }

  /**
   * Sets the control to its untouched state.
   *
   * This method can be called to remove the `ng-touched` class and set the control to its
   * untouched state (`ng-untouched` class). Upon compilation, a model is set as untouched
   * by default, however this function can be used to restore that state if the model has
   * already been touched by the user.
   */
  $setUntouched() {
    this.$touched = false;
    this.$untouched = true;
    if (hasAnimate(this.$$element)) {
      this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
    } else {
      this.$$element.classList.remove(TOUCHED_CLASS);
      this.$$element.classList.add(UNTOUCHED_CLASS);
    }
  }

  /**
   * Sets the control to its touched state.
   *
   * This method can be called to remove the `ng-untouched` class and set the control to its
   * touched state (`ng-touched` class). A model is considered to be touched when the user has
   * first focused the control element and then shifted focus away from the control (blur event).
   */
  $setTouched() {
    this.$touched = true;
    this.$untouched = false;
    if (hasAnimate(this.$$element)) {
      this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
    } else {
      this.$$element.classList.remove(UNTOUCHED_CLASS);
      this.$$element.classList.add(TOUCHED_CLASS);
    }
  }

  /**
   * Cancel an update and reset the input element's value to prevent an update to the `$modelValue`,
   * which may be caused by a pending debounced event or because the input is waiting for some
   * future event.
   *
   * If you have an input that uses `ng-model-options` to set up debounced updates or updates that
   * depend on special events such as `blur`, there can be a period when the `$viewValue` is out of
   * sync with the ngModel's `$modelValue`.
   *
   * In this case, you can use `$rollbackViewValue()` to manually cancel the debounced / future update
   * and reset the input to the last committed view value.
   *
   * It is also possible that you run into difficulties if you try to update the ngModel's `$modelValue`
   * programmatically before these debounced/future events have resolved/occurred, because AngularJS's
   * dirty checking mechanism is not able to tell whether the model has actually changed or not.
   *
   * The `$rollbackViewValue()` method should be called before programmatically changing the model of an
   * input which may have such events pending. This is important in order to make sure that the
   * input field will be updated with the new model value and any pending operations are cancelled.
   *
   * @example
   * <example name="ng-model-cancel-update" module="cancel-update-example">
   *   <file name="app.js">
   *     angular.module('cancel-update-example', [])
   *
   *     .controller('CancelUpdateController', ['$scope', function($scope) {
   *       $scope.model = {value1: '', value2: ''};
   *
   *       $scope.setEmpty = function(e, value, rollback) {
   *         if (e.keyCode === 27) {
   *           e.preventDefault();
   *           if (rollback) {
   *             $scope.myForm[value].$rollbackViewValue();
   *           }
   *           $scope.model[value] = '';
   *         }
   *       };
   *     }]);
   *   </file>
   *   <file name="index.html">
   *     <div ng-controller="CancelUpdateController">
   *       <p>Both of these inputs are only updated if they are blurred. Hitting escape should
   *       empty them. Follow these steps and observe the difference:</p>
   *       <ol>
   *         <li>Type something in the input. You will see that the model is not yet updated</li>
   *         <li>Press the Escape key.
   *           <ol>
   *             <li> In the first example, nothing happens, because the model is already '', and no
   *             update is detected. If you blur the input, the model will be set to the current view.
   *             </li>
   *             <li> In the second example, the pending update is cancelled, and the input is set back
   *             to the last committed view value (''). Blurring the input does nothing.
   *             </li>
   *           </ol>
   *         </li>
   *       </ol>
   *
   *       <form name="myForm" ng-model-options="{ updateOn: 'blur' }">
   *         <div>
   *           <p id="inputDescription1">Without $rollbackViewValue():</p>
   *           <input name="value1" aria-describedby="inputDescription1" ng-model="model.value1"
   *                  ng-keydown="setEmpty($event, 'value1')">
   *           value1: "{{ model.value1 }}"
   *         </div>
   *
   *         <div>
   *           <p id="inputDescription2">With $rollbackViewValue():</p>
   *           <input name="value2" aria-describedby="inputDescription2" ng-model="model.value2"
   *                  ng-keydown="setEmpty($event, 'value2', true)">
   *           value2: "{{ model.value2 }}"
   *         </div>
   *       </form>
   *     </div>
   *   </file>
       <file name="style.css">
          div {
            display: table-cell;
          }
          div:nth-child(1) {
            padding-right: 30px;
          }

        </file>
   * </example>
   */
  $rollbackViewValue() {
    clearTimeout(this.$$pendingDebounce);
    this.$viewValue = this.$$lastCommittedViewValue;
    this.$render();
  }

  /**
   * Runs each of the registered validators (first synchronous validators and then
   * asynchronous validators).
   * If the validity changes to invalid, the model will be set to `undefined`,
   * unless {@link ngModelOptions `ngModelOptions.allowInvalid`} is `true`.
   * If the validity changes to valid, it will set the model to the last available valid
   * `$modelValue`, i.e. either the last parsed value or the last value set from the scope.
   */
  $validate() {
    // ignore $validate before model is initialized
    if (isNumberNaN(this.$modelValue)) {
      return;
    }

    const viewValue = this.$$lastCommittedViewValue;
    // Note: we use the $$rawModelValue as $modelValue might have been
    // set to undefined during a view -> model update that found validation
    // errors. We can't parse the view here, since that could change
    // the model although neither viewValue nor the model on the scope changed
    const modelValue = this.$$rawModelValue;

    const prevValid = this.$valid;
    const prevModelValue = this.$modelValue;

    const allowInvalid = this.$options.getOption("allowInvalid");

    const that = this;
    this.$$runValidators(modelValue, viewValue, (allValid) => {
      // If there was no change in validity, don't update the model
      // This prevents changing an invalid modelValue to undefined
      if (!allowInvalid && prevValid !== allValid) {
        // Note: Don't check this.$valid here, as we could have
        // external validators (e.g. calculated on the server),
        // that just call $setValidity and need the model value
        // to calculate their validity.
        that.$modelValue = allValid ? modelValue : undefined;

        if (that.$modelValue !== prevModelValue) {
          that.$$writeModelToScope();
        }
      }
    });
  }

  $$runValidators(modelValue, viewValue, doneCallback) {
    this.$$currentValidationRunId++;
    const localValidationRunId = this.$$currentValidationRunId;
    const that = this;

    // check parser error
    if (!processParseErrors()) {
      validationDone(false);
      return;
    }
    if (!processSyncValidators()) {
      validationDone(false);
      return;
    }
    processAsyncValidators();

    function processParseErrors() {
      const errorKey = that.$$parserName;

      if (isUndefined(that.$$parserValid)) {
        setValidity(errorKey, null);
      } else {
        if (!that.$$parserValid) {
          Object.keys(that.$validators).forEach((name) => {
            setValidity(name, null);
          });
          Object.keys(that.$asyncValidators).forEach((name) => {
            setValidity(name, null);
          });
        }

        // Set the parse error last, to prevent unsetting it, should a $validators key == parserName
        setValidity(errorKey, that.$$parserValid);
        return that.$$parserValid;
      }
      return true;
    }

    function processSyncValidators() {
      let syncValidatorsValid = true;
      Object.entries(that.$validators).forEach(([name, validator]) => {
        const result = Boolean(validator(modelValue, viewValue));
        syncValidatorsValid = syncValidatorsValid && result;
        setValidity(name, result);
      });
      if (!syncValidatorsValid) {
        Object.keys(that.$asyncValidators).forEach((name) => {
          setValidity(name, null);
        });
        return false;
      }
      return true;
    }

    function processAsyncValidators() {
      const validatorPromises = [];
      let allValid = true;
      Object.entries(that.$asyncValidators).forEach(([name, validator]) => {
        const promise = validator(modelValue, viewValue);
        if (!isPromiseLike(promise)) {
          throw ngModelMinErr(
            "nopromise",
            "Expected asynchronous validator to return a promise but got '{0}' instead.",
            promise,
          );
        }
        setValidity(name, undefined);
        validatorPromises.push(
          promise.then(
            () => {
              setValidity(name, true);
            },
            () => {
              allValid = false;
              setValidity(name, false);
            },
          ),
        );
      });
      if (!validatorPromises.length) {
        validationDone(true);
      } else {
        Promise.all(validatorPromises).then(
          () => {
            validationDone(allValid);
          },
          () => {},
        );
      }
    }

    function setValidity(name, isValid) {
      if (localValidationRunId === that.$$currentValidationRunId) {
        that.$setValidity(name, isValid);
      }
    }

    function validationDone(allValid) {
      if (localValidationRunId === that.$$currentValidationRunId) {
        doneCallback(allValid);
      }
    }
  }

  /**
   * Commit a pending update to the `$modelValue`.
   *
   * Updates may be pending by a debounced event or because the input is waiting for a some future
   * event defined in `ng-model-options`. this method is rarely needed as `NgModelController`
   * usually handles calling this in response to input events.
   */
  $commitViewValue() {
    clearTimeout(this.$$pendingDebounce);

    // If the view value has not changed then we should just exit, except in the case where there is
    // a native validator on the element. In this case the validation state may have changed even though
    // the viewValue has stayed empty.
    if (
      this.$$lastCommittedViewValue === this.$viewValue &&
      (this.$viewValue !== "" || !this.$$hasNativeValidators)
    ) {
      return;
    }

    if (
      this.$$lastCommittedViewValue === undefined &&
      Number.isNaN(this.$viewValue)
    ) {
      return;
    }

    this.$$updateEmptyClasses(this.$viewValue);
    this.$$lastCommittedViewValue = this.$viewValue;

    // change to dirty
    if (this.$pristine) {
      this.$setDirty();
    }
    this.$$parseAndValidate();
  }

  $$parseAndValidate() {
    const viewValue = this.$$lastCommittedViewValue;
    let modelValue = viewValue;
    const that = this;

    this.$$parserValid = isUndefined(modelValue) ? undefined : true;

    // Reset any previous parse error
    this.$setValidity(this.$$parserName, null);
    this.$$parserName = "parse";

    if (this.$$parserValid) {
      for (let i = 0; i < this.$parsers.length; i++) {
        modelValue = this.$parsers[i](modelValue);
        if (isUndefined(modelValue)) {
          this.$$parserValid = false;
          break;
        }
      }
    }
    if (isNumberNaN(this.$modelValue)) {
      // this.$modelValue has not been touched yet...
      // @ts-ignore
      this.$modelValue = this.$$ngModelGet(this.$$scope);
    }
    const prevModelValue = this.$modelValue;
    const allowInvalid = this.$options.getOption("allowInvalid");
    this.$$rawModelValue = modelValue;

    if (allowInvalid) {
      this.$modelValue = modelValue;
      writeToModelIfNeeded();
    }

    // Pass the $$lastCommittedViewValue here, because the cached viewValue might be out of date.
    // This can happen if e.g. $setViewValue is called from inside a parser
    this.$$runValidators(
      modelValue,
      this.$$lastCommittedViewValue,
      (allValid) => {
        if (!allowInvalid) {
          // Note: Don't check this.$valid here, as we could have
          // external validators (e.g. calculated on the server),
          // that just call $setValidity and need the model value
          // to calculate their validity.
          // if (that.$modelValue ?? that.$modelValue[isProxySymbol]) {
          //   delete that.$modelValue;
          // }
          that.$modelValue = allValid ? modelValue : undefined;
          writeToModelIfNeeded();
        }
      },
    );

    function writeToModelIfNeeded() {
      // intentional loose equality
      if (that.$modelValue != prevModelValue) {
        that.$$writeModelToScope();
      }
    }
  }

  $$writeModelToScope() {
    this.$$ngModelSet(this.$$scope.$target, this.$modelValue);
    Object.values(this.$viewChangeListeners).forEach((listener) => {
      try {
        listener();
      } catch (e) {
        this.$$exceptionHandler(e);
      }
    }, this);
  }

  /**
   * Update the view value.
   *
   * This method should be called when a control wants to change the view value; typically,
   * this is done from within a DOM event handler. For example, the {@link ng.directive:input input}
   * directive calls it when the value of the input changes and {@link ng.directive:select select}
   * calls it when an option is selected.
   *
   * When `$setViewValue` is called, the new `value` will be staged for committing through the `$parsers`
   * and `$validators` pipelines. If there are no special {@link ngModelOptions} specified then the staged
   * value is sent directly for processing through the `$parsers` pipeline. After this, the `$validators` and
   * `$asyncValidators` are called and the value is applied to `$modelValue`.
   * Finally, the value is set to the **expression** specified in the `ng-model` attribute and
   * all the registered change listeners, in the `$viewChangeListeners` list are called.
   *
   * In case the {@link ng.directive:ngModelOptions ngModelOptions} directive is used with `updateOn`
   * and the `default` trigger is not listed, all those actions will remain pending until one of the
   * `updateOn` events is triggered on the DOM element.
   * All these actions will be debounced if the {@link ng.directive:ngModelOptions ngModelOptions}
   * directive is used with a custom debounce for this particular event.
   * Note that a `$digest` is only triggered once the `updateOn` events are fired, or if `debounce`
   * is specified, once the timer runs out.
   *
   * When used with standard inputs, the view value will always be a string (which is in some cases
   * parsed into another type, such as a `Date` object for `input[date]`.)
   * However, custom controls might also pass objects to this method. In this case, we should make
   * a copy of the object before passing it to `$setViewValue`. This is because `ngModel` does not
   * perform a deep watch of objects, it only looks for a change of identity. If you only change
   * the property of the object then ngModel will not realize that the object has changed and
   * will not invoke the `$parsers` and `$validators` pipelines. For this reason, you should
   * not change properties of the copy once it has been passed to `$setViewValue`.
   * Otherwise you may cause the model value on the scope to change incorrectly.
   *
   * <div class="alert alert-info">
   * In any case, the value passed to the method should always reflect the current value
   * of the control. For example, if you are calling `$setViewValue` for an input element,
   * you should pass the input DOM value. Otherwise, the control and the scope model become
   * out of sync. It's also important to note that `$setViewValue` does not call `$render` or change
   * the control's DOM value in any way. If we want to change the control's DOM value
   * programmatically, we should update the `ngModel` scope expression. Its new value will be
   * picked up by the model controller, which will run it through the `$formatters`, `$render` it
   * to update the DOM, and finally call `$validate` on it.
   * </div>
   *
   * @param {*} value value from the view.
   * @param {string} [trigger] Event that triggered the update.
   */
  $setViewValue(value, trigger) {
    this.$viewValue = value;
    if (this.$options?.getOption("updateOnDefault")) {
      this.$$debounceViewValueCommit(trigger);
    }
  }

  $$debounceViewValueCommit(trigger) {
    let debounceDelay = this.$options.getOption("debounce");

    if (isNumber(debounceDelay[trigger])) {
      debounceDelay = debounceDelay[trigger];
    } else if (
      isNumber(debounceDelay["default"]) &&
      /** @type {string} */ (this.$options.getOption("updateOn")).indexOf(
        trigger,
      ) === -1
    ) {
      debounceDelay = debounceDelay["default"];
    } else if (isNumber(debounceDelay["*"])) {
      debounceDelay = debounceDelay["*"];
    }

    clearTimeout(this.$$pendingDebounce);
    const that = this;
    if (/** @type {number} */ (debounceDelay) > 0) {
      // this fails if debounceDelay is an object
      this.$$pendingDebounce = setTimeout(() => {
        that.$commitViewValue();
      }, /** @type {number} */ (debounceDelay));
    } else {
      this.$commitViewValue();
    }
  }

  /**
   *
   * Override the current model options settings programmatically.
   *
   * The previous `ModelOptions` value will not be modified. Instead, a
   * new `ModelOptions` object will inherit from the previous one overriding
   * or inheriting settings that are defined in the given parameter.
   *
   * See {@link ngModelOptions} for information about what options can be specified
   * and how model option inheritance works.
   *
   * <div class="alert alert-warning">
   * **Note:** this function only affects the options set on the `ngModelController`,
   * and not the options on the {@link ngModelOptions} directive from which they might have been
   * obtained initially.
   * </div>
   *
   * <div class="alert alert-danger">
   * **Note:** it is not possible to override the `getterSetter` option.
   * </div>
   *
   * @param {Object} options a hash of settings to override the previous options
   *
   */
  $overrideModelOptions(options) {
    this.$$removeAllEventListeners();
    this.$options = this.$options.createChild(options);
    this.$$updateEvents = this.$options.$$options.updateOn;
    this.$$setUpdateOnEvents();
  }

  /**
   * Runs the model -> view pipeline on the current
   * {@link ngModel.NgModelController#$modelValue $modelValue}.
   *
   * The following actions are performed by this method:
   *
   * - the `$modelValue` is run through the {@link ngModel.NgModelController#$formatters $formatters}
   * and the result is set to the {@link ngModel.NgModelController#$viewValue $viewValue}
   * - the `ng-empty` or `ng-not-empty` class is set on the element
   * - if the `$viewValue` has changed:
   *   - {@link ngModel.NgModelController#$render $render} is called on the control
   *   - the {@link ngModel.NgModelController#$validators $validators} are run and
   *   the validation status is set.
   *
   * This method is called by ngModel internally when the bound scope value changes.
   * Application developers usually do not have to call this function themselves.
   *
   * This function can be used when the `$viewValue` or the rendered DOM value are not correctly
   * formatted and the `$modelValue` must be run through the `$formatters` again.
   *
   * @example
   * Consider a text input with an autocomplete list (for fruit), where the items are
   * objects with a name and an id.
   * A user enters `ap` and then selects `Apricot` from the list.
   * Based on this, the autocomplete widget will call `$setViewValue({name: 'Apricot', id: 443})`,
   * but the rendered value will still be `ap`.
   * The widget can then call `ctrl.$processModelValue()` to run the model -> view
   * pipeline again, which formats the object to the string `Apricot`,
   * then updates the `$viewValue`, and finally renders it in the DOM.
   *
   * <example module="inputExample" name="ng-model-process">
     <file name="index.html">
      <div ng-controller="inputController" style="display: flex;">
        <div style="margin-right: 30px;">
          Search Fruit:
          <basic-autocomplete items="items" on-select="selectedFruit = item"></basic-autocomplete>
        </div>
        <div>
          Model:<br>
          <pre>{{selectedFruit | json}}</pre>
        </div>
      </div>
     </file>
     <file name="app.js">
      angular.module('inputExample', [])
        .controller('inputController', function($scope) {
          $scope.items = [
            {name: 'Apricot', id: 443},
            {name: 'Clementine', id: 972},
            {name: 'Durian', id: 169},
            {name: 'Jackfruit', id: 982},
            {name: 'Strawberry', id: 863}
          ];
        })
        .component('basicAutocomplete', {
          bindings: {
            items: '<',
            onSelect: '&'
          },
          templateUrl: 'autocomplete.html',
          controller: function($element, $scope) {
            let that = this;
            let ngModel;

            that.$postLink = function() {
              ngModel = $element.querySelectorAll('input').controller('ngModel');

              ngModel.$formatters.push(function(value) {
                return (value && value.name) || value;
              });

              ngModel.$parsers.push(function(value) {
                let match = value;
                for (let i = 0; i < that.items.length; i++) {
                  if (that.items[i].name === value) {
                    match = that.items[i];
                    break;
                  }
                }

                return match;
              });
            };

            that.selectItem = function(item) {
              ngModel.$setViewValue(item);
              ngModel.$processModelValue();
              that.onSelect({item: item});
            };
          }
        });
     </file>
     <file name="autocomplete.html">
       <div>
         <input type="search" ng-model="$ctrl.searchTerm" />
         <ul>
           <li ng-repeat="item in $ctrl.items | filter:$ctrl.searchTerm">
             <button ng-click="$ctrl.selectItem(item)">{{ item.name }}</button>
           </li>
         </ul>
       </div>
     </file>
   * </example>
   *
   */
  $processModelValue() {
    const viewValue = this.$$format();

    if (this.$viewValue !== viewValue) {
      this.$$updateEmptyClasses(viewValue);
      this.$viewValue = this.$$lastCommittedViewValue = viewValue;
      this.$render();
      // It is possible that model and view value have been updated during render
      this.$$runValidators(this.$modelValue, this.$viewValue, () => {});
    }
  }

  /**
   * This method is called internally to run the $formatters on the $modelValue
   */
  $$format() {
    const formatters = this.$formatters;
    let idx = formatters.length;

    let viewValue = this.$modelValue;
    while (idx--) {
      viewValue = formatters[idx](viewValue);
    }

    return viewValue;
  }

  /**
   * This method is called internally when the bound scope value changes.
   */
  $$setModelValue(modelValue) {
    this.$modelValue = this.$$rawModelValue = modelValue;
    this.$$parserValid = undefined;
    this.$processModelValue();
  }

  $$removeAllEventListeners() {
    this.$$eventRemovers.forEach((removeCallback) => removeCallback());
    this.$$eventRemovers.clear();
  }

  $$setUpdateOnEvents() {
    if (this.$$updateEvents) {
      this.$$updateEvents.split(" ").forEach((ev) => {
        this.$$element.addEventListener(ev, this.$$updateEventHandler);
        this.$$eventRemovers.add(() =>
          this.$$element.removeEventListener(ev, this.$$updateEventHandler),
        );
      });
    }

    this.$$updateEvents = /** @type {string} */ (
      this.$options.getOption("updateOn")
    );
    if (this.$$updateEvents) {
      this.$$updateEvents.split(" ").forEach((ev) => {
        this.$$element.addEventListener(ev, this.$$updateEventHandler);
        this.$$eventRemovers.add(() =>
          this.$$element.removeEventListener(ev, this.$$updateEventHandler),
        );
      });
    }
  }

  $$updateEventHandler(ev) {
    this.$$debounceViewValueCommit(ev && ev.type);
  }
}

function setupModelWatcher(ctrl) {
  // model -> value
  // Note: we cannot use a normal scope.$watch as we want to detect the following:
  // 1. scope value is 'a'
  // 2. user enters 'b'
  // 3. ng-change kicks in and reverts scope value to 'a'
  //    -> scope value did not change since the last digest as
  //       ng-change executes in apply phase
  // 4. view should be changed back to 'a'
  ctrl.$$scope.$watch("value", () => {
    const modelValue = ctrl.$$ngModelGet(ctrl.$$scope);

    // if scope model value and ngModel value are out of sync
    // This cannot be moved to the action function, because it would not catch the
    // case where the model is changed in the ngChange function or the model setter
    if (
      modelValue !== ctrl.$modelValue &&
      // checks for NaN is needed to allow setting the model to NaN when there's an asyncValidator

      (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)
    ) {
      ctrl.$$setModelValue(modelValue);
    }
  });
}

function ngModelDirective() {
  return {
    restrict: "A",
    require: ["ngModel", "^?form", "^?ngModelOptions"],
    controller: NgModelController,
    // Prelink needs to run before any input directive
    // so that we can set the NgModelOptions in NgModelController
    // before anyone else uses it.
    priority: 1,
    compile:
      /** @param {Element} element  */
      (element) => {
        // Setup initial state of the control
        element.classList.add(PRISTINE_CLASS, UNTOUCHED_CLASS, VALID_CLASS);

        return {
          pre: (scope, _element, attr, ctrls) => {
            const modelCtrl = ctrls[0];
            const formCtrl = ctrls[1] || modelCtrl.$$parentForm;
            const optionsCtrl = ctrls[2];

            if (optionsCtrl) {
              modelCtrl.$options = optionsCtrl.$options;
            }
            modelCtrl.$$initGetterSetters();

            // notify others, especially parent forms
            formCtrl.$addControl(modelCtrl);

            attr.$observe("name", (newValue) => {
              if (modelCtrl.$name !== newValue) {
                modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
              }
            });
            let deregisterWatch = scope.$watch(attr["ngModel"], (val) => {
              modelCtrl.$$setModelValue(isProxy(val) ? val.$target : val);
            });

            scope.$on("$destroy", () => {
              modelCtrl.$$parentForm.$removeControl(modelCtrl);
              deregisterWatch();
            });
          },
          post: (scope, element, _attr, ctrls) => {
            const modelCtrl = ctrls[0];
            modelCtrl.$$setUpdateOnEvents();

            function setTouched() {
              modelCtrl.$setTouched();
            }

            element.addEventListener("blur", () => {
              if (modelCtrl.$touched) return;
              setTouched();
            });
          },
        };
      },
  };
}

// Regex code was initially obtained from SO prior to modification: https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime#answer-3143231
const ISO_DATE_REGEXP =
  /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
// See valid URLs in RFC3987 (http://tools.ietf.org/html/rfc3987)
// Note: We are being more lenient, because browsers are too.
//   1. Scheme
//   2. Slashes
//   3. Username
//   4. Password
//   5. Hostname
//   6. Port
//   7. Path
//   8. Query
//   9. Fragment
//                 1111111111111111 222   333333    44444        55555555555555555555555     666     77777777     8888888     999
const URL_REGEXP =
  /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;

const EMAIL_REGEXP =
  /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
const NUMBER_REGEXP = /^\s*([-+])?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
const DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
const DATETIMELOCAL_REGEXP =
  /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
const WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
const MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
const TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
// The name of a form control's ValidityState property.
// This is used so that it's possible for internal tests to create mock ValidityStates.
const VALIDITY_STATE_PROPERTY = "validity";

const PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown";
/**
 * @type {Map<string, boolean>}
 */
const PARTIAL_VALIDATION_TYPES = new Map();
"date,datetime-local,month,time,week".split(",").forEach((type) => {
  PARTIAL_VALIDATION_TYPES.set(type, true);
});

const inputType = {
  text: textInputType,
  date: createDateInputType(
    "date",
    DATE_REGEXP,
    createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]),
  ),
  "datetime-local": createDateInputType(
    "datetimelocal",
    DATETIMELOCAL_REGEXP,
    createDateParser(DATETIMELOCAL_REGEXP, [
      "yyyy",
      "MM",
      "dd",
      "HH",
      "mm",
      "ss",
      "sss",
    ]),
  ),
  time: createDateInputType(
    "time",
    TIME_REGEXP,
    createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]),
  ),
  week: createDateInputType("week", WEEK_REGEXP, weekParser),
  month: createDateInputType(
    "month",
    MONTH_REGEXP,
    createDateParser(MONTH_REGEXP, ["yyyy", "MM"]),
  ),
  number: numberInputType,
  url: urlInputType,
  email: emailInputType,
  radio: radioInputType,
  range: rangeInputType,
  checkbox: checkboxInputType,
  hidden: () => {},
  button: () => {},
  submit: () => {},
  reset: () => {},
  file: () => {},
};

function stringBasedInputType(ctrl) {
  ctrl.$formatters.push((value) =>
    ctrl.$isEmpty(value) ? value : value.toString(),
  );
}

function textInputType(scope, element, attr, ctrl) {
  baseInputType(scope, element, attr, ctrl);
  stringBasedInputType(ctrl);
}

function baseInputType(scope, element, attr, ctrl) {
  const type = element.type.toLowerCase();
  let composing = false;
  // In composition mode, users are still inputting intermediate text buffer,
  // hold the listener until composition is done.
  // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent
  element.addEventListener("compositionstart", () => {
    composing = true;
  });

  element.addEventListener("compositionend", () => {
    composing = false;
    listener();
  });

  let timeout;

  let listener = function (ev) {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
    if (composing) return;
    let value = element.value;
    const event = ev && ev.type;

    // By default we will trim the value
    // If the attribute ng-trim exists we will avoid trimming
    // If input type is 'password', the value is never trimmed
    if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
      value = trim(value);
    }

    // If a control is suffering from bad input (due to native validators), browsers discard its
    // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the
    // control's value is the same empty value twice in a row.
    if (
      ctrl.$viewValue !== value ||
      (value === "" && ctrl.$$hasNativeValidators)
    ) {
      ctrl.$target.$setViewValue(value, event);
    }
  };

  ["input", "change", "paste", "drop", "cut"].forEach((event) => {
    element.addEventListener(event, listener);
  });

  // Some native input types (date-family) have the ability to change validity without
  // firing any input/change events.
  // For these event types, when native validators are present and the browser supports the type,
  // check for validity changes on various DOM events.
  if (
    PARTIAL_VALIDATION_TYPES[type] &&
    ctrl.$$hasNativeValidators &&
    type === attr.type
  ) {
    element.addEventListener(PARTIAL_VALIDATION_EVENTS, function (ev) {
      if (!timeout) {
        const validity = this[VALIDITY_STATE_PROPERTY];
        const origBadInput = validity.badInput;
        const origTypeMismatch = validity.typeMismatch;
        timeout = setTimeout(() => {
          timeout = null;
          if (
            validity.badInput !== origBadInput ||
            validity.typeMismatch !== origTypeMismatch
          ) {
            listener(ev);
          }
        });
      }
    });
  }

  ctrl.$render = function () {
    // Workaround for Firefox validation #12102.
    const value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
    if (element.value !== value) {
      element.value = value;
    }
  };
}

function weekParser(isoWeek, existingDate) {
  if (isDate(isoWeek)) {
    return isoWeek;
  }

  function getFirstThursdayOfYear(year) {
    // 0 = index of January
    const dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
    // 4 = index of Thursday (+1 to account for 1st = 5)
    // 11 = index of *next* Thursday (+1 account for 1st = 12)
    return new Date(
      year,
      0,
      (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst,
    );
  }

  if (isString(isoWeek)) {
    WEEK_REGEXP.lastIndex = 0;
    const parts = WEEK_REGEXP.exec(isoWeek);
    if (parts) {
      const year = +parts[1];
      const week = +parts[2];
      let hours = 0;
      let minutes = 0;
      let seconds = 0;
      let milliseconds = 0;
      const firstThurs = getFirstThursdayOfYear(year);
      const addDays = (week - 1) * 7;

      if (existingDate) {
        hours = existingDate.getHours();
        minutes = existingDate.getMinutes();
        seconds = existingDate.getSeconds();
        milliseconds = existingDate.getMilliseconds();
      }

      return new Date(
        year,
        0,
        firstThurs.getDate() + addDays,
        hours,
        minutes,
        seconds,
        milliseconds,
      );
    }
  }

  return NaN;
}

function createDateParser(regexp, mapping) {
  return function (iso, previousDate) {
    let parts;
    let map;

    if (isDate(iso)) {
      return iso;
    }

    if (isString(iso)) {
      // When a date is JSON'ified to wraps itself inside of an extra
      // set of double quotes. This makes the date parsing code unable
      // to match the date string and parse it as a date.
      if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
        iso = iso.substring(1, iso.length - 1);
      }
      if (ISO_DATE_REGEXP.test(iso)) {
        return new Date(iso);
      }
      regexp.lastIndex = 0;
      parts = regexp.exec(iso);

      if (parts) {
        parts.shift();
        if (previousDate) {
          map = {
            yyyy: previousDate.getFullYear(),
            MM: previousDate.getMonth() + 1,
            dd: previousDate.getDate(),
            HH: previousDate.getHours(),
            mm: previousDate.getMinutes(),
            ss: previousDate.getSeconds(),
            sss: previousDate.getMilliseconds() / 1000,
          };
        } else {
          map = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };
        }

        Object.entries(parts).forEach(([index, part]) => {
          if (index < mapping.length) {
            map[mapping[index]] = +part;
          }
        });

        const date = new Date(
          map.yyyy,
          map.MM - 1,
          map.dd,
          map.HH,
          map.mm,
          map.ss || 0,
          map.sss * 1000 || 0,
        );
        if (map.yyyy < 100) {
          // In the constructor, 2-digit years map to 1900-1999.
          // Use `setFullYear()` to set the correct year.
          date.setFullYear(map.yyyy);
        }

        return date;
      }
    }

    return NaN;
  };
}

const MONTH_INPUT_FORMAT = /\b\d{4}-(0[1-9]|1[0-2])\b/;

function createDateInputType(type, regexp, parseDate) {
  return function dynamicDateInputType(
    scope,
    element,
    attr,
    ctrl,
    $browser,
    $filter,
    $parse,
  ) {
    badInputChecker(scope, element, attr, ctrl, type);
    baseInputType(scope, element, attr, ctrl);
    let previousDate;

    ctrl.$parsers.push((value) => {
      if (ctrl.$isEmpty(value)) return null;

      if (regexp.test(value)) {
        // Do not convert for native HTML
        if (["month", "week", "datetimelocal", "time", "date"].includes(type)) {
          return value;
        }

        // Note: We cannot read ctrl.$modelValue, as there might be a different
        // parser/formatter in the processing chain so that the model
        // contains some different data format!
        return parseDateAndConvertTimeZoneToLocal(value, previousDate);
      }
      ctrl.$$parserName = type;
      return undefined;
    });

    ctrl.$formatters.push(function (value) {
      if (value && !isString(value)) {
        throw ngModelMinErr("datefmt", "Expected `{0}` to be a String", value);
      }

      if (type === "month") {
        if (value == null) {
          return "";
        }
        if (!MONTH_INPUT_FORMAT.test(value)) {
          throw ngModelMinErr(
            "datefmt",
            "Expected month `{0}` to be a 'YYYY-DD'",
            value,
          );
        }
      }

      if (type === "week") {
        if (value == null) {
          return "";
        }
        if (!WEEK_REGEXP.test(value)) {
          throw ngModelMinErr(
            "datefmt",
            "Expected week `{0}` to be a 'yyyy-Www'",
            value,
          );
        }
      }

      if (type === "datetimelocal") {
        if (value == null) {
          return "";
        }
        if (!DATETIMELOCAL_REGEXP.test(value)) {
          throw ngModelMinErr(
            "datefmt",
            "Expected week `{0}` to be a in date time format. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats#local_date_and_time_strings",
            value,
          );
        }
      }

      return value;

      // if (isValidDate(value)) {
      //   previousDate = value;
      //   const timezone = ctrl.$options.getOption("timezone");

      //   if (timezone) {
      //     previousTimezone = timezone;
      //     previousDate = convertTimezoneToLocal(previousDate, timezone, true);
      //   }

      //   return value;
      // }
      // previousDate = null;
      // previousTimezone = null;
      // return "";
    });

    if (isDefined(attr.min) || attr.ngMin) {
      let minVal = attr.min || $parse(attr.ngMin)(scope);
      let parsedMinVal = parseObservedDateValue(minVal);

      ctrl.$validators.min = function (value) {
        if (type === "month") {
          return (
            isUndefined(parsedMinVal) ||
            parseDate(value) >= parseDate(parsedMinVal)
          );
        }

        return (
          !isValidDate(value) ||
          isUndefined(parsedMinVal) ||
          parseDate(value) >= parsedMinVal
        );
      };
      attr.$observe("min", (val) => {
        if (val !== minVal) {
          parsedMinVal = parseObservedDateValue(val);
          minVal = val;
          ctrl.$validate();
        }
      });
    }

    if (isDefined(attr.max) || attr.ngMax) {
      let maxVal = attr.max || $parse(attr.ngMax)(scope);
      let parsedMaxVal = parseObservedDateValue(maxVal);

      ctrl.$validators.max = function (value) {
        if (type === "month") {
          return (
            isUndefined(parsedMaxVal) ||
            parseDate(value) <= parseDate(parsedMaxVal)
          );
        }
        return (
          !isValidDate(value) ||
          isUndefined(parsedMaxVal) ||
          parseDate(value) <= parsedMaxVal
        );
      };
      attr.$observe("max", (val) => {
        if (val !== maxVal) {
          parsedMaxVal = parseObservedDateValue(val);
          maxVal = val;
          ctrl.$validate();
        }
      });
    }

    function isValidDate(value) {
      // Invalid Date: getTime() returns NaN
      return value && !(value.getTime && value.getTime() !== value.getTime());
    }

    function parseObservedDateValue(val) {
      return isDefined(val) && !isDate(val)
        ? parseDateAndConvertTimeZoneToLocal(val) || undefined
        : val;
    }

    function parseDateAndConvertTimeZoneToLocal(value, previousDate) {
      const timezone = ctrl.$options.getOption("timezone");

      let parsedDate = parseDate(value, previousDate);

      if (!Number.isNaN(parsedDate) && timezone) {
        parsedDate = convertTimezoneToLocal(parsedDate, timezone);
      }
      return parsedDate;
    }
  };
}

function badInputChecker(scope, element, attr, ctrl, parserName) {
  const node = element;
  const nativeValidation = (ctrl.$$hasNativeValidators = isObject(
    node.validity,
  ));

  if (nativeValidation) {
    ctrl.$parsers.push((value) => {
      const validity = element[VALIDITY_STATE_PROPERTY] || {};
      if (validity.badInput || validity.typeMismatch) {
        ctrl.$$parserName = parserName;
        return undefined;
      }

      return value;
    });
  }
}

function numberFormatterParser(ctrl) {
  ctrl.$parsers.push((value) => {
    if (ctrl.$isEmpty(value)) return null;
    if (NUMBER_REGEXP.test(value)) return parseFloat(value);

    ctrl.$$parserName = "number";
    return undefined;
  });

  ctrl.$formatters.push((value) => {
    if (!ctrl.$isEmpty(value)) {
      if (!isNumber(value)) {
        throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
      }
      value = value.toString();
    }
    return value;
  });
}

function parseNumberAttrVal(val) {
  if (isDefined(val) && !isNumber(val)) {
    val = parseFloat(val);
  }
  return !isNumberNaN(val) ? val : undefined;
}

function isNumberInteger(num) {
  // See http://stackoverflow.com/questions/14636536/how-to-check-if-a-variable-is-an-integer-in-javascript#14794066
  // (minus the assumption that `num` is a number)

  return (num | 0) === num;
}

function countDecimals(num) {
  const numString = num.toString();
  const decimalSymbolIndex = numString.indexOf(".");

  if (decimalSymbolIndex === -1) {
    if (num > -1 && num < 1) {
      // It may be in the exponential notation format (`1e-X`)
      const match = /e-(\d+)$/.exec(numString);

      if (match) {
        return Number(match[1]);
      }
    }

    return 0;
  }

  return numString.length - decimalSymbolIndex - 1;
}

function isValidForStep(viewValue, stepBase, step) {
  // At this point `stepBase` and `step` are expected to be non-NaN values
  // and `viewValue` is expected to be a valid stringified number.
  let value = Number(viewValue);

  const isNonIntegerValue = !isNumberInteger(value);
  const isNonIntegerStepBase = !isNumberInteger(stepBase);
  const isNonIntegerStep = !isNumberInteger(step);

  // Due to limitations in Floating Point Arithmetic (e.g. `0.3 - 0.2 !== 0.1` or
  // `0.5 % 0.1 !== 0`), we need to convert all numbers to integers.
  if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
    const valueDecimals = isNonIntegerValue ? countDecimals(value) : 0;
    const stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0;
    const stepDecimals = isNonIntegerStep ? countDecimals(step) : 0;

    const decimalCount = Math.max(
      valueDecimals,
      stepBaseDecimals,
      stepDecimals,
    );
    const multiplier = 10 ** decimalCount;

    value *= multiplier;
    stepBase *= multiplier;
    step *= multiplier;

    if (isNonIntegerValue) value = Math.round(value);
    if (isNonIntegerStepBase) stepBase = Math.round(stepBase);
    if (isNonIntegerStep) step = Math.round(step);
  }

  return (value - stepBase) % step === 0;
}

function numberInputType(
  scope,
  element,
  attr,
  ctrl,
  $browser,
  $filter,
  $parse,
) {
  badInputChecker(scope, element, attr, ctrl, "number");
  numberFormatterParser(ctrl);
  baseInputType(scope, element, attr, ctrl);

  let parsedMinVal;

  if (isDefined(attr.min) || attr.ngMin) {
    let minVal = attr.min || $parse(attr.ngMin)(scope);
    parsedMinVal = parseNumberAttrVal(minVal);

    ctrl.$validators.min = function (modelValue, viewValue) {
      return (
        ctrl.$isEmpty(viewValue) ||
        isUndefined(parsedMinVal) ||
        viewValue >= parsedMinVal
      );
    };

    attr.$observe("min", (val) => {
      if (val !== minVal) {
        parsedMinVal = parseNumberAttrVal(val);
        minVal = val;
        // TODO(matsko): implement validateLater to reduce number of validations
        ctrl.$validate();
      }
    });
  }

  if (isDefined(attr.max) || attr.ngMax) {
    let maxVal = attr.max || $parse(attr.ngMax)(scope);
    let parsedMaxVal = parseNumberAttrVal(maxVal);

    ctrl.$validators.max = function (modelValue, viewValue) {
      return (
        ctrl.$isEmpty(viewValue) ||
        isUndefined(parsedMaxVal) ||
        viewValue <= parsedMaxVal
      );
    };

    attr.$observe("max", (val) => {
      if (val !== maxVal) {
        parsedMaxVal = parseNumberAttrVal(val);
        maxVal = val;
        // TODO(matsko): implement validateLater to reduce number of validations
        ctrl.$validate();
      }
    });
  }

  if (isDefined(attr.step) || attr.ngStep) {
    let stepVal = attr.step || $parse(attr.ngStep)(scope);
    let parsedStepVal = parseNumberAttrVal(stepVal);

    ctrl.$validators.step = function (modelValue, viewValue) {
      return (
        ctrl.$isEmpty(viewValue) ||
        isUndefined(parsedStepVal) ||
        isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal)
      );
    };

    attr.$observe("step", (val) => {
      // TODO(matsko): implement validateLater to reduce number of validations
      if (val !== stepVal) {
        parsedStepVal = parseNumberAttrVal(val);
        stepVal = val;
        ctrl.$validate();
      }
    });
  }
}

function rangeInputType(scope, element, attr, ctrl) {
  badInputChecker(scope, element, attr, ctrl, "range");
  numberFormatterParser(ctrl);
  baseInputType(scope, element, attr, ctrl);

  const supportsRange = ctrl.$$hasNativeValidators && element.type === "range";
  let minVal = supportsRange ? 0 : undefined;
  let maxVal = supportsRange ? 100 : undefined;
  let stepVal = supportsRange ? 1 : undefined;
  const { validity } = element;
  const hasMinAttr = isDefined(attr.min);
  const hasMaxAttr = isDefined(attr.max);
  const hasStepAttr = isDefined(attr.step);

  const originalRender = ctrl.$render;

  ctrl.$render =
    supportsRange &&
    isDefined(validity.rangeUnderflow) &&
    isDefined(validity.rangeOverflow)
      ? // Browsers that implement range will set these values automatically, but reading the adjusted values after
        // $render would cause the min / max validators to be applied with the wrong value
        function rangeRender() {
          originalRender();
          ctrl.$setViewValue(element.value);
        }
      : originalRender;

  if (hasMinAttr) {
    minVal = parseNumberAttrVal(attr.min);

    ctrl.$validators.min = supportsRange
      ? // Since all browsers set the input to a valid value, we don't need to check validity
        function noopMinValidator() {
          return true;
        }
      : // non-support browsers validate the min val
        function minValidator(modelValue, viewValue) {
          return (
            ctrl.$isEmpty(viewValue) ||
            isUndefined(minVal) ||
            viewValue >= minVal
          );
        };

    setInitialValueAndObserver("min", minChange);
  }

  if (hasMaxAttr) {
    maxVal = parseNumberAttrVal(attr.max);

    ctrl.$validators.max = supportsRange
      ? // Since all browsers set the input to a valid value, we don't need to check validity
        function noopMaxValidator() {
          return true;
        }
      : // non-support browsers validate the max val
        function maxValidator(modelValue, viewValue) {
          return (
            ctrl.$isEmpty(viewValue) ||
            isUndefined(maxVal) ||
            viewValue <= maxVal
          );
        };

    setInitialValueAndObserver("max", maxChange);
  }

  if (hasStepAttr) {
    stepVal = parseNumberAttrVal(attr.step);

    ctrl.$validators.step = supportsRange
      ? function nativeStepValidator() {
          // Currently, only FF implements the spec on step change correctly (i.e. adjusting the
          // input element value to a valid value). It's possible that other browsers set the stepMismatch
          // validity error instead, so we can at least report an error in that case.
          return !validity.stepMismatch;
        }
      : // ngStep doesn't set the setp attr, so the browser doesn't adjust the input value as setting step would
        function stepValidator(modelValue, viewValue) {
          return (
            ctrl.$isEmpty(viewValue) ||
            isUndefined(stepVal) ||
            isValidForStep(viewValue, minVal || 0, stepVal)
          );
        };

    setInitialValueAndObserver("step", stepChange);
  }

  function setInitialValueAndObserver(htmlAttrName, changeFn) {
    // interpolated attributes set the attribute value only after a digest, but we need the
    // attribute value when the input is first rendered, so that the browser can adjust the
    // input value based on the min/max value
    element.setAttribute(htmlAttrName, attr[htmlAttrName]);
    let oldVal = attr[htmlAttrName];
    attr.$observe(htmlAttrName, (val) => {
      if (val !== oldVal) {
        oldVal = val;
        changeFn(val);
      }
    });
  }

  function minChange(val) {
    minVal = parseNumberAttrVal(val);
    // ignore changes before model is initialized
    if (isNumberNaN(ctrl.$modelValue)) {
      return;
    }

    if (supportsRange) {
      let elVal = element.value;
      // IE11 doesn't set the el val correctly if the minVal is greater than the element value
      if (minVal > elVal) {
        elVal = minVal;
        element.value = elVal;
      }
      ctrl.$setViewValue(elVal);
    } else {
      // TODO(matsko): implement validateLater to reduce number of validations
      ctrl.$validate();
    }
  }

  function maxChange(val) {
    maxVal = parseNumberAttrVal(val);
    // ignore changes before model is initialized
    if (isNumberNaN(ctrl.$modelValue)) {
      return;
    }

    if (supportsRange) {
      let elVal = element.value;
      // IE11 doesn't set the el val correctly if the maxVal is less than the element value
      if (maxVal < elVal) {
        element.value = maxVal;
        // IE11 and Chrome don't set the value to the minVal when max < min
        elVal = maxVal < minVal ? minVal : maxVal;
      }
      ctrl.$setViewValue(elVal);
    } else {
      // TODO(matsko): implement validateLater to reduce number of validations
      ctrl.$validate();
    }
  }

  function stepChange(val) {
    stepVal = parseNumberAttrVal(val);
    // ignore changes before model is initialized
    if (isNumberNaN(ctrl.$modelValue)) {
      return;
    }

    // Some browsers don't adjust the input value correctly, but set the stepMismatch error
    if (!supportsRange) {
      // TODO(matsko): implement validateLater to reduce number of validations
      ctrl.$validate();
    } else if (ctrl.$viewValue !== element.value) {
      ctrl.$setViewValue(element.value);
    }
  }
}

function urlInputType(scope, element, attr, ctrl) {
  // Note: no badInputChecker here by purpose as `url` is only a validation
  // in browsers, i.e. we can always read out input.value even if it is not valid!
  baseInputType(scope, element, attr, ctrl);
  stringBasedInputType(ctrl);

  ctrl.$validators.url = function (modelValue, viewValue) {
    const value = modelValue || viewValue;
    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
  };
}

function emailInputType(scope, element, attr, ctrl) {
  // Note: no badInputChecker here by purpose as `url` is only a validation
  // in browsers, i.e. we can always read out input.value even if it is not valid!
  baseInputType(scope, element, attr, ctrl);
  stringBasedInputType(ctrl);

  ctrl.$validators.email = function (modelValue, viewValue) {
    const value = modelValue || viewValue;
    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
  };
}

function radioInputType(scope, element, attr, ctrl) {
  const doTrim = !attr.ngTrim || trim(attr.ngTrim) !== "false";
  // make the name unique, if not defined
  if (isUndefined(attr.name)) {
    element.setAttribute("name", nextUid());
  }

  const listener = function (ev) {
    let value;
    if (element.checked) {
      value = attr.value;
      if (doTrim) {
        value = trim(value);
      }
      ctrl.$setViewValue(value, ev && ev.type);
    }
  };

  element.addEventListener("change", listener);

  ctrl.$render = function () {
    let { value } = attr;
    if (doTrim) {
      value = trim(value);
    }
    element.checked = value === ctrl.$viewValue;
  };

  attr.$observe("value", ctrl.$render);
}

function parseConstantExpr($parse, context, name, expression, fallback) {
  let parseFn;
  if (isDefined(expression)) {
    parseFn = $parse(expression);
    if (!parseFn.constant) {
      throw ngModelMinErr(
        "constexpr",
        "Expected constant expression for `{0}`, but saw " + "`{1}`.",
        name,
        expression,
      );
    }
    return parseFn(context);
  }
  return fallback;
}

function checkboxInputType(
  scope,
  element,
  attr,
  ctrl,
  $browser,
  $filter,
  $parse,
) {
  const trueValue = parseConstantExpr(
    $parse,
    scope,
    "ngTrueValue",
    attr.ngTrueValue,
    true,
  );
  const falseValue = parseConstantExpr(
    $parse,
    scope,
    "ngFalseValue",
    attr.ngFalseValue,
    false,
  );

  const listener = function (ev) {
    ctrl.$setViewValue(element.checked, ev && ev.type);
  };

  element.addEventListener("change", listener);

  ctrl.$render = function () {
    element.checked = ctrl.$viewValue;
  };

  // Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`
  // This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert
  // it to a boolean.
  ctrl.$isEmpty = function (value) {
    return value === false;
  };

  ctrl.$formatters.push((value) => equals$1(value, trueValue));

  ctrl.$parsers.push((value) => (value ? trueValue : falseValue));
}

/**
 * @returns {import('../../types.js').Directive}
 */
inputDirective.$inject = ["$browser", "$filter", "$parse"];

/**
 * @param {import('../../services/browser').Browser} $browser
 * @param {*} $filter
 * @param {*} $parse
 * @returns
 */
function inputDirective($browser, $filter, $parse) {
  return {
    restrict: "E",
    require: ["?ngModel"],
    link: {
      pre(scope, element, attr, ctrls) {
        if (ctrls[0]) {
          (inputType[lowercase(attr.type)] || inputType.text)(
            scope,
            element,
            attr,
            ctrls[0],
            $browser,
            $filter,
            $parse,
          );
        }
      },
    },
  };
}

/**
 * @returns {import('../../types.js').Directive}
 */
function hiddenInputBrowserCacheDirective() {
  const valueProperty = {
    configurable: true,
    enumerable: false,
    get() {
      return this.getAttribute("value") || "";
    },
    set(val) {
      this.setAttribute("value", val);
    },
  };

  return {
    restrict: "E",
    priority: 200,
    compile(_, attr) {
      if (lowercase(attr.type) !== "hidden") {
        return;
      }

      return {
        pre(scope, element) {
          const node = element;

          // Support: Edge
          // Moving the DOM around prevents autofillling
          if (node.parentNode) {
            node.parentNode.insertBefore(node, node.nextSibling);
          }

          // Support: FF, IE
          // Avoiding direct assignment to .value prevents autofillling
          if (Object.defineProperty) {
            Object.defineProperty(node, "value", valueProperty);
          }
        },
      };
    },
  };
}

const CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;

/**
 * @returns {import('../../types.js').Directive}
 */
function ngValueDirective() {
  /**
   *  inputs use the value attribute as their default value if the value property is not set.
   *  Once the value property has been set (by adding input), it will not react to changes to
   *  the value attribute anymore. Setting both attribute and property fixes this behavior, and
   *  makes it possible to use ngValue as a sort of one-way bind.
   */
  function updateElementValue(element, attr, value) {
    // Support: IE9 only
    // In IE9 values are converted to string (e.g. `input.value = null` results in `input.value === 'null'`).
    const propValue = isDefined(value) ? value : null;
    element["value"] = propValue;
    attr.$set("value", value);
  }

  return {
    restrict: "A",
    priority: 100,
    compile(tpl, tplAttr) {
      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
        return function ngValueConstantLink(scope, elm, attr) {
          const value = scope.$eval(attr.ngValue);
          updateElementValue(elm, attr, value);
        };
      }
      return function ngValueLink(scope, elm, attr) {
        scope.$watch(attr.ngValue, (value) => {
          updateElementValue(elm, attr, value);
        });
      };
    },
  };
}

scriptDirective.$inject = ["$templateCache"];

/**
 * @param {import('../../core/cache/cache-factory').TemplateCache} $templateCache
 * @returns {import('../../types.js').Directive}
 */
function scriptDirective($templateCache) {
  return {
    restrict: "E",
    terminal: true,
    compile(element, attr) {
      if (attr.type === "text/ng-template") {
        $templateCache.set(attr.id, element.innerText);
      }
    },
  };
}

/**
 * The controller for the {@link ng.select select} directive.
 * The controller exposes a few utility methods that can be used to augment
 * the behavior of a regular or an {@link ng.ngOptions ngOptions} select element.
 */
class SelectController {
  static $nonscope = [
    "ngModelCtrl",
    "selectValueMap",
    "emptyOption",
    "optionsMap",
    "$scope",
    "$element",
  ];

  /**
   * @type {Array<string>}
   */
  static $inject = ["$element", "$scope"];

  /**
   * @param {HTMLSelectElement} $element
   * @param {import('../../core/scope/scope.js').Scope} $scope
   */
  constructor($element, $scope) {
    /** @type {HTMLSelectElement} */
    this.$element = $element;

    /** @type {import('../../core/scope/scope.js').Scope} */
    this.$scope = $scope;

    /** @type {Object<string, any>} */
    this.selectValueMap = {};

    /** @type {any} */
    this.ngModelCtrl = {};

    /** @type {boolean} */
    this.multiple = false;

    /** @type {HTMLOptionElement} */
    this.unknownOption = document.createElement("option");

    /** @type {boolean} */
    this.hasEmptyOption = false;

    /** @type {HTMLOptionElement|undefined} */
    this.emptyOption = undefined;

    /** @type {Map<any, number>} */
    this.optionsMap = new Map();

    /** @type {boolean} */
    this.renderScheduled = false;

    /** @type {boolean} */
    this.updateScheduled = false;

    $scope.$on("$destroy", () => {
      // disable unknown option so that we don't do work when the whole select is being destroyed
      this.renderUnknownOption = () => {};
    });
  }

  /**
   * Render the unknown option when the viewValue doesn't match any options.
   * @param {*} val
   */
  renderUnknownOption(val) {
    const unknownVal = this.generateUnknownOptionValue(val);
    this.unknownOption.value = unknownVal;
    this.$element.prepend(this.unknownOption);
    this.unknownOption.selected = true;
    this.unknownOption.setAttribute("selected", "selected");
    this.$element.value = unknownVal;
  }

  /**
   * Update the unknown option if it's already rendered.
   * @param {*} val
   */
  updateUnknownOption(val) {
    const unknownVal = this.generateUnknownOptionValue(val);
    this.unknownOption.value = unknownVal;
    this.unknownOption.selected = true;
    this.unknownOption.setAttribute("selected", "selected");
    this.$element.value = unknownVal;
  }

  /**
   * Generate a special value used for unknown options.
   * @param {*} val
   * @returns {string}
   */
  generateUnknownOptionValue(val) {
    if (isUndefined(val)) {
      return `? undefined:undefined ?`;
    }
    return `? ${hashKey(val)} ?`;
  }

  /**
   * Remove the unknown option from the select element if it exists.
   */
  removeUnknownOption() {
    if (this.unknownOption.parentElement) this.unknownOption.remove();
  }

  /**
   * Select the empty option (value="") if it exists.
   */
  selectEmptyOption() {
    if (this.emptyOption) {
      this.$element.value = "";
      this.emptyOption.selected = true;
      this.emptyOption.setAttribute("selected", "selected");
    }
  }

  /**
   * Unselect the empty option if present.
   */
  unselectEmptyOption() {
    if (this.hasEmptyOption) {
      this.emptyOption.selected = false;
    }
  }

  /**
   * Read the current value from the select element.
   * @returns {*|null}
   */
  readValue() {
    const val = this.$element.value;
    const realVal = val in this.selectValueMap ? this.selectValueMap[val] : val;
    return this.hasOption(realVal) ? realVal : null;
  }

  /**
   * Write a value to the select control.
   * @param {*} value
   */
  writeValue(value) {
    const currentlySelectedOption =
      this.$element.options[this.$element.selectedIndex];
    if (currentlySelectedOption) currentlySelectedOption.selected = false;

    if (this.hasOption(value)) {
      this.removeUnknownOption();

      const hashedVal = hashKey(value);
      this.$element.value =
        hashedVal in this.selectValueMap ? hashedVal : value;
      const selectedOption = this.$element.options[this.$element.selectedIndex];
      if (!selectedOption) {
        this.selectUnknownOrEmptyOption(value);
      } else {
        selectedOption.selected = true;
      }
    } else {
      this.selectUnknownOrEmptyOption(value);
    }
  }

  /**
   * Register a new option with the controller.
   * @param {*} value
   * @param {HTMLOptionElement} element
   */
  addOption(value, element) {
    if (element.nodeType === Node.COMMENT_NODE) return;

    assertNotHasOwnProperty(value, '"option value"');
    if (value === "") {
      this.hasEmptyOption = true;
      this.emptyOption = element;
    }
    const count = this.optionsMap.get(value) || 0;
    this.optionsMap.set(value, count + 1);
    this.scheduleRender();
  }

  /**
   * Remove an option from the controller.
   * @param {*} value
   */
  removeOption(value) {
    const count = this.optionsMap.get(value);
    if (count) {
      if (count === 1) {
        this.optionsMap.delete(value);
        if (value === "") {
          this.hasEmptyOption = false;
          this.emptyOption = undefined;
        }
      } else {
        this.optionsMap.set(value, count - 1);
      }
    }
  }

  /**
   * Check if an option exists for the given value.
   * @param {*} value
   * @returns {boolean}
   */
  hasOption(value) {
    return !!this.optionsMap.get(value);
  }

  /**
   * @returns {boolean} Whether the select element currently has an empty option.
   */
  $hasEmptyOption() {
    return this.hasEmptyOption;
  }

  /**
   * @returns {boolean} Whether the unknown option is currently selected.
   */
  $isUnknownOptionSelected() {
    return this.$element.options[0] === this.unknownOption;
  }

  /**
   * @returns {boolean} Whether the empty option is selected.
   */
  $isEmptyOptionSelected() {
    return (
      this.hasEmptyOption &&
      this.$element.options[this.$element.selectedIndex] === this.emptyOption
    );
  }

  /**
   * Select unknown or empty option depending on the value.
   * @param {*} value
   */
  selectUnknownOrEmptyOption(value) {
    if (value == null && this.emptyOption) {
      this.removeUnknownOption();
      this.selectEmptyOption();
    } else if (this.unknownOption.parentElement) {
      this.updateUnknownOption(value);
    } else {
      this.renderUnknownOption(value);
    }
  }

  /**
   * Schedule a render at the end of the digest cycle.
   */
  scheduleRender() {
    if (this.renderScheduled) return;
    this.renderScheduled = true;
    this.$scope.$postUpdate(() => {
      this.renderScheduled = false;
      this.ngModelCtrl.$render();
    });
  }

  /**
   * Schedule a view value update at the end of the digest cycle.
   * @param {boolean} [renderAfter=false]
   */
  scheduleViewValueUpdate(renderAfter = false) {
    if (this.updateScheduled) return;

    this.updateScheduled = true;

    this.$scope.$postUpdate(() => {
      if (this.$scope.$$destroyed) return;

      this.updateScheduled = false;
      this.ngModelCtrl.$setViewValue(this.readValue());
      if (renderAfter) this.ngModelCtrl.$render();
    });
  }

  /**
   * Register an option with interpolation or dynamic value/text.
   * @param {any} optionScope
   * @param {HTMLOptionElement} optionElement
   * @param {any} optionAttrs
   * @param {Function} [interpolateValueFn]
   * @param {Function} [interpolateTextFn]
   */
  registerOption(
    optionScope,
    optionElement,
    optionAttrs,
    interpolateValueFn,
    interpolateTextFn,
  ) {
    let oldVal;
    let hashedVal;
    if (optionAttrs.$attr.ngValue) {
      optionAttrs.$observe("value", (newVal) => {
        let removal;
        const previouslySelected = optionElement.selected;

        if (isDefined(hashedVal)) {
          this.removeOption(oldVal);
          delete this.selectValueMap[hashedVal];
          removal = true;
        }

        hashedVal = hashKey(newVal);
        oldVal = newVal;
        this.selectValueMap[hashedVal] = newVal;
        this.addOption(newVal, optionElement);
        optionElement.setAttribute("value", hashedVal);

        if (removal && previouslySelected) {
          this.scheduleViewValueUpdate();
        }
      });
    } else if (interpolateValueFn) {
      optionAttrs.$observe("value", (newVal) => {
        this.readValue();
        let removal;
        const previouslySelected = optionElement.selected;

        if (isDefined(oldVal)) {
          this.removeOption(oldVal);
          removal = true;
        }
        oldVal = newVal;
        this.addOption(newVal, optionElement);

        if (removal && previouslySelected) {
          this.scheduleViewValueUpdate();
        }
      });
    } else if (interpolateTextFn) {
      optionScope.value = interpolateTextFn(optionScope);
      if (!optionAttrs["value"]) {
        optionAttrs.$set("value", optionScope.value);
        this.addOption(optionScope.value, optionElement);
      }

      let oldVal;
      optionScope.$watch("value", () => {
        let newVal = interpolateTextFn(optionScope);
        if (!optionAttrs["value"]) {
          optionAttrs.$set("value", newVal);
        }
        const previouslySelected = optionElement.selected;
        if (oldVal !== newVal) {
          this.removeOption(oldVal);
          oldVal = newVal;
        }
        this.addOption(newVal, optionElement);

        if (oldVal && previouslySelected) {
          this.scheduleViewValueUpdate();
        }
      });
    } else {
      this.addOption(optionAttrs.value, optionElement);
    }

    optionAttrs.$observe("disabled", (newVal) => {
      if (newVal === "true" || (newVal && optionElement.selected)) {
        if (this.multiple) {
          this.scheduleViewValueUpdate(true);
        } else {
          this.ngModelCtrl.$setViewValue(null);
          this.ngModelCtrl.$render();
        }
      }
    });

    optionElement.addEventListener("$destroy", () => {
      const currentValue = this.readValue();
      const removeValue = optionAttrs.value;

      this.removeOption(removeValue);
      this.scheduleRender();

      if (
        (this.multiple &&
          currentValue &&
          currentValue.indexOf(removeValue) !== -1) ||
        currentValue === removeValue
      ) {
        this.scheduleViewValueUpdate(true);
      }
    });
  }
}

/**
 * @returns {import('../../types.js').Directive}
 */
function selectDirective() {
  return {
    restrict: "E",
    require: ["select", "?ngModel"],
    controller: SelectController,
    priority: 1,
    link: {
      pre: selectPreLink,
      post: selectPostLink,
    },
  };

  function selectPreLink(_scope, element, attr, ctrls) {
    /** @type {SelectController} */
    const selectCtrl = ctrls[0];
    /** @type {import("../model/model.js").NgModelController} */
    const ngModelCtrl = ctrls[1];

    // if ngModel is not defined, we don't need to do anything but set the registerOption
    // function to noop, so options don't get added internally
    if (!ngModelCtrl) {
      selectCtrl.registerOption = () => {};
      return;
    }
    selectCtrl["ngModelCtrl"] = ngModelCtrl;

    // When the selected item(s) changes we delegate getting the value of the select control
    // to the `readValue` method, which can be changed if the select can have multiple
    // selected values or if the options are being generated by `ngOptions`
    element.addEventListener("change", () => {
      selectCtrl.removeUnknownOption();
      const viewValue = selectCtrl.readValue();
      ngModelCtrl.$setViewValue(viewValue);
    });

    // If the select allows multiple values then we need to modify how we read and write
    // values from and to the control; also what it means for the value to be empty and
    // we have to add an extra watch since ngModel doesn't work well with arrays - it
    // doesn't trigger rendering if only an item in the array changes.
    if (attr.multiple) {
      selectCtrl.multiple = true;

      // Read value now needs to check each option to see if it is selected
      selectCtrl.readValue = function () {
        const array = [];
        /**
         * @type {HTMLCollection}
         */
        const options = element.getElementsByTagName("option");
        Array.from(options).forEach(
          /**
           * @param {HTMLOptionElement} option
           */
          (option) => {
            if (option.selected && !option.disabled) {
              const val = option.value;
              array.push(
                val in selectCtrl.selectValueMap
                  ? selectCtrl.selectValueMap[val]
                  : val,
              );
            }
          },
        );
        return array;
      };

      // Write value now needs to set the selected property of each matching option
      selectCtrl.writeValue = function (value) {
        /**
         * @type {HTMLCollection}
         */
        const options = element.getElementsByTagName("option");
        Array.from(options).forEach(
          /**
           * @param {HTMLOptionElement} option
           */
          (option) => {
            const shouldBeSelected =
              !!value &&
              (includes(value, option.value) ||
                includes(value, selectCtrl.selectValueMap[option.value]));
            const currentlySelected = option.selected;

            // Support: IE 9-11 only, Edge 12-15+
            // In IE and Edge adding options to the selection via shift+click/UP/DOWN
            // will de-select already selected options if "selected" on those options was set
            // more than once (i.e. when the options were already selected)
            // So we only modify the selected property if necessary.
            // Note: this behavior cannot be replicated via unit tests because it only shows in the
            // actual user interface.
            if (shouldBeSelected !== currentlySelected) {
              option.selected = shouldBeSelected;
            }
          },
        );
      };

      // we have to do it on each watch since ngModel watches reference, but
      // we need to work of an array, so we need to see if anything was inserted/removed
      let lastView;
      let lastViewRef = NaN;
      if (
        lastViewRef === ngModelCtrl.$viewValue &&
        !equals$1(lastView, ngModelCtrl.$viewValue)
      ) {
        lastView = shallowCopy(ngModelCtrl.$viewValue);
        ngModelCtrl.$render();
      }
      lastViewRef = ngModelCtrl.$viewValue;

      // If we are a multiple select then value is now a collection
      // so the meaning of $isEmpty changes
      ngModelCtrl.$isEmpty = function (value) {
        return !value || value.length === 0;
      };
    }
  }

  function selectPostLink(_scope, _element, _attrs, ctrls) {
    // if ngModel is not defined, we don't need to do anything
    const ngModelCtrl = ctrls[1];
    if (!ngModelCtrl) return;

    const selectCtrl = ctrls[0];

    // We delegate rendering to the `writeValue` method, which can be changed
    // if the select can have multiple selected values or if the options are being
    // generated by `ngOptions`.
    // This must be done in the postLink fn to prevent $render to be called before
    // all nodes have been linked correctly.
    ngModelCtrl.$render = function () {
      selectCtrl.writeValue(ngModelCtrl.$viewValue);
    };
  }
}

// The option directive is purely designed to communicate the existence (or lack of)
// of dynamically created (and destroyed) option elements to their containing select
// directive via its controller.
/**
 * @returns {import('../../types.js').Directive}
 */
optionDirective.$inject = ["$interpolate"];
function optionDirective($interpolate) {
  return {
    restrict: "E",
    priority: 100,
    compile(element, attr) {
      let interpolateValueFn;
      let interpolateTextFn;

      if (isDefined(attr.ngValue)) ; else if (isDefined(attr.value)) {
        // If the value attribute is defined, check if it contains an interpolation
        interpolateValueFn = $interpolate(attr.value, true);
      } else {
        // If the value attribute is not defined then we fall back to the
        // text content of the option element, which may be interpolated
        interpolateTextFn = $interpolate(element.textContent, true);
        if (!interpolateTextFn) {
          attr.$set("value", element.textContent);
        }
      }

      return function (scope, element, attr) {
        // This is an optimization over using ^^ since we don't want to have to search
        // all the way to the root of the DOM for every single option element
        const selectCtrlName = "$selectController";
        const parent = element.parentElement;
        const selectCtrl =
          getCacheData(parent, selectCtrlName) ||
          getCacheData(parent.parentElement, selectCtrlName); // in case we are in optgroup

        if (selectCtrl) {
          selectCtrl.registerOption(
            scope,
            element,
            attr,
            interpolateValueFn,
            interpolateTextFn,
          );
        }
      };
    },
  };
}

/**
 * @returns {import('../../types.js').Directive}
 */
function ngBindDirective() {
  return {
    restrict: "EA",
    /**
     * @param {import('../../core/scope/scope.js').Scope} scope
     * @param {Element} element
     * @param {import('../../core/compile/attributes.js').Attributes} attr
     */
    link(scope, element, attr) {
      scope.$watch(attr["ngBind"], (value) => {
        element.textContent = stringify$1(isProxy(value) ? value.$target : value);
      });
    },
  };
}

/**
 * @returns {import('../../types.js').Directive}
 */
function ngBindTemplateDirective() {
  return {
    restrict: "EA",
    /**
     * @param {import('../../core/scope/scope.js').Scope} _scope
     * @param {Element} element
     * @param {import('../../core/compile/attributes.js').Attributes} attr
     */
    link(_scope, element, attr) {
      attr.$observe("ngBindTemplate", (value) => {
        element.textContent = isUndefined(value) ? "" : value;
      });
    },
  };
}

ngBindHtmlDirective.$inject = ["$parse"];
/**
 * @returns {import('../../types.js').Directive}
 */
function ngBindHtmlDirective($parse) {
  return {
    restrict: "A",
    compile(_tElement, tAttrs) {
      $parse(tAttrs.ngBindHtml); // checks for interpolation errors
      return (
        /**
         * @param {import('../../core/scope/scope.js').Scope} scope
         * @param {Element} element
         */
        (scope, element) => {
          scope.$watch(tAttrs.ngBindHtml, (val) => {
            if (isUndefined(val) || isNull(val)) {
              val = "";
            }
            element.innerHTML = val;
          });
        }
      );
    },
  };
}

/**
 * @returns {() => import("../../types.js").Directive}
 */
function classDirective(name, selector) {
  name = `ngClass${name}`;

  return function () {
    return {
      restrict: "EA",
      /**
       * @param {import("../../core/scope/scope.js").Scope} scope
       * @param {Element} element
       * @param {import("../../core/compile/attributes").Attributes} attr
       */
      link(scope, element, attr) {
        let classCounts = getCacheData(element, "$classCounts");
        let oldModulo = true;
        let oldClassString;

        if (!classCounts) {
          // Use Object.create(null) to prevent class assumptions involving property
          // names in Object.prototype
          classCounts = Object.create(null);
          setCacheData(element, "$classCounts", classCounts);
        }

        if (name !== "ngClass") {
          scope.$watch("$index", () => {
            ngClassIndexWatchAction(scope["$index"] & 1);
          });
        }
        scope.$watch(attr[name], (val) => {
          ngClassWatchAction(toClassString(val));
        });

        function addClasses(classString) {
          classString = digestClassCounts(split(classString), 1);
          if (hasAnimate(element)) {
            attr.$addClass(classString);
          } else {
            scope.$postUpdate(() => {
              if (classString !== "") {
                element.classList.add(...classString.trim().split(" "));
              }
            });
          }
        }

        function removeClasses(classString) {
          classString = digestClassCounts(split(classString), -1);
          if (hasAnimate(element)) {
            attr.$removeClass(classString);
          } else {
            scope.$postUpdate(() => {
              if (classString !== "") {
                element.classList.remove(...classString.trim().split(" "));
              }
            });
          }
        }

        function updateClasses(oldClassString, newClassString) {
          const oldClassArray = split(oldClassString);
          const newClassArray = split(newClassString);

          const toRemoveArray = arrayDifference(oldClassArray, newClassArray);
          const toAddArray = arrayDifference(newClassArray, oldClassArray);

          const toRemoveString = digestClassCounts(toRemoveArray, -1);
          const toAddString = digestClassCounts(toAddArray, 1);
          if (hasAnimate(element)) {
            attr.$addClass(toAddString);
            attr.$removeClass(toRemoveString);
          } else {
            if (toAddString !== "") {
              element.classList.add(...toAddString.trim().split(" "));
            }
            if (toRemoveString !== "") {
              element.classList.remove(...toRemoveString.trim().split(" "));
            }
          }
        }

        function digestClassCounts(classArray, count) {
          const classesToUpdate = [];
          if (classArray) {
            classArray.forEach((className) => {
              if (count > 0 || classCounts[className]) {
                classCounts[className] = (classCounts[className] || 0) + count;
                if (classCounts[className] === +(count > 0)) {
                  classesToUpdate.push(className);
                }
              }
            });
          }
          return classesToUpdate.join(" ");
        }

        function ngClassIndexWatchAction(newModulo) {
          // This watch-action should run before the `ngClassWatchAction()`, thus it
          // adds/removes `oldClassString`. If the `ngClass` expression has changed as well, the
          // `ngClassWatchAction()` will update the classes.
          if (newModulo === selector) {
            addClasses(oldClassString);
          } else {
            removeClasses(oldClassString);
          }

          oldModulo = newModulo;
        }

        function ngClassWatchAction(newClassString) {
          if (oldModulo === selector) {
            updateClasses(oldClassString, newClassString);
          }

          oldClassString = newClassString;
        }
      },
    };
  };
}

// Helpers
function arrayDifference(tokens1, tokens2) {
  if (!tokens1 || !tokens1.length) return [];
  if (!tokens2 || !tokens2.length) return tokens1;

  const values = [];

  outer: for (let i = 0; i < tokens1.length; i++) {
    const token = tokens1[i];
    for (let j = 0; j < tokens2.length; j++) {
      if (token === tokens2[j]) continue outer;
    }
    values.push(token);
  }

  return values;
}

function split(classString) {
  return classString && classString.split(" ");
}

function toClassString(classValue) {
  if (!classValue) return classValue;

  let classString = classValue;

  if (Array.isArray(classValue)) {
    classString = classValue.map(toClassString).join(" ");
  } else if (isObject(classValue)) {
    classString = Object.keys(classValue)
      .filter((key) => classValue[key])
      .join(" ");
  } else if (!isString(classValue)) {
    classString = `${classValue}`;
  }

  return classString;
}

const ngClassDirective = classDirective("", true);
const ngClassOddDirective = classDirective("Odd", 0);
const ngClassEvenDirective = classDirective("Even", 1);

/**
 * @returns {import('../../types.js').Directive}
 */
function ngCloakDirective() {
  return {
    restrict: "EA",
    compile(element, attr) {
      attr.$set("ngCloak", undefined);
      element.classList.remove("ng-cloak");
    },
  };
}

/**
 * @returns {import("../../types.js").Directive}
 */
function ngControllerDirective() {
  return {
    restrict: "A",
    scope: true,
    controller: "@",
    priority: 500,
  };
}

const NG_HIDE_CLASS = "ng-hide";
const NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";

ngShowDirective.$inject = ["$animate"];
/**
 * @returns {import('../../types.js').Directive}
 */
function ngShowDirective($animate) {
  return {
    restrict: "A",
    /**
     * @param scope
     * @param {Element} element
     * @param $attr
     */
    link(scope, element, $attr) {
      scope.$watch($attr["ngShow"], (value) => {
        // we're adding a temporary, animation-specific class for ng-hide since this way
        // we can control when the element is actually displayed on screen without having
        // to have a global/greedy CSS selector that breaks when other animations are run.
        // Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845
        if (hasAnimate(element)) {
          $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
            tempClasses: NG_HIDE_IN_PROGRESS_CLASS,
          });
        } else {
          if (value) {
            element.classList.remove(NG_HIDE_CLASS);
          } else {
            element.classList.add(NG_HIDE_CLASS);
          }
        }
      });
    },
  };
}

ngHideDirective.$inject = ["$animate"];
/**
 * @returns {import('../../types.js').Directive}
 */
function ngHideDirective($animate) {
  return {
    restrict: "A",
    link(scope, element, attr) {
      scope.$watch(attr["ngHide"], (value) => {
        // The comment inside of the ngShowDirective explains why we add and
        // remove a temporary class for the show/hide animation
        if (hasAnimate(element)) {
          $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
            tempClasses: NG_HIDE_IN_PROGRESS_CLASS,
          });
        } else {
          if (value) {
            element.classList.add(NG_HIDE_CLASS);
          } else {
            element.classList.remove(NG_HIDE_CLASS);
          }
        }
      });
    },
  };
}

ngIfDirective.$inject = ["$animate"];
/**
 *
 * TODO // Add type for animate service
 * @param {*}  $animate
 * @returns {import("../../types.js").Directive}
 */
function ngIfDirective($animate) {
  return {
    transclude: "element",
    priority: 600,
    terminal: true,
    restrict: "A",
    /**
     *
     * @param {import("../../core/scope/scope.js").Scope} $scope
     * @param {Element} $element
     * @param {import("../../core/compile/attributes.js").Attributes} $attr
     * @param {Object} _ctrl
     * @param {*} $transclude
     */
    link($scope, $element, $attr, _ctrl, $transclude) {
      /** @type {Element} */
      let block;

      /** @type {import('../../core/scope/scope.js').Scope} */
      let childScope;

      let previousElements;

      $scope.$watch($attr["ngIf"], (value) => {
        if (value) {
          if (!childScope) {
            $transclude((clone, newScope) => {
              childScope = newScope;
              // Note: We only need the first/last node of the cloned nodes.
              // However, we need to keep the reference to the dom wrapper as it might be changed later
              // by a directive with templateUrl when its template arrives.
              block = clone;
              if (hasAnimate(clone)) {
                $animate.enter(clone, $element.parentElement, $element);
              } else {
                $element.after(clone);
              }
            });
          }
        } else {
          if (previousElements) {
            removeElement(previousElements);
            previousElements = null;
          }
          if (childScope) {
            childScope.$destroy();
            childScope = null;
          }
          if (block) {
            previousElements = block;
            if (hasAnimate(previousElements)) {
              $animate.leave(previousElements).done((response) => {
                if (response !== false) previousElements = null;
              });
            } else {
              $element.nextElementSibling.remove();
            }
            block = null;
          }
        }
      });
    },
  };
}

ngIncludeDirective.$inject = ["$templateRequest", "$anchorScroll", "$animate"];

/**
 *
 * @param {*} $templateRequest
 * @param {import("../../services/anchor-scroll.js").AnchorScrollFunction} $anchorScroll
 * @param {*} $animate
 * @returns
 */
function ngIncludeDirective($templateRequest, $anchorScroll, $animate) {
  return {
    restrict: "EA",
    priority: 400,
    terminal: true,
    transclude: "element",
    controller: () => {},
    compile(_element, attr) {
      const srcExp = attr.ngInclude || attr.src;
      const onloadExp = attr.onload || "";
      const autoScrollExp = attr.autoscroll;

      return (scope, $element, _$attr, ctrl, $transclude) => {
        function maybeScroll() {
          if (
            isDefined(autoScrollExp) &&
            (!autoScrollExp || scope.$eval(autoScrollExp))
          ) {
            $anchorScroll();
          }
        }

        let changeCounter = 0;
        let currentScope;
        let previousElement;
        let currentElement;
        const cleanupLastIncludeContent = () => {
          if (previousElement) {
            previousElement.remove();
            previousElement = null;
          }
          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if (currentElement) {
            if (hasAnimate(currentElement)) {
              $animate.leave(currentElement).done((response) => {
                if (response !== false) previousElement = null;
              });
            } else {
              currentElement.remove();
            }

            previousElement = currentElement;
            currentElement = null;
          }
        };

        scope.$watch(srcExp, async (src) => {
          const afterAnimation = function (response) {
            response !== false && maybeScroll();
          };

          const thisChangeId = ++changeCounter;
          if (src) {
            // set the 2nd param to true to ignore the template request error so that the inner
            // contents and scope can be cleaned up.
            await $templateRequest(src, true).then(
              (response) => {
                if (scope.$$destroyed) return;
                if (thisChangeId !== changeCounter) return;
                const newScope = scope.$new();
                ctrl.template = response;

                // Note: This will also link all children of ng-include that were contained in the original
                // html. If that content contains controllers, ... they could pollute/change the scope.
                // However, using ng-include on an element with additional content does not make sense...
                // Note: We can't remove them in the cloneAttchFn of $transclude as that
                // function is called before linking the content, which would apply child
                // directives to non existing elements.
                const clone = $transclude(newScope, (clone) => {
                  cleanupLastIncludeContent();
                  if (hasAnimate(clone)) {
                    $animate.enter(clone, null, $element).done(afterAnimation);
                  } else {
                    $element.after(clone);
                    maybeScroll();
                  }
                });

                currentScope = newScope;
                currentElement = clone;
                currentScope.$emit("$includeContentLoaded", src);
                scope.$eval(onloadExp);
              },
              () => {
                if (scope.$$destroyed) return;

                if (thisChangeId === changeCounter) {
                  cleanupLastIncludeContent();
                  scope.$emit("$includeContentError", src);
                }
              },
            );
            scope.$emit("$includeContentRequested", src);
          } else {
            cleanupLastIncludeContent();
            ctrl.template = null;
          }
        });
      };
    },
  };
}

// This directive is called during the $transclude call of the first `ngInclude` directive.
// It will replace and compile the content of the element with the loaded template.
// We need this directive so that the element content is already filled when
// the link function of another directive on the same element as ngInclude
// is called.
ngIncludeFillContentDirective.$inject = ["$compile"];

/**
 * @param {import("../../core/compile/compile.js").CompileFn} $compile
 * @returns {import("../../types.js").Directive}
 */
function ngIncludeFillContentDirective($compile) {
  return {
    restrict: "EA",
    priority: -400,
    require: "ngInclude",
    link(scope, $element, _$attr, ctrl) {
      $element.innerHTML = ctrl["template"];
      $compile($element.childNodes)(scope);
    },
  };
}

/**
 * @returns {import('../../types.js').Directive}
 */
function ngInitDirective() {
  return {
    priority: 450,
    compile() {
      return {
        pre(scope, element, attrs) {
          const controller = getController(element);
          if (controller) {
            controller.$eval(attrs["ngInit"]);
          } else {
            scope.$eval(attrs["ngInit"]);
          }
        },
      };
    },
  };
}

/**
 * @returns {import('../../types.js').Directive}
 */
function ngNonBindableDirective() {
  return {
    restrict: "EA",
    terminal: true,
    priority: 1000,
  };
}

/**
 * The `ngRef` attribute tells AngularJS to assign the controller of a component (or a directive)
 * to the given property in the current scope.
 *
 * If the element with `ngRef` is destroyed `null` is assigned to the property.
 *
 * Note that if you want to assign from a child into the parent scope, you must initialize the
 * target property on the parent scope, otherwise `ngRef` will assign on the child scope.
 * This commonly happens when assigning elements or components wrapped in {@link ngIf} or
 * {@link ngRepeat}. See the second example below.
 *
 *
 * @element ANY
 * @param {string} ngRef property name - A valid AngularJS expression identifier to which the
 *                       controller or dom-wrapped DOM element will be bound.
 * @param {string=} ngRefRead read value - The name of a directive (or component) on this element,
 *                            or the special string `$element`. If a name is provided, `ngRef` will
 *                            assign the matching controller. If `$element` is provided, the element
 *                            itself is assigned (even if a controller is available).
 */

const ngRefMinErr = minErr("ngRef");
ngRefDirective.$inject = ["$parse"];
function ngRefDirective($parse) {
  return {
    priority: -1, // Needed for compatibility with element transclusion on the same element
    restrict: "A",
    compile(tElement, tAttrs) {
      // Get the expected controller name, converts <data-some-thing> into "someThing"
      const controllerName = directiveNormalize(getNodeName(tElement));

      // Get the expression for value binding
      const getter = $parse(tAttrs.ngRef);
      const setter =
        getter.assign ||
        function () {
          throw ngRefMinErr(
            "nonassign",
            'Expression in ngRef="{0}" is non-assignable!',
            tAttrs.ngRef,
          );
        };

      return (scope, element, attrs) => {
        let refValue;

        if (Object.prototype.hasOwnProperty.call(attrs, "ngRefRead")) {
          if (attrs.ngRefRead === "$element") {
            refValue = element;
          } else {
            refValue = getCacheData(element, `$${attrs.ngRefRead}Controller`);

            if (!refValue) {
              throw ngRefMinErr(
                "noctrl",
                'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"',
                attrs.ngRefRead,
                tAttrs.ngRef,
              );
            }
          }
        } else {
          refValue = getCacheData(element, `$${controllerName}Controller`);
        }

        refValue = refValue || element;

        setter(scope, refValue);

        // when the element is removed, remove it (nullify it)
        element.addEventListener("$destroy", () => {
          // only remove it if value has not changed,
          // because animations (and other procedures) may duplicate elements
          if (getter(scope) === refValue) {
            setter(scope, null);
          }
        });
      };
    },
  };
}

const NG_REMOVED = "$$NG_REMOVED";
const ngRepeatMinErr = minErr("ngRepeat");

/**
 * Regular expression to match either:
 * 1. A single variable name (optionally preceded by whitespace), e.g. "foo", "   $bar"
 * 2. A pair of variable names inside parentheses separated by a comma (with optional whitespace), e.g. "(x, y)", "($foo, _bar123)"
 *
 * Capturing groups:
 * - Group 1: The single variable name (if present)
 * - Group 2: The first variable in the tuple (if present)
 * - Group 3: The second variable in the tuple (if present)
 *
 * Examples:
 *  - Matches: "foo", "   $var", "(x, y)", "($a, $b)"
 *  - Does NOT match: "x,y", "(x)", "(x y)", ""
 *
 * @constant {RegExp}
 */
const VAR_OR_TUPLE_REGEX =
  /^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/;

ngRepeatDirective.$inject = ["$animate"];

/**
 * TODO // Add type for animate service
 * @param {*}  $animate
 * @returns {import("../../types.js").Directive}
 */
function ngRepeatDirective($animate) {
  function updateScope(
    scope,
    index,
    valueIdentifier,
    value,
    keyIdentifier,
    key,
    arrayLength,
  ) {
    // TODO(perf): generate setters to shave off ~40ms or 1-1.5%
    if (scope[valueIdentifier] !== value) {
      scope[valueIdentifier] = value;
    }

    if (keyIdentifier) scope[keyIdentifier] = key;
    if (value) {
      scope.$target.$$hashKey = value.$$hashKey;
    }
    scope.$index = index;
    scope.$first = index === 0;
    scope.$last = index === arrayLength - 1;
    scope.$middle = !(scope.$first || scope.$last);
    scope.$odd = !(scope.$even = (index & 1) === 0);
  }

  function getBlockStart(block) {
    return block.clone;
  }

  function getBlockEnd(block) {
    return block.clone;
  }

  function trackByIdArrayFn(_$scope, _key, value) {
    return hashKey(value);
  }

  function trackByIdObjFn(_$scope, key) {
    return key;
  }

  return {
    restrict: "A",
    transclude: "element",
    priority: 1000,
    terminal: true,
    compile: (_$element, $attr) => {
      const expression = $attr.ngRepeat;
      const hasAnimate = !!$attr.animate;

      let match = expression.match(
        /^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/,
      );

      if (!match) {
        throw ngRepeatMinErr(
          "iexp",
          "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
          expression,
        );
      }

      const lhs = match[1];
      const rhs = match[2];
      const aliasAs = match[3];

      match = lhs.match(VAR_OR_TUPLE_REGEX);

      if (!match) {
        throw ngRepeatMinErr(
          "iidexp",
          "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
          lhs,
        );
      }
      const valueIdentifier = match[3] || match[1];
      const keyIdentifier = match[2];

      if (
        aliasAs &&
        (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||
          /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(
            aliasAs,
          ))
      ) {
        throw ngRepeatMinErr(
          "badident",
          "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
          aliasAs,
        );
      }

      return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
        // Store a list of elements from previous run. This is a hash where key is the item from the
        // iterator, and the value is objects with following properties.
        //   - scope: bound scope
        //   - clone: previous element.
        //   - index: position
        //
        // We are using no-proto object so that we don't need to guard against inherited props via
        // hasOwnProperty.
        let lastBlockMap = Object.create(null);
        // watch props
        $scope.$watch(rhs, (collection) => {
          var index,
            length,
            previousNode = $element, // node that cloned nodes should be inserted after
            // initialized to the comment node anchor
            nextNode,
            // Same as lastBlockMap but it has the current state. It will become the
            // lastBlockMap on the next iteration.
            nextBlockMap = Object.create(null),
            collectionLength,
            key,
            value, // key/value of iteration
            trackById,
            trackByIdFn,
            collectionKeys,
            block, // last object information {scope, element, id}
            nextBlockOrder,
            elementsToRemove;

          if (aliasAs) {
            $scope[aliasAs] = collection;
          }

          if (isArrayLike(collection)) {
            collectionKeys = collection;
            trackByIdFn = trackByIdArrayFn;
          } else {
            trackByIdFn = trackByIdObjFn;
            // if object, extract keys, in enumeration order, unsorted
            collectionKeys = [];
            for (const itemKey in collection) {
              if (
                Object.hasOwnProperty.call(collection, itemKey) &&
                itemKey.charAt(0) !== "$"
              ) {
                collectionKeys.push(itemKey);
              }
            }
          }

          collectionLength = collectionKeys.length;
          nextBlockOrder = new Array(collectionLength);

          // locate existing items
          for (index = 0; index < collectionLength; index++) {
            key = collection === collectionKeys ? index : collectionKeys[index];
            value = collection[key];
            trackById = trackByIdFn($scope, key, value, index);
            if (lastBlockMap[trackById]) {
              // found previously seen block
              block = lastBlockMap[trackById];
              delete lastBlockMap[trackById];
              nextBlockMap[trackById] = block;
              nextBlockOrder[index] = block;
            } else if (nextBlockMap[trackById]) {
              // if collision detected. restore lastBlockMap and throw an error
              Object.values(nextBlockOrder).forEach((block) => {
                if (block && block.scope) lastBlockMap[block.id] = block;
              });
              throw ngRepeatMinErr(
                "dupes",
                "Duplicates keys in a repeater are not allowed. Repeater: {0}, Duplicate key: {1} for value: {2}",
                expression,
                trackById,
                value,
              );
            } else {
              // new never before seen block
              nextBlockOrder[index] = {
                id: trackById,
                scope: undefined,
                clone: undefined,
              };
              nextBlockMap[trackById] = true;
            }
          }

          // remove leftover items
          for (var blockKey in lastBlockMap) {
            block = lastBlockMap[blockKey];
            elementsToRemove = block.clone;
            if (hasAnimate) {
              $animate.leave(elementsToRemove);
            } else {
              elementsToRemove.remove();
            }
            if (elementsToRemove.parentNode) {
              // if the element was not removed yet because of pending animation, mark it as deleted
              // so that we can ignore it later
              for (
                index = 0, length = elementsToRemove.length;
                index < length;
                index++
              ) {
                elementsToRemove[index][NG_REMOVED] = true;
              }
            }
            block.scope.$destroy();
          }

          for (index = 0; index < collectionLength; index++) {
            key = collection === collectionKeys ? index : collectionKeys[index];
            value = collection[key];
            block = nextBlockOrder[index];

            if (block.scope) {
              // if we have already seen this object, then we need to reuse the
              // associated scope/element

              nextNode = previousNode;

              // skip nodes that are already pending removal via leave animation
              do {
                nextNode = nextNode.nextSibling;
              } while (nextNode && nextNode[NG_REMOVED]);

              if (getBlockStart(block) !== nextNode) {
                // existing item which got moved
                $animate.move(getBlockNodes(block.clone), null, previousNode);
              }
              previousNode = getBlockEnd(block);
              updateScope(
                block.scope,
                index,
                valueIdentifier,
                value,
                keyIdentifier,
                key,
                collectionLength,
              );
            } else {
              // new item which we don't know about
              $transclude(
                /**
                 * Clone attach function
                 * @param {Array<NodeList>} clone
                 * @param {import("../../core/scope/scope.js").Scope} scope
                 */

                (clone, scope) => {
                  block.scope = scope;
                  const endNode = clone;
                  if (hasAnimate) {
                    $animate.enter(clone, null, previousNode);
                  } else {
                    previousNode.after(clone);
                  }

                  previousNode = endNode;
                  // Note: We only need the first/last node of the cloned nodes.
                  // However, we need to keep the reference to the dom wrapper as it might be changed later
                  // by a directive with templateUrl when its template arrives.
                  block.clone = clone;
                  nextBlockMap[block.id] = block;
                  updateScope(
                    block.scope,
                    index,
                    valueIdentifier,
                    value,
                    keyIdentifier,
                    key,
                    collectionLength,
                  );
                },
              );
            }
          }
          lastBlockMap = nextBlockMap;
        });
      };
    },
  };
}

/**
 * @returns {import('../../types.js').Directive}
 */
function ngStyleDirective() {
  return {
    restrict: "A",
    link: (scope, element, attr) => {
      let oldStyles;
      scope.$watch(attr.ngStyle, (newStyles) => {
        if (oldStyles) {
          const oldKeys = Object.keys(oldStyles);
          for (let i = 0, length = oldKeys.length; i < length; i++) {
            element.style.removeProperty(oldKeys[i]);
          }
        }
        if (newStyles) {
          oldStyles = { ...newStyles.$target };
          const newEntries = Object.entries(newStyles);
          for (let i = 0, length = newEntries.length; i < length; i++) {
            const [key, value] = newEntries[i];
            element.style.setProperty(key, value);
          }
        }
      });
    },
  };
}

ngSwitchDirective.$inject = ["$animate"];

/**
 * @returns {import('../../types.js').Directive}
 */
function ngSwitchDirective($animate) {
  return {
    require: "ngSwitch",

    // asks for $scope to fool the BC controller module
    controller: [
      "$scope",
      class {
        constructor() {
          this.cases = {};
        }
      },
    ],
    link(scope, _element, attr, ngSwitchController) {
      const watchExpr = attr.ngSwitch || attr.on;
      let selectedTranscludes = [];
      const selectedElements = [];
      const previousLeaveAnimations = [];
      const selectedScopes = [];

      const spliceFactory = function (array, index) {
        return function (response) {
          if (response !== false) array.splice(index, 1);
        };
      };

      scope.$watch(watchExpr, (value) => {
        let i;
        let ii;

        // Start with the last, in case the array is modified during the loop
        while (previousLeaveAnimations.length) {
          $animate.cancel(previousLeaveAnimations.pop());
        }

        for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
          const selected = getBlockNodes(selectedElements[i].clone);
          selectedScopes[i].$destroy();

          if (hasAnimate(selected)) {
            const runner = (previousLeaveAnimations[i] =
              $animate.leave(selected));
            runner.done(spliceFactory(previousLeaveAnimations, i));
          } else {
            selected.remove();
          }
        }

        selectedElements.length = 0;
        selectedScopes.length = 0;

        if (
          (selectedTranscludes =
            ngSwitchController["cases"][`!${value}`] ||
            ngSwitchController["cases"]["?"])
        ) {
          Object.values(selectedTranscludes).forEach((selectedTransclude) => {
            selectedTransclude.transclude((caseElement, selectedScope) => {
              selectedScopes.push(selectedScope);
              const anchor = selectedTransclude.element;
              // TODO removing this breaks repeater test
              const block = {
                clone: caseElement,
                comment: document.createComment(""),
              };
              selectedElements.push(block);
              if (hasAnimate(caseElement)) {
                $animate.enter(caseElement, anchor.parentElement, anchor);
              } else {
                domInsert(caseElement, anchor.parentElement, anchor);
              }
            });
          });
        }
      });
    },
  };
}

/**
 * @returns {import('../../types.js').Directive}
 */
function ngSwitchWhenDirective() {
  return {
    transclude: "element",
    terminal: true,
    priority: 1200,
    restrict: "EA",
    require: "^ngSwitch",
    link(scope, element, attrs, ctrl, $transclude) {
      const cases = attrs.ngSwitchWhen
        .split(attrs.ngSwitchWhenSeparator)
        .sort()
        .filter(
          // Filter duplicate cases
          (element, index, array) => array[index - 1] !== element,
        );

      cases.forEach((whenCase) => {
        ctrl["cases"][`!${whenCase}`] = ctrl["cases"][`!${whenCase}`] || [];
        ctrl["cases"][`!${whenCase}`].push({
          transclude: $transclude,
          element,
        });
      });
    },
  };
}

/**
 * @returns {import('../../types.js').Directive}
 */
function ngSwitchDefaultDirective() {
  return {
    restrict: "EA",
    transclude: "element",
    terminal: true,
    priority: 1200,
    require: "^ngSwitch",
    link(_scope, element, _attr, ctrl, $transclude) {
      ctrl["cases"]["?"] = ctrl["cases"]["?"] || [];
      ctrl["cases"]["?"].push({ transclude: $transclude, element });
    },
  };
}

const ngOptionsMinErr = minErr("ngOptions");

const NG_OPTIONS_REGEXP =
  /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
// 1: value expression (valueFn)
// 2: label expression (displayFn)
// 3: group by expression (groupByFn)
// 4: disable when expression (disableWhenFn)
// 5: array item variable name
// 6: object item key variable name
// 7: object item value variable name
// 8: collection expression
// 9: track by expression

const ngOptionsDirective = [
  "$compile",
  "$parse",
  /**
   *
   * @param {import("../../core/compile/compile.js").CompileFn} $compile
   * @param {import("../../core/parse/parse.js").ParseService} $parse
   * @returns
   */
  function ($compile, $parse) {
    function parseOptionsExpression(optionsExp, selectElement, scope) {
      const match = optionsExp.match(NG_OPTIONS_REGEXP);
      if (!match) {
        throw ngOptionsMinErr(
          "iexp",
          "Expected expression in form of " +
            "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
            " but got '{0}'. Element: {1}",
          optionsExp,
          startingTag(selectElement[0]),
        );
      }

      // Extract the parts from the ngOptions expression

      // The variable name for the value of the item in the collection
      const valueName = match[5] || match[7];
      // The variable name for the key of the item in the collection
      const keyName = match[6];

      // An expression that generates the viewValue for an option if there is a label expression
      const selectAs = / as /.test(match[0]) && match[1];
      // An expression that is used to track the id of each object in the options collection
      const trackBy = match[9];
      // An expression that generates the viewValue for an option if there is no label expression
      const valueFn = $parse(match[2] ? match[1] : valueName);
      const selectAsFn = selectAs && $parse(selectAs);
      const viewValueFn = selectAsFn || valueFn;
      const trackByFn = trackBy && $parse(trackBy);

      // Get the value by which we are going to track the option
      // if we have a trackFn then use that (passing scope and locals)
      // otherwise just hash the given viewValue
      const getTrackByValueFn = trackBy
        ? function (value, locals) {
            return trackByFn(scope, locals);
          }
        : function getHashOfValue(value) {
            return hashKey(value);
          };
      const getTrackByValue = function (value, key) {
        return getTrackByValueFn(value, getLocals(value, key));
      };

      const displayFn = $parse(match[2] || match[1]);
      const groupByFn = $parse(match[3] || "");
      const disableWhenFn = $parse(match[4] || "");
      const valuesFn = $parse(match[8]);

      const locals = {};
      let getLocals = keyName
        ? function (value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          }
        : function (value) {
            locals[valueName] = value;
            return locals;
          };

      function Option(selectValue, viewValue, label, group, disabled) {
        this.selectValue = selectValue;
        this.viewValue = viewValue;
        this.label = label;
        this.group = group;
        this.disabled = disabled;
      }

      function getOptionValuesKeys(optionValues) {
        let optionValuesKeys;

        if (!keyName && isArrayLike(optionValues)) {
          optionValuesKeys = optionValues;
        } else {
          // if object, extract keys, in enumeration order, unsorted
          optionValuesKeys = [];
          for (const itemKey in optionValues) {
            if (
              Object.prototype.hasOwnProperty.call(optionValues, itemKey) &&
              itemKey.charAt(0) !== "$"
            ) {
              optionValuesKeys.push(itemKey);
            }
          }
        }
        return optionValuesKeys;
      }

      return {
        trackBy,
        getTrackByValue,
        getWatchables: $parse(valuesFn, (optionValues) => {
          // Create a collection of things that we would like to watch (watchedArray)
          // so that they can all be watched using a single $watchCollection
          // that only runs the handler once if anything changes
          const watchedArray = [];
          optionValues = optionValues || [];

          const optionValuesKeys = getOptionValuesKeys(optionValues);
          const optionValuesLength = optionValuesKeys.length;
          for (let index = 0; index < optionValuesLength; index++) {
            const key =
              optionValues === optionValuesKeys
                ? index
                : optionValuesKeys[index];
            const value = optionValues[key];

            const locals = getLocals(value, key);
            const selectValue = getTrackByValueFn(value, locals);
            watchedArray.push(selectValue);

            // Only need to watch the displayFn if there is a specific label expression
            if (match[2] || match[1]) {
              const label = displayFn(scope, locals);
              watchedArray.push(label);
            }

            // Only need to watch the disableWhenFn if there is a specific disable expression
            if (match[4]) {
              const disableWhen = disableWhenFn(scope, locals);
              watchedArray.push(disableWhen);
            }
          }
          return watchedArray;
        }),

        getOptions() {
          const optionItems = [];
          const selectValueMap = {};

          // The option values were already computed in the `getWatchables` fn,
          // which must have been called to trigger `getOptions`
          const optionValues = valuesFn(scope) || [];
          const optionValuesKeys = getOptionValuesKeys(optionValues);
          const optionValuesLength = optionValuesKeys.length;

          for (let index = 0; index < optionValuesLength; index++) {
            const key =
              optionValues === optionValuesKeys
                ? index
                : optionValuesKeys[index];
            const value = optionValues[key];
            const locals = getLocals(value, key);
            const viewValue = viewValueFn(scope, locals);
            const selectValue = getTrackByValueFn(viewValue, locals);
            const label = displayFn(scope, locals);
            const group = groupByFn(scope, locals);
            const disabled = disableWhenFn(scope, locals);
            const optionItem = new Option(
              selectValue,
              viewValue,
              label,
              group,
              disabled,
            );

            optionItems.push(optionItem);
            selectValueMap[selectValue] = optionItem;
          }

          return {
            items: optionItems,
            selectValueMap,
            getOptionFromViewValue(value) {
              return selectValueMap[getTrackByValue(value)];
            },
            getViewValueFromOption(option) {
              // If the viewValue could be an object that may be mutated by the application,
              // we need to make a copy and not return the reference to the value on the option.
              return trackBy
                ? structuredClone(option.viewValue)
                : option.viewValue;
            },
          };
        },
      };
    }

    // Support: IE 9 only
    // We can't just ('<option>') since JQLite is not smart enough
    // to create it in <select> and IE barfs otherwise.
    const optionTemplate = document.createElement("option");
    const optGroupTemplate = document.createElement("optgroup");

    /**
     *
     * @param {import("../../core/scope/scope.js").Scope} scope
     * @param {HTMLSelectElement} selectElement
     * @param {*} attr
     * @param {*} ctrls
     */
    function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
      const selectCtrl = ctrls[0];
      const ngModelCtrl = ctrls[1];
      const { multiple } = attr;

      // The emptyOption allows the application developer to provide their own custom "empty"
      // option when the viewValue does not match any of the option values.
      for (
        let i = 0, children = selectElement.childNodes, ii = children.length;
        i < ii;
        i++
      ) {
        if (/** @type {HTMLOptionElement} */ (children[i]).value === "") {
          selectCtrl.hasEmptyOption = true;
          selectCtrl.emptyOption = children[i];
          break;
        }
      }

      // The empty option will be compiled and rendered before we first generate the options
      emptyElement(selectElement);

      const providedEmptyOption = !!selectCtrl.emptyOption;

      const unknownOption = optionTemplate.cloneNode(false);
      // TODO double check
      unknownOption.nodeValue = "?";

      let options;
      const ngOptions = parseOptionsExpression(
        attr.ngOptions,
        selectElement,
        scope,
      );
      // This stores the newly created options before they are appended to the select.
      // Since the contents are removed from the fragment when it is appended,
      // we only need to create it once.
      const listFragment = document.createDocumentFragment();

      // Overwrite the implementation. ngOptions doesn't use hashes
      selectCtrl.generateUnknownOptionValue = () => "?";

      // Update the controller methods for multiple selectable options
      if (!multiple) {
        selectCtrl.writeValue = function writeNgOptionsValue(value) {
          // The options might not be defined yet when ngModel tries to render
          if (!options) return;

          const selectedOption =
            selectElement.options[selectElement.selectedIndex];
          const option = options.getOptionFromViewValue(value);

          // Make sure to remove the selected attribute from the previously selected option
          // Otherwise, screen readers might get confused
          if (selectedOption) selectedOption.removeAttribute("selected");

          if (option) {
            // Don't update the option when it is already selected.
            // For example, the browser will select the first option by default. In that case,
            // most properties are set automatically - except the `selected` attribute, which we
            // set always

            if (selectElement.value !== option.selectValue) {
              selectCtrl.removeUnknownOption();

              selectElement.value = option.selectValue;
              option.element.selected = true;
            }

            option.element.setAttribute("selected", "selected");
          } else {
            selectCtrl.selectUnknownOrEmptyOption(value);
          }
        };

        selectCtrl.readValue = function readNgOptionsValue() {
          const selectedOption = options.selectValueMap[selectElement.value];

          if (selectedOption && !selectedOption.disabled) {
            selectCtrl.unselectEmptyOption();
            selectCtrl.removeUnknownOption();
            return options.getViewValueFromOption(selectedOption);
          }
          return null;
        };

        // If we are using `track by` then we must watch the tracked value on the model
        // since ngModel only watches for object identity change
        // FIXME: When a user selects an option, this watch will fire needlessly
        // if (ngOptions.trackBy) {
        //   scope.$watch(
        //     () => ngOptions.getTrackByValue(ngModelCtrl.$viewValue),
        //     () => {
        //       ngModelCtrl.$render();
        //     },
        //   );
        // }
      } else {
        selectCtrl.writeValue = function writeNgOptionsMultiple(values) {
          // The options might not be defined yet when ngModel tries to render
          if (!options) return;

          // Only set `<option>.selected` if necessary, in order to prevent some browsers from
          // scrolling to `<option>` elements that are outside the `<select>` element's viewport.
          const selectedOptions =
            (values && values.map(getAndUpdateSelectedOption)) || [];

          options.items.forEach((option) => {
            if (option.element.selected && !includes(selectedOptions, option)) {
              option.element.selected = false;
            }
          });
        };

        selectCtrl.readValue = function readNgOptionsMultiple() {
          const selectedValues = selectElement.value || [];
          const selections = [];
          selectedValues.forEach((value) => {
            const option = options.selectValueMap[value];
            if (option && !option.disabled)
              selections.push(options.getViewValueFromOption(option));
          });

          return selections;
        };

        // If we are using `track by` then we must watch these tracked values on the model
        // since ngModel only watches for object identity change
        if (ngOptions.trackBy) {
          scope.$watchCollection(
            () => {
              if (Array.isArray(ngModelCtrl.$viewValue)) {
                return ngModelCtrl.$viewValue.map((value) =>
                  ngOptions.getTrackByValue(value),
                );
              }
            },
            () => {
              ngModelCtrl.$render();
            },
          );
        }
      }

      if (providedEmptyOption) {
        // compile the element since there might be bindings in it
        const linkFn = $compile(selectCtrl.emptyOption);
        assertArg$1(linkFn, "LinkFn required");
        linkFn(scope);

        selectElement.prepend(selectCtrl.emptyOption);

        if (selectCtrl.emptyOption[0].nodeType === Node.COMMENT_NODE) {
          // This means the empty option has currently no actual DOM node, probably because
          // it has been modified by a transclusion directive.
          selectCtrl.hasEmptyOption = false;

          // Redefine the registerOption function, which will catch
          // options that are added by ngIf etc. (rendering of the node is async because of
          // lazy transclusion)
          selectCtrl.registerOption = function (optionScope, optionEl) {
            if (optionEl.value === "") {
              selectCtrl.hasEmptyOption = true;
              selectCtrl.emptyOption = optionEl;
              // This ensures the new empty option is selected if previously no option was selected
              ngModelCtrl.$render();

              optionEl.addEventListener("$destroy", () => {
                const needsRerender = selectCtrl.$isEmptyOptionSelected();

                selectCtrl.hasEmptyOption = false;
                selectCtrl.emptyOption = undefined;

                if (needsRerender) ngModelCtrl.$render();
              });
            }
          };
        }
      }

      // We will re-render the option elements if the option values or labels change
      scope.$watchCollection(ngOptions.getWatchables, updateOptions);

      // ------------------------------------------------------------------ //

      function addOptionElement(option, parent) {
        const optionElement = optionTemplate.cloneNode(false);
        parent.appendChild(optionElement);
        updateOptionElement(option, optionElement);
      }

      function getAndUpdateSelectedOption(viewValue) {
        const option = options.getOptionFromViewValue(viewValue);
        const element = option && option.element;

        if (element && !element.selected) element.selected = true;

        return option;
      }

      function updateOptionElement(option, element) {
        option.element = element;
        element.disabled = option.disabled;
        // Support: IE 11 only, Edge 12-13 only
        // NOTE: The label must be set before the value, otherwise IE 11 & Edge create unresponsive
        // selects in certain circumstances when multiple selects are next to each other and display
        // the option list in listbox style, i.e. the select is [multiple], or specifies a [size].
        // See https://github.com/angular/angular.js/issues/11314 for more info.
        // This is unfortunately untestable with unit / e2e tests
        if (option.label !== element.label) {
          element.label = option.label;
          element.textContent = option.label;
        }
        element.value = option.selectValue;
      }

      function updateOptions() {
        const previousValue = options && selectCtrl.readValue();

        // We must remove all current options, but cannot simply set innerHTML = null
        // since the providedEmptyOption might have an ngIf on it that inserts comments which we
        // must preserve.
        // Instead, iterate over the current option elements and remove them or their optgroup
        // parents
        if (options) {
          for (let i = options.items.length - 1; i >= 0; i--) {
            const option = options.items[i];
            if (isDefined(option.group)) {
              removeElement(option.element.parentNode);
            } else {
              removeElement(option.element);
            }
          }
        }

        options = ngOptions.getOptions();

        const groupElementMap = {};

        options.items.forEach((option) => {
          let groupElement;

          if (isDefined(option.group)) {
            // This option is to live in a group
            // See if we have already created this group
            groupElement = groupElementMap[option.group];

            if (!groupElement) {
              groupElement = optGroupTemplate.cloneNode(false);
              listFragment.appendChild(groupElement);

              // Update the label on the group element
              // "null" is special cased because of Safari
              /** @type {HTMLOptGroupElement} */
              (groupElement).label =
                option.group === null ? "null" : option.group;

              // Store it for use later
              groupElementMap[option.group] = groupElement;
            }

            addOptionElement(option, groupElement);
          } else {
            // This option is not in a group
            addOptionElement(option, listFragment);
          }
        });

        selectElement.appendChild(listFragment);

        ngModelCtrl.$render();

        // Check to see if the value has changed due to the update to the options
        if (!ngModelCtrl.$isEmpty(previousValue)) {
          const nextValue = selectCtrl.readValue();
          const isNotPrimitive = ngOptions.trackBy || multiple;
          if (
            isNotPrimitive
              ? !equals$1(previousValue, nextValue)
              : previousValue !== nextValue
          ) {
            ngModelCtrl.$setViewValue(nextValue);
            ngModelCtrl.$render();
          }
        }
      }
    }

    return {
      restrict: "A",
      terminal: true,
      require: ["select", "ngModel"],
      link: {
        pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
          // Deactivate the SelectController.register method to prevent
          // option directives from accidentally registering themselves
          // (and unwanted $destroy handlers etc.)
          ctrls[0].registerOption = () => {};
        },
        post: ngOptionsPostLink,
      },
    };
  },
];

/**
 * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.
 *
 * You can specify that you want to insert a named transclusion slot, instead of the default slot, by providing the slot name
 * as the value of the `ng-transclude` or `ng-transclude-slot` attribute.
 *
 * If the transcluded content is not empty (i.e. contains one or more DOM nodes, including whitespace text nodes), any existing
 * content of this element will be removed before the transcluded content is inserted.
 * If the transcluded content is empty (or only whitespace), the existing content is left intact. This lets you provide fallback
 * content in the case that no transcluded content is provided.
 *
 * @element ANY
 *
 * @param {string} ngTransclude|ngTranscludeSlot the name of the slot to insert at this point. If this is not provided, is empty
 *                                               or its value is the same as the name of the attribute then the default slot is used.
 */
const ngTranscludeMinErr = minErr("ngTransclude");
const ngTranscludeDirective = [
  "$compile",
  /**
   *
   * @param {import("../../core/compile/compile.js").CompileFn} $compile
   * @returns {import("../../types").Directive}
   */
  function ($compile) {
    return {
      restrict: "EA",
      compile: function ngTranscludeCompile(tElement) {
        // Remove and cache any original content to act as a fallback
        const fallbackLinkFn = $compile(tElement.childNodes);
        emptyElement(tElement);

        /**
         *
         * @param {import("../../core/scope/scope.js").Scope} $scope
         * @param {Element} $element
         * @param {import("../../core/compile/attributes.js").Attributes} $attrs
         * @param {*} _controller
         * @param {*} $transclude
         */
        function ngTranscludePostLink(
          $scope,
          $element,
          $attrs,
          _controller,
          $transclude,
        ) {
          if (!$transclude) {
            throw ngTranscludeMinErr(
              "orphan",
              "Illegal use of ngTransclude directive in the template! " +
                "No parent directive that requires a transclusion found. " +
                "Element: {0}",
              startingTag($element),
            );
          }

          // If the attribute is of the form: `ng-transclude="ng-transclude"` then treat it like the default
          if ($attrs["ngTransclude"] === $attrs.$attr.ngTransclude) {
            $attrs["ngTransclude"] = "";
          }
          const slotName = $attrs["ngTransclude"] || $attrs["ngTranscludeSlot"];

          // If the slot is required and no transclusion content is provided then this call will throw an error
          $transclude(ngTranscludeCloneAttachFn, null, slotName);

          // If the slot is optional and no transclusion content is provided then use the fallback content
          if (slotName && !$transclude.isSlotFilled(slotName)) {
            useFallbackContent();
          }

          /**
           * @param {NodeList | Node} clone
           * @param {import("../../core/scope/scope.js").Scope} transcludedScope
           */
          function ngTranscludeCloneAttachFn(clone, transcludedScope) {
            if (notWhitespace(clone)) {
              if (clone instanceof NodeList) {
                Array.from(clone).forEach((el) => {
                  $element.append(el);
                });
              } else {
                $element.append(/** @type {Node} */ (clone));
              }
            } else {
              useFallbackContent();
              // There is nothing linked against the transcluded scope since no content was available,
              // so it should be safe to clean up the generated scope.
              transcludedScope.$destroy();
            }
          }

          function useFallbackContent() {
            // Since this is the fallback content rather than the transcluded content,
            // we link against the scope of this directive rather than the transcluded scope
            fallbackLinkFn(
              $scope,

              (clone) => {
                $element.append(clone);
              },
            );
          }

          function notWhitespace(node) {
            if (node instanceof Array) {
              return false;
            } else if (
              node.nodeType !== Node.TEXT_NODE ||
              node.nodeValue.trim()
            ) {
              return true;
            }
          }
        }

        return ngTranscludePostLink;
      },
    };
  },
];

/**
 * @returns {import('../../types.js').Directive}
 */
function ngChangeDirective() {
  return {
    restrict: "A",
    require: "ngModel",
    link(scope, _element, attr, ctrl) {
      /** @type {import('../../types.js').NgModelController} */ (
        ctrl
      ).$viewChangeListeners.push(() => scope.$eval(attr["ngChange"]));
    },
  };
}

const REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;

const ngAttributeAliasDirectives = {};

// boolean attrs are evaluated
BOOLEAN_ATTR.forEach((i) => {
  // binding to multiple is not supported
  if (i === "multiple") return;

  function defaultLinkFn(scope, _element, attr) {
    scope.$watch(attr[normalized], (value) => {
      attr.$set(i, !!value);
    });
  }

  let normalized = directiveNormalize(`ng-${i}`);
  let linkFn = defaultLinkFn;

  if (i === "checked") {
    linkFn = function (scope, element, attr) {
      // ensuring ngChecked doesn't interfere with ngModel when both are set on the same input
      if (attr.ngModel !== attr[normalized]) {
        defaultLinkFn(scope, element, attr);
      }
    };
  }

  ngAttributeAliasDirectives[normalized] = function () {
    return {
      restrict: "A",
      priority: 100,
      link: linkFn,
    };
  };
});

// aliased input attrs are evaluated
Object.entries(ALIASED_ATTR).forEach(([ngAttr]) => {
  ngAttributeAliasDirectives[ngAttr] = function () {
    return {
      priority: 100,
      link(scope, element, attr) {
        // special case ngPattern when a literal regular expression value
        // is used as the expression (this way we don't have to watch anything).
        if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) === "/") {
          const match = attr.ngPattern.match(REGEX_STRING_REGEXP);
          if (match) {
            attr.$set("ngPattern", new RegExp(match[1], match[2]));
            return;
          }
        }

        scope.$watch(attr[ngAttr], (value) => {
          attr.$set(ngAttr, value);
        });
      },
    };
  };
});

// ng-src, ng-srcset, ng-href are interpolated
["src", "srcset", "href"].forEach((attrName) => {
  const normalized = directiveNormalize(`ng-${attrName}`);
  ngAttributeAliasDirectives[normalized] = [
    "$sce",
    function ($sce) {
      return {
        priority: 99, // it needs to run after the attributes are interpolated
        link(_scope, element, attr) {
          let name = attrName;

          if (
            attrName === "href" &&
            toString.call(element.href) === "[object SVGAnimatedString]"
          ) {
            name = "xlinkHref";
            attr.$attr[name] = "href";
          }

          // We need to sanitize the url at least once, in case it is a constant
          // non-interpolated attribute.
          attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized]));

          attr.$observe(normalized, (value) => {
            if (!value) {
              if (attrName === "href") {
                attr.$set(name, null);
              }
              return;
            }

            attr.$set(name, value);
          });
        },
      };
    },
  ];
});

/**
 *
 * @param {string} ngRequired AngularJS expression. If it evaluates to `true`, it sets the
 *                                `required` attribute to the element and adds the `required`
 *                                {@link ngModel.NgModelController#$validators `validator`}.
 *
 *
 * ngRequired adds the required {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.
 * It is most often used for {@link input `input`} and {@link select `select`} controls, but can also be
 * applied to custom controls.
 *
 * The directive sets the `required` attribute on the element if the AngularJS expression inside
 * `ngRequired` evaluates to true. A special directive for setting `required` is necessary because we
 * cannot use interpolation inside `required`. See the {@link guide/interpolation interpolation guide}
 * for more info.
 *
 * The validator will set the `required` error key to true if the `required` attribute is set and
 * calling {@link ngModel.NgModelController#$isEmpty `NgModelController.$isEmpty`} with the
 * {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`} returns `true`. For example, the
 * `$isEmpty()` implementation for `input[text]` checks the length of the `$viewValue`. When developing
 * custom controls, `$isEmpty()` can be overwritten to account for a $viewValue that is not string-based.
 *
 */
const requiredDirective = [
  "$parse",
  /**
   * @param {import("../../core/parse/parse.js").ParseService} $parse
   * @returns {import("../../types.js").Directive}
   */
  ($parse) => ({
    restrict: "A",
    require: "?ngModel",
    link:
      /**
       * @param {import("../../core/scope/scope.js").Scope} scope
       * @param {Element} _elm
       * @param {import("../../types.js").Attributes} attr
       * @param {import("../../types.js").NgModelController} ctrl
       * @returns
       */
      (scope, _elm, attr, ctrl) => {
        if (!ctrl) return;
        // For boolean attributes like required, presence means true
        let value =
          Object.prototype.hasOwnProperty.call(attr, "required") ||
          $parse(attr.ngRequired)(scope);

        if (!attr.ngRequired) {
          // force truthy in case we are on non input element
          // (input elements do this automatically for boolean attributes like required)
          attr.required = true;
        }

        ctrl.$validators.required = (_modelValue, viewValue) => {
          return !value || !ctrl.$isEmpty(viewValue);
        };

        attr.$observe("required", (newVal) => {
          if (value !== newVal) {
            value = newVal;
            ctrl.$validate();
          }
        });
      },
  }),
];

/**
 * @param {String|RegExp} ngPattern AngularJS expression that must evaluate to a `RegExp` or a `String`
 *                                      parsable into a `RegExp`, or a `RegExp` literal. See above for
 *                                      more details.
 *
 * @description
 *
 * ngPattern adds the pattern {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.
 * It is most often used for text-based {@link input `input`} controls, but can also be applied to custom text-based controls.
 *
 * The validator sets the `pattern` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
 * does not match a RegExp which is obtained from the `ngPattern` attribute value:
 * - the value is an AngularJS expression:
 *   - If the expression evaluates to a RegExp object, then this is used directly.
 *   - If the expression evaluates to a string, then it will be converted to a RegExp after wrapping it
 *     in `^` and `$` characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
 * - If the value is a RegExp literal, e.g. `ngPattern="/^\d+$/"`, it is used directly.
 *
 * <div class="alert alert-info">
 * **Note:** Avoid using the `g` flag on the RegExp, as it will cause each successive search to
 * start at the index of the last search's match, thus not taking the whole input value into
 * account.
 * </div>
 *
 * <div class="alert alert-info">
 * **Note:** This directive is also added when the plain `pattern` attribute is used, with two
 * differences:
 * <ol>
 *   <li>
 *     `ngPattern` does not set the `pattern` attribute and therefore HTML5 constraint validation is
 *     not available.
 *   </li>
 *   <li>
 *     The `ngPattern` attribute must be an expression, while the `pattern` value must be
 *     interpolated.
 *   </li>
 * </ol>
 * </div>
 */
const patternDirective = [
  "$parse",
  /**
   * @param {import("../../core/parse/parse.js").ParseService} $parse
   * @returns {import("../../types.js").Directive}
   */
  ($parse) => {
    return {
      restrict: "A",
      require: "?ngModel",
      compile: (_Elm, tAttr) => {
        var patternExp;
        var parseFn;

        if (tAttr.ngPattern) {
          patternExp = tAttr.ngPattern;

          // ngPattern might be a scope expression, or an inlined regex, which is not parsable.
          // We get value of the attribute here, so we can compare the old and the new value
          // in the observer to avoid unnecessary validations
          if (
            tAttr.ngPattern.charAt(0) === "/" &&
            REGEX_STRING_REGEXP.test(tAttr.ngPattern)
          ) {
            parseFn = function () {
              return tAttr.ngPattern;
            };
          } else {
            parseFn = $parse(tAttr.ngPattern);
          }
        }

        return function (scope, elm, attr, ctrl) {
          if (!ctrl) return;

          var attrVal = attr.pattern;

          if (attr.ngPattern) {
            attrVal = parseFn(scope);
          } else {
            patternExp = attr.pattern;
          }

          var regexp = parsePatternAttr(attrVal, patternExp, elm);
          attr.$observe("pattern", function (newVal) {
            var oldRegexp = regexp;

            regexp = parsePatternAttr(newVal, patternExp, elm);

            if (
              (oldRegexp && oldRegexp.toString()) !==
              (regexp && regexp.toString())
            ) {
              ctrl.$validate();
            }
          });

          ctrl.$validators.pattern = function (modelValue, viewValue) {
            // HTML5 pattern constraint validates the input value, so we validate the viewValue
            return (
              ctrl.$isEmpty(viewValue) ||
              isUndefined(regexp) ||
              regexp.test(viewValue)
            );
          };
        };
      },
    };
  },
];

/**
 * @param {string} ngMaxlength AngularJS expression that must evaluate to a `Number` or `String`
 *                                 parsable into a `Number`. Used as value for the `maxlength`
 *                                 {@link ngModel.NgModelController#$validators validator}.
 *
 * @description
 *
 * ngMaxlength adds the maxlength {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.
 * It is most often used for text-based {@link input `input`} controls, but can also be applied to custom text-based controls.
 *
 * The validator sets the `maxlength` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
 * is longer than the integer obtained by evaluating the AngularJS expression given in the
 * `ngMaxlength` attribute value.
 *
 * <div class="alert alert-info">
 * **Note:** This directive is also added when the plain `maxlength` attribute is used, with two
 * differences:
 * <ol>
 *   <li>
 *     `ngMaxlength` does not set the `maxlength` attribute and therefore HTML5 constraint
 *     validation is not available.
 *   </li>
 *   <li>
 *     The `ngMaxlength` attribute must be an expression, while the `maxlength` value must be
 *     interpolated.
 *   </li>
 * </ol>
 * </div>
 *
 */
const maxlengthDirective = [
  "$parse",
  /**
   * @param {import("../../core/parse/parse.js").ParseService} $parse
   * @returns {import("../../types.js").Directive}
   */
  ($parse) => ({
    restrict: "A",
    require: "?ngModel",
    link:
      /**
       * @param {import("../../core/scope/scope.js").Scope} scope
       * @param {*} _elm
       * @param {import("../../types.js").Attributes} attr
       * @param {import("../../types.js").NgModelController} ctrl
       * @returns
       */
      (scope, _elm, attr, ctrl) => {
        if (!ctrl) return;

        let maxlength = attr.maxlength || $parse(attr.ngMaxlength)(scope);
        let maxlengthParsed = parseLength(maxlength);

        attr.$observe("maxlength", (value) => {
          if (maxlength !== value) {
            maxlengthParsed = parseLength(value);
            maxlength = value;
            ctrl.$validate();
          }
        });
        ctrl.$validators.maxlength = function (modelValue, viewValue) {
          return (
            maxlengthParsed < 0 ||
            ctrl.$isEmpty(viewValue) ||
            viewValue.length <= maxlengthParsed
          );
        };
      },
  }),
];

/**
 *
 * @param {string} ngMinlength AngularJS expression that must evaluate to a `Number` or `String`
 *                                 parsable into a `Number`. Used as value for the `minlength`
 *                                 {@link ngModel.NgModelController#$validators validator}.
 *
 * @description
 *
 * ngMinlength adds the minlength {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.
 * It is most often used for text-based {@link input `input`} controls, but can also be applied to custom text-based controls.
 *
 * The validator sets the `minlength` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
 * is shorter than the integer obtained by evaluating the AngularJS expression given in the
 * `ngMinlength` attribute value.
 *
 * <div class="alert alert-info">
 * **Note:** This directive is also added when the plain `minlength` attribute is used, with two
 * differences:
 * <ol>
 *   <li>
 *     `ngMinlength` does not set the `minlength` attribute and therefore HTML5 constraint
 *     validation is not available.
 *   </li>
 *   <li>
 *     The `ngMinlength` value must be an expression, while the `minlength` value must be
 *     interpolated.
 *   </li>
 * </ol>
 * </div>
 *
 */
const minlengthDirective = [
  "$parse",
  function ($parse) {
    return {
      restrict: "A",
      require: "?ngModel",
      link(scope, elm, attr, ctrl) {
        if (!ctrl) return;

        let minlength = attr.minlength || $parse(attr.ngMinlength)(scope);
        let minlengthParsed = parseLength(minlength) || -1;

        attr.$observe("minlength", (value) => {
          if (minlength !== value) {
            minlengthParsed = parseLength(value) || -1;
            minlength = value;
            ctrl.$validate();
          }
        });
        ctrl.$validators.minlength = function (modelValue, viewValue) {
          return (
            ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed
          );
        };
      },
    };
  },
];

function parsePatternAttr(regex, patternExp, elm) {
  if (!regex) return undefined;

  if (isProxy(regex)) {
    regex = regex.$target;
  }

  if (isString(regex)) {
    regex = new RegExp(`^${regex}$`);
  }

  if (!regex.test) {
    throw minErr("ngPattern")(
      "noregexp",
      "Expected {0} to be a RegExp but was {1}. Element: {2}",
      patternExp,
      regex,
      startingTag(elm),
    );
  }

  return regex;
}

function parseLength(val) {
  const intVal = toInt(val);
  return isNumberNaN(intVal) ? -1 : intVal;
}

/**
 * @typedef {Object} AnchorScrollObject
 * @property {number|function|Element} yOffset
 */

/**
 * @typedef {(string) => void} AnchorScrollFunction
 */

/**
 * @typedef {AnchorScrollFunction | AnchorScrollObject} AnchorScrollService
 */

class AnchorScrollProvider {
  constructor() {
    this.autoScrollingEnabled = true;
  }

  disableAutoScrolling() {
    this.autoScrollingEnabled = false;
  }

  $get = [
    "$location",
    "$rootScope",
    /**
     *
     * @param {import('../core/location/location').Location} $location
     * @param {import('../core/scope/scope.js').Scope} $rootScope
     * @returns
     */
    function ($location, $rootScope) {
      // Helper function to get first anchor from a NodeList
      // (using `Array#some()` instead of `angular#forEach()` since it's more performant
      //  and working in all supported browsers.)
      function getFirstAnchor(list) {
        let result = null;
        Array.prototype.some.call(list, (element) => {
          if (getNodeName(element) === "a") {
            result = element;
            return true;
          }
        });
        return result;
      }

      function getYOffset() {
        // Figure out a better way to configure this other than bolting on a property onto a function
        let offset = /** @type {AnchorScrollObject} */ (scroll).yOffset;

        if (isFunction(offset)) {
          offset = /** @type {Function} */ (offset)();
        } else if (isElement(offset)) {
          const elem = offset[0];
          const style = window.getComputedStyle(elem);
          if (style.position !== "fixed") {
            offset = 0;
          } else {
            offset = elem.getBoundingClientRect().bottom;
          }
        } else if (!isNumber(offset)) {
          offset = 0;
        }

        return offset;
      }

      function scrollTo(elem) {
        if (elem) {
          elem.scrollIntoView();

          const offset = getYOffset();

          if (offset) {
            // `offset` is the number of pixels we should scroll UP in order to align `elem` properly.
            // This is true ONLY if the call to `elem.scrollIntoView()` initially aligns `elem` at the
            // top of the viewport.
            //
            // IF the number of pixels from the top of `elem` to the end of the page's content is less
            // than the height of the viewport, then `elem.scrollIntoView()` will align the `elem` some
            // way down the page.
            //
            // This is often the case for elements near the bottom of the page.
            //
            // In such cases we do not need to scroll the whole `offset` up, just the difference between
            // the top of the element and the offset, which is enough to align the top of `elem` at the
            // desired position.
            const elemTop = elem.getBoundingClientRect().top;
            window.scrollBy(0, elemTop - /** @type {number} */ (offset));
          }
        } else {
          window.scrollTo(0, 0);
        }
      }

      /** @type {AnchorScrollService} */
      const scroll = function (hash) {
        // Allow numeric hashes
        hash = isString(hash)
          ? hash
          : isNumber(hash)
            ? hash.toString()
            : $location.hash();
        let elm;

        // empty hash, scroll to the top of the page
        if (!hash) {
          scrollTo(null);
        }
        // element with given id
        else if ((elm = document.getElementById(hash))) scrollTo(elm);
        // first anchor with given name :-D
        else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
          scrollTo(elm);
        // no element and hash === 'top', scroll to the top of the page
        else if (hash === "top") scrollTo(null);
      };

      // does not scroll when user clicks on anchor link that is currently on
      // (no url change, no $location.hash() change), browser native does scroll
      if (this.autoScrollingEnabled) {
        $rootScope["$location"] = $location;
        $rootScope.$watch("$location.$$hash", (newVal, oldVal) => {
          // skip the initial scroll if $location.hash is empty
          if (newVal === oldVal && newVal === "") return;

          const action = () => $rootScope.$evalAsync(scroll);
          if (document.readyState === "complete") {
            // Force the action to be run async for consistent behavior
            // from the action's point of view
            // i.e. it will definitely not be in a $apply
            window.setTimeout(() => action());
          } else {
            window.addEventListener("load", () => action());
          }
        });
      }

      return scroll;
    },
  ];
}

/**
 * @readonly
 * @enum {number}
 */
const ASTType = {
  Program: 1,
  ExpressionStatement: 2,
  AssignmentExpression: 3,
  ConditionalExpression: 4,
  LogicalExpression: 5,
  BinaryExpression: 6,
  UnaryExpression: 7,
  CallExpression: 8,
  MemberExpression: 9,
  Identifier: 10,
  Literal: 11,
  ArrayExpression: 12,
  Property: 13,
  ObjectExpression: 14,
  ThisExpression: 15,
  LocalsExpression: 16,
  NGValueParameter: 17,
};

const ADD_CLASS_SUFFIX = "-add";
const REMOVE_CLASS_SUFFIX = "-remove";
const EVENT_CLASS_PREFIX = "ng-";
const ACTIVE_CLASS_SUFFIX = "-active";
const PREPARE_CLASS_SUFFIX = "-prepare";

const NG_ANIMATE_CLASSNAME = "ng-animate";
const NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren";
let TRANSITION_PROP;
let TRANSITIONEND_EVENT;
let ANIMATION_PROP;
let ANIMATIONEND_EVENT;

// If unprefixed events are not supported but webkit-prefixed are, use the latter.
// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
// Register both events in case `window.onanimationend` is not supported because of that,
// do the same for `transitionend` as Safari is likely to exhibit similar behavior.
// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
// therefore there is no reason to test anymore for other vendor prefixes:
// http://caniuse.com/#search=transition
if (
  window.ontransitionend === undefined &&
  window.onwebkittransitionend !== undefined
) {
  TRANSITION_PROP = "WebkitTransition";
  TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
} else {
  TRANSITION_PROP = "transition";
  TRANSITIONEND_EVENT = "transitionend";
}

if (
  window.onanimationend === undefined &&
  window.onwebkitanimationend !== undefined
) {
  ANIMATION_PROP = "WebkitAnimation";
  ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
} else {
  ANIMATION_PROP = "animation";
  ANIMATIONEND_EVENT = "animationend";
}

const DURATION_KEY = "Duration";
const PROPERTY_KEY = ASTType.Property;
const DELAY_KEY = "Delay";
const TIMING_KEY = "TimingFunction";
const ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
const ANIMATION_PLAYSTATE_KEY = "PlayState";
const SAFE_FAST_FORWARD_DURATION_VALUE = 9999;

const ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
const ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
const TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
const TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;

const ngMinErr$1 = minErr("ng");
function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr$1(
      "areq",
      "Argument '{0}' is {1}",
      name || "?",
      reason,
    );
  }
  return arg;
}

function packageStyles(options) {
  const styles = {};
  if (options && (options.to || options.from)) {
    styles.to = options.to;
    styles.from = options.from;
  }
  return styles;
}

function pendClasses(classes, fix, isPrefix) {
  let className = "";

  classes = Array.isArray(classes)
    ? classes
    : classes && isString(classes) && classes.length
      ? classes.split(/\s+/)
      : [];
  classes.forEach((klass, i) => {
    if (klass && klass.length > 0) {
      className += i > 0 ? " " : "";
      className += isPrefix ? fix + klass : klass + fix;
    }
  });
  return className;
}

function removeFromArray(arr, val) {
  const index = arr.indexOf(val);
  if (val >= 0) {
    arr.splice(index, 1);
  }
}

/**
 *
 * @param {NodeList|Node} element
 * @returns {Node[]|Node|undefined}
 */
function stripCommentsFromElement(element) {
  if (element instanceof NodeList) {
    return Array.from(element).filter((x) => x.nodeType == Node.ELEMENT_NODE);
  } else if (element.nodeType === Node.ELEMENT_NODE) {
    return /** @type {Node} */ (element);
  } else {
    return undefined;
  }
}

/**
 * @param {NodeList|Node} element
 * @returns {Node}
 */
function extractElementNode(element) {
  if (!element) return /** @type {Node} */ (element);
  for (let i = 0; i < /** @type {NodeList} */ (element).length; i++) {
    const elm = element[i];
    if (elm.nodeType === Node.ELEMENT_NODE) {
      return elm;
    }
  }
}

function applyAnimationClassesFactory() {
  return function (element, options) {
    if (options.addClass) {
      element.classList.add(...options.addClass.trim().split(" "));
      options.addClass = null;
    }
    if (options.removeClass) {
      element.classList.remove(...options.removeClass.trim().split(" "));
      options.removeClass = null;
    }
  };
}

function prepareAnimationOptions(options) {
  options = options || {};
  if (!options.$$prepared) {
    let domOperation = options.domOperation || (() => {});
    options.domOperation = function () {
      options.$$domOperationFired = true;
      domOperation();
      domOperation = () => {};
    };
    options.$$prepared = true;
  }
  return options;
}

function applyAnimationStyles(element, options) {
  applyAnimationFromStyles(element, options);
  applyAnimationToStyles(element, options);
}

function applyAnimationFromStyles(element, options) {
  if (options.from) {
    //element.css(options.from);
    options.from = null;
  }
}

function applyAnimationToStyles(element, options) {
  if (options.to) {
    //element.css(options.to);
    options.to = null;
  }
}

function mergeAnimationDetails(element, oldAnimation, newAnimation) {
  const target = oldAnimation.options || {};
  const newOptions = newAnimation.options || {};

  const toAdd = `${target.addClass || ""} ${newOptions.addClass || ""}`;
  const toRemove = `${target.removeClass || ""} ${newOptions.removeClass || ""}`;
  const classes = resolveElementClasses(
    element.getAttribute("class"),
    toAdd,
    toRemove,
  );

  if (newOptions.preparationClasses) {
    target.preparationClasses = concatWithSpace(
      newOptions.preparationClasses,
      target.preparationClasses,
    );
    delete newOptions.preparationClasses;
  }

  // noop is basically when there is no callback; otherwise something has been set
  const realDomOperation =
    target.domOperation !== (() => {}) ? target.domOperation : null;

  extend(target, newOptions);

  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.
  if (realDomOperation) {
    target.domOperation = realDomOperation;
  }

  if (classes.addClass) {
    target.addClass = classes.addClass;
  } else {
    target.addClass = null;
  }

  if (classes.removeClass) {
    target.removeClass = classes.removeClass;
  } else {
    target.removeClass = null;
  }

  oldAnimation.addClass = target.addClass;
  oldAnimation.removeClass = target.removeClass;

  return target;
}

function resolveElementClasses(existing, toAdd, toRemove) {
  const ADD_CLASS = 1;
  const REMOVE_CLASS = -1;

  const flags = {};
  existing = splitClassesToLookup(existing);

  toAdd = splitClassesToLookup(toAdd);
  Object.keys(toAdd).forEach((key) => {
    flags[key] = ADD_CLASS;
  });

  toRemove = splitClassesToLookup(toRemove);
  Object.keys(toRemove).forEach((key) => {
    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
  });

  const classes = {
    addClass: "",
    removeClass: "",
  };

  Object.entries(flags).forEach(([klass, val]) => {
    var prop, allow;
    if (val === ADD_CLASS) {
      prop = "addClass";
      allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
    } else if (val === REMOVE_CLASS) {
      prop = "removeClass";
      allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
    }
    if (allow) {
      if (classes[prop].length) {
        classes[prop] += " ";
      }
      classes[prop] += klass;
    }
  });

  function splitClassesToLookup(classes) {
    if (isString(classes)) {
      classes = classes.trim().split(" ");
    }

    const obj = {};
    if (classes) {
      classes.forEach((klass) => {
        // sometimes the split leaves empty string values
        // incase extra spaces were applied to the options
        if (klass.length) {
          obj[klass] = true;
        }
      });
    }
    return obj;
  }

  return classes;
}

function applyGeneratedPreparationClasses(element, event, options) {
  let classes = "";
  if (event) {
    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
  }
  if (options.addClass) {
    classes = concatWithSpace(
      classes,
      pendClasses(options.addClass, ADD_CLASS_SUFFIX),
    );
  }
  if (options.removeClass) {
    classes = concatWithSpace(
      classes,
      pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX),
    );
  }
  if (classes.length) {
    options.preparationClasses = classes;
    element.className += ` ${classes}`;
  }
}

function clearGeneratedClasses(element, options) {
  if (options.preparationClasses) {
    options.preparationClasses
      .split(" ")
      .forEach((cls) => element.classList.remove(cls));
    options.preparationClasses = null;
  }
  if (options.activeClasses) {
    options.activeClasses
      .split(" ")
      .forEach((cls) => element.classList.remove(cls));
    options.activeClasses = null;
  }
}

function blockKeyframeAnimations(node, applyBlock) {
  const value = applyBlock ? "paused" : "";
  const key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
  applyInlineStyle(node, [key, value]);
  return [key, value];
}

function applyInlineStyle(node, styleTuple) {
  const prop = styleTuple[0];
  const value = styleTuple[1];
  node.style[prop] = value;
}

function concatWithSpace(a, b) {
  if (!a) return b;
  if (!b) return a;
  return `${a} ${b}`;
}

/** @typedef {"enter"|"leave"|"move"|"addClass"|"setClass"|"removeClass"} AnimationMethod */

/**
 * @typedef {Object} AnimationOptions
 * @property {string} addClass - space-separated CSS classes to add to element
 * @property {Object} from - CSS properties & values at the beginning of animation. Must have matching `to`
 * @property {string} removeClass - space-separated CSS classes to remove from element
 * @property {string} to - CSS properties & values at end of animation. Must have matching `from`
 */

const $animateMinErr = minErr("$animate");

function mergeClasses(a, b) {
  if (!a && !b) return "";
  if (!a) return b;
  if (!b) return a;
  if (Array.isArray(a)) a = a.join(" ");
  if (Array.isArray(b)) b = b.join(" ");
  return `${a} ${b}`;
}

// if any other type of options value besides an Object value is
// passed into the $animate.method() animation then this helper code
// will be run which will ignore it. While this patch is not the
// greatest solution to this, a lot of existing plugins depend on
// $animate to either call the callback (< 1.2) or return a promise
// that can be changed. This helper function ensures that the options
// are wiped clean incase a callback function is provided.
function prepareAnimateOptions(options) {
  return isObject(options) ? options : {};
}

AnimateProvider.$inject = ["$provide"];
function AnimateProvider($provide) {
  const provider = this;
  let classNameFilter = null;
  let customFilter = null;

  this.$$registeredAnimations = Object.create(null);

  /**
   * Registers a new injectable animation factory function. The factory function produces the
   * animation object which contains callback functions for each event that is expected to be
   * animated.
   *
   *   * `eventFn`: `function(element, ... , doneFunction, options)`
   *   The element to animate, the `doneFunction` and the options fed into the animation. Depending
   *   on the type of animation additional arguments will be injected into the animation function. The
   *   list below explains the function signatures for the different animation methods:
   *
   *   - setClass: function(element, addedClasses, removedClasses, doneFunction, options)
   *   - addClass: function(element, addedClasses, doneFunction, options)
   *   - removeClass: function(element, removedClasses, doneFunction, options)
   *   - enter, leave, move: function(element, doneFunction, options)
   *   - animate: function(element, fromStyles, toStyles, doneFunction, options)
   *
   *   Make sure to trigger the `doneFunction` once the animation is fully complete.
   *
   * ```js
   *   return {
   *     //enter, leave, move signature
   *     eventFn : function(element, done, options) {
   *       //code to run the animation
   *       //once complete, then run done()
   *       return function endFunction(wasCancelled) {
   *         //code to cancel the animation
   *       }
   *     }
   *   }
   * ```
   *
   * @param {string} name The name of the animation (this is what the class-based CSS value will be compared to).
   * @param {Function} factory The factory function that will be executed to return the animation
   *                           object.
   */
  this.register = function (name, factory) {
    if (name && name.charAt(0) !== ".") {
      throw $animateMinErr(
        "notcsel",
        "Expecting class selector starting with '.' got '{0}'.",
        name,
      );
    }

    const key = `${name}-animation`;
    provider.$$registeredAnimations[name.substring(1)] = key;
    $provide.factory(key, factory);
  };

  /**
   * Sets and/or returns the custom filter function that is used to "filter" animations, i.e.
   * determine if an animation is allowed or not. When no filter is specified (the default), no
   * animation will be blocked. Setting the `customFilter` value will only allow animations for
   * which the filter function's return value is truthy.
   *
   * This allows to easily create arbitrarily complex rules for filtering animations, such as
   * allowing specific events only, or enabling animations on specific subtrees of the DOM, etc.
   * Filtering animations can also boost performance for low-powered devices, as well as
   * applications containing a lot of structural operations.
   *
   * <div class="alert alert-success">
   *   **Best Practice:**
   *   Keep the filtering function as lean as possible, because it will be called for each DOM
   *   action (e.g. insertion, removal, class change) performed by "animation-aware" directives.
   *   See {@link guide/animations#which-directives-support-animations- here} for a list of built-in
   *   directives that support animations.
   *   Performing computationally expensive or time-consuming operations on each call of the
   *   filtering function can make your animations sluggish.
   * </div>
   *
   * **Note:** If present, `customFilter` will be checked before
   * {@link $animateProvider#classNameFilter classNameFilter}.
   *
   * @param {Function=} filterFn - The filter function which will be used to filter all animations.
   *   If a falsy value is returned, no animation will be performed. The function will be called
   *   with the following arguments:
   *   - **node** `{Element}` - The DOM element to be animated.
   *   - **event** `{String}` - The name of the animation event (e.g. `enter`, `leave`, `addClass`
   *     etc).
   *   - **options** `{Object}` - A collection of options/styles used for the animation.
   * @return {Function} The current filter function or `null` if there is none set.
   */
  this.customFilter = function (filterFn) {
    if (arguments.length === 1) {
      customFilter = isFunction(filterFn) ? filterFn : null;
    }

    return customFilter;
  };

  /**
   * Sets and/or returns the CSS class regular expression that is checked when performing
   * an animation. Upon bootstrap the classNameFilter value is not set at all and will
   * therefore enable $animate to attempt to perform an animation on any element that is triggered.
   * When setting the `classNameFilter` value, animations will only be performed on elements
   * that successfully match the filter expression. This in turn can boost performance
   * for low-powered devices as well as applications containing a lot of structural operations.
   *
   * **Note:** If present, `classNameFilter` will be checked after
   * {@link $animateProvider#customFilter customFilter}. If `customFilter` is present and returns
   * false, `classNameFilter` will not be checked.
   *
   * @param {RegExp=} expression The className expression which will be checked against all animations
   * @return {RegExp} The current CSS className expression value. If null then there is no expression value
   */
  this.classNameFilter = function (expression) {
    if (arguments.length === 1) {
      classNameFilter = expression instanceof RegExp ? expression : null;
      if (classNameFilter) {
        const reservedRegex = new RegExp(
          `[(\\s|\\/)]${NG_ANIMATE_CLASSNAME}[(\\s|\\/)]`,
        );
        if (reservedRegex.test(classNameFilter.toString())) {
          classNameFilter = null;
          throw $animateMinErr(
            "nongcls",
            '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.',
            NG_ANIMATE_CLASSNAME,
          );
        }
      }
    }
    return classNameFilter;
  };

  this.$get = [
    "$$animateQueue",
    function ($$animateQueue) {
      /**
       * The $animate service exposes a series of DOM utility methods that provide support
       * for animation hooks. The default behavior is the application of DOM operations, however,
       * when an animation is detected (and animations are enabled), $animate will do the heavy lifting
       * to ensure that animation runs with the triggered DOM operation.
       *
       * By default $animate doesn't trigger any animations. This is because the `ngAnimate` module isn't
       * included and only when it is active then the animation hooks that `$animate` triggers will be
       * functional. Once active then all structural `ng-` directives will trigger animations as they perform
       * their DOM-related operations (enter, leave and move). Other directives such as `ngClass`,
       * `ngShow`, `ngHide` and `ngMessages` also provide support for animations.
       *
       * It is recommended that the`$animate` service is always used when executing DOM-related procedures within directives.
       */
      return {
        /**
         *
         * Sets up an event listener to fire whenever the animation event (enter, leave, move, etc...)
         *    has fired on the given element or among any of its children. Once the listener is fired, the provided callback
         *    is fired with the following params:
         *
         * ```js
         * $animate.on('enter', container,
         *    function callback(element, phase) {
         *      // cool we detected an enter animation within the container
         *    }
         * );
         * ```
         *
         * <div class="alert alert-warning">
         * **Note**: Generally, the events that are fired correspond 1:1 to `$animate` method names,
         * e.g. {@link ng.$animate#addClass addClass()} will fire `addClass`, and {@link ng.ngClass}
         * will fire `addClass` if classes are added, and `removeClass` if classes are removed.
         * However, there are two exceptions:
         *
         * <ul>
         *   <li>if both an {@link ng.$animate#addClass addClass()} and a
         *   {@link ng.$animate#removeClass removeClass()} action are performed during the same
         *   animation, the event fired will be `setClass`. This is true even for `ngClass`.</li>
         *   <li>an {@link ng.$animate#animate animate()} call that adds and removes classes will fire
         *   the `setClass` event, but if it either removes or adds classes,
         *   it will fire `animate` instead.</li>
         * </ul>
         *
         * </div>
         *
         * @param {string} event the animation event that will be captured (e.g. enter, leave, move, addClass, removeClass, etc...)
         * @param {Element} container the container element that will capture each of the animation events that are fired on itself
         *     as well as among its children
         * @param {Function} callback the callback function that will be fired when the listener is triggered.
         *
         * The arguments present in the callback function are:
         * * `element` - The captured DOM element that the animation was fired on.
         * * `phase` - The phase of the animation. The two possible phases are **start** (when the animation starts) and **close** (when it ends).
         * * `data` - an object with these properties:
         *     * addClass - `{string|null}` - space-separated CSS classes to add to the element
         *     * removeClass - `{string|null}` - space-separated CSS classes to remove from the element
         *     * from - `{Object|null}` - CSS properties & values at the beginning of the animation
         *     * to - `{Object|null}` - CSS properties & values at the end of the animation
         *
         * Note that the callback does not trigger a scope digest. Wrap your call into a
         * {@link $rootScope.Scope#$apply scope.$apply} to propagate changes to the scope.
         */
        on: $$animateQueue.on,

        /**
         * Deregisters an event listener based on the event which has been associated with the provided element. This method
         * can be used in three different ways depending on the arguments:
         *
         * ```js
         * // remove all the animation event listeners listening for `enter`
         * $animate.off('enter');
         *
         * // remove listeners for all animation events from the container element
         * $animate.off(container);
         *
         * // remove all the animation event listeners listening for `enter` on the given element and its children
         * $animate.off('enter', container);
         *
         * // remove the event listener function provided by `callback` that is set
         * // to listen for `enter` on the given `container` as well as its children
         * $animate.off('enter', container, callback);
         * ```
         *
         * @param {string|Element} event|container the animation event (e.g. enter, leave, move,
         * addClass, removeClass, etc...), or the container element. If it is the element, all other
         * arguments are ignored.
         * @param {Element=} container the container element the event listener was placed on
         * @param {Function=} callback the callback function that was registered as the listener
         */
        off: $$animateQueue.off,

        /**
         *  Associates the provided element with a host parent element to allow the element to be animated even if it exists
         *  outside of the DOM structure of the AngularJS application. By doing so, any animation triggered via `$animate` can be issued on the
         *  element despite being outside the realm of the application or within another application. Say for example if the application
         *  was bootstrapped on an element that is somewhere inside of the `<body>` tag, but we wanted to allow for an element to be situated
         *  as a direct child of `document.body`, then this can be achieved by pinning the element via `$animate.pin(element)`. Keep in mind
         *  that calling `$animate.pin(element, parentElement)` will not actually insert into the DOM anywhere; it will just create the association.
         *
         *  Note that this feature is only active when the `ngAnimate` module is used.
         *
         * @param {Element} element the external element that will be pinned
         * @param {Element} parentElement the host parent element that will be associated with the external element
         */
        pin: $$animateQueue.pin,

        /**
         * Used to get and set whether animations are enabled or not on the entire application or on an element and its children. This
         * function can be called in four ways:
         *
         * ```js
         * // returns true or false
         * $animate.enabled();
         *
         * // changes the enabled state for all animations
         * $animate.enabled(false);
         * $animate.enabled(true);
         *
         * // returns true or false if animations are enabled for an element
         * $animate.enabled(element);
         *
         * // changes the enabled state for an element and its children
         * $animate.enabled(element, true);
         * $animate.enabled(element, false);
         * ```
         *
         * @param {Element=} element the element that will be considered for checking/setting the enabled state
         * @param {boolean=} enabled whether or not the animations will be enabled for the element
         *
         * @return {boolean} whether or not animations are enabled
         */
        enabled: $$animateQueue.enabled,

        /**
       * Cancels the provided animation and applies the end state of the animation.
       * Note that this does not cancel the underlying operation, e.g. the setting of classes or
       * adding the element to the DOM.
       *
       * @param {import('./animate-runner').AnimateRunner} runner An animation runner returned by an $animate function.
       *
       * @example
        <example module="animationExample" deps="angular-animate.js" animations="true" name="animate-cancel">
          <file name="app.js">
            angular.module('animationExample', []).component('cancelExample', {
              templateUrl: 'template.html',
              controller: function($element, $animate) {
                this.runner = null;

                this.addClass = function() {
                  this.runner = $animate.addClass($element.querySelectorAll('div'), 'red');
                  let ctrl = this;
                  this.runner.finally(function() {
                    ctrl.runner = null;
                  });
                };

                this.removeClass = function() {
                  this.runner = $animate.removeClass($element.querySelectorAll('div'), 'red');
                  let ctrl = this;
                  this.runner.finally(function() {
                    ctrl.runner = null;
                  });
                };

                this.cancel = function() {
                  $animate.cancel(this.runner);
                };
              }
            });
          </file>
          <file name="template.html">
            <p>
              <button id="add" ng-click="$ctrl.addClass()">Add</button>
              <button ng-click="$ctrl.removeClass()">Remove</button>
              <br>
              <button id="cancel" ng-click="$ctrl.cancel()" ng-disabled="!$ctrl.runner">Cancel</button>
              <br>
              <div id="target">CSS-Animated Text</div>
            </p>
          </file>
          <file name="index.html">
            <cancel-example></cancel-example>
          </file>
          <file name="style.css">
            .red-add, .red-remove {
              transition: all 4s cubic-bezier(0.250, 0.460, 0.450, 0.940);
            }

            .red,
            .red-add.red-add-active {
              color: #FF0000;
              font-size: 40px;
            }

            .red-remove.red-remove-active {
              font-size: 10px;
              color: black;
            }

          </file>
        </example>
       */
        cancel(runner) {
          if (runner.cancel) {
            runner.cancel();
          }
        },

        /**
         * Inserts the element into the DOM either after the `after` element (if provided) or
         * as the first child within the `parent` element and then triggers an animation.
         * A promise is returned that will be resolved during the next digest once the animation
         * has completed.
         *
         * @param {Element} element - the element which will be inserted into the DOM
         * @param {Element} parent - the parent element which will append the element as a child (so long as the after element is not present)
         * @param {Element} after - after the sibling element after which the element will be appended
         * @param {AnimationOptions} [options] - an optional collection of options/styles that will be applied to the element.
         * @returns {import('./animate-runner').AnimateRunner} the animation runner
         */
        enter(element, parent, after, options) {
          parent = parent || after.parentElement;
          domInsert(element, parent, after);
          return $$animateQueue.push(
            element,
            "enter",
            prepareAnimateOptions(options),
          );
        },

        /**
         * Inserts (moves) the element into its new position in the DOM either after
         * the `after` element (if provided) or as the first child within the `parent` element
         * and then triggers an animation. A promise is returned that will be resolved
         * during the next digest once the animation has completed.
         *
         * @param {Element} element - the element which will be inserted into the DOM
         * @param {Element} parent - the parent element which will append the element as a child (so long as the after element is not present)
         * @param {Element} after - after the sibling element after which the element will be appended
         * @param {AnimationOptions} [options] - an optional collection of options/styles that will be applied to the element.
         * @returns {import('./animate-runner').AnimateRunner} the animation runner
         */
        move(element, parent, after, options) {
          parent = parent || after.parentElement;
          domInsert(element, parent, after);
          return $$animateQueue.push(
            element,
            "move",
            prepareAnimateOptions(options),
          );
        },

        /**
         * Triggers an animation and then removes the element from the DOM.
         * When the function is called a promise is returned that will be resolved during the next
         * digest once the animation has completed.
         *
         * @param {Element} element the element which will be removed from the DOM
         * @param {AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.
         * @returns {import('./animate-runner').AnimateRunner} the animation runner
         */
        leave(element, options) {
          return $$animateQueue.push(
            element,
            "leave",
            prepareAnimateOptions(options),
            () => {
              // TODO no array should be here
              if (Array.isArray(element)) {
                element.forEach((x) => removeElement(x));
              } else {
                removeElement(element);
              }
            },
          );
        },

        /**
         * Triggers an addClass animation surrounding the addition of the provided CSS class(es). Upon
         * execution, the addClass operation will only be handled after the next digest and it will not trigger an
         * animation if element already contains the CSS class or if the class is removed at a later step.
         * Note that class-based animations are treated differently compared to structural animations
         * (like enter, move and leave) since the CSS classes may be added/removed at different points
         * depending if CSS or JavaScript animations are used.
         *
         * @param {Element} element the element which the CSS classes will be applied to
         * @param {string} className the CSS class(es) that will be added (multiple classes are separated via spaces)
         * @param {AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.
         * @return {import('./animate-runner').AnimateRunner}} animationRunner the animation runner
         */
        addClass(element, className, options) {
          options = prepareAnimateOptions(options);
          options.addClass = mergeClasses(options.addClass, className);
          return $$animateQueue.push(element, "addClass", options);
        },

        /**
         * Triggers a removeClass animation surrounding the removal of the provided CSS class(es). Upon
         * execution, the removeClass operation will only be handled after the next digest and it will not trigger an
         * animation if element does not contain the CSS class or if the class is added at a later step.
         * Note that class-based animations are treated differently compared to structural animations
         * (like enter, move and leave) since the CSS classes may be added/removed at different points
         * depending if CSS or JavaScript animations are used.
         *
         * @param {Element} element the element which the CSS classes will be applied to
         * @param {string} className the CSS class(es) that will be removed (multiple classes are separated via spaces)
         * @param {AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.         *
         * @return {import('./animate-runner').AnimateRunner} animationRunner the animation runner
         */
        removeClass(element, className, options) {
          options = prepareAnimateOptions(options);
          options.removeClass = mergeClasses(options.removeClass, className);
          return $$animateQueue.push(element, "removeClass", options);
        },

        /**
         * Performs both the addition and removal of a CSS classes on an element and (during the process)
         * triggers an animation surrounding the class addition/removal. Much like `$animate.addClass` and
         * `$animate.removeClass`, `setClass` will only evaluate the classes being added/removed once a digest has
         * passed. Note that class-based animations are treated differently compared to structural animations
         * (like enter, move and leave) since the CSS classes may be added/removed at different points
         * depending if CSS or JavaScript animations are used.
         *
         * @param {Element} element the element which the CSS classes will be applied to
         * @param {string} add the CSS class(es) that will be added (multiple classes are separated via spaces)
         * @param {string} remove the CSS class(es) that will be removed (multiple classes are separated via spaces)
         * @param {object=} options an optional collection of options/styles that will be applied to the element.
         *
         * @return {import('./animate-runner').AnimateRunner} the animation runner
         */
        setClass(element, add, remove, options) {
          options = prepareAnimateOptions(options);
          options.addClass = mergeClasses(options.addClass, add);
          options.removeClass = mergeClasses(options.removeClass, remove);
          return $$animateQueue.push(element, "setClass", options);
        },

        /**
         * Performs an inline animation on the element which applies the provided to and from CSS styles to the element.
         * If any detected CSS transition, keyframe or JavaScript matches the provided className value, then the animation will take
         * on the provided styles. For example, if a transition animation is set for the given className, then the provided `from` and
         * `to` styles will be applied alongside the given transition. If the CSS style provided in `from` does not have a corresponding
         * style in `to`, the style in `from` is applied immediately, and no animation is run.
         * If a JavaScript animation is detected then the provided styles will be given in as function parameters into the `animate`
         * method (or as part of the `options` parameter):
         *
         * ```js
         * ngModule.animation('.my-inline-animation', function() {
         *   return {
         *     animate : function(element, from, to, done, options) {
         *       //animation
         *       done();
         *     }
         *   }
         * });
         * ```
         *  @return {import('./animate-runner').AnimateRunner} the animation runner
         */
        animate(element, from, to, className, options) {
          options = prepareAnimateOptions(options);
          options.from = options.from ? extend(options.from, from) : from;
          options.to = options.to ? extend(options.to, to) : to;

          className = className || "ng-inline-animate";
          options.tempClasses = mergeClasses(options.tempClasses, className);
          return $$animateQueue.push(element, "animate", options);
        },
      };
    },
  ];
}

/**
 * Removes a trailing hash ('#') from the given URL if it exists.
 *
 * @param {string} url
 * @returns {string}
 */
function trimEmptyHash(url) {
  return url.replace(/#$/, "");
}

/**
 * @typedef {function(string, string|null): any} UrlChangeListener
 */

/**
 * This object has two goals:
 *
 * - hide all the global state in the browser caused by the window object
 * - abstract away all the browser specific features and inconsistencies
 */
class Browser {
  /**
   * @param {import('../core/task-tracker-factory.js').TaskTracker} taskTracker
   */
  constructor(taskTracker) {
    /**
     * @type {import('../core/task-tracker-factory.js').TaskTracker} taskTracker
     */
    this.taskTracker = taskTracker;
    this.pendingDeferIds = {};
    /** @type {Array<UrlChangeListener>} */
    this.urlChangeListeners = [];
    this.urlChangeInit = false;

    /** @type {any} */
    this.cachedState = null;
    /** @type {any} */
    this.lastHistoryState = null;
    /** @type {string} */
    this.lastBrowserUrl = window.location.href;
    /** @type {HTMLBaseElement | null} */
    this.baseElement = document.querySelector("base");

    // Task-tracking API
    this.$$completeOutstandingRequest =
      this.taskTracker.completeTask.bind(taskTracker);
    this.$$incOutstandingRequestCount =
      this.taskTracker.incTaskCount.bind(taskTracker);
    this.notifyWhenNoOutstandingRequests =
      this.taskTracker.notifyWhenNoPendingTasks.bind(taskTracker);

    this.cacheState();
  }

  /// ///////////////////////////////////////////////////////////
  // URL API
  /// ///////////////////////////////////////////////////////////

  url(url, state) {
    if (state === undefined) {
      state = null;
    }

    // setter
    if (url) {
      url = urlResolve(url).href;

      if (this.lastBrowserUrl === url && this.lastHistoryState === state) {
        return this;
      }

      this.lastBrowserUrl = url;
      this.lastHistoryState = state;
      history.pushState(state, "", url);
      this.cacheState();
      return this;
    }

    // getter
    return trimEmptyHash(window.location.href);
  }

  /**
   * Returns the cached state.
   *
   * @returns {any} The cached state.
   */
  state() {
    return this.cachedState;
  }

  /**
   * Caches the current state and fires the URL change event.
   *
   * @private
   */
  cacheStateAndFireUrlChange() {
    this.fireStateOrUrlChange();
  }

  /**
   * Caches the current state.
   *
   * @private
   */
  cacheState() {
    const currentState = history.state ?? null;
    if (!equals$1(currentState, this.lastCachedState)) {
      this.cachedState = currentState;
      this.lastCachedState = currentState;
      this.lastHistoryState = currentState;
    }
  }

  /**
   * Fires the state or URL change event.
   *
   * @private
   */
  fireStateOrUrlChange() {
    const prevLastHistoryState = this.lastHistoryState;
    this.cacheState();

    if (
      this.lastBrowserUrl === this.url() &&
      prevLastHistoryState === this.cachedState
    ) {
      return;
    }

    this.lastBrowserUrl = /** @type {string} */ (this.url());
    this.lastHistoryState = this.cachedState;
    this.urlChangeListeners.forEach((listener) => {
      listener(trimEmptyHash(window.location.href), this.cachedState);
    });
  }

  /**
   * Registers a callback to be called when the URL changes.
   *
   * @param {UrlChangeListener} callback - The callback function to register.
   * @returns {UrlChangeListener} The registered callback function.
   */
  onUrlChange(callback) {
    if (!this.urlChangeInit) {
      window.addEventListener(
        "popstate",
        this.cacheStateAndFireUrlChange.bind(this),
      );
      window.addEventListener(
        "hashchange",
        this.cacheStateAndFireUrlChange.bind(this),
      );

      this.urlChangeInit = true;
    }

    this.urlChangeListeners.push(callback);
    return callback;
  }

  $$applicationDestroyed() {
    window.removeEventListener(
      "popstate",
      this.cacheStateAndFireUrlChange.bind(this),
    );
    window.removeEventListener(
      "hashchange",
      this.cacheStateAndFireUrlChange.bind(this),
    );
  }

  $$checkUrlChange() {
    this.fireStateOrUrlChange();
  }

  /// ///////////////////////////////////////////////////////////
  // Misc API
  /// ///////////////////////////////////////////////////////////

  /**
   * Returns the base href of the document.
   *
   * @returns {string} The base href.
   */
  baseHref() {
    const href = this.baseElement?.getAttribute("href");
    return href ? href.replace(/^(https?:)?\/\/[^/]*/, "") : "";
  }

  /**
   * Defers a function to be executed after a delay.
   *
   * @param {function(): any} fn - The function to defer.
   * @param {number} [delay=0] - The delay in milliseconds before executing the function.
   * @param {string} [taskType=this.taskTracker.DEFAULT_TASK_TYPE] - The type of task to track.
   * @returns {number} The timeout ID associated with the deferred function.
   */
  defer(fn, delay = 0, taskType = this.taskTracker.DEFAULT_TASK_TYPE) {
    let timeoutId;

    this.taskTracker.incTaskCount(taskType);
    timeoutId = window.setTimeout(() => {
      delete this.pendingDeferIds[timeoutId];
      this.taskTracker.completeTask(fn, taskType);
    }, delay);
    this.pendingDeferIds[timeoutId] = taskType;

    return timeoutId;
  }

  /**
   * Cancels a deferred function.
   *
   * @param {number} deferId - The ID of the deferred function to cancel.
   * @returns {boolean} True if the function was successfully canceled, false otherwise.
   */
  cancel(deferId) {
    if (Object.prototype.hasOwnProperty.call(this.pendingDeferIds, deferId)) {
      const taskType = this.pendingDeferIds[deferId];
      delete this.pendingDeferIds[deferId];
      window.clearTimeout(deferId);
      this.taskTracker.completeTask(() => {}, taskType);
      return true;
    }
    return false;
  }
}

/**
 * This object has two goals:
 *
 * - hide all the global state in the browser caused by the window object
 * - abstract away all the browser specific features and inconsistencies
 *
 * Remove this in the future
 */
class BrowserProvider {
  $get = [
    "$$taskTrackerFactory",
    /**
     * @param {import('../core/task-tracker-factory').TaskTracker} $$taskTrackerFactory
     * @returns
     */
    ($$taskTrackerFactory) => new Browser($$taskTrackerFactory),
  ];
}

function AnimateAsyncRunFactoryProvider() {
  this.$get = [
    function () {
      var waitQueue = [];

      function waitForTick(fn) {
        waitQueue.push(fn);
        if (waitQueue.length > 1) return;
        window.requestAnimationFrame(function () {
          for (var i = 0; i < waitQueue.length; i++) {
            waitQueue[i]();
          }
          waitQueue = [];
        });
      }

      return function () {
        var passed = false;
        waitForTick(function () {
          passed = true;
        });
        return function (callback) {
          if (passed) {
            callback();
          } else {
            waitForTick(callback);
          }
        };
      };
    },
  ];
}

const INITIAL_STATE = 0;
const DONE_PENDING_STATE = 1;
const DONE_COMPLETE_STATE = 2;
let $$animateAsyncRun;

function AnimateRunnerFactoryProvider() {
  this.$get = [
    "$$animateAsyncRun",
    function (animateAsyncRun) {
      $$animateAsyncRun = animateAsyncRun;
      return AnimateRunner;
    },
  ];
}

class AnimateRunner {
  static chain(chain, callback) {
    let index = 0;

    function next() {
      if (index === chain.length) {
        callback(true);
        return;
      }

      chain[index]((response) => {
        if (response === false) {
          callback(false);
          return;
        }
        index++;
        next();
      });
    }

    next();
  }

  static all(runners, callback) {
    let count = 0;
    let status = true;

    runners.forEach((runner) => {
      runner.done(onProgress);
    });

    function onProgress(response) {
      status = status && response;
      if (++count === runners.length) {
        callback(status);
      }
    }
  }

  constructor(host) {
    this.setHost(host);

    const rafTick = $$animateAsyncRun();
    const timeoutTick = (fn) => {
      setTimeout(fn, 0, false);
    };

    this._doneCallbacks = [];
    this._tick = (fn) => {
      if (document.hidden) {
        timeoutTick(fn);
      } else {
        rafTick(fn);
      }
    };
    this._state = 0;
  }

  setHost(host) {
    this.host = host || {};
  }

  done(fn) {
    if (this._state === DONE_COMPLETE_STATE) {
      fn();
    } else {
      this._doneCallbacks.push(fn);
    }
  }

  progress() {}

  getPromise() {
    if (!this.promise) {
      const self = this;
      this.promise = new Promise((resolve, reject) => {
        self.done((status) => {
          if (status === false) {
            reject();
          } else {
            resolve();
          }
        });
      });
    }
    return this.promise;
  }

  then(resolveHandler, rejectHandler) {
    return this.getPromise().then(resolveHandler, rejectHandler);
  }

  catch(handler) {
    return this.getPromise().catch(handler);
  }

  finally(handler) {
    return this.getPromise().finally(handler);
  }

  pause() {
    if (this.host.pause) {
      this.host.pause();
    }
  }

  resume() {
    if (this.host.resume) {
      this.host.resume();
    }
  }

  end() {
    if (this.host.end) {
      this.host.end();
    }
    this._resolve(true);
  }

  cancel() {
    if (this.host.cancel) {
      this.host.cancel();
    }
    this._resolve(false);
  }

  complete(response) {
    if (this._state === INITIAL_STATE) {
      this._state = DONE_PENDING_STATE;
      this._tick(() => {
        this._resolve(response);
      });
    }
  }

  _resolve(response) {
    if (this._state !== DONE_COMPLETE_STATE) {
      this._doneCallbacks.forEach((fn) => {
        fn(response);
      });
      this._doneCallbacks.length = 0;
      this._state = DONE_COMPLETE_STATE;
    }
  }
}

/**
 * A cache for maping template names to their respective content.
 *
 * @typedef {Map<string, string>} TemplateCache
 */

/**
 * Service responsible for providing a cache for templates.
 *
 * @class TemplateCacheProvider
 * @description Provides an instance of a template cache that can be used to store and retrieve template content.
 */
class TemplateCacheProvider {
  /**
   * @description Returns a new instance of a `TemplateCache`, which is a Map used to store templates.
   * @returns {TemplateCache} A new instance of the template cache (Map object).
   */
  $get = () => new Map();
}

/**
 * Any uncaught exception in AngularJS expressions is delegated to this service.
 * The default implementation simply delegates to `$log.error` which logs it into
 * the browser console.
 *
 *
 * ## Example:
 *
 * The example below will overwrite the default `$exceptionHandler` in order to (a) log uncaught
 * errors to the backend for later inspection by the developers and (b) to use `$log.warn()` instead
 * of `$log.error()`.
 *
 * ```js
 *   angular.
 *     module('exceptionOverwrite', []).
 *     factory('$exceptionHandler', ['$log', 'logErrorsToBackend', function($log, logErrorsToBackend) {
 *       return function myExceptionHandler(exception, cause) {
 *         logErrorsToBackend(exception, cause);
 *         $log.warn(exception, cause);
 *       };
 *     }]);
 * ```
 *
 * <hr />
 * Note, that code executed in event-listeners (even those registered using JQLite's `on`/`bind`
 * methods) does not delegate exceptions to the {@link angular.ErrorHandler }
 * (unless executed during a digest).
 *
 * If you wish, you can manually delegate exceptions, e.g.
 * `try { ... } catch(e) { $exceptionHandler(e); }`
 *
 */

/** @type {import('../services/log').LogService} */
let log;

/**
 * @callback ErrorHandler
 * @param {Error} exception - Exception associated with the error.
 * @param {string} [cause] - Optional information about the context in which the error was thrown.
 * @returns {void}
 */
const errorHandler = (exception, cause) => {
  log.error(exception, cause);
};

/**
 * @constructor
 * @this {import('../types.js').ServiceProvider}
 */
function ExceptionHandlerProvider() {
  this.$get = [
    "$log",
    /**
     * @param {import('../services/log').LogService} $log
     * @returns {ErrorHandler}
     */
    function ($log) {
      log = $log;
      return errorHandler;
    },
  ];
}

/**
 * @returns {function(Array, string|Object|function(any, number, []):[], function(any, any):boolean|boolean, string?): Array}
 */
function filterFilter() {
  /**
   * @param {Array} array The source array.
   * @param {string|Object|function(any, number, []):[]} expression The predicate to be used for selecting items from `array`.
   * @param {function(any, any):boolean|boolean} [comparator] Comparator which is used in determining if values retrieved using `expression`
   * (when it is not a function) should be considered a match based on the expected value (from the filter expression) and actual value (from the object in the array).
   * @param {string} [anyPropertyKey] The special property name that matches against any property.
   * @return {Array} Filtered array
   */
  return function (array, expression, comparator, anyPropertyKey) {
    if (!isArrayLike(array)) {
      if (array == null) {
        return array;
      }
      throw minErr("filter")(
        "notarray",
        "Expected array but received: {0}",
        array,
      );
    }

    anyPropertyKey = anyPropertyKey || "$";
    let predicateFn;

    let matchAgainstAnyProp = false;

    switch (getTypeForFilter(expression)) {
      case "function":
        predicateFn = expression;
        break;
      case "boolean":
      case "null":
      case "number":
      case "string":
        matchAgainstAnyProp = true;
      // falls through
      case "object":
        predicateFn = createPredicateFn(
          expression,
          comparator,
          anyPropertyKey,
          matchAgainstAnyProp,
        );
        break;
      default:
        return array;
    }

    return Array.prototype.filter.call(array, predicateFn);
  };
}

// Helper functions for `filterFilter`
function createPredicateFn(
  expression,
  comparator,
  anyPropertyKey,
  matchAgainstAnyProp,
) {
  const shouldMatchPrimitives =
    isObject(expression) && anyPropertyKey in expression;
  let predicateFn;

  if (comparator === true) {
    comparator = equals$1;
  } else if (!isFunction(comparator)) {
    comparator = function (actual, expected) {
      if (isUndefined(actual)) {
        // No substring matching against `undefined`
        return false;
      }
      if (actual === null || expected === null) {
        // No substring matching against `null`; only match against `null`
        return actual === expected;
      }
      if (
        isObject(expected) ||
        (isObject(actual) && !hasCustomToString(actual))
      ) {
        // Should not compare primitives against objects, unless they have custom `toString` method
        return false;
      }

      actual = `${actual}`.toLowerCase();
      expected = `${expected}`.toLowerCase();
      return actual.indexOf(expected) !== -1;
    };
  }

  predicateFn = function (item) {
    if (shouldMatchPrimitives && !isObject(item)) {
      return deepCompare(
        item,
        expression[anyPropertyKey],
        comparator,
        anyPropertyKey,
        false,
      );
    }
    return deepCompare(
      item,
      expression,
      comparator,
      anyPropertyKey,
      matchAgainstAnyProp,
    );
  };

  return predicateFn;
}

function deepCompare(
  actual,
  expected,
  comparator,
  anyPropertyKey,
  matchAgainstAnyProp,
  dontMatchWholeObject,
) {
  const actualType = getTypeForFilter(actual);
  const expectedType = getTypeForFilter(expected);

  if (expectedType === "string" && expected.charAt(0) === "!") {
    return !deepCompare(
      actual,
      expected.substring(1),
      comparator,
      anyPropertyKey,
      matchAgainstAnyProp,
    );
  }
  if (Array.isArray(actual)) {
    // In case `actual` is an array, consider it a match
    // if ANY of it's items matches `expected`
    return actual.some((item) =>
      deepCompare(
        item,
        expected,
        comparator,
        anyPropertyKey,
        matchAgainstAnyProp,
      ),
    );
  }

  switch (actualType) {
    case "object":
      if (matchAgainstAnyProp) {
        for (let key in actual) {
          // Under certain, rare, circumstances, key may not be a string and `charAt` will be undefined
          // See: https://github.com/angular/angular.js/issues/15644
          if (
            key.charAt &&
            key.charAt(0) !== "$" &&
            deepCompare(actual[key], expected, comparator, anyPropertyKey, true)
          ) {
            return true;
          }
        }
        return dontMatchWholeObject
          ? false
          : deepCompare(actual, expected, comparator, anyPropertyKey, false);
      }
      if (expectedType === "object") {
        for (let key in expected) {
          const expectedVal = expected[key];
          if (isFunction(expectedVal) || isUndefined(expectedVal)) {
            continue;
          }

          const matchAnyProperty = key === anyPropertyKey;
          const actualVal = matchAnyProperty ? actual : actual[key];
          if (
            !deepCompare(
              actualVal,
              expectedVal,
              comparator,
              anyPropertyKey,
              matchAnyProperty,
              matchAnyProperty,
            )
          ) {
            return false;
          }
        }
        return true;
      }
      return comparator(actual, expected);

    case "function":
      return false;
    default:
      return comparator(actual, expected);
  }
}

// Used for easily differentiating between `null` and actual `object`
function getTypeForFilter(val) {
  return val === null ? "null" : typeof val;
}

/**
 * @returns {function(Object, number?): Object}
 */
function jsonFilter() {
  return function (object, spacing) {
    if (isUndefined(spacing)) {
      spacing = 2;
    }
    return toJson(object, spacing);
  };
}

/**
 * @returns {function(Array|ArrayLike|string|number, string|number, (string|number)?):Array|ArrayLike|string|number}
 */
function limitToFilter() {
  /**
   * @param {Array|ArrayLike|string|number|Function} input Array/array-like, string, or number to be limited.
   * @param {string|number} limit The length of the returned array or string.
   * @param {string|number} [begin] Index at which to begin limitation. As a negative index, `begin` indicates an offset from the end of `input`. Defaults to `0`.
   */
  return function (input, limit, begin) {
    if (isFunction(input)) {
      input = /** @type {Function} */ (input)();
    }
    if (Math.abs(Number(limit)) === Infinity) {
      limit = Number(limit);
    } else {
      limit = toInt(/** @type {string} */ (limit));
    }
    if (isNumberNaN(limit)) return input;

    if (isNumber(input)) input = input.toString();
    if (!isArrayLike(input)) return input;

    begin =
      !begin || isNaN(/** @type {any} */ (begin))
        ? 0
        : toInt(/** @type {string} */ (begin));
    begin =
      begin < 0 ? Math.max(0, /** @type {[]} */ (input).length + begin) : begin;

    if (limit >= 0) {
      return sliceFn(input, begin, begin + limit);
    } else {
      if (begin === 0) {
        return sliceFn(input, limit, /** @type {[]} */ (input).length);
      } else {
        return sliceFn(input, Math.max(0, begin + limit), begin);
      }
    }
  };
}

function sliceFn(input, begin, end) {
  if (isString(input)) return input.slice(begin, end);

  return [].slice.call(input, begin, end);
}

orderByFilter.$inject = ["$parse"];

function orderByFilter($parse) {
  return function (array, sortPredicate, reverseOrder, compareFn) {
    if (array == null) return array;
    if (isFunction(array)) return array();
    if (!isArrayLike(array)) {
      throw minErr("orderBy")(
        "notarray",
        "Expected array but received: {0}",
        array,
      );
    }

    if (!Array.isArray(sortPredicate)) {
      sortPredicate = [sortPredicate];
    }
    if (sortPredicate.length === 0) {
      sortPredicate = ["+"];
    }

    const predicates = processPredicates(sortPredicate);

    const descending = reverseOrder ? -1 : 1;

    // Define the `compare()` function. Use a default comparator if none is specified.
    const compare = isFunction(compareFn) ? compareFn : defaultCompare;

    // The next three lines are a version of a Swartzian Transform idiom from Perl
    // (sometimes called the Decorate-Sort-Undecorate idiom)
    // See https://en.wikipedia.org/wiki/Schwartzian_transform
    const compareValues = Array.prototype.map.call(array, getComparisonObject);
    compareValues.sort(doComparison);
    array = compareValues.map((item) => item.value);

    return array;

    function getComparisonObject(value, index) {
      // NOTE: We are adding an extra `tieBreaker` value based on the element's index.
      // This will be used to keep the sort stable when none of the input predicates can
      // distinguish between two elements.
      return {
        value,
        tieBreaker: { value: index, type: "number", index },
        predicateValues: predicates.map((predicate) =>
          getPredicateValue(predicate.get(value), index),
        ),
      };
    }

    function doComparison(v1, v2) {
      for (let i = 0, ii = predicates.length; i < ii; i++) {
        const result = compare(v1.predicateValues[i], v2.predicateValues[i]);
        if (result) {
          return result * predicates[i].descending * descending;
        }
      }

      return (
        (compare(v1.tieBreaker, v2.tieBreaker) ||
          defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending
      );
    }
  };

  function processPredicates(sortPredicates) {
    return sortPredicates.map((predicate) => {
      let descending = 1;
      let get = (x) => x;

      if (isFunction(predicate)) {
        get = predicate;
      } else if (isString(predicate)) {
        if (predicate.charAt(0) === "+" || predicate.charAt(0) === "-") {
          descending = predicate.charAt(0) === "-" ? -1 : 1;
          predicate = predicate.substring(1);
        }
        if (predicate !== "") {
          let parsed = $parse(predicate);
          if (parsed.constant) {
            const key = parsed();
            get = (value) => value[key];
          } else {
            get = parsed;
          }
        }
      }
      return { get, descending };
    });
  }

  function isPrimitive(value) {
    switch (typeof value) {
      case "number": /* falls through */
      case "boolean": /* falls through */
      case "string":
        return true;
      default:
        return false;
    }
  }

  function objectValue(value) {
    // If `valueOf` is a valid function use that
    if (isFunction(value.valueOf)) {
      value = value.valueOf();
      if (isPrimitive(value)) return value;
    }
    // If `toString` is a valid function and not the one from `Object.prototype` use that
    if (hasCustomToString(value)) {
      value = value.toString();
      if (isPrimitive(value)) return value;
    }

    return value;
  }

  function getPredicateValue(value, index) {
    /** @type {String} */ let type = typeof value;
    if (value === null) {
      type = "null";
    } else if (type === "object") {
      value = objectValue(value);
    }
    return { value, type, index };
  }

  function defaultCompare(v1, v2) {
    let result = 0;
    const type1 = v1.type;
    const type2 = v2.type;

    if (type1 === type2) {
      let value1 = v1.value;
      let value2 = v2.value;

      if (type1 === "string") {
        // Compare strings case-insensitively
        value1 = value1.toLowerCase();
        value2 = value2.toLowerCase();
      } else if (type1 === "object") {
        // For basic objects, use the position of the object
        // in the collection instead of the value
        if (isObject(value1)) value1 = v1.index;
        if (isObject(value2)) value2 = v2.index;
      }

      if (value1 !== value2) {
        result = value1 < value2 ? -1 : 1;
      }
    } else {
      result =
        type1 === "undefined"
          ? 1
          : type2 === "undefined"
            ? -1
            : type1 === "null"
              ? 1
              : type2 === "null"
                ? -1
                : type1 < type2
                  ? -1
                  : 1;
    }

    return result;
  }
}

/**
 * `isState` Filter: truthy if the current state is the parameter
 *
 * Translates to [[StateService.is]] `$state.is("stateName")`.
 *
 * #### Example:
 * ```html
 * <div ng-if="'stateName' | isState">show if state is 'stateName'</div>
 * ```
 */
$IsStateFilter.$inject = ["$state"];
function $IsStateFilter($state) {
  const isFilter = function (state, params, options) {
    return $state.is(state, params, options);
  };
  //isFilter.$stateful = true;
  return isFilter;
}
/**
 * `includedByState` Filter: truthy if the current state includes the parameter
 *
 * Translates to [[StateService.includes]]` $state.is("fullOrPartialStateName")`.
 *
 * #### Example:
 * ```html
 * <div ng-if="'fullOrPartialStateName' | includedByState">show if state includes 'fullOrPartialStateName'</div>
 * ```
 */
$IncludedByStateFilter.$inject = ["$state"];
function $IncludedByStateFilter($state) {
  const includesFilter = function (state, params, options) {
    return $state.includes(state, params, options);
  };
  //includesFilter.$stateful = true;
  return includesFilter;
}

FilterProvider.$inject = ["$provide"];
function FilterProvider($provide) {
  const suffix = "Filter";

  function register(name, factory) {
    if (isObject(name)) {
      const filters = {};
      Object.entries(name).forEach(([key, filter]) => {
        filters[key] = register(key, filter);
      });
      return filters;
    }
    return $provide.factory(name + suffix, factory);
  }
  this.register = register;

  this.$get = [
    "$injector",
    /**
     *
     * @param {import("../../core/di/internal-injector").InjectorService} $injector
     * @returns
     */
    function ($injector) {
      return function (name) {
        return $injector.get(name + suffix);
      };
    },
  ];

  register("filter", filterFilter);
  register("json", jsonFilter);
  register("limitTo", limitToFilter);
  register("orderBy", orderByFilter);
  register("isState", $IsStateFilter);
  register("includedByState", $IncludedByStateFilter);
}

const PURITY_ABSOLUTE = 1;
const PURITY_RELATIVE = 2;

class ASTInterpreter {
  /**
   * @param {function(any):any} $filter
   */
  constructor($filter) {
    this.$filter = $filter;
  }

  /**
   * Compiles the AST into a function.
   * @param {import("./ast/ast").ASTNode} ast - The AST to compile.
   * @returns {import("./parse").CompiledExpression}
   */
  compile(ast) {
    let decoratedNode = findConstantAndWatchExpressions(ast, this.$filter);
    /** @type {import("./ast/ast").ASTNode} */
    let assignable;
    /** @type {import("./parse").CompiledExpression} */
    let assign;
    if ((assignable = assignableAST(decoratedNode))) {
      assign = /** @type {import("./parse").CompiledExpression} */ (
        this.recurse(assignable)
      );
    }
    const toWatch = getInputs(decoratedNode.body);
    let inputs;
    if (toWatch) {
      inputs = [];
      for (const [key, watch] of Object.entries(toWatch)) {
        const input = /** @type {import("./parse").CompiledExpression} */ (
          this.recurse(watch)
        );
        input.isPure = watch.isPure;
        watch.input = input;
        inputs.push(input);
        watch.watchId = key;
      }
    }
    const expressions = [];
    decoratedNode.body.forEach((expression) => {
      expressions.push(this.recurse(expression.expression));
    });

    /** @type {import("./parse").CompiledExpression} */
    const fn =
      decoratedNode.body.length === 0
        ? () => {}
        : decoratedNode.body.length === 1
          ? expressions[0]
          : function (scope, locals) {
              let lastValue;
              expressions.forEach((exp) => {
                lastValue = exp(scope, locals);
              });
              return lastValue;
            };
    if (assign) {
      fn.assign = (scope, value, locals) => assign(scope, locals, value);
    }
    if (inputs) {
      fn.inputs = inputs;
    }
    fn.decoratedNode = decoratedNode;
    return fn;
  }

  /**
   * Recurses the AST nodes.
   * @param {import("./ast/ast").ASTNode} ast - The AST node.
   * @param {Object} [context] - The context.
   * @param {boolean|1} [create] - The create flag.
   * @returns {import("./parse").CompiledExpressionFunction} The recursive function.
   */
  recurse(ast, context, create) {
    let left;
    let right;
    const self = this;
    let args;
    switch (ast.type) {
      case ASTType.Literal:
        return this.value(ast.value, context);
      case ASTType.UnaryExpression:
        right = this.recurse(ast.argument);
        return this[`unary${ast.operator}`](right, context);
      case ASTType.BinaryExpression:
        left = this.recurse(ast.left);
        right = this.recurse(ast.right);
        return this[`binary${ast.operator}`](left, right, context);
      case ASTType.LogicalExpression:
        left = this.recurse(ast.left);
        right = this.recurse(ast.right);
        return this[`binary${ast.operator}`](left, right, context);
      case ASTType.ConditionalExpression:
        return this["ternary?:"](
          this.recurse(ast.test),
          this.recurse(ast.alternate),
          this.recurse(ast.consequent),
          context,
        );
      case ASTType.Identifier:
        return self.identifier(ast.name, context, create);
      case ASTType.MemberExpression:
        left = this.recurse(ast.object, false, !!create);
        if (!ast.computed) {
          right = ast.property.name;
        }
        if (ast.computed) right = this.recurse(ast.property);
        return ast.computed
          ? this.computedMember(
              left,
              /** @type {function } */ (right),
              context,
              create,
            )
          : this.nonComputedMember(
              left,
              /** @type {string } */ (right),
              context,
              create,
            );
      case ASTType.CallExpression:
        args = [];
        ast.arguments.forEach((expr) => {
          args.push(self.recurse(expr));
        });
        if (ast.filter) right = this.$filter(ast.callee.name);
        if (!ast.filter) right = this.recurse(ast.callee, true);
        return ast.filter
          ? function (scope, locals, assign) {
              const values = [];
              for (let i = 0; i < args.length; ++i) {
                const res = args[i](scope, locals, assign);
                values.push(res);
              }
              const value = () => {
                return right.apply(undefined, values);
              };
              return context
                ? { context: undefined, name: undefined, value }
                : value;
            }
          : function (scope, locals, assign) {
              const rhs = right(scope, locals, assign);
              let value;
              if (rhs.value != null && isFunction(rhs.value)) {
                const values = [];
                for (let i = 0; i < args.length; ++i) {
                  const res = args[i](scope, locals, assign);
                  values.push(isFunction(res) ? res() : res);
                }
                value = rhs.value.apply(rhs.context, values);
              }
              return context ? { value } : value;
            };
      case ASTType.AssignmentExpression:
        left = this.recurse(ast.left, true, 1);
        right = this.recurse(ast.right);
        return function (scope, locals, assign) {
          const lhs = left(scope, locals, assign);
          const rhs = right(scope, locals, assign);
          lhs.context[lhs.name] = rhs;
          return context ? { value: rhs } : rhs;
        };
      case ASTType.ArrayExpression:
        args = [];
        ast.elements.forEach((expr) => {
          args.push(self.recurse(expr));
        });
        return function (scope, locals, assign) {
          const value = [];
          for (let i = 0; i < args.length; ++i) {
            value.push(args[i](scope, locals, assign));
          }
          return context ? { value } : value;
        };
      case ASTType.ObjectExpression:
        args = [];
        ast.properties.forEach((property) => {
          if (property.computed) {
            args.push({
              key: self.recurse(property.key),
              computed: true,
              value: self.recurse(property.value),
            });
          } else {
            args.push({
              key:
                property.key.type === ASTType.Identifier
                  ? property.key.name
                  : `${property.key.value}`,
              computed: false,
              value: self.recurse(property.value),
            });
          }
        });
        return function (scope, locals, assign) {
          const value = {};
          for (let i = 0; i < args.length; ++i) {
            if (args[i].computed) {
              value[args[i].key(scope, locals, assign)] = args[i].value(
                scope,
                locals,
                assign,
              );
            } else {
              value[args[i].key] = args[i].value(scope, locals, assign);
            }
          }
          return context ? { value } : value;
        };
      case ASTType.ThisExpression:
        return function (scope) {
          return context ? { value: scope } : scope;
        };
      case ASTType.LocalsExpression:
        return function (scope, locals) {
          return context ? { value: locals } : locals;
        };
      case ASTType.NGValueParameter:
        return function (scope, locals, assign) {
          return context ? { value: assign } : assign;
        };
    }
  }

  /**
   * Unary plus operation.
   * @param {function} argument - The argument function.
   * @param {Object} [context] - The context.
   * @returns {function} The unary plus function.
   */
  "unary+"(argument, context) {
    return function (scope, locals, assign) {
      let arg = argument(scope, locals, assign);
      if (isDefined(arg)) {
        arg = +arg;
      } else {
        arg = 0;
      }
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Unary minus operation.
   * @param {function} argument - The argument function.
   * @param {Object} [context] - The context.
   * @returns {function} The unary minus function.
   */
  "unary-"(argument, context) {
    return function (scope, locals, assign) {
      let arg = argument(scope, locals, assign);
      if (isDefined(arg)) {
        arg = -arg;
      } else {
        arg = -0;
      }
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Unary negation operation.
   * @param {function} argument - The argument function.
   * @param {Object} [context] - The context.
   * @returns {function} The unary negation function.
   */
  "unary!"(argument, context) {
    return function (scope, locals, assign) {
      const arg = !argument(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary plus operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary plus function.
   */
  "binary+"(left, right, context) {
    return function (scope, locals, assign) {
      const lhs = left(scope, locals, assign);
      const rhs = right(scope, locals, assign);
      const arg = plusFn(lhs, rhs);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary minus operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary minus function.
   */
  "binary-"(left, right, context) {
    return function (scope, locals, assign) {
      const lhs = left(scope, locals, assign);
      const rhs = right(scope, locals, assign);
      const arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary multiplication operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary multiplication function.
   */
  "binary*"(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) * right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  "binary/"(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) / right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary division operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary division function.
   */
  "binary%"(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) % right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary strict equality operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary strict equality function.
   */
  "binary==="(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) === right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary strict inequality operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary strict inequality function.
   */
  "binary!=="(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) !== right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary equality operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary equality function.
   */
  "binary=="(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) == right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary inequality operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary inequality function.
   */
  "binary!="(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) != right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary less-than operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary less-than function.
   */
  "binary<"(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) < right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary greater-than operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary greater-than function.
   */
  "binary>"(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) > right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary less-than-or-equal-to operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary less-than-or-equal-to function.
   */
  "binary<="(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) <= right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary greater-than-or-equal-to operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary greater-than-or-equal-to function.
   */
  "binary>="(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) >= right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }
  /**
   * Binary logical AND operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary logical AND function.
   */
  "binary&&"(left, right, context) {
    return (scope, locals, assign) => {
      const arg = left(scope, locals, assign) && right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Binary logical OR operation.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @returns {function} The binary logical OR function.
   */
  "binary||"(left, right, context) {
    return function (scope, locals, assign) {
      const arg = left(scope, locals, assign) || right(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Ternary conditional operation.
   * @param {function} test - The test function.
   * @param {function} alternate - The alternate function.
   * @param {function} consequent - The consequent function.
   * @param {Object} [context] - The context.
   * @returns {function} The ternary conditional function.
   */
  "ternary?:"(test, alternate, consequent, context) {
    return function (scope, locals, assign) {
      const arg = test(scope, locals, assign)
        ? alternate(scope, locals, assign)
        : consequent(scope, locals, assign);
      return context ? { value: arg } : arg;
    };
  }

  /**
   * Returns the value of a literal.
   * @param {*} value - The literal value.
   * @param {Object} [context] - The context.
   * @returns {function} The function returning the literal value.
   */
  value(value, context) {
    return function () {
      return context ? { context: undefined, name: undefined, value } : value;
    };
  }

  /**
   * Returns the value of an identifier.
   * @param {string} name - The identifier name.
   * @param {Object} [context] - The context.
   * @param {boolean|1} [create] - Whether to create the identifier if it does not exist.
   * @returns {function} The function returning the identifier value.
   */
  identifier(name, context, create) {
    return function (scope, locals) {
      const base = locals && name in locals ? locals : scope;
      if (create && create !== 1 && base && base[name] == null) {
        base[name] = {};
      }
      let value = undefined;
      if (base) {
        value = base[name];
      }
      if (context) {
        return { context: base, name, value };
      }
      return value;
    };
  }

  /**
   * Returns the value of a computed member expression.
   * @param {function} left - The left operand function.
   * @param {function} right - The right operand function.
   * @param {Object} [context] - The context.
   * @param {boolean|1} [create] - Whether to create the member if it does not exist.
   * @returns {function} The function returning the computed member value.
   */
  computedMember(left, right, context, create) {
    return function (scope, locals, assign) {
      const lhs = left(scope, locals, assign);
      let rhs;
      let value;
      if (lhs != null) {
        rhs = right(scope, locals, assign);
        rhs = getStringValue(rhs);
        if (create && create !== 1) {
          if (lhs && !lhs[rhs]) {
            lhs[rhs] = {};
          }
        }
        value = lhs[rhs];
      }
      if (context) {
        return { context: lhs, name: rhs, value };
      }
      return value;
    };
  }

  /**
   * Returns the value of a non-computed member expression.
   * @param {function} left - The left operand function.
   * @param {string} right - The right operand function.
   * @param {Object} [context] - The context.
   * @param {boolean|1} [create] - Whether to create the member if it does not exist.
   * @returns {function} The function returning the non-computed member value.
   */
  nonComputedMember(left, right, context, create) {
    return function (scope, locals, assign) {
      const lhs = left(scope, locals, assign);
      if (create && create !== 1) {
        if (lhs && lhs[right] == null) {
          lhs[right] = {};
        }
      }
      const value = lhs != null ? lhs[right] : undefined;
      if (context) {
        return { context: lhs, name: right, value };
      }
      return value;
    };
  }
}

/**
 * @typedef {import("./ast/ast").ASTNode & {
 *  isPure: boolean|number,
 *  constant: boolean,
 *  toWatch: Array,
 * }} DecoratedASTNode
 */

/**
 * Decorates AST with constant, toWatch, and isPure properties
 * @param {import("./ast/ast").ASTNode} ast
 * @param {function(any):any} $filter
 * @param {boolean|1|2} [parentIsPure]
 * @returns {DecoratedASTNode}
 */
function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
  let allConstants;
  let argsToWatch;
  let isStatelessFilter;
  let decoratedNode = /** @type  {DecoratedASTNode} */ (ast);
  let decoratedLeft,
    decoratedRight,
    decoratedTest,
    decoratedAlternate,
    decoratedConsequent,
    decoratedObject,
    decoratedProperty,
    decoratedKey;
  const astIsPure = (decoratedNode.isPure = isPure(ast, parentIsPure));

  switch (ast.type) {
    case ASTType.Program:
      allConstants = true;
      decoratedNode.body.forEach((expr) => {
        let decorated = findConstantAndWatchExpressions(
          expr.expression,
          $filter,
          astIsPure,
        );
        allConstants = allConstants && decorated.constant;
      });
      decoratedNode.constant = allConstants;
      return decoratedNode;
    case ASTType.Literal:
      decoratedNode.constant = true;
      decoratedNode.toWatch = [];
      return decoratedNode;
    case ASTType.UnaryExpression:
      var decorated = findConstantAndWatchExpressions(
        decoratedNode.argument,
        $filter,
        astIsPure,
      );
      decoratedNode.constant = decorated.constant;
      decoratedNode.toWatch = decorated.toWatch;
      return decoratedNode;
    case ASTType.BinaryExpression:
      decoratedLeft = findConstantAndWatchExpressions(
        decoratedNode.left,
        $filter,
        astIsPure,
      );
      decoratedRight = findConstantAndWatchExpressions(
        decoratedNode.right,
        $filter,
        astIsPure,
      );
      decoratedNode.constant =
        decoratedLeft.constant && decoratedRight.constant;
      decoratedNode.toWatch = decoratedLeft.toWatch.concat(
        decoratedRight.toWatch,
      );
      return decoratedNode;
    case ASTType.LogicalExpression:
      decoratedLeft = findConstantAndWatchExpressions(
        decoratedNode.left,
        $filter,
        astIsPure,
      );
      decoratedRight = findConstantAndWatchExpressions(
        decoratedNode.right,
        $filter,
        astIsPure,
      );
      decoratedNode.constant =
        decoratedLeft.constant && decoratedRight.constant;
      decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];
      return decoratedNode;
    case ASTType.ConditionalExpression:
      decoratedTest = findConstantAndWatchExpressions(
        ast.test,
        $filter,
        astIsPure,
      );
      decoratedAlternate = findConstantAndWatchExpressions(
        ast.alternate,
        $filter,
        astIsPure,
      );
      decoratedConsequent = findConstantAndWatchExpressions(
        ast.consequent,
        $filter,
        astIsPure,
      );
      decoratedNode.constant =
        decoratedTest.constant &&
        decoratedAlternate.constant &&
        decoratedConsequent.constant;
      decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];
      return decoratedNode;
    case ASTType.Identifier:
      decoratedNode.constant = false;
      decoratedNode.toWatch = [ast];
      return decoratedNode;
    case ASTType.MemberExpression:
      decoratedObject = findConstantAndWatchExpressions(
        ast.object,
        $filter,
        astIsPure,
      );
      if (ast.computed) {
        decoratedProperty = findConstantAndWatchExpressions(
          ast.property,
          $filter,
          astIsPure,
        );
      }
      decoratedNode.constant =
        decoratedObject.constant &&
        (!decoratedNode.computed || decoratedProperty.constant);
      decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];
      return decoratedNode;
    case ASTType.CallExpression:
      isStatelessFilter = ast.filter
        ? isStateless($filter, ast.callee.name)
        : false;
      allConstants = isStatelessFilter;
      argsToWatch = [];
      ast.arguments.forEach((expr) => {
        decorated = findConstantAndWatchExpressions(expr, $filter, astIsPure);
        allConstants = allConstants && decorated.constant;
        argsToWatch.push.apply(argsToWatch, decorated.toWatch);
      });
      decoratedNode.constant = allConstants;
      decoratedNode.toWatch = isStatelessFilter ? argsToWatch : [decoratedNode];
      return decoratedNode;
    case ASTType.AssignmentExpression:
      decoratedLeft = findConstantAndWatchExpressions(
        ast.left,
        $filter,
        astIsPure,
      );
      decoratedRight = findConstantAndWatchExpressions(
        ast.right,
        $filter,
        astIsPure,
      );
      decoratedNode.constant =
        decoratedLeft.constant && decoratedRight.constant;
      decoratedNode.toWatch = [decoratedNode];
      return decoratedNode;
    case ASTType.ArrayExpression:
      allConstants = true;
      argsToWatch = [];
      ast.elements.forEach((expr) => {
        decorated = findConstantAndWatchExpressions(expr, $filter, astIsPure);
        allConstants = allConstants && decorated.constant;
        argsToWatch.push.apply(argsToWatch, decorated.toWatch);
      });
      decoratedNode.constant = allConstants;
      decoratedNode.toWatch = argsToWatch;
      return decoratedNode;
    case ASTType.ObjectExpression:
      allConstants = true;
      argsToWatch = [];
      ast.properties.forEach((property) => {
        decorated = findConstantAndWatchExpressions(
          property.value,
          $filter,
          astIsPure,
        );
        allConstants = allConstants && decorated.constant;
        argsToWatch.push.apply(argsToWatch, decorated.toWatch);
        if (property.computed) {
          // `{[key]: value}` implicitly does `key.toString()` which may be non-pure
          decoratedKey = findConstantAndWatchExpressions(
            property.key,
            $filter,
            false,
          );
          allConstants = allConstants && decoratedKey.constant;
          argsToWatch.push.apply(argsToWatch, decoratedKey.toWatch);
        }
      });
      decoratedNode.constant = allConstants;
      decoratedNode.toWatch = argsToWatch;
      return decoratedNode;
    case ASTType.ThisExpression:
      decoratedNode.constant = false;
      decoratedNode.toWatch = [];
      return decoratedNode;
    case ASTType.LocalsExpression:
      decoratedNode.constant = false;
      decoratedNode.toWatch = [];
      return decoratedNode;
  }
}

/**
 * Converts a single expression AST node into an assignment expression if the expression is assignable.
 *
 * @param {import("./ast/ast").ASTNode} ast
 * @returns {import("./ast/ast").ASTNode}
 */
function assignableAST(ast) {
  if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
    return {
      type: ASTType.AssignmentExpression,
      left: ast.body[0].expression,
      right: { type: ASTType.NGValueParameter },
      operator: "=",
    };
  }
}

function plusFn(l, r) {
  if (typeof l === "undefined" || isObject(l)) return r;
  if (typeof r === "undefined" || isObject(r)) return l;
  return l + r;
}

/**
 *
 * @param {import("./ast/ast").ASTNode[]} body
 * @returns {any}
 */
function getInputs(body) {
  if (body.length !== 1) return;
  const lastExpression = /** @type {DecoratedASTNode} */ (body[0].expression);
  const candidate = lastExpression.toWatch;
  if (candidate.length !== 1) return candidate;
  return candidate[0] !== lastExpression ? candidate : undefined;
}

/**
 * Detect nodes which could depend on non-shallow state of objects
 * @param {import("./ast/ast").ASTNode} node
 * @param {boolean|PURITY_ABSOLUTE|PURITY_RELATIVE} parentIsPure
 * @returns {boolean|PURITY_ABSOLUTE|PURITY_RELATIVE}
 */
function isPure(node, parentIsPure) {
  switch (node.type) {
    // Computed members might invoke a stateful toString()
    case ASTType.MemberExpression:
      if (node.computed) {
        return false;
      }
      break;

    // Unary always convert to primitive
    case ASTType.UnaryExpression:
      return PURITY_ABSOLUTE;

    // The binary + operator can invoke a stateful toString().
    case ASTType.BinaryExpression:
      return node.operator !== "+" ? PURITY_ABSOLUTE : false;

    // Functions / filters probably read state from within objects
    case ASTType.CallExpression:
      return false;
  }

  return undefined === parentIsPure ? PURITY_RELATIVE : parentIsPure;
}

function isStateless($filter, filterName) {
  const fn = $filter(filterName);
  return !fn.$stateful;
}

/**
 * Converts parameter to  strings property name for use  as keys in an object.
 * Any non-string object, including a number, is typecasted into a string via the toString method.
 * {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names}
 *
 * @param {!any} name
 * @returns {string}
 */
function getStringValue(name) {
  return `${name}`;
}

/**
 * @param {import("./ast/ast").ASTNode} ast
 * @returns {boolean}
 */
function isAssignable(ast) {
  return (
    ast.type === ASTType.Identifier || ast.type === ASTType.MemberExpression
  );
}

const $parseMinErr$1 = minErr("$parse");

const ESCAPE = {
  n: "\n",
  f: "\f",
  r: "\r",
  t: "\t",
  v: "\v",
  "'": "'",
  '"': '"',
};

const OPERATORS = new Set(
  "+ - * / % === !== == != < > <= >= && || ! = |".split(" "),
);

/**
 * @typedef {Object} LexerOptions
 * @property {(ch: string, codePoint: number) => boolean} [isIdentifierStart] - Custom function to determine if a character is a valid identifier start.
 * @property {(ch: string, codePoint: number) => boolean} [isIdentifierContinue] - Custom function to determine if a character is a valid identifier continuation.
 */

/**
 * Represents a token produced by the lexer, which will be used by the AST to construct an abstract syntax tree.
 * @typedef {Object} Token
 * @property {number} index - Index of the token.
 * @property {string} text - Text of the token.
 * @property {boolean} [identifier] - Indicates if token is an identifier.
 * @property {boolean} [constant] - Indicates if token is a constant.
 * @property {string|number} [value] - Value of the token if it's a constant.
 * @property {boolean} [operator] - Indicates if token is an operator.
 */

/**
 * Represents a lexer that tokenizes input text. The Lexer takes the original expression string and returns an array of tokens parsed from that string.
 * For example, the string "a + b" would result in tokens for a, +, and b.
 */
class Lexer {
  /**
   * Creates an instance of Lexer.
   * @param {LexerOptions} options - Lexer options.
   */
  constructor(options) {
    /** @type {LexerOptions} */
    this.options = options;
  }

  /**
   * Tokenizes the input text.
   * @param {string} text Input text to lex.
   * @returns {Array<Token>} Array of tokens.
   */
  lex(text) {
    this.text = text;
    this.index = 0;
    /** @type {Array<Token>} */
    this.tokens = [];

    while (this.index < this.text.length) {
      const ch = this.text.charAt(this.index);
      if (ch === '"' || ch === "'") {
        this.readString(ch);
      } else if (
        this.isNumber(ch) ||
        (ch === "." && this.isNumber(/** @type {string} */ (this.peek())))
      ) {
        this.readNumber();
      } else if (
        this.isIdentifierStart &&
        this.isIdentifierStart(this.peekMultichar())
      ) {
        this.readIdent();
      } else if (this.is(ch, "(){}[].,;:?")) {
        this.tokens.push({ index: this.index, text: ch });
        this.index++;
      } else if (this.isWhitespace(ch)) {
        this.index++;
      } else {
        const ch2 = ch + this.peek();
        const ch3 = ch2 + this.peek(2);
        const op1 = OPERATORS.has(ch);
        const op2 = OPERATORS.has(ch2);
        const op3 = OPERATORS.has(ch3);
        if (op1 || op2 || op3) {
          const token = op3 ? ch3 : op2 ? ch2 : ch;
          this.tokens.push({ index: this.index, text: token, operator: true });
          this.index += token.length;
        } else {
          this.throwError(
            "Unexpected next character ",
            this.index,
            this.index + 1,
          );
        }
      }
    }
    return this.tokens;
  }

  /**
   * Checks if a character is contained in a set of characters.
   * @param {string} ch Character to check.
   * @param {string} chars Set of characters.
   * @returns {boolean} True if character is in the set, false otherwise.
   */
  is(ch, chars) {
    return chars.indexOf(ch) !== -1;
  }

  /**
   * Peeks at the next character in the text.
   * @param {number} [i=1] Number of characters to peek.
   * @returns {string|false} Next character or false if end of text.
   */
  peek(i) {
    const num = i || 1;
    return this.index + num < this.text.length
      ? this.text.charAt(this.index + num)
      : false;
  }

  /**
   * Checks if a character is a number.
   * @param {string} ch Character to check.
   * @returns {boolean} True if character is a number, false otherwise.
   */
  isNumber(ch) {
    return ch >= "0" && ch <= "9" && typeof ch === "string";
  }

  /**
   * Checks if a character is whitespace.
   * @param {string} ch Character to check.
   * @returns {boolean} True if character is whitespace, false otherwise.
   */
  isWhitespace(ch) {
    return (
      ch === " " || ch === "\r" || ch === "\t" || ch === "\n" || ch === "\v"
    );
  }

  /**
   * Checks if a character is a valid identifier start.
   * @param {string} ch Character to check.
   * @returns {boolean} True if character is a valid identifier start, false otherwise.
   */
  isIdentifierStart(ch) {
    return this.options.isIdentifierStart
      ? this.options.isIdentifierStart(ch, this.codePointAt(ch))
      : (ch >= "a" && ch <= "z") ||
          (ch >= "A" && ch <= "Z") ||
          ch === "_" ||
          ch === "$";
  }

  /**
   * Checks if a character is a valid identifier continuation.
   * @param {string} ch Character to check.
   * @returns {boolean} True if character is a valid identifier continuation, false otherwise.
   */
  isIdentifierContinue(ch) {
    return this.options.isIdentifierContinue
      ? this.options.isIdentifierContinue(ch, this.codePointAt(ch))
      : (ch >= "a" && ch <= "z") ||
          (ch >= "A" && ch <= "Z") ||
          ch === "_" ||
          ch === "$" ||
          (ch >= "0" && ch <= "9");
  }

  /**
   * Converts a character to its Unicode code point.
   * @param {string} ch Character to convert.
   * @returns {number} Unicode code point.
   */
  codePointAt(ch) {
    if (ch.length === 1) return ch.charCodeAt(0);
    return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35fdc00;
  }

  /**
   * Peeks at the next multicharacter sequence in the text.
   * @returns {string} Next multicharacter sequence.
   */
  peekMultichar() {
    const ch = this.text.charAt(this.index);
    const peek = this.peek();
    if (!peek) {
      return ch;
    }
    const cp1 = ch.charCodeAt(0);
    const cp2 = peek.charCodeAt(0);
    if (cp1 >= 0xd800 && cp1 <= 0xdbff && cp2 >= 0xdc00 && cp2 <= 0xdfff) {
      return ch + peek;
    }
    return ch;
  }

  /**
   * Checks if a character is an exponent operator.
   * @param {string} ch Character to check.
   * @returns {boolean} True if character is an exponent operator, false otherwise.
   */
  isExpOperator(ch) {
    return ch === "-" || ch === "+" || this.isNumber(ch);
  }

  /**
   * Throws a lexer error.
   * @param {string} error Error message.
   * @param {number} [start] Start index.
   * @param {number} [end] End index.
   * @throws {Error} Lexer error.
   */
  throwError(error, start, end) {
    end = end || this.index;
    const colStr = isDefined(start)
      ? `s ${start}-${this.index} [${this.text.substring(start, end)}]`
      : ` ${end}`;
    throw $parseMinErr$1(
      "lexerr",
      `Lexer Error: ${error} at column${colStr} in expression [${this.text}].`,
    );
  }

  /**
   * Reads and tokenizes a number from the text.
   * @return {void}
   */
  readNumber() {
    let number = "";
    const start = this.index;
    while (this.index < this.text.length) {
      const ch = this.text.charAt(this.index).toLowerCase();
      if (ch === "." || this.isNumber(ch)) {
        number += ch;
      } else {
        const peekCh = this.peek();
        if (ch === "e" && this.isExpOperator(/** @type {string} */ (peekCh))) {
          number += ch;
        } else if (
          this.isExpOperator(ch) &&
          peekCh &&
          this.isNumber(peekCh) &&
          number.charAt(number.length - 1) === "e"
        ) {
          number += ch;
        } else if (
          this.isExpOperator(ch) &&
          (!peekCh || !this.isNumber(peekCh)) &&
          number.charAt(number.length - 1) === "e"
        ) {
          this.throwError("Invalid exponent");
        } else {
          break;
        }
      }
      this.index++;
    }
    this.tokens.push({
      index: start,
      text: number,
      constant: true,
      value: Number(number),
    });
  }

  /**
   * Reads and tokenizes an identifier from the text.
   */
  readIdent() {
    const start = this.index;
    this.index += this.peekMultichar().length;
    while (this.index < this.text.length) {
      const ch = this.peekMultichar();
      if (this.isIdentifierContinue && !this.isIdentifierContinue(ch)) {
        break;
      }
      this.index += ch.length;
    }
    this.tokens.push({
      index: start,
      text: this.text.slice(start, this.index),
      identifier: true,
    });
  }

  /**
   * Reads and tokenizes a string from the text.
   * @param {string} quote Quote character used for the string.
   */
  readString(quote) {
    const start = this.index;
    let string = "";
    let escape = false;

    this.index++; // Skip opening quote

    while (this.index < this.text.length) {
      const ch = this.text[this.index];

      if (escape) {
        if (ch === "u") {
          // Handle unicode escapes
          // Simplified for brevity
          string += this.handleUnicodeEscape();
        } else {
          string += ESCAPE[ch] || ch;
        }
        escape = false;
      } else if (ch === "\\") {
        escape = true;
      } else if (ch === quote) {
        this.tokens.push({
          index: start,
          text: this.text.slice(start, this.index + 1),
          constant: true,
          value: string,
        });
        this.index++; // Skip closing quote
        return;
      } else {
        string += ch;
      }

      this.index++;
    }

    this.throwError("Unterminated quote", start);
  }

  /**
   * @returns {string}
   */
  handleUnicodeEscape() {
    const hex = this.text.substring(this.index + 1, this.index + 5);
    if (!hex.match(/[\da-f]{4}/i)) {
      this.throwError(`Invalid unicode escape [\\u${hex}]`);
    }
    this.index += 4; // Move index past the four hexadecimal digits
    return String.fromCharCode(parseInt(hex, 16));
  }
}

const $parseMinErr = minErr("$parse");

/**
 * @typedef {import("./ast.d.ts").ASTNode} ASTNode
 */

// Keep this exported in case modification is required
/** @type {Map<string,any>} */
const literals = new Map(
  Object.entries({
    true: true,
    false: false,
    null: null,
    undefined,
  }),
);

/**
 * @class
 */
class AST {
  /**
   * @param {import('../lexer/lexer.js').Lexer} lexer - The lexer instance for tokenizing input
   */
  constructor(lexer) {
    /** @type {import('../lexer/lexer.js').Lexer} */
    this.lexer = lexer;
    this.selfReferential = {
      this: { type: ASTType.ThisExpression },
      $locals: { type: ASTType.LocalsExpression },
    };
  }

  /**
   * Parses the input text and generates an AST.
   * @param {string} text - The input text to parse.
   * @returns {ASTNode} The root node of the AST.
   */
  ast(text) {
    this.text = text;
    this.tokens = this.lexer.lex(text);
    const value = this.program();
    if (this.tokens.length !== 0) {
      this.throwError("is an unexpected token", this.tokens[0]);
    }
    return value;
  }

  /**
   * Parses a program.
   * @returns {ASTNode} The program node.
   */
  program() {
    const body = [];
    let hasMore = true;
    while (hasMore) {
      if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]"))
        body.push(this.expressionStatement());
      if (!this.expect(";")) {
        hasMore = false;
      }
    }
    return { type: ASTType.Program, body };
  }

  /**
   * Parses an expression statement.
   * @returns {ASTNode} The expression statement node.
   */
  expressionStatement() {
    return {
      type: ASTType.ExpressionStatement,
      expression: this.filterChain(),
    };
  }

  /**
   * Parses a filter chain.
   * @returns {ASTNode} The filter chain node.
   */
  filterChain() {
    let left = this.assignment();
    while (this.expect("|")) {
      left = this.filter(left);
    }
    return left;
  }

  /**
   * Parses an assignment expression.
   * @returns {ASTNode} The assignment expression node.
   */
  assignment() {
    let result = this.ternary();
    if (this.expect("=")) {
      if (!isAssignable(result)) {
        throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
      }

      result = {
        type: ASTType.AssignmentExpression,
        left: result,
        right: this.assignment(),
        operator: "=",
      };
    }
    return result;
  }

  /**
   * Parses a ternary expression.
   * @returns {ASTNode} The ternary expression node.
   */
  ternary() {
    const test = this.logicalOR();
    let alternate;
    let consequent;
    if (this.expect("?")) {
      alternate = this.assignment();
      if (this.consume(":")) {
        consequent = this.assignment();
        return {
          type: ASTType.ConditionalExpression,
          test,
          alternate,
          consequent,
        };
      }
    }
    return test;
  }

  /**
   * Parses a logical OR expression.
   * @returns {ASTNode} The logical OR expression node.
   */
  logicalOR() {
    let left = this.logicalAND();
    while (this.expect("||")) {
      left = {
        type: ASTType.LogicalExpression,
        operator: "||",
        left,
        right: this.logicalAND(),
      };
    }
    return left;
  }

  /**
   * Parses a logical AND expression.
   * @returns {ASTNode} The logical AND expression node.
   */
  logicalAND() {
    let left = this.equality();
    while (this.expect("&&")) {
      left = {
        type: ASTType.LogicalExpression,
        operator: "&&",
        left,
        right: this.equality(),
      };
    }
    return left;
  }

  /**
   * Parses an equality expression.
   * @returns {ASTNode} The equality expression node.
   */
  equality() {
    let left = this.relational();
    let token;
    while ((token = this.expect("==", "!=", "===", "!=="))) {
      left = {
        type: ASTType.BinaryExpression,
        operator: /** @type {import("../lexer/lexer.js").Token} */ (token).text,
        left,
        right: this.relational(),
      };
    }
    return left;
  }

  /**
   * Parses a relational expression.
   * @returns {ASTNode} The relational expression node.
   */
  relational() {
    let left = this.additive();
    let token;
    while ((token = this.expect("<", ">", "<=", ">="))) {
      left = {
        type: ASTType.BinaryExpression,
        operator: /** @type {import("../lexer/lexer.js").Token} */ (token).text,
        left,
        right: this.additive(),
      };
    }
    return left;
  }

  /**
   * Parses an additive expression.
   * @returns {ASTNode} The additive expression node.
   */
  additive() {
    let left = this.multiplicative();
    let token;
    while ((token = this.expect("+", "-"))) {
      left = {
        type: ASTType.BinaryExpression,
        operator: /** @type {import("../lexer/lexer.js").Token} */ (token).text,
        left,
        right: this.multiplicative(),
      };
    }
    return left;
  }

  /**
   * Parses a multiplicative expression.
   * @returns {ASTNode} The multiplicative expression node.
   */
  multiplicative() {
    let left = this.unary();
    let token;
    while ((token = this.expect("*", "/", "%"))) {
      left = {
        type: ASTType.BinaryExpression,
        operator: /** @type {import("../lexer/lexer.js").Token} */ (token).text,
        left,
        right: this.unary(),
      };
    }
    return left;
  }

  /**
   * Parses a unary expression.
   * @returns {ASTNode} The unary expression node.
   */
  unary() {
    let token;
    if ((token = this.expect("+", "-", "!"))) {
      return {
        type: ASTType.UnaryExpression,
        operator: /** @type {import("../lexer/lexer.js").Token} */ (token).text,
        prefix: true,
        argument: this.unary(),
      };
    }
    return this.primary();
  }

  /**
   * Parses a primary expression.
   * @returns {ASTNode} The primary expression node.
   */
  primary() {
    let primary;
    if (this.expect("(")) {
      primary = this.filterChain();
      this.consume(")");
    } else if (this.expect("[")) {
      primary = this.arrayDeclaration();
    } else if (this.expect("{")) {
      primary = this.object();
    } else if (
      Object.prototype.hasOwnProperty.call(
        this.selfReferential,
        /** @type {import("../lexer/lexer.js").Token} */ (this.peek()).text,
      )
    ) {
      primary = structuredClone(this.selfReferential[this.consume().text]);
    } else if (
      literals.has(
        /** @type {import("../lexer/lexer.js").Token} */ (this.peek()).text,
      )
    ) {
      primary = {
        type: ASTType.Literal,
        value: literals.get(this.consume().text),
      };
    } else if (
      /** @type {import("../lexer/lexer.js").Token} */ (this.peek()).identifier
    ) {
      primary = this.identifier();
    } else if (
      /** @type {import("../lexer/lexer.js").Token} */ (this.peek()).constant
    ) {
      primary = this.constant();
    } else {
      this.throwError(
        "not a primary expression",
        /** @type {import("../lexer/lexer.js").Token} */ (this.peek()),
      );
    }

    let next;
    while ((next = this.expect("(", "[", "."))) {
      if (
        /** @type {import("../lexer/lexer.js").Token} */ (next).text === "("
      ) {
        primary = {
          type: ASTType.CallExpression,
          callee: primary,
          arguments: this.parseArguments(),
        };
        this.consume(")");
      } else if (
        /** @type {import("../lexer/lexer.js").Token} */ (next).text === "["
      ) {
        primary = {
          type: ASTType.MemberExpression,
          object: primary,
          property: this.assignment(),
          computed: true,
        };
        this.consume("]");
      } else if (
        /** @type {import("../lexer/lexer.js").Token} */ (next).text === "."
      ) {
        primary = {
          type: ASTType.MemberExpression,
          object: primary,
          property: this.identifier(),
          computed: false,
        };
      } else {
        this.throwError("IMPOSSIBLE");
      }
    }
    return primary;
  }

  /**
   * Parses a filter.
   * @param {ASTNode} baseExpression - The base expression to apply the filter to.
   * @returns {ASTNode} The filter node.
   */
  filter(baseExpression) {
    /** @type {ASTNode[]} */
    const args = [baseExpression];
    const result = {
      type: ASTType.CallExpression,
      callee: this.identifier(),
      arguments: args,
      filter: true,
    };

    while (this.expect(":")) {
      args.push(this.assignment());
    }

    return result;
  }

  /**
   * Parses function arguments.
   * @returns {ASTNode[]} The arguments array.
   */
  parseArguments() {
    /** @type {ASTNode[]} */
    const args = [];
    if (this.peekToken().text !== ")") {
      do {
        args.push(this.filterChain());
      } while (this.expect(","));
    }
    return args;
  }

  /**
   * Parses an identifier.
   * @returns {ASTNode} The identifier node.
   */
  identifier() {
    const token = this.consume();
    if (!token.identifier) {
      this.throwError("is not a valid identifier", token);
    }
    return { type: ASTType.Identifier, name: token.text };
  }

  /**
   * Parses a constant.
   * @returns {ASTNode} The constant node.
   */
  constant() {
    // TODO check that it is a constant
    return { type: ASTType.Literal, value: this.consume().value };
  }

  /**
   * Parses an array declaration.
   * @returns {ASTNode} The array declaration node.
   */
  arrayDeclaration() {
    /** @type {ASTNode[]} */
    const elements = [];
    if (this.peekToken().text !== "]") {
      do {
        if (this.peek("]")) {
          // Support trailing commas per ES5.1.
          break;
        }
        elements.push(this.assignment());
      } while (this.expect(","));
    }
    this.consume("]");

    return { type: ASTType.ArrayExpression, elements };
  }

  /**
   * Parses an object.
   * @returns {ASTNode} The object node.
   */
  object() {
    /** @type {ASTNode[]} */
    const properties = [];
    /** @type {ASTNode} */
    let property;
    if (this.peekToken().text !== "}") {
      do {
        if (this.peek("}")) {
          // Support trailing commas per ES5.1.
          break;
        }
        property = { type: ASTType.Property, kind: "init" };
        if (
          /** @type {import("../lexer/lexer.js").Token} */ (this.peek())
            .constant
        ) {
          property.key = this.constant();
          property.computed = false;
          this.consume(":");
          property.value = this.assignment();
        } else if (
          /** @type {import("../lexer/lexer.js").Token} */ (this.peek())
            .identifier
        ) {
          property.key = this.identifier();
          property.computed = false;
          if (this.peek(":")) {
            this.consume(":");
            property.value = this.assignment();
          } else {
            property.value = property.key;
          }
        } else if (this.peek("[")) {
          this.consume("[");
          property.key = this.assignment();
          this.consume("]");
          property.computed = true;
          this.consume(":");
          property.value = this.assignment();
        } else {
          this.throwError(
            "invalid key",
            /** @type {import("../lexer/lexer.js").Token} */ (this.peek()),
          );
        }
        properties.push(property);
      } while (this.expect(","));
    }
    this.consume("}");

    return { type: ASTType.ObjectExpression, properties };
  }

  /**
   * Throws a syntax error.
   * @param {string} msg - The error message.
   * @param {import("../lexer/lexer.js").Token} [token] - The token that caused the error.
   */
  throwError(msg, token) {
    throw $parseMinErr(
      "syntax",
      "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].",
      token.text,
      msg,
      token.index + 1,
      this.text,
      this.text.substring(token.index),
    );
  }

  /**
   * Consumes a token if it matches the expected type.
   * @param {string} [e1] - The expected token type.
   * @returns {import("../lexer/lexer.js").Token} The consumed token.
   */
  consume(e1) {
    if (this.tokens.length === 0) {
      throw $parseMinErr(
        "ueoe",
        "Unexpected end of expression: {0}",
        this.text,
      );
    }

    const token = this.expect(e1);
    if (!token) {
      this.throwError(
        `is unexpected, expecting [${e1}]`,
        /** @type {import("../lexer/lexer.js").Token} */ (this.peek()),
      );
    } else {
      return /** @type  {import("../lexer/lexer.js").Token} */ (token);
    }
  }

  /**
   * Returns the next token without consuming it.
   * @returns {import("../lexer/lexer.js").Token} The next token.
   */
  peekToken() {
    if (this.tokens.length === 0) {
      throw $parseMinErr(
        "ueoe",
        "Unexpected end of expression: {0}",
        this.text,
      );
    }
    return this.tokens[0];
  }

  /**
   * Checks if the next token matches any of the expected types.
   * @param {...string} [expected] - The expected token types.
   * @returns {import('../lexer/lexer.js').Token|boolean} The next token if it matches, otherwise false.
   */
  peek(...expected) {
    return this.peekAhead(0, ...expected);
  }

  /**
   * Checks if the token at the specified index matches any of the expected types.
   * @param {number} i - The index to check.
   * @param {...string} [expected] - The expected token types.
   * @returns {import("../lexer/lexer.js").Token|boolean} The token at the specified index if it matches, otherwise false.
   */
  peekAhead(i, ...expected) {
    if (this.tokens.length > i) {
      const token = this.tokens[i];
      const t = token.text;
      if (
        expected.includes(t) ||
        (!expected[0] && !expected[1] && !expected[2] && !expected[3])
      ) {
        return token;
      }
    }
    return false;
  }

  /**
   * Consumes the next token if it matches any of the expected types.
   * @param {...string} [expected] - The expected token types.
   * @returns {import("../lexer/lexer.js").Token|boolean} The consumed token if it matches, otherwise false.
   */
  expect(...expected) {
    const token = this.peek(...expected);
    if (token) {
      this.tokens.shift();
      return token;
    }
    return false;
  }
}

/**
 * @typedef {Object} ParsedAST
 * @property {import("../ast/ast.js").ASTNode} ast - AST representation of expression
 */

/**
 * @constructor
 */
class Parser {
  /**
   *
   * @param {import('../lexer/lexer.js').Lexer} lexer
   * @param {function(any):any} $filter
   */
  constructor(lexer, $filter) {
    /** @type {AST} */
    this.ast = new AST(lexer);

    /** @type {ASTInterpreter} */
    this.astCompiler = new ASTInterpreter($filter);
  }

  /**
   *
   * @param {string} exp - Expression to be parsed
   * @returns {import("../parse.js").CompiledExpression}
   */
  parse(exp) {
    const { ast } = this.getAst(exp);
    const fn = this.astCompiler.compile(ast);
    fn.literal = isLiteral(ast);
    fn.constant = isConstant(ast);
    return fn;
  }

  /**
   * @param {string} exp - Expression to be parsed
   * @returns {ParsedAST}
   */
  getAst(exp) {
    exp = exp.trim();
    return {
      ast: this.ast.ast(exp),
    };
  }
}

function isLiteral(ast) {
  return (
    ast.body.length === 0 ||
    (ast.body.length === 1 &&
      (ast.body[0].expression.type === ASTType.Literal ||
        ast.body[0].expression.type === ASTType.ArrayExpression ||
        ast.body[0].expression.type === ASTType.ObjectExpression))
  );
}

function isConstant(ast) {
  return ast.constant;
}

/**
 * @typedef {Object} CompiledExpressionProps
 * @property {boolean} literal - Indicates if the expression is a literal.
 * @property {boolean} constant - Indicates if the expression is constant.
 * @property {boolean} [isPure]
 * @property {boolean} oneTime
 * @property {import("./interpreter.js").DecoratedASTNode} decoratedNode
 * @property {function(import('../scope/scope.js').Scope, Function, boolean, CompiledExpression, string | ((scope:  import('../scope/scope.js').Scope) => any) | CompiledExpression): any} [$$watchDelegate]
 * @property {any[]|Function} inputs
 * @property {function(any, any): any} [assign] - Assigns a value to a context. If value is not provided,
 */

/**
 * @typedef {Object} CompiledExpressionHandlerMap
 * @property {boolean} literal - Indicates if the expression is a literal.
 * @property {boolean} constant - Indicates if the expression is constant.
 * @property {boolean} [isPure]
 * @property {boolean} oneTime
 * @property {Map<string, Function>} keyMap - property keys to observe
 */

/**
 * @typedef {Function} CompiledExpressionFunction
 * @param {import('../scope/scope.js').Scope} context - An object against which any expressions embedded in the strings are evaluated against (typically a scope object).
 * @param {object} [locals] - local variables context object, useful for overriding values in `context`.
 * @param {any} [assign]
 * @returns {any}
 * undefined is gonna be used since the implementation
 * does not check the parameter. Let's force a value for consistency. If consumer
 * wants to undefine it, pass the undefined value explicitly.
 */

/**
 * @typedef {CompiledExpressionFunction & CompiledExpressionProps} CompiledExpression
 */

/**
 * @typedef {function(CompiledExpression|string|function(import('../scope/scope.js').Scope):any, function(any, import('../scope/scope.js').Scope, any):any=, boolean=): CompiledExpression} ParseService
 */

function ParseProvider() {
  const cache = Object.create(null);

  /** @type {function(any):boolean?} */
  var identStart;

  /** @type {function(any):boolean?} */
  var identContinue;

  /**
   * Allows defining the set of characters that are allowed in AngularJS expressions. The function
   * `identifierStart` will get called to know if a given character is a valid character to be the
   * first character for an identifier. The function `identifierContinue` will get called to know if
   * a given character is a valid character to be a follow-up identifier character. The functions
   * `identifierStart` and `identifierContinue` will receive as arguments the single character to be
   * identifier and the character code point. These arguments will be `string` and `numeric`. Keep in
   * mind that the `string` parameter can be two characters long depending on the character
   * representation. It is expected for the function to return `true` or `false`, whether that
   * character is allowed or not.
   *
   * Since this function will be called extensively, keep the implementation of these functions fast,
   * as the performance of these functions have a direct impact on the expressions parsing speed.
   *
   * @param {function(any):boolean} [identifierStart] The function that will decide whether the given character is
   *   a valid identifier start character.
   * @param {function(any):boolean} [identifierContinue] The function that will decide whether the given character is
   *   a valid identifier continue character.
   * @returns {ParseProvider}
   */
  this.setIdentifierFns = function (identifierStart, identifierContinue) {
    identStart = identifierStart;
    identContinue = identifierContinue;
    return this;
  };

  this.$get = [
    "$filter",
    /**
     *
     * @param {(any) => any} $filter
     * @returns {ParseService}
     */
    function ($filter) {
      /** @type {import("./lexer/lexer.js").LexerOptions} */
      var $lexerOptions = {
        isIdentifierStart: isFunction(identStart) && identStart,
        isIdentifierContinue: isFunction(identContinue) && identContinue,
      };
      return $parse;

      /**
       * @param {string} exp
       * @param interceptorFn
       * @returns {*|((function(import('../scope/scope.js').Scope, Object=, *=): *)&{literal: boolean, constant: boolean, isPure?: boolean, oneTime: boolean, decoratedNode: import("./interpreter.js").DecoratedASTNode, $$watchDelegate?: (function(import('../scope/scope.js').Scope, Function, boolean, CompiledExpression, (string|(function(import('../scope/scope.js').Scope): *)|CompiledExpression)): *), inputs: (*[]|Function), assign?: (function(*, *): *)})}
       */
      function $parse(exp, interceptorFn) {
        var parsedExpression, cacheKey;

        switch (typeof exp) {
          case "string":
            exp = exp.trim();
            cacheKey = exp;

            parsedExpression = cache[cacheKey];

            if (!parsedExpression) {
              var lexer = new Lexer($lexerOptions);
              var parser = new Parser(lexer, $filter);
              parsedExpression = parser.parse(exp);

              cache[cacheKey] = addWatchDelegate(parsedExpression);
            }
            return addInterceptor(parsedExpression, interceptorFn);

          case "function":
            return addInterceptor(exp, interceptorFn);

          default:
            return addInterceptor(() => {}, interceptorFn);
        }
      }

      /**
       * @param {Function} parsedExpression
       * @param interceptorFn
       * @returns {CompiledExpression|*}
       */
      function addInterceptor(parsedExpression, interceptorFn) {
        if (!interceptorFn) return parsedExpression;

        // Extract any existing interceptors out of the parsedExpression
        // to ensure the original parsedExpression is always the $$intercepted
        if (parsedExpression.$$interceptor) {
          interceptorFn = chainInterceptors(
            parsedExpression.$$interceptor,
            interceptorFn,
          );
          parsedExpression = parsedExpression.$$intercepted;
        }

        let useInputs = false;

        const fn = function interceptedExpression(
          scope,
          locals,
          assign,
          inputs,
        ) {
          const value =
            useInputs && inputs
              ? inputs[0]
              : parsedExpression(scope, locals, assign, inputs);
          // Do not invoke for getters
          if (scope?.getter) {
            return;
          }
          const res = isFunction(value) ? value() : value;
          return interceptorFn(isProxy(res) ? res.$target : res);
        };

        // Maintain references to the interceptor/intercepted
        fn.$$intercepted = parsedExpression;
        fn.$$interceptor = interceptorFn;

        // Propagate the literal/oneTime/constant attributes
        fn.literal = parsedExpression.literal;
        fn.oneTime = parsedExpression.oneTime;
        fn.constant = parsedExpression.constant;
        fn.decoratedNode = parsedExpression.decoratedNode;

        // Treat the interceptor like filters.
        // If it is not $stateful then only watch its inputs.
        // If the expression itself has no inputs then use the full expression as an input.
        if (!interceptorFn.$stateful) {
          useInputs = !parsedExpression.inputs;
          fn.inputs = parsedExpression.inputs
            ? parsedExpression.inputs
            : [parsedExpression];

          if (!interceptorFn.$$pure) {
            fn.inputs = fn.inputs.map(function (e) {
              // Remove the isPure flag of inputs when it is not absolute because they are now wrapped in a
              // non-pure interceptor function.
              if (e.isPure === PURITY_RELATIVE) {
                return function depurifier(s) {
                  return e(s);
                };
              }
              return e;
            });
          }
        }

        return addWatchDelegate(fn);
      }
    },
  ];
}

function constantWatchDelegate(
  scope,
  listener,
  objectEquality,
  parsedExpression,
) {
  const unwatch = scope.$watch(
    () => {
      unwatch();
      return parsedExpression(scope);
    },
    listener,
    objectEquality,
  );
  return unwatch;
}

/**
 *
 * @param {CompiledExpression} parsedExpression
 * @returns {CompiledExpression}
 */
function addWatchDelegate(parsedExpression) {
  if (parsedExpression.constant) {
    parsedExpression.$$watchDelegate = constantWatchDelegate;
  } else if (parsedExpression.inputs) {
    parsedExpression.$$watchDelegate = inputsWatchDelegate;
  }

  return parsedExpression;
}

/**
 *
 * @param {import('../scope/scope.js').Scope} scope
 * @param {Function} listener
 * @param {*} objectEquality
 * @param {CompiledExpression} parsedExpression
 * @returns
 */
function inputsWatchDelegate(
  scope,
  listener,
  objectEquality,
  parsedExpression,
) {
  let inputExpressions = /** @type {Function} */ (parsedExpression.inputs);
  let lastResult;

  if (inputExpressions.length === 1) {
    let oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails

    let inputExpression = inputExpressions[0];
    return scope.$watch(
      ($scope) => {
        const newInputValue = inputExpression($scope);
        if (
          !expressionInputDirtyCheck(
            newInputValue,
            oldInputValueOf,
            inputExpression.isPure,
          )
        ) {
          lastResult = parsedExpression($scope, undefined, undefined, [
            newInputValue,
          ]);
          oldInputValueOf = newInputValue && getValueOf(newInputValue);
        }
        return lastResult;
      },
      listener,
      objectEquality,
    );
  } else {
    const oldInputValueOfValues = [];
    const oldInputValues = [];
    for (let i = 0, ii = inputExpressions.length; i < ii; i++) {
      oldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails
      oldInputValues[i] = null;
    }
    return scope.$watch(
      (scope) => {
        let changed = false;

        for (let i = 0, ii = inputExpressions.length; i < ii; i++) {
          const newInputValue = inputExpressions[i](scope);
          if (
            changed ||
            (changed = !expressionInputDirtyCheck(
              newInputValue,
              oldInputValueOfValues[i],
              inputExpressions[i].isPure,
            ))
          ) {
            oldInputValues[i] = newInputValue;
            oldInputValueOfValues[i] =
              newInputValue && getValueOf(newInputValue);
          }
        }

        if (changed) {
          lastResult = parsedExpression(
            scope,
            undefined,
            undefined,
            oldInputValues,
          );
        }

        return lastResult;
      },
      listener,
      objectEquality,
    );
  }
}

function chainInterceptors(first, second) {
  function chainedInterceptor(value) {
    return second(first(value));
  }
  chainedInterceptor.$stateful = first.$stateful || second.$stateful;
  chainedInterceptor.$$pure = first.$$pure && second.$$pure;

  return chainedInterceptor;
}

function expressionInputDirtyCheck(
  newValue,
  oldValueOfValue,
  compareObjectIdentity,
) {
  if (newValue == null || oldValueOfValue == null) {
    // null/undefined
    return newValue === oldValueOfValue;
  }

  if (typeof newValue === "object") {
    // attempt to convert the value to a primitive type
    // TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can
    //             be cheaply dirty-checked
    newValue = getValueOf(newValue);

    if (typeof newValue === "object" && !compareObjectIdentity) {
      // objects/arrays are not supported - deep-watching them would be too expensive
      return false;
    }

    // fall-through to the primitive equality check
  }

  // Primitive or NaN

  return (
    newValue === oldValueOfValue ||
    (newValue !== newValue && oldValueOfValue !== oldValueOfValue)
  );
}

function getValueOf(value) {
  return isFunction(value.valueOf)
    ? value.valueOf()
    : {}.constructor.prototype.valueOf.call(value);
}

const $interpolateMinErr = minErr("$interpolate");
function throwNoconcat(text) {
  throw $interpolateMinErr(
    "noconcat",
    "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
      "interpolations that concatenate multiple expressions when a trusted value is " +
      "required.  See http://docs.angularjs.org/api/ng.$sce",
    text,
  );
}

function interr(text, err) {
  throw $interpolateMinErr(
    "interr",
    "Can't interpolate: {0}\n{1}",
    text,
    err.toString(),
  );
}

/**
 *
 * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.
 *
 * <div class="alert alert-danger">
 * This feature is sometimes used to mix different markup languages, e.g. to wrap an AngularJS
 * template within a Python Jinja template (or any other template language). Mixing templating
 * languages is **very dangerous**. The embedding template language will not safely escape AngularJS
 * expressions, so any user-controlled values in the template will cause Cross Site Scripting (XSS)
 * security bugs!
 * </div>
 */
class InterpolateProvider {
  constructor() {
    /**
     * @type {string} Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
     */
    this.startSymbol = "{{";

    /**
     * @type {string} Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
     */
    this.endSymbol = "}}";
  }

  $get = [
    "$parse",
    "$sce",
    /**
     *
     * @param {import("../parse/parse.js").ParseService} $parse
     * @param {*} $sce
     * @returns
     */
    function ($parse, $sce) {
      /** @type {InterpolateProvider} */
      const provider = this;
      const startSymbolLength = provider.startSymbol.length;
      const endSymbolLength = provider.endSymbol.length;

      const escapedStartRegexp = new RegExp(
        provider.startSymbol.replace(/./g, escape),
        "g",
      );
      const escapedEndRegexp = new RegExp(
        provider.endSymbol.replace(/./g, escape),
        "g",
      );

      function escape(ch) {
        return `\\\\\\${ch}`;
      }

      function unescapeText(text) {
        return text
          .replace(escapedStartRegexp, provider.startSymbol)
          .replace(escapedEndRegexp, provider.endSymbol);
      }

      /**
       *
       * Compiles a string with markup into an interpolation function. This service is used by the
       * HTML {@link ng.$compile $compile} service for data binding. See
       * {@link ng.$interpolateProvider $interpolateProvider} for configuring the
       * interpolation markup.
       *
       *
       * ```js
       *   let $interpolate = ...; // injected
       *   let exp = $interpolate('Hello {{name | uppercase}}!');
       *   expect(exp({name:'AngularJS'})).toEqual('Hello ANGULARJS!');
       * ```
       *
       * `$interpolate` takes an optional fourth argument, `allOrNothing`. If `allOrNothing` is
       * `true`, the interpolation function will return `undefined` unless all embedded expressions
       * evaluate to a value other than `undefined`.
       *
       * ```js
       *   let $interpolate = ...; // injected
       *   let context = {greeting: 'Hello', name: undefined };
       *
       *   // default "forgiving" mode
       *   let exp = $interpolate('{{greeting}} {{name}}!');
       *   expect(exp(context)).toEqual('Hello !');
       *
       *   // "allOrNothing" mode
       *   exp = $interpolate('{{greeting}} {{name}}!', false, null, true);
       *   expect(exp(context)).toBeUndefined();
       *   context.name = 'AngularJS';
       *   expect(exp(context)).toEqual('Hello AngularJS!');
       * ```
       *
       * `allOrNothing` is useful for interpolating URLs. `ngSrc` and `ngSrcset` use this behavior.
       *
       * #### Escaped Interpolation
       * $interpolate provides a mechanism for escaping interpolation markers. Start and end markers
       * can be escaped by preceding each of their characters with a REVERSE SOLIDUS U+005C (backslash).
       * It will be rendered as a regular start/end marker, and will not be interpreted as an expression
       * or binding.
       *
       * This enables web-servers to prevent script injection attacks and defacing attacks, to some
       * degree, while also enabling code examples to work without relying on the
       * {@link ng.directive:ngNonBindable ngNonBindable} directive.
       *
       * **For security purposes, it is strongly encouraged that web servers escape user-supplied data,
       * replacing angle brackets (&lt;, &gt;) with &amp;lt; and &amp;gt; respectively, and replacing all
       * interpolation start/end markers with their escaped counterparts.**
       *
       * Escaped interpolation markers are only replaced with the actual interpolation markers in rendered
       * output when the $interpolate service processes the text. So, for HTML elements interpolated
       * by {@link ng.$compile $compile}, or otherwise interpolated with the `mustHaveExpression` parameter
       * set to `true`, the interpolated text must contain an unescaped interpolation expression. As such,
       * this is typically useful only when user-data is used in rendering a template from the server, or
       * when otherwise untrusted data is used by a directive.
       *
       * <example name="interpolation">
       *  <file name="index.html">
       *    <div ng-init="username='A user'">
       *      <p ng-init="apptitle='Escaping demo'">{{apptitle}}: \{\{ username = "defaced value"; \}\}
       *        </p>
       *      <p><strong>{{username}}</strong> attempts to inject code which will deface the
       *        application, but fails to accomplish their task, because the server has correctly
       *        escaped the interpolation start/end markers with REVERSE SOLIDUS U+005C (backslash)
       *        characters.</p>
       *      <p>Instead, the result of the attempted script injection is visible, and can be removed
       *        from the database by an administrator.</p>
       *    </div>
       *  </file>
       * </example>
       *
       * @knownIssue
       * It is currently not possible for an interpolated expression to contain the interpolation end
       * symbol. For example, `{{ '}}' }}` will be incorrectly interpreted as `{{ ' }}` + `' }}`, i.e.
       * an interpolated expression consisting of a single-quote (`'`) and the `' }}` string.
       *
       * @knownIssue
       * All directives and components must use the standard `{{` `}}` interpolation symbols
       * in their templates. If you change the application interpolation symbols the {@link $compile}
       * service will attempt to denormalize the standard symbols to the custom symbols.
       * The denormalization process is not clever enough to know not to replace instances of the standard
       * symbols where they would not normally be treated as interpolation symbols. For example in the following
       * code snippet the closing braces of the literal object will get incorrectly denormalized:
       *
       * ```
       * <div data-context='{"context":{"id":3,"type":"page"}}">
       * ```
       *
       * The workaround is to ensure that such instances are separated by whitespace:
       * ```
       * <div data-context='{"context":{"id":3,"type":"page"} }">
       * ```
       *
       * See https://github.com/angular/angular.js/pull/14610#issuecomment-219401099 for more information.
       *
       * @param {string} text The text with markup to interpolate.
       * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
       *    embedded expression in order to return an interpolation function. Strings with no
       *    embedded expression will return null for the interpolation function.
       * @param {string=} trustedContext when provided, the returned function passes the interpolated
       *    result through {@link ng.$sce#getTrusted $sce.getTrusted(interpolatedResult,
       *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that
       *    provides Strict Contextual Escaping for details.
       * @param {boolean=} allOrNothing if `true`, then the returned function returns undefined
       *    unless all embedded expressions evaluate to a value other than `undefined`.
       * @returns {Function} an interpolation function which is used to compute the
       *    interpolated string. The function has these parameters:
       *
       * - `context`: evaluation context for all expressions embedded in the interpolated text
       */
      function $interpolate(
        text,
        mustHaveExpression,
        trustedContext,
        allOrNothing,
      ) {
        const contextAllowsConcatenation =
          trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;

        // Provide a quick exit and simplified result function for text with no interpolation
        if (!text.length || text.indexOf(provider.startSymbol) === -1) {
          if (mustHaveExpression) return;

          let unescapedText = unescapeText(text);
          if (contextAllowsConcatenation) {
            unescapedText = $sce.getTrusted(trustedContext, unescapedText);
          }

          /**
           * @type {any}
           */
          const constantInterp = () => unescapedText;
          constantInterp.exp = text;
          constantInterp.expressions = [];
          constantInterp.$$watchDelegate = constantWatchDelegate;

          return constantInterp;
        }

        allOrNothing = !!allOrNothing;
        let startIndex;
        let endIndex;
        let index = 0;
        const expressions = [];
        let parseFns;
        const textLength = text.length;
        let exp;
        const concat = [];
        const expressionPositions = [];
        let singleExpression;

        while (index < textLength) {
          if (
            (startIndex = text.indexOf(provider.startSymbol, index)) !== -1 &&
            (endIndex = text.indexOf(
              provider.endSymbol,
              startIndex + startSymbolLength,
            )) !== -1
          ) {
            if (index !== startIndex) {
              concat.push(unescapeText(text.substring(index, startIndex)));
            }
            exp = text.substring(startIndex + startSymbolLength, endIndex);
            expressions.push(exp);
            index = endIndex + endSymbolLength;
            expressionPositions.push(concat.length);
            concat.push(""); // Placeholder that will get replaced with the evaluated expression.
          } else {
            // we did not find an interpolation, so we have to add the remainder to the separators array
            if (index !== textLength) {
              concat.push(unescapeText(text.substring(index)));
            }
            break;
          }
        }

        singleExpression =
          concat.length === 1 && expressionPositions.length === 1;
        // Intercept expression if we need to stringify concatenated inputs, which may be SCE trusted
        // objects rather than simple strings
        // (we don't modify the expression if the input consists of only a single trusted input)
        const interceptor =
          contextAllowsConcatenation && singleExpression
            ? undefined
            : parseStringifyInterceptor;
        parseFns = expressions.map((exp) => $parse(exp, interceptor));

        // Concatenating expressions makes it hard to reason about whether some combination of
        // concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a
        // single expression be used for some $sce-managed secure contexts (RESOURCE_URLs mostly),
        // we ensure that the value that's used is assigned or constructed by some JS code somewhere
        // that is more testable or make it obvious that you bound the value to some user controlled
        // value.  This helps reduce the load when auditing for XSS issues.

        // Note that URL and MEDIA_URL $sce contexts do not need this, since `$sce` can sanitize the values
        // passed to it. In that case, `$sce.getTrusted` will be called on either the single expression
        // or on the overall concatenated string (losing trusted types used in the mix, by design).
        // Both these methods will sanitize plain strings. Also, HTML could be included, but since it's
        // only used in srcdoc attributes, this would not be very useful.

        if (!mustHaveExpression || expressions.length) {
          const compute = function (values) {
            for (let i = 0, ii = expressions.length; i < ii; i++) {
              if (allOrNothing && isUndefined(values[i])) return;
              concat[expressionPositions[i]] = values[i];
            }

            if (contextAllowsConcatenation) {
              // If `singleExpression` then `concat[0]` might be a "trusted" value or `null`, rather than a string
              return $sce.getTrusted(
                trustedContext,
                singleExpression ? concat[0] : concat.join(""),
              );
            }
            if (trustedContext && concat.length > 1) {
              // This context does not allow more than one part, e.g. expr + string or exp + exp.
              throwNoconcat(text);
            }
            // In an unprivileged context or only one part: just concatenate and return.
            return concat.join("");
          };

          return extend(
            (context, cb) => {
              let i = 0;
              const ii = expressions.length;
              const values = new Array(ii);
              try {
                for (; i < ii; i++) {
                  if (cb) {
                    const watchProp = expressions[i].trim();
                    context.$watch(watchProp, () => {
                      let vals = new Array(ii);
                      let j = 0;
                      for (; j < ii; j++) {
                        let fn = parseFns[j];
                        let res = fn(context);
                        vals[j] = res;
                      }
                      cb(compute(vals));
                    });
                  }

                  values[i] = parseFns[i](context);
                }

                let res = compute(values);
                return res;
              } catch (err) {
                interr(text, err);
              }
            },
            {
              // Most likely we would need to register watches during interpolation
              // all of these properties are undocumented for now
              exp: text, // just for compatibility with regular watchers created via $watch
              expressions,
              $$watchDelegate(scope, listener) {
                let lastValue;
                return scope.$watch(
                  parseFns,
                  function interpolateFnWatcher(values, oldValues) {
                    const currValue = compute(values);
                    listener.call(
                      this,
                      currValue,
                      values !== oldValues ? lastValue : currValue,
                      scope,
                    );
                    lastValue = currValue;
                  },
                );
              },
            },
          );
        }

        function parseStringifyInterceptor(value) {
          try {
            // In concatenable contexts, getTrusted comes at the end, to avoid sanitizing individual
            // parts of a full URL. We don't care about losing the trustedness here.
            // In non-concatenable contexts, where there is only one expression, this interceptor is
            // not applied to the expression.
            value =
              trustedContext && !contextAllowsConcatenation
                ? $sce.getTrusted(trustedContext, value)
                : $sce.valueOf(value);
            return allOrNothing && !isDefined(value) ? value : stringify$1(value);
          } catch (err) {
            interr(text, err);
          }
        }
      }

      /**
       * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
       *
       * Use {@link ng.$interpolateProvider#startSymbol `$interpolateProvider.startSymbol`} to change
       * the symbol.
       *
       * @returns {string} start symbol.
       */
      $interpolate.startSymbol = function () {
        return provider.startSymbol;
      };

      /**
       * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
       *
       * Use {@link ng.$interpolateProvider#endSymbol `$interpolateProvider.endSymbol`} to change
       * the symbol.
       *
       * @returns {string} end symbol.
       */
      $interpolate.endSymbol = function () {
        return provider.endSymbol;
      };

      return $interpolate;
    },
  ];
}

let lastCookies = {};
let lastCookieString = "";

/**
 * @returns {Object<String, String>} List of all cookies
 */
function getCookies() {
  let cookieArray;
  let cookie;
  let i;
  let index;
  let name;
  const currentCookieString = document.cookie;

  if (currentCookieString !== lastCookieString) {
    lastCookieString = currentCookieString;
    cookieArray = lastCookieString.split("; ");
    lastCookies = {};

    for (i = 0; i < cookieArray.length; i++) {
      cookie = cookieArray[i];
      index = cookie.indexOf("=");
      if (index > 0) {
        // ignore nameless cookies
        name = safeDecodeURIComponent(cookie.substring(0, index));
        // the first value that is seen for a cookie is the most
        // specific one.  values for the same cookie name that
        // follow are for less specific paths.
        if (isUndefined(lastCookies[name])) {
          lastCookies[name] = safeDecodeURIComponent(
            cookie.substring(index + 1),
          );
        }
      }
    }
  }
  return lastCookies;
}

function safeDecodeURIComponent(str) {
  try {
    return decodeURIComponent(str);
  } catch (e) {
    return str;
  }
}

const APPLICATION_JSON = "application/json";
const CONTENT_TYPE_APPLICATION_JSON = {
  "Content-Type": `${APPLICATION_JSON};charset=utf-8`,
};
const JSON_START = /^\[|^\{(?!\{)/;
const JSON_ENDS = {
  "[": /]$/,
  "{": /}$/,
};
const JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
const $httpMinErr = minErr("$http");

function serializeValue(v) {
  if (isObject(v)) {
    return isDate(v) ? v.toISOString() : toJson(v);
  }
  return v;
}

/**
 * Default params serializer that converts objects to strings
 * according to the following rules:
 *
 * * `{'foo': 'bar'}` results in `foo=bar`
 * * `{'foo': Date.now()}` results in `foo=2015-04-01T09%3A50%3A49.262Z` (`toISOString()` and encoded representation of a Date object)
 * * `{'foo': ['bar', 'baz']}` results in `foo=bar&foo=baz` (repeated key for each array element)
 * * `{'foo': {'bar':'baz'}}` results in `foo=%7B%22bar%22%3A%22baz%22%7D` (stringified and encoded representation of an object)
 *
 * Note that serializer will sort the request parameters alphabetically.
 */
function HttpParamSerializerProvider() {
  this.$get = function () {
    return function ngParamSerializer(params) {
      if (!params) return "";
      const parts = [];
      Object.keys(params)
        .sort()
        .forEach((key) => {
          const value = params[key];
          if (value === null || isUndefined(value) || isFunction(value)) return;
          if (Array.isArray(value)) {
            value.forEach((v) => {
              parts.push(
                `${encodeUriQuery(key)}=${encodeUriQuery(serializeValue(v))}`,
              );
            });
          } else {
            parts.push(
              `${encodeUriQuery(key)}=${encodeUriQuery(serializeValue(value))}`,
            );
          }
        });

      return parts.join("&");
    };
  };
}

function defaultHttpResponseTransform(data, headers) {
  if (isString(data)) {
    // Strip json vulnerability protection prefix and trim whitespace
    const tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();

    if (tempData) {
      const contentType = headers("Content-Type");
      const hasJsonContentType =
        contentType && contentType.indexOf(APPLICATION_JSON) === 0;

      if (hasJsonContentType || isJsonLike(tempData)) {
        try {
          data = fromJson(tempData);
        } catch (e) {
          if (!hasJsonContentType) {
            return data;
          }
          throw $httpMinErr(
            "baddata",
            'Data must be a valid JSON object. Received: "{0}". ' +
              'Parse error: "{1}"',
            data,
            e,
          );
        }
      }
    }
  }

  return data;
}

function isJsonLike(str) {
  const jsonStart = str.match(JSON_START);
  return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
}

/**
 * Parse headers into key value object
 *
 * @param {string} headers Raw headers as a string
 * @returns {Object} Parsed headers as key value object
 */
function parseHeaders(headers) {
  const parsed = Object.create(null);
  let i;

  function fillInParsed(key, val) {
    if (key) {
      parsed[key] = parsed[key] ? `${parsed[key]}, ${val}` : val;
    }
  }

  if (isString(headers)) {
    headers.split("\n").forEach(
      /** @param {string} line */
      (line) => {
        i = line.indexOf(":");
        fillInParsed(
          line.substring(0, i).trim().toLowerCase(),
          trim(line.substring(i + 1)),
        );
      },
    );
  } else if (isObject(headers)) {
    Object.entries(headers).forEach(([headerKey, headerVal]) => {
      fillInParsed(lowercase(headerKey), trim(headerVal));
    });
  }

  return parsed;
}

/**
 * Returns a function that provides access to parsed headers.
 *
 * Headers are lazy parsed when first requested.
 * @see parseHeaders
 *
 * @param {(string|Object)} headers Headers to provide access to.
 * @returns {function(string=)} Returns a getter function which if called with:
 *
 *   - if called with an argument returns a single header value or null
 *   - if called with no arguments returns an object containing all headers.
 */
function headersGetter(headers) {
  let headersObj;

  return function (name) {
    if (!headersObj) headersObj = parseHeaders(headers);

    if (name) {
      let value = headersObj[lowercase(name)];
      if (value === undefined) {
        value = null;
      }
      return value;
    }

    return headersObj;
  };
}

/**
 * Chain all given functions
 *
 * This function is used for both request and response transforming
 *
 * @param {*} data Data to transform.
 * @param {function(string=):any} headers HTTP headers getter fn.
 * @param {number} status HTTP status code of the response.
 * @param {function(...any): any | Array<Function>} fns Function or an array of functions.
 * @returns {*} Transformed data.
 */
function transformData(data, headers, status, fns) {
  if (isFunction(fns)) {
    return fns(data, headers, status);
  }

  if (Array.isArray(fns)) {
    /** @type {Array<function(...any): any>} */ (fns).forEach((fn) => {
      data = fn(data, headers, status);
    });
  }

  return data;
}

function isSuccess(status) {
  return status >= 200 && status < 300;
}

/**
 * Use `$httpProvider` to change the default behavior of the {@link ng.$http $http} service.
 */
function HttpProvider() {
  /**
   * Object containing default values for all {@link ng.$http $http} requests.
   *
   * - **`defaults.cache`** - {boolean|Object} - A boolean value or object created with
   * {@link ng.$cacheFactory `$cacheFactory`} to enable or disable caching of HTTP responses
   * by default. See {@link $http#caching $http Caching} for more information.
   *
   * - **`defaults.headers`** - {Object} - Default headers for all $http requests.
   * Refer to {@link ng.$http#setting-http-headers $http} for documentation on
   * setting default headers.
   *     - **`defaults.headers.common`**
   *     - **`defaults.headers.post`**
   *     - **`defaults.headers.put`**
   *     - **`defaults.headers.patch`**
   *   *
   * - **`defaults.paramSerializer`** - `{string|function(Object<string,string>):string}` - A function
   *  used to the prepare string representation of request parameters (specified as an object).
   *  If specified as string, it is interpreted as a function registered with the {@link auto.$injector $injector}.
   *  Defaults to {@link ng.$httpParamSerializer $httpParamSerializer}.
   *
   * - **`defaults.transformRequest`** -
   * `{Array<function(data, headersGetter)>|function(data, headersGetter)}` -
   * An array of functions (or a single function) which are applied to the request data.
   * By default, this is an array with one request transformation function:
   *
   *   - If the `data` property of the request configuration object contains an object, serialize it
   *     into JSON format.
   *
   * - **`defaults.transformResponse`** -
   * `{Array<function(data, headersGetter, status)>|function(data, headersGetter, status)}` -
   * An array of functions (or a single function) which are applied to the response data. By default,
   * this is an array which applies one response transformation function that does two things:
   *
   *  - If XSRF prefix is detected, strip it
   *    (see {@link ng.$http#security-considerations Security Considerations in the $http docs}).
   *  - If the `Content-Type` is `application/json` or the response looks like JSON,
   *    deserialize it using a JSON parser.
   *
   * - **`defaults.xsrfCookieName`** - {string} - Name of cookie containing the XSRF token.
   * Defaults value is `'XSRF-TOKEN'`.
   *
   * - **`defaults.xsrfHeaderName`** - {string} - Name of HTTP header to populate with the
   * XSRF token. Defaults value is `'X-XSRF-TOKEN'`.
   *
   */
  const defaults = (this.defaults = {
    // transform incoming response data
    transformResponse: [defaultHttpResponseTransform],

    // transform outgoing request data
    transformRequest: [
      function (d) {
        return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d)
          ? toJson(d)
          : d;
      },
    ],

    // default headers
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
      },
      post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
      put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
      patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
    },

    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",

    paramSerializer: "$httpParamSerializer",
  });

  let useApplyAsync = false;
  /**
   * Configure $http service to combine processing of multiple http responses received at around
   * the same time via {@link ng.$rootScope.Scope#$applyAsync $rootScope.$applyAsync}. This can result in
   * significant performance improvement for bigger applications that make many HTTP requests
   * concurrently (common during application bootstrap).
   *
   * Defaults to false. If no value is specified, returns the current configured value.
   *
   * @param {boolean=} value If true, when requests are loaded, they will schedule a deferred
   *    "apply" on the next tick, giving time for subsequent requests in a roughly ~10ms window
   *    to load and share the same digest cycle.
   *
   * @returns {boolean|Object} If a value is specified, returns the $httpProvider for chaining.
   *    otherwise, returns the current configured value.
   */
  this.useApplyAsync = function (value) {
    if (isDefined(value)) {
      useApplyAsync = !!value;
      return this;
    }
    return useApplyAsync;
  };

  /**
   * Array containing service factories for all synchronous or asynchronous {@link ng.$http $http}
   * pre-processing of request or postprocessing of responses.
   *
   * These service factories are ordered by request, i.e. they are applied in the same order as the
   * array, on request, but reverse order, on response.
   *
   * {@link ng.$http#interceptors Interceptors detailed info}
   */
  const interceptorFactories = (this.interceptors = []);

  /**
   * Array containing URLs whose origins are trusted to receive the XSRF token. See the
   * {@link ng.$http#security-considerations Security Considerations} sections for more details on
   * XSRF.
   *
   * **Note:** An "origin" consists of the [URI scheme](https://en.wikipedia.org/wiki/URI_scheme),
   * the [hostname](https://en.wikipedia.org/wiki/Hostname) and the
   * [port number](https://en.wikipedia.org/wiki/Port_(computer_networking). For `http:` and
   * `https:`, the port number can be omitted if using th default ports (80 and 443 respectively).
   * Examples: `http://example.com`, `https://api.example.com:9876`
   *
   * <div class="alert alert-warning">
   *   It is not possible to trust specific URLs/paths. The `path`, `query` and `fragment` parts
   *   of a URL will be ignored. For example, `https://foo.com/path/bar?query=baz#fragment` will be
   *   treated as `https://foo.com`, meaning that **all** requests to URLs starting with
   *   `https://foo.com/` will include the XSRF token.
   * </div>
   *
   * @example
   *
   * ```js
   * // App served from `https://example.com/`.
   * angular.
   *   module('xsrfTrustedOriginsExample', []).
   *   config(['$httpProvider', function($httpProvider) {
   *     $httpProvider.xsrfTrustedOrigins.push('https://api.example.com');
   *   }]).
   *   run(['$http', function($http) {
   *     // The XSRF token will be sent.
   *     $http.get('https://api.example.com/preferences').then(...);
   *
   *     // The XSRF token will NOT be sent.
   *     $http.get('https://stats.example.com/activity').then(...);
   *   }]);
   * ```
   */
  const xsrfTrustedOrigins = (this.xsrfTrustedOrigins = []);

  /**
   * This property is deprecated. Use {@link $httpProvider#xsrfTrustedOrigins xsrfTrustedOrigins}
   * instead.
   */
  Object.defineProperty(this, "xsrfWhitelistedOrigins", {
    get() {
      return this.xsrfTrustedOrigins;
    },
    set(origins) {
      this.xsrfTrustedOrigins = origins;
    },
  });

  this.$get = [
    "$browser",
    "$httpBackend",
    "$rootScope",
    "$injector",
    "$sce",
    /**
     *
     * @param {*} $browser
     * @param {*} $httpBackend
     * @param {*} $rootScope
     * @param {import("../../core/di/internal-injector").InjectorService} $injector
     * @param {*} $sce
     * @returns
     */
    function ($browser, $httpBackend, $rootScope, $injector, $sce) {
      /**
       * @type {Map<string, string>}
       */
      const defaultCache = new Map();

      /**
       * Make sure that default param serializer is exposed as a function
       */
      defaults.paramSerializer = isString(defaults.paramSerializer)
        ? $injector.get(defaults.paramSerializer)
        : defaults.paramSerializer;

      /**
       * Interceptors stored in reverse order. Inner interceptors before outer interceptors.
       * The reversal is needed so that we can build up the interception chain around the
       * server request.
       */
      const reversedInterceptors = [];

      interceptorFactories.forEach((interceptorFactory) => {
        reversedInterceptors.unshift(
          isString(interceptorFactory)
            ? $injector.get(interceptorFactory)
            : $injector.invoke(interceptorFactory),
        );
      });

      /**
       * A function to check request URLs against a list of allowed origins.
       */
      const urlIsAllowedOrigin = urlIsAllowedOriginFactory(xsrfTrustedOrigins);

      /**
       * @property {Array.<Object>} requestConfig Array of config objects for currently pending
       * requests. This is primarily meant to be used for debugging purposes.
       */
      function $http(requestConfig) {
        if (!isObject(requestConfig)) {
          throw minErr("$http")(
            "badreq",
            "Http request configuration must be an object.  Received: {0}",
            requestConfig,
          );
        }

        if (!isString($sce.valueOf(requestConfig.url))) {
          throw minErr("$http")(
            "badreq",
            "Http request configuration url must be a string or a $sce trusted object.  Received: {0}",
            requestConfig.url,
          );
        }

        const config = extend(
          {
            method: "get",
            transformRequest: defaults.transformRequest,
            transformResponse: defaults.transformResponse,
            paramSerializer: defaults.paramSerializer,
          },
          requestConfig,
        );

        config.headers = mergeHeaders(requestConfig);
        config.method = uppercase(config.method);
        config.paramSerializer = isString(config.paramSerializer)
          ? $injector.get(config.paramSerializer)
          : config.paramSerializer;

        $browser.$$incOutstandingRequestCount("$http");

        const requestInterceptors = [];
        const responseInterceptors = [];
        let promise = Promise.resolve(config);

        // apply interceptors
        reversedInterceptors.forEach((interceptor) => {
          if (interceptor.request || interceptor.requestError) {
            requestInterceptors.unshift(
              interceptor.request,
              interceptor.requestError,
            );
          }
          if (interceptor.response || interceptor.responseError) {
            responseInterceptors.push(
              interceptor.response,
              interceptor.responseError,
            );
          }
        });

        promise = chainInterceptors(promise, requestInterceptors);
        promise = promise.then(serverRequest);
        promise = chainInterceptors(promise, responseInterceptors);
        promise = promise.finally(completeOutstandingRequest);

        return promise;

        function chainInterceptors(promise, interceptors) {
          for (let i = 0, ii = interceptors.length; i < ii; ) {
            const thenFn = interceptors[i++];
            const rejectFn = interceptors[i++];

            promise = promise.then(thenFn, rejectFn);
          }

          interceptors.length = 0;

          return promise;
        }

        function completeOutstandingRequest() {
          $browser.$$completeOutstandingRequest(() => {}, "$http");
        }

        function executeHeaderFns(headers, config) {
          let headerContent;
          const processedHeaders = {};

          Object.entries(headers).forEach(([header, headerFn]) => {
            if (isFunction(headerFn)) {
              headerContent = headerFn(config);
              if (headerContent != null) {
                processedHeaders[header] = headerContent;
              }
            } else {
              processedHeaders[header] = headerFn;
            }
          });

          return processedHeaders;
        }

        function mergeHeaders(config) {
          let defHeaders = defaults.headers,
            reqHeaders = extend({}, config.headers);

          defHeaders = extend(
            {},
            defHeaders.common,
            defHeaders[lowercase(config.method)],
          );

          Object.keys(defHeaders).forEach((defHeaderName) => {
            const lowercaseDefHeaderName = lowercase(defHeaderName);
            const hasMatchingHeader = Object.keys(reqHeaders).some(
              (reqHeaderName) => {
                return lowercase(reqHeaderName) === lowercaseDefHeaderName;
              },
            );
            if (!hasMatchingHeader) {
              reqHeaders[defHeaderName] = defHeaders[defHeaderName];
            }
          });

          // execute if header value is a function for merged headers
          return executeHeaderFns(reqHeaders, shallowCopy(config));
        }

        function serverRequest(config) {
          const { headers } = config;
          const reqData = transformData(
            config.data,
            headersGetter(headers),
            undefined,
            config.transformRequest,
          );

          // strip content-type if data is undefined
          if (isUndefined(reqData)) {
            Object.keys(headers).forEach((header) => {
              if (lowercase(header) === "content-type") {
                delete headers[header];
              }
            });
          }

          if (
            isUndefined(config.withCredentials) &&
            !isUndefined(defaults.withCredentials)
          ) {
            config.withCredentials = defaults.withCredentials;
          }

          // send request
          return sendReq(config, reqData).then(
            transformResponse,
            transformResponse,
          );
        }

        function transformResponse(response) {
          // make a copy since the response must be cacheable
          const resp = extend({}, response);
          resp.data = transformData(
            response.data,
            response.headers,
            response.status,
            config.transformResponse,
          );
          return isSuccess(response.status) ? resp : Promise.reject(resp);
        }
      }

      $http.pendingRequests = [];

      /**
       * Shortcut method to perform `GET` request.
       *
       * @param {string} url Absolute or relative URL of the resource that is being requested;
       *                                   or an object created by a call to `$sce.trustAsResourceUrl(url)`.
       * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
       * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
       * See {@link ng.$http#$http-returns `$http()` return value}.
       */

      /**
       * Shortcut method to perform `DELETE` request.
       *
       * @param {string} url Absolute or relative URL of the resource that is being requested;
       *                                   or an object created by a call to `$sce.trustAsResourceUrl(url)`.
       * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
       * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
       * See {@link ng.$http#$http-returns `$http()` return value}.
       */

      /**
       * Shortcut method to perform `HEAD` request.
       *
       * @param {string} url Absolute or relative URL of the resource that is being requested;
       *                                   or an object created by a call to `$sce.trustAsResourceUrl(url)`.
       * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
       * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
       * See {@link ng.$http#$http-returns `$http()` return value}.
       */

      /**
       * Shortcut method to perform `JSONP` request.
       *
       * Note that, since JSONP requests are sensitive because the response is given full access to the browser,
       * the url must be declared, via {@link $sce} as a trusted resource URL.
       * You can trust a URL by adding it to the trusted resource URL list via
       * {@link $sceDelegateProvider#trustedResourceUrlList  `$sceDelegateProvider.trustedResourceUrlList`} or
       * by explicitly trusting the URL via {@link $sce#trustAsResourceUrl `$sce.trustAsResourceUrl(url)`}.
       *
       * You should avoid generating the URL for the JSONP request from user provided data.
       * Provide additional query parameters via `params` property of the `config` parameter, rather than
       * modifying the URL itself.
       *
       * You can also specify a default callback parameter name in `$http.defaults.jsonpCallbackParam`.
       * Initially this is set to `'callback'`.
       *
       * <div class="alert alert-danger">
       * You can no longer use the `JSON_CALLBACK` string as a placeholder for specifying where the callback
       * parameter value should go.
       * </div>
       *
       * If you would like to customise where and how the callbacks are stored then try overriding
       * or decorating the {@link $jsonpCallbacks} service.
       *
       * @param {string} url Absolute or relative URL of the resource that is being requested;
       *                                   or an object created by a call to `$sce.trustAsResourceUrl(url)`.
       * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
       * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
       * See {@link ng.$http#$http-returns `$http()` return value}.
       */
      createShortMethods("get", "delete", "head");

      /**
       * Shortcut method to perform `POST` request.
       *
       * @param {string} url Relative or absolute URL specifying the destination of the request
       * @param {*} data Request content
       * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
       * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
       * See {@link ng.$http#$http-returns `$http()` return value}.
       */

      /**
       * Shortcut method to perform `PUT` request.
       *
       * @param {string} url Relative or absolute URL specifying the destination of the request
       * @param {*} data Request content
       * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
       * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
       * See {@link ng.$http#$http-returns `$http()` return value}.
       */

      /**
       * Shortcut method to perform `PATCH` request.
       *
       * @param {string} url Relative or absolute URL specifying the destination of the request
       * @param {*} data Request content
       * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
       * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
       * See {@link ng.$http#$http-returns `$http()` return value}.
       */
      createShortMethodsWithData("post", "put", "patch");

      /**
       * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of
       * default headers, withCredentials as well as request and response transformations.
       *
       * See "Setting HTTP Headers" and "Transforming Requests and Responses" sections above.
       */
      $http.defaults = defaults;

      return $http;

      function createShortMethods(...names) {
        names.forEach((name) => {
          $http[name] = function (url, config) {
            return $http(
              extend({}, config || {}, {
                method: name,
                url,
              }),
            );
          };
        });
      }

      function createShortMethodsWithData(...names) {
        names.forEach((name) => {
          $http[name] = function (url, data, config) {
            return $http(
              extend({}, config || {}, {
                method: name,
                url,
                data,
              }),
            );
          };
        });
      }

      /**
       * Makes the request.
       *
       * !!! ACCESSES CLOSURE VARS:
       * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests
       */
      function sendReq(config, reqData) {
        const { promise, resolve, reject } = Promise.withResolvers();
        let cache;
        let cachedResp;
        const reqHeaders = config.headers;
        let { url } = config;

        if (!isString(url)) {
          // If it is not a string then the URL must be a $sce trusted object
          url = $sce.valueOf(url);
        }

        url = buildUrl(url, config.paramSerializer(config.params));

        $http.pendingRequests.push(config);
        promise.then(removePendingReq, removePendingReq);

        if (
          (config.cache || defaults.cache) &&
          config.cache !== false &&
          config.method === "GET"
        ) {
          cache = isObject(config.cache)
            ? config.cache
            : isObject(/** @type {?} */ (defaults).cache)
              ? /** @type {?} */ (defaults).cache
              : defaultCache;
        }

        if (cache) {
          cachedResp = cache.get(url);
          if (isDefined(cachedResp)) {
            if (isPromiseLike(cachedResp)) {
              // cached request has already been sent, but there is no response yet
              cachedResp.then(
                resolvePromiseWithResult,
                resolvePromiseWithResult,
              );
            } else {
              // serving from cache
              if (Array.isArray(cachedResp)) {
                resolvePromise(
                  cachedResp[1],
                  cachedResp[0],
                  shallowCopy(cachedResp[2]),
                  cachedResp[3],
                  cachedResp[4],
                );
              } else {
                resolvePromise(cachedResp, 200, {}, "OK", "complete");
              }
            }
          } else {
            // put the promise for the non-transformed response into cache as a placeholder
            cache.set(url, promise);
          }
        }

        // if we won't have the response in cache, set the xsrf headers and
        // send the request to the backend
        if (isUndefined(cachedResp)) {
          const xsrfValue = urlIsAllowedOrigin(config.url)
            ? getCookies()[config.xsrfCookieName || defaults.xsrfCookieName]
            : undefined;
          if (xsrfValue) {
            reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] =
              xsrfValue;
          }

          $httpBackend(
            config.method,
            url,
            reqData,
            done,
            reqHeaders,
            config.timeout,
            config.withCredentials,
            config.responseType,
            createApplyHandlers(config.eventHandlers),
            createApplyHandlers(config.uploadEventHandlers),
          );
        }

        return promise;

        function createApplyHandlers(eventHandlers) {
          if (eventHandlers) {
            const applyHandlers = {};
            Object.entries(eventHandlers).forEach(([key, eventHandler]) => {
              applyHandlers[key] = function (event) {
                if (useApplyAsync) {
                  setTimeout(() => $rootScope.$apply(callEventHandler));
                } else {
                  $rootScope.$apply(callEventHandler);
                }

                function callEventHandler() {
                  eventHandler(event);
                }
              };
            });
            return applyHandlers;
          }
        }

        /**
         * Callback registered to $httpBackend():
         *  - caches the response if desired
         *  - resolves the raw $http promise
         *  - calls $apply
         */
        function done(status, response, headersString, statusText, xhrStatus) {
          if (cache) {
            if (isSuccess(status)) {
              cache.set(url, [
                status,
                response,
                parseHeaders(headersString),
                statusText,
                xhrStatus,
              ]);
            } else {
              // remove promise from the cache
              cache.delete(url);
            }
          }

          function resolveHttpPromise() {
            resolvePromise(
              response,
              status,
              headersString,
              statusText,
              xhrStatus,
            );
          }

          if (useApplyAsync) {
            setTimeout(resolveHttpPromise);
          } else {
            resolveHttpPromise();
          }
        }

        /**
         * Resolves the raw $http promise.
         */
        function resolvePromise(
          response,
          status,
          headers,
          statusText,
          xhrStatus,
        ) {
          // status: HTTP response status code, 0, -1 (aborted by timeout / promise)
          status = status >= -1 ? status : 0;

          (isSuccess(status) ? resolve : reject)({
            data: response,
            status,
            headers: headersGetter(headers),
            config,
            statusText,
            xhrStatus,
          });
        }

        function resolvePromiseWithResult(result) {
          resolvePromise(
            result.data,
            result.status,
            shallowCopy(result.headers()),
            result.statusText,
            result.xhrStatus,
          );
        }

        function removePendingReq() {
          const idx = $http.pendingRequests.indexOf(config);
          if (idx !== -1) $http.pendingRequests.splice(idx, 1);
        }
      }

      function buildUrl(url, serializedParams) {
        if (serializedParams.length > 0) {
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      }
    },
  ];
}

/**
 * HTTP backend used by the {@link ng.$http service} that delegates to
 * XMLHttpRequest object and deals with browser incompatibilities.
 *
 * You should never need to use this service directly, instead use the higher-level abstractions:
 * {@link ng.$http $http}.
 *
 */
function HttpBackendProvider() {
  this.$get = [
    "$browser",
    /**
     * @param {import('../browser').Browser} $browser
     * @returns
     */
    function ($browser) {
      return createHttpBackend($browser);
    },
  ];
}

/**
 * @param {import('../browser').Browser} $browser
 * @returns
 */
function createHttpBackend($browser) {
  // TODO(vojta): fix the signature
  return function (
    method,
    url,
    post,
    callback,
    headers,
    timeout,
    withCredentials,
    responseType,
    eventHandlers,
    uploadEventHandlers,
  ) {
    url = url || $browser.url();

    const xhr = new XMLHttpRequest();
    let abortedByTimeout = false;

    xhr.open(method, url, true);
    if (headers) {
      Object.entries(headers).forEach(([key, value]) => {
        if (isDefined(value)) {
          xhr.setRequestHeader(key, value);
        }
      });
    }

    xhr.onload = function () {
      const statusText = xhr.statusText || "";

      let status = xhr.status;

      // fix status code when it is 0 (0 status is undocumented).
      // Occurs when accessing file resources or on Android 4.1 stock browser
      // while retrieving files from application cache.
      if (status === 0) {
        status = xhr.response
          ? 200
          : urlResolve(url).protocol === "file"
            ? 404
            : 0;
      }

      completeRequest(
        callback,
        status,
        xhr.response,
        xhr.getAllResponseHeaders(),
        statusText,
        "complete",
      );
    };

    xhr.onerror = function () {
      // The response is always empty
      // See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/#concept-network-error
      completeRequest(callback, -1, null, null, "", "error");
    };
    xhr.ontimeout = function () {
      // The response is always empty
      // See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/#concept-network-error
      completeRequest(callback, -1, null, null, "", "timeout");
    };

    xhr.onabort = function () {
      completeRequest(
        callback,
        -1,
        null,
        null,
        "",
        abortedByTimeout ? "timeout" : "abort",
      );
    };

    if (eventHandlers) {
      eventHandlers &&
        Object.entries(eventHandlers).forEach(([key, value]) => {
          xhr.addEventListener(key, value);
        });
    }

    if (uploadEventHandlers) {
      Object.entries(uploadEventHandlers).forEach(([key, value]) => {
        xhr.upload.addEventListener(key, value);
      });
    }

    if (withCredentials) {
      xhr.withCredentials = true;
    }

    if (responseType) {
      try {
        xhr.responseType = responseType;
      } catch (e) {
        // WebKit added support for the json responseType value on 09/03/2013
        // https://bugs.webkit.org/show_bug.cgi?id=73648. Versions of Safari prior to 7 are
        // known to throw when setting the value "json" as the response type. Other older
        // browsers implementing the responseType
        //
        // The json response type can be ignored if not supported, because JSON payloads are
        // parsed on the client-side regardless.
        if (responseType !== "json") {
          throw e;
        }
      }
    }

    xhr.send(isUndefined(post) ? null : post);

    // Since we are using xhr.abort() when a request times out, we have to set a flag that
    // indicates to requestAborted if the request timed out or was aborted.
    //
    // http.timeout = numerical timeout   timeout
    // http.timeout = $timeout            timeout
    // http.timeout = promise             abort
    // xhr.abort()                        abort (The xhr object is normally inaccessible, but
    //                                    can be exposed with the xhrFactory)
    if (timeout > 0) {
      var timeoutId = setTimeout(() => {
        timeoutRequest("timeout");
      }, timeout);
    } else if (isPromiseLike(timeout)) {
      timeout.then(() => {
        timeoutRequest(isDefined(timeout.$$timeoutId) ? "timeout" : "abort");
      });
    }

    function timeoutRequest(reason) {
      abortedByTimeout = reason === "timeout";
      if (xhr) {
        xhr.abort();
      }
    }

    function completeRequest(
      callback,
      status,
      response,
      headersString,
      statusText,
      xhrStatus,
    ) {
      // cancel timeout and subsequent timeout promise resolution
      if (isDefined(timeoutId)) {
        clearTimeout(timeoutId);
      }

      callback(status, response, headersString, statusText, xhrStatus);
    }
  };
}

/**
 * @typedef {Object} DefaultPorts
 * @property {number} http
 * @property {number} https
 * @property {number} ftp
 */

/**
 * Represents the configuration options for HTML5 mode.
 *
 * @typedef {Object} Html5Mode
 * @property {boolean} enabled - (default: false) If true, will rely on `history.pushState` to
 *     change URLs where supported. Falls back to hash-prefixed paths in browsers that do not
 *     support `pushState`.
 * @property {boolean} requireBase - (default: `true`) When html5Mode is enabled, specifies
 *     whether or not a `<base>` tag is required to be present. If both `enabled` and `requireBase`
 *     are true, and a `<base>` tag is not present, an error will be thrown when `$location` is injected.
 *     See the {@link guide/$location $location guide} for more information.
 * @property {boolean|string} rewriteLinks - (default: `true`) When html5Mode is enabled, enables or
 *     disables URL rewriting for relative links. If set to a string, URL rewriting will only apply to links
 *     with an attribute that matches the given string. For example, if set to `'internal-link'`, URL rewriting
 *     will only occur for `<a internal-link>` links. Note that [attribute name normalization](guide/directive#normalization)
 *     does not apply here, so `'internalLink'` will **not** match `'internal-link'`.
 */

/** @type {DefaultPorts} */
const DEFAULT_PORTS = { http: 80, https: 443, ftp: 21 };
const PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/;
const $locationMinErr = minErr("$location");

/**
 * @abstract
 */
class Location {
  /**
   * @param {string} appBase application base URL
   * @param {string} appBaseNoFile application base URL stripped of any filename
   */
  constructor(appBase, appBaseNoFile) {
    const parsedUrl = urlResolve(appBase);

    /** @type {string} */
    this.appBase = appBase;

    /** @type {string} */
    this.appBaseNoFile = appBaseNoFile;

    /**
     * An absolute URL is the full URL, including protocol (http/https ), the optional subdomain (e.g. www ), domain (example.com), and path (which includes the directory and slug).
     * @type {string}
     */
    this.$$absUrl = "";

    /**
     * If html5 mode is enabled
     * @type {boolean}
     */
    this.$$html5 = false;

    /**
     * Has any change been replacing?
     * @type {boolean}
     */
    this.$$replace = false;

    /** @type {import('../url-utils/url-utils').HttpProtocol} */
    this.$$protocol = parsedUrl.protocol;

    /** @type {string} */
    this.$$host = parsedUrl.hostname;

    /**
     * The port, without ":"
     * @type {number}
     */
    this.$$port =
      toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;

    /**
     * The pathname, beginning with "/"
     * @type {string}
     */
    this.$$path = undefined;

    /**
     * The hash string, minus the hash symbol
     * @type {string}
     */
    this.$$hash = undefined;

    /**
     * Helper property for scope watch changes
     * @type {boolean}
     */
    this.$$urlUpdatedByLocation = false;
  }

  /**
   * Return full URL representation with all segments encoded according to rules specified in
   * [RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).
   *
   * @return {string} full URL
   */
  absUrl() {
    return this.$$absUrl;
  }

  /**
   * This method is getter / setter.
   *
   * Return URL (e.g. `/path?a=b#hash`) when called without any parameter.
   * Change path, search and hash, when called with parameter and return `$location`.
   *
   * @param {string=} url New URL without base prefix (e.g. `/path?a=b#hash`)
   * @return {Location|string} url
   */
  url(url) {
    if (isUndefined(url)) {
      return this.$$url;
    }

    const match = PATH_MATCH.exec(url);
    if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
    if (match[2] || match[1] || url === "") this.search(match[3] || "");
    this.hash(match[5] || "");

    return this;
  }

  /**
   *
   * Return protocol of current URL.
   * @return {import("../url-utils/url-utils").HttpProtocol} protocol of current URL
   */
  protocol() {
    return this.$$protocol;
  }

  /**
   * This method is getter only.
   *
   * Return host of current URL.
   *
   * Note: compared to the non-AngularJS version `location.host` which returns `hostname:port`, this returns the `hostname` portion only.
   *
   *
   * @return {string} host of current URL.
   */
  host() {
    return this.$$host;
  }

  /**
   * This method is getter only.
   *
   * Return port of current URL.
   *
   *
   * ```js
   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
   * let port = $location.port();
   * // => 80
   * ```
   *
   * @return {number} port
   */
  port() {
    return this.$$port;
  }

  /**
   * This method is getter / setter.
   *
   * Return path of current URL when called without any parameter.
   *
   * Change path when called with parameter and return `$location`.
   *
   * Note: Path should always begin with forward slash (/), this method will add the forward slash
   * if it is missing.
   *
   *
   * ```js
   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
   * let path = $location.path();
   * // => "/some/path"
   * ```
   *
   * @param {(string|number)=} path New path
   * @return {(string|object)} path if called with no parameters, or `$location` if called with a parameter
   */
  path(path) {
    if (isUndefined(path)) {
      return this.$$path;
    }
    let newPath = path !== null ? path.toString() : "";
    this.$$path = newPath.charAt(0) === "/" ? newPath : `/${newPath}`;
    this.$$compose();
    return this;
  }

  /**
   * This method is getter / setter.
   *
   * Returns the hash fragment when called without any parameters.
   *
   * Changes the hash fragment when called with a parameter and returns `$location`.
   *
   *
   * ```js
   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo#hashValue
   * let hash = $location.hash();
   * // => "hashValue"
   * ```
   *
   * @param {(string|number)=} hash New hash fragment
   * @return {string|Location} hash
   */
  hash(hash) {
    if (isUndefined(hash)) {
      return this.$$hash;
    }

    this.$$hash = hash !== null ? hash.toString() : "";
    this.$$compose();
    return this;
  }

  /**
   * If called, all changes to $location during the current `$digest` will replace the current history
   * record, instead of adding a new one.
   */
  replace() {
    this.$$replace = true;
    return this;
  }

  /**
   * Returns or sets the search part (as object) of current URL when called without any parameter
   *
   * @param {string|Object=} search New search params - string or hash object.
   * @param {(string|number|Array<string>|boolean)=} paramValue If search is a string or number, then paramValue will override only a single search property.
   * @returns {Object|Location} Search object or Location object
   */
  search(search, paramValue) {
    switch (arguments.length) {
      case 0:
        return this.$$search;
      case 1:
        if (isString(search) || isNumber(search)) {
          search = search.toString();
          this.$$search = parseKeyValue(search);
        } else if (isObject(search)) {
          search = structuredClone(search, {});
          // remove object undefined or null properties
          Object.entries(search).forEach(([key, value]) => {
            if (value == null) delete search[key];
          });

          this.$$search = search;
        } else {
          throw $locationMinErr(
            "isrcharg",
            "The first argument of the `$location#search()` call must be a string or an object.",
          );
        }
        break;
      default:
        if (isUndefined(paramValue) || paramValue === null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
    }

    this.$$compose();
    return this;
  }

  /**
   * Compose url and update `url` and `absUrl` property
   * @returns {void}
   */
  $$compose() {
    this.$$url = normalizePath(this.$$path, this.$$search, this.$$hash);
    this.$$absUrl = this.$$normalizeUrl(this.$$url);
    this.$$urlUpdatedByLocation = true;
  }

  /**
   * @param {string} _url
   * @returns {string}
   */
  $$normalizeUrl(_url) {
    throw new Error(`Method not implemented ${_url}`);
  }

  /**
   * This method is getter / setter.
   *
   * Return the history state object when called without any parameter.
   *
   * Change the history state object when called with one parameter and return `$location`.
   * The state object is later passed to `pushState` or `replaceState`.
   * See {@link https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#state|History.state}
   *
   * NOTE: This method is supported only in HTML5 mode and only in browsers supporting
   * the HTML5 History API (i.e. methods `pushState` and `replaceState`). If you need to support
   * older browsers (like IE9 or Android < 4.0), don't use this method.
   *
   * @param {any} state State object for pushState or replaceState
   * @return {any} state
   */
  state(state) {
    if (!arguments.length) {
      return this.$$state;
    }

    if (!(this instanceof LocationHtml5Url) || !this.$$html5) {
      throw $locationMinErr(
        "nostate",
        "History API state support is available only " +
          "in HTML5 mode and only in browsers supporting HTML5 History API",
      );
    }
    // The user might modify `stateObject` after invoking `$location.state(stateObject)`
    // but we're changing the $$state reference to $browser.state() during the $digest
    // so the modification window is narrow.
    this.$$state = isUndefined(state) ? null : state;
    this.$$urlUpdatedByLocation = true;
    return this;
  }

  /**
   * @param {string} _url
   * @param {string} _url2
   * @returns {boolean}
   */
  $$parseLinkUrl(_url, _url2) {
    throw new Error(`Method not implemented ${_url} ${_url2}`);
  }

  $$parse(_url) {
    throw new Error(`Method not implemented ${_url}`);
  }
}

/**
 * This object is exposed as $location service when HTML5 mode is enabled and supported
 */
class LocationHtml5Url extends Location {
  /**
   * @param {string} appBase application base URL
   * @param {string} appBaseNoFile application base URL stripped of any filename
   * @param {string} basePrefix URL path prefix
   */
  constructor(appBase, appBaseNoFile, basePrefix) {
    super(appBase, appBaseNoFile);
    this.$$html5 = true;
    this.basePrefix = basePrefix || "";
  }

  /**
   * Parse given HTML5 (regular) URL string into properties
   * @param {string} url HTML5 URL
   */
  $$parse(url) {
    const pathUrl = stripBaseUrl(this.appBaseNoFile, url);
    if (!isString(pathUrl)) {
      throw $locationMinErr(
        "ipthprfx",
        'Invalid url "{0}", missing path prefix "{1}".',
        url,
        this.appBaseNoFile,
      );
    }

    parseAppUrl(pathUrl, this, true);

    if (!this.$$path) {
      this.$$path = "/";
    }

    this.$$compose();
  }

  $$normalizeUrl(url) {
    return this.appBaseNoFile + url.substring(1); // first char is always '/'
  }

  /**
   * @param {string} url
   * @param {string} relHref
   * @returns {boolean}
   */
  $$parseLinkUrl(url, relHref) {
    if (relHref && relHref[0] === "#") {
      // special case for links to hash fragments:
      // keep the old url and only replace the hash fragment
      this.hash(relHref.slice(1));
      return true;
    }
    let appUrl;
    let prevAppUrl;
    let rewrittenUrl;

    if (isDefined((appUrl = stripBaseUrl(this.appBase, url)))) {
      prevAppUrl = appUrl;
      if (
        this.basePrefix &&
        isDefined((appUrl = stripBaseUrl(this.basePrefix, appUrl)))
      ) {
        rewrittenUrl =
          this.appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl);
      } else {
        rewrittenUrl = this.appBase + prevAppUrl;
      }
    } else if (isDefined((appUrl = stripBaseUrl(this.appBaseNoFile, url)))) {
      rewrittenUrl = this.appBaseNoFile + appUrl;
    } else if (this.appBaseNoFile === `${url}/`) {
      rewrittenUrl = this.appBaseNoFile;
    }
    if (rewrittenUrl) {
      this.$$parse(rewrittenUrl);
    }
    return !!rewrittenUrl;
  }
}

/**
 * LocationHashbangUrl represents URL
 * This object is exposed as $location service when developer doesn't opt into html5 mode.
 * It also serves as the base class for html5 mode fallback on legacy browsers.
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} appBaseNoFile application base URL stripped of any filename
 * @param {string} hashPrefix hashbang prefix
 */
class LocationHashbangUrl extends Location {
  constructor(appBase, appBaseNoFile, hashPrefix) {
    super(appBase, appBaseNoFile);
    this.hashPrefix = hashPrefix;
  }

  /**
   * Parse given hashbang URL into properties
   * @param {string} url Hashbang URL
   */
  $$parse(url) {
    const withoutBaseUrl =
      stripBaseUrl(this.appBase, url) || stripBaseUrl(this.appBaseNoFile, url);
    let withoutHashUrl;

    if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
      // The rest of the URL starts with a hash so we have
      // got either a hashbang path or a plain hash fragment
      withoutHashUrl = stripBaseUrl(this.hashPrefix, withoutBaseUrl);
      if (isUndefined(withoutHashUrl)) {
        // There was no hashbang prefix so we just have a hash fragment
        withoutHashUrl = withoutBaseUrl;
      }
    } else {
      // There was no hashbang path nor hash fragment:
      // If we are in HTML5 mode we use what is left as the path;
      // Otherwise we ignore what is left
      if (this.$$html5) {
        withoutHashUrl = withoutBaseUrl;
      } else {
        withoutHashUrl = "";
        if (isUndefined(withoutBaseUrl)) {
          this.appBase = url;
          /** @type {?} */ (this).replace();
        }
      }
    }

    parseAppUrl(withoutHashUrl, this, false);

    this.$$path = removeWindowsDriveName(
      this.$$path,
      withoutHashUrl,
      this.appBase,
    );

    this.$$compose();

    /*
     * In Windows, on an anchor node on documents loaded from
     * the filesystem, the browser will return a pathname
     * prefixed with the drive name ('/C:/path') when a
     * pathname without a drive is set:
     *  * a.setAttribute('href', '/foo')
     *   * a.pathname === '/C:/foo' //true
     *
     * Inside of AngularJS, we're always using pathnames that
     * do not include drive names for routing.
     */
    function removeWindowsDriveName(path, url, base) {
      /*
      Matches paths for file protocol on windows,
      such as /C:/foo/bar, and captures only /foo/bar.
      */
      const windowsFilePathExp = /^\/[A-Z]:(\/.*)/;

      let firstPathSegmentMatch;

      // Get the relative path from the input URL.
      if (startsWith(url, base)) {
        url = url.replace(base, "");
      }

      // The input URL intentionally contains a first path segment that ends with a colon.
      if (windowsFilePathExp.exec(url)) {
        return path;
      }

      firstPathSegmentMatch = windowsFilePathExp.exec(path);
      return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
    }
  }

  $$normalizeUrl(url) {
    return this.appBase + (url ? this.hashPrefix + url : "");
  }

  /**
   * @param {string} url
   * @returns {boolean}
   */
  $$parseLinkUrl(url) {
    if (stripHash(this.appBase) === stripHash(url)) {
      this.$$parse(url);
      return true;
    }
    return false;
  }
}

class LocationProvider {
  constructor() {
    /** @type {string} */
    this.hashPrefixConf = "!";

    /** @type {Html5Mode} */
    this.html5ModeConf = {
      enabled: false,
      requireBase: true,
      rewriteLinks: true,
    };
  }

  /**
   * The default value for the prefix is `'!'`.
   * @param {string=} prefix Prefix for hash part (containing path and search)
   * @returns {void}
   */
  setHashPrefix(prefix) {
    this.hashPrefixConf = prefix;
  }

  /**
   * Current hash prefix
   * @returns {string}
   */
  getHashPrefix() {
    return this.hashPrefixConf;
  }

  /**
   * Configures html5 mode
   * @param {(boolean|Html5Mode)=} mode If boolean, sets `html5Mode.enabled` to value. Otherwise, accepts html5Mode object
   *
   * @returns {void}
   */
  setHtml5Mode(mode) {
    if (isBoolean(mode)) {
      this.html5ModeConf.enabled = /** @type {boolean} */ (mode);
    }
    if (isObject(mode)) {
      const html5Mode = /** @type {Html5Mode} */ (mode);
      if (isDefined(html5Mode.enabled) && isBoolean(html5Mode.enabled)) {
        this.html5ModeConf.enabled = html5Mode.enabled;
      }

      if (
        isDefined(html5Mode.requireBase) &&
        isBoolean(html5Mode.requireBase)
      ) {
        this.html5ModeConf.requireBase = html5Mode.requireBase;
      }

      if (
        isDefined(html5Mode.rewriteLinks) &&
        (isBoolean(html5Mode.rewriteLinks) || isString(html5Mode.rewriteLinks))
      ) {
        this.html5ModeConf.rewriteLinks = html5Mode.rewriteLinks;
      }
    }
  }

  /**
   * Returns html5 mode cofiguration
   * @returns {Html5Mode}
   */
  getHtml5Mode() {
    return this.html5ModeConf;
  }

  $get = [
    "$rootScope",
    "$browser",
    "$rootElement",
    /**
     *
     * @param {import('../scope/scope.js').Scope} $rootScope
     * @param {import('../../services/browser').Browser} $browser
     * @param {Element} $rootElement
     * @returns
     */
    ($rootScope, $browser, $rootElement) => {
      /** @type {Location} */
      let $location;
      let LocationMode;
      const baseHref = $browser.baseHref(); // if base[href] is undefined, it defaults to ''
      const initialUrl = /** @type {string} */ ($browser.url());
      let appBase;

      if (this.getHtml5Mode().enabled) {
        if (!baseHref && this.getHtml5Mode().requireBase) {
          throw $locationMinErr(
            "nobase",
            "$location in HTML5 mode requires a <base> tag to be present!",
          );
        }
        appBase = serverBase(initialUrl) + (baseHref || "/");
        LocationMode = LocationHtml5Url;
      } else {
        appBase = stripHash(initialUrl);
        LocationMode = LocationHashbangUrl;
      }
      const appBaseNoFile = stripFile(appBase);

      $location = new LocationMode(
        appBase,
        appBaseNoFile,
        `#${this.getHashPrefix()}`,
      );
      $location.$$parseLinkUrl(initialUrl, initialUrl);

      $location.$$state = $browser.state();

      const IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;

      function setBrowserUrlWithFallback(url, state) {
        const oldUrl = $location.url();
        const oldState = $location.$$state;
        try {
          $browser.url(url, state);

          // Make sure $location.state() returns referentially identical (not just deeply equal)
          // state object; this makes possible quick checking if the state changed in the digest
          // loop. Checking deep equality would be too expensive.
          $location.$$state = $browser.state();
        } catch (e) {
          // Restore old values if pushState fails
          $location.url(/** @type {string} */ (oldUrl));
          $location.$$state = oldState;

          throw e;
        }
      }

      $rootElement.addEventListener(
        "click",
        /** @param {MouseEvent} event */
        (event) => {
          const rewriteLinks = this.getHtml5Mode().rewriteLinks;
          // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
          // currently we open nice url link and redirect then

          if (
            !rewriteLinks ||
            event.ctrlKey ||
            event.metaKey ||
            event.shiftKey ||
            event.which === 2 ||
            event.button === 2
          ) {
            return;
          }
          let elm = /** @type {HTMLAnchorElement} */ (event.target);

          // traverse the DOM up to find first A tag
          while (elm.nodeName.toLowerCase() !== "a") {
            // ignore rewriting if no A tag (reached root element, or no parent - removed from document)
            if (elm === $rootElement || !(elm = elm.parentElement)) return;
          }

          if (
            isString(rewriteLinks) &&
            isUndefined(elm.getAttribute(/** @type {string} */ (rewriteLinks)))
          ) {
            return;
          }

          let absHref = elm.href;
          // get the actual href attribute - see
          // http://msdn.microsoft.com/en-us/library/ie/dd347148(v=vs.85).aspx
          const relHref =
            elm.getAttribute("href") || elm.getAttribute("xlink:href");

          if (
            isObject(absHref) &&
            absHref.toString() === "[object SVGAnimatedString]"
          ) {
            // SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during
            // an animation.
            absHref = urlResolve(absHref.animVal).href;
          }

          // Ignore when url is started with javascript: or mailto:
          if (IGNORE_URI_REGEXP.test(absHref)) return;

          if (
            absHref &&
            !elm.getAttribute("target") &&
            !event.defaultPrevented
          ) {
            if ($location.$$parseLinkUrl(absHref, relHref)) {
              // We do a preventDefault for all urls that are part of the AngularJS application,
              // in html5mode and also without, so that we are able to abort navigation without
              // getting double entries in the location history.
              event.preventDefault();
              // update location manually
              // if ($location.absUrl() !== $browser.url()) {
              //   $rootScope.$apply();
              // }
            }
          }
        },
      );

      // rewrite hashbang url <> html5 url
      if ($location.absUrl() !== initialUrl) {
        $browser.url($location.absUrl(), true);
      }

      let initializing = true;

      // update $location when $browser url changes
      $browser.onUrlChange((newUrl, newState) => {
        if (!startsWith(newUrl, appBaseNoFile)) {
          // If we are navigating outside of the app then force a reload
          window.location.href = newUrl;
          return;
        }

        $rootScope.$evalAsync(() => {
          const oldUrl = $location.absUrl();
          const oldState = $location.$$state;
          let defaultPrevented;
          $location.$$parse(newUrl);
          $location.$$state = newState;

          defaultPrevented = $rootScope.$broadcast(
            "$locationChangeStart",
            newUrl,
            oldUrl,
            newState,
            oldState,
          ).defaultPrevented;

          // if the location was changed by a `$locationChangeStart` handler then stop
          // processing this location change
          if ($location.absUrl() !== newUrl) return;

          if (defaultPrevented) {
            $location.$$parse(oldUrl);
            $location.$$state = oldState;
            setBrowserUrlWithFallback(oldUrl, oldState);
          } else {
            initializing = false;
            afterLocationChange(oldUrl, oldState);
          }
        });
      });

      // update browser
      const updateBrowser = () => {
        if (initializing || $location.$$urlUpdatedByLocation) {
          $location.$$urlUpdatedByLocation = false;

          const oldUrl = /** @type {string} */ ($browser.url());
          const newUrl = $location.absUrl();
          const oldState = $browser.state();
          const urlOrStateChanged =
            !urlsEqual(oldUrl, newUrl) ||
            ($location.$$html5 && oldState !== $location.$$state);

          if (initializing || urlOrStateChanged) {
            initializing = false;

            setTimeout(() => {
              const newUrl = $location.absUrl();
              const { defaultPrevented } = $rootScope.$broadcast(
                "$locationChangeStart",
                newUrl,
                oldUrl,
                $location.$$state,
                oldState,
              );

              // if the location was changed by a `$locationChangeStart` handler then stop
              // processing this location change
              if ($location.absUrl() !== newUrl) return;

              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
              } else {
                if (urlOrStateChanged) {
                  setBrowserUrlWithFallback(
                    newUrl,
                    oldState === $location.$$state ? null : $location.$$state,
                  );
                }
                afterLocationChange(oldUrl, oldState);
              }
            });
          }
        }

        $location.$$replace = false;

        // we don't need to return anything because $evalAsync will make the digest loop dirty when
        // there is a change
      };

      updateBrowser();
      $rootScope.$on("$updateBrowser", updateBrowser);

      return $location;

      function afterLocationChange(oldUrl, oldState) {
        $rootScope.$broadcast(
          "$locationChangeSuccess",
          $location.absUrl(),
          oldUrl,
          $location.$$state,
          oldState,
        );
      }
    },
  ];
}

/**
 * ///////////////////////////
 *          HELPERS
 * ///////////////////////////
 */

/**
 * Encode path using encodeUriSegment, ignoring forward slashes
 *
 * @param {string} path Path to encode
 * @returns {string}
 */
function encodePath(path) {
  const segments = path.split("/");
  let i = segments.length;

  while (i--) {
    // decode forward slashes to prevent them from being double encoded
    segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, "/"));
  }

  return segments.join("/");
}

function decodePath(path, html5Mode) {
  const segments = path.split("/");
  let i = segments.length;

  while (i--) {
    segments[i] = decodeURIComponent(segments[i]);
    if (html5Mode) {
      // encode forward slashes to prevent them from being mistaken for path separators
      segments[i] = segments[i].replace(/\//g, "%2F");
    }
  }

  return segments.join("/");
}

function normalizePath(pathValue, searchValue, hashValue) {
  const search = toKeyValue(searchValue);
  const hash = hashValue ? `#${encodeUriSegment(hashValue)}` : "";
  const path = encodePath(pathValue);

  return path + (search ? `?${search}` : "") + hash;
}

function parseAppUrl(url, locationObj, html5Mode) {
  if (/^\s*[\\/]{2,}/.test(url)) {
    throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
  }

  const prefixed = url.charAt(0) !== "/";
  if (prefixed) {
    url = `/${url}`;
  }
  const match = urlResolve(url);
  const path =
    prefixed && match.pathname.charAt(0) === "/"
      ? match.pathname.substring(1)
      : match.pathname;
  locationObj.$$path = decodePath(path, html5Mode);
  locationObj.$$search = parseKeyValue(match.search);
  locationObj.$$hash = decodeURIComponent(match.hash);

  // make sure path starts with '/';
  if (locationObj.$$path && locationObj.$$path.charAt(0) !== "/") {
    locationObj.$$path = `/${locationObj.$$path}`;
  }
}

function startsWith(str, search) {
  return str.slice(0, search.length) === search;
}

/**
 *
 * @param {string} base
 * @param {string} url
 * @returns {string} returns text from `url` after `base` or `undefined` if it does not begin with
 *                   the expected string.
 */
function stripBaseUrl(base, url) {
  if (startsWith(url, base)) {
    return url.substring(base.length);
  }
}

function stripHash(url) {
  const index = url.indexOf("#");
  return index === -1 ? url : url.substring(0, index);
}

function stripFile(url) {
  return url.substring(0, stripHash(url).lastIndexOf("/") + 1);
}

/* return the server only (scheme://host:port) */
function serverBase(url) {
  return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
}

// Determine if two URLs are equal despite potentially having different encoding/normalizing
//  such as $location.absUrl() vs $browser.url()
// See https://github.com/angular/angular.js/issues/16592
function urlsEqual(a, b) {
  return a === b || urlResolve(a).href === urlResolve(b).href;
}

///////////////////////////////////////////////////////////////////////////
// LogService
// see http://docs.angularjs.org/api/ng/service/$log
// see http://docs.angularjs.org/api/ng/provider/$logProvider
///////////////////////////////////////////////////////////////////////////

/**
 * @typedef {(...args: any[]) => void} LogCall
 */

/**
 * @typedef {Object} LogService
 * @property {LogCall} debug - Log a debug messages
 * @property {LogCall} error - Log a error message
 * @property {LogCall} info - Log a info message
 * @property {LogCall} log - Log a general message
 * @property {LogCall} warn - Log a warning message
 */

/**
 * @type {LogService}
 */
let LogService = {
  debug: undefined,
  error: undefined,
  info: undefined,
  log: undefined,
  warn: undefined,
};

/**
 * @type {LogProvider}
 * Use the `$logProvider` to configure how the application logs messages
 */
class LogProvider {
  constructor() {
    this.debug = true;
  }

  /**
   * @param {boolean=} flag enable or disable debug level messages
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  debugEnabled(flag) {
    if (typeof flag !== "undefined") {
      this.debug = flag;
      return this;
    }
    return this.debug;
  }

  formatError(arg) {
    if (isError(arg)) {
      if (arg.stack) {
        arg =
          arg.message && arg.stack.indexOf(arg.message) === -1
            ? `Error: ${arg.message}\n${arg.stack}`
            : arg.stack;
      } else if (arg.sourceURL) {
        arg = `${arg.message}\n${arg.sourceURL}:${arg.line}`;
      }
    }
    return arg;
  }

  consoleLog(type) {
    const console = window.console || {};
    const logFn = console[type] || console.log || (() => {});

    return (...args) => {
      const formattedArgs = args.map((arg) => this.formatError(arg));
      return logFn.apply(console, formattedArgs);
    };
  }

  $get() {
    LogService = {
      log: this.consoleLog("log"),
      info: this.consoleLog("info"),
      warn: this.consoleLog("warn"),
      error: this.consoleLog("error"),
      debug: (() => {
        const fn = this.consoleLog("debug");
        return (...args) => {
          if (this.debug) {
            fn.apply(this, args);
          }
        };
      })(),
    };
    return LogService;
  }
}

/**
 * @type {number}
 */
let uid = 0;

function nextId() {
  uid += 1;
  return uid;
}

/**
 * @type {import('../parse/parse.js').ParseService}
 */
let $parse;

/**@type {import('../exception-handler.js').ErrorHandler} */
let $exceptionHandler;

/**
 * @typedef {Object} AsyncQueueTask
 * @property {Scope} handler
 * @property {Function} fn
 * @property {Object} locals
 */

const $postUpdateQueue = [];

class RootScopeProvider {
  constructor() {
    this.rootScope = createScope();
  }

  $get = [
    "$exceptionHandler",
    "$parse",
    /**
     * @param {import('../exception-handler.js').ErrorHandler} exceptionHandler
     * @param {import('../parse/parse.js').ParseService} parse
     */
    (exceptionHandler, parse) => {
      $exceptionHandler = exceptionHandler;
      $parse = parse;
      return this.rootScope;
    },
  ];
}

/**
 * Creates a deep proxy for the target object, intercepting property changes
 * and recursively applying proxies to nested objects.
 *
 * @param {Object} target - The object to be wrapped in a proxy.
 * @param {Scope} [context] - The context for the handler, used to track listeners.
 * @returns {Scope} - A proxy that intercepts operations on the target object,
 *                                     or the original value if the target is not an object.
 */
function createScope(target = {}, context) {
  if (
    isNull(target) ||
    target[NONSCOPE] === true ||
    (target.constructor && target.constructor[NONSCOPE]) === true
  ) {
    return target;
  }

  if (typeof target === "object") {
    const proxy = new Proxy(target, context || new Scope());
    for (const key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        try {
          if (
            (target.constructor.$nonscope &&
              Array.isArray(target.constructor.$nonscope) &&
              target.constructor.$nonscope.includes(key)) ||
            (target.$nonscope &&
              Array.isArray(target.$nonscope) &&
              target.$nonscope.includes(key))
          ) {
            continue;
          } else {
            target[key] = createScope(target[key], proxy.$handler);
          }
        } catch (e) {
          // convert only what we can
        }
      }
    }

    return proxy;
  } else {
    return target;
  }
}

/**
 * Listener function definition.
 * @typedef {Object} Listener
 * @property {Object} originalTarget - The original target object.
 * @property {ListenerFunction} listenerFn - The function invoked when changes are detected.
 * @property {import("../parse/parse.js").CompiledExpression} watchFn
 * @property {number} id - Deregistration id
 * @property {number} scopeId - The scope that created the Listener
 * @property {string[]} property
 * @property {string} [watchProp] - The original property to watch if different from observed key
 * @property {Proxy} [foreignListener]
 *
 */

/**
 * Listener function type.
 * @callback ListenerFunction
 * @param {*} newValue - The new value of the changed property.
 * @param {Object} originalTarget - The original target object.
 */

/**
 * Decorator for excluding objects from scope observability
 */
const NONSCOPE = "$nonscope";

/**
 * Scope class for the Proxy. It intercepts operations like property access (get)
 * and property setting (set), and adds support for deep change tracking and
 * observer-like behavior.
 */
class Scope {
  /**
   * Initializes the handler with the target object and a context.
   *
   * @param {Scope} [context] - The context containing listeners.
   * @param {Scope} [parent] - Custom parent.
   */
  constructor(context, parent) {
    this.context = context
      ? context.context
        ? context.context
        : context
      : undefined;

    /** @type {Map<string, Array<Listener>>} Watch listeners */
    this.watchers = context ? context.watchers : new Map();

    /** @type {Map<String, Function[]>} Event listeners */
    this.$$listeners = new Map();

    /** @type {Map<string, Array<Listener>>} Watch listeners from other proxies */
    this.foreignListeners = context ? context.foreignListeners : new Map();

    /** @type {Set<ProxyConstructor>} */
    this.foreignProxies = context ? context.foreignProxies : new Set();

    /** @type {WeakMap<Object, Array<string>>} */
    this.objectListeners = context ? context.objectListeners : new WeakMap();

    /** @type {Map<Function, {oldValue: any, fn: Function}>} */
    this.functionListeners = context ? context.functionListeners : new Map();

    /** Current proxy being operated on */
    this.$proxy = null;

    /** @type {Scope} The actual proxy */
    this.$handler = /** @type {Scope} */ (this);

    /** @type {*} Current target being called on */
    this.$target = null;

    /** @type {*} Value wrapped by the proxy */
    this.$value = null;

    /**
     * @type {Scope[]}
     */
    this.$children = [];

    /**
     * @type {number} Unique model ID (monotonically increasing) useful for debugging.
     */
    this.$id = nextId();

    /**
     * @type {Scope}
     */
    this.$root = context ? context.$root : /** @type {Scope} */ (this);

    this.$parent = parent
      ? parent
      : /** @type {Scope} */ (this).$root === this
        ? null
        : context;

    /** @type {AsyncQueueTask[]} */
    this.$$asyncQueue = [];

    this.filters = [];

    /** @type {boolean} */
    this.$$destroyed = false;

    this.scheduled = [];
  }

  /**
   * Intercepts and handles property assignments on the target object. If a new value is
   * an object, it will be recursively proxied.
   *
   * @param {Object} target - The target object.
   * @param {string} property - The name of the property being set.
   * @param {*} value - The new value being assigned to the property.
   * @returns {boolean} - Returns true to indicate success of the operation.
   */
  set(target, property, value, proxy) {
    if (property === "undefined") {
      throw new Error("Attempting to set undefined property");
    }
    if (
      (target.constructor?.$nonscope &&
        Array.isArray(target.constructor.$nonscope) &&
        target.constructor.$nonscope.includes(property)) ||
      (target.$nonscope &&
        Array.isArray(target.$nonscope) &&
        target.$nonscope.includes(property))
    ) {
      target[property] = value;
      return true;
    }

    this.$proxy = proxy;
    this.$target = target;
    const oldValue = target[property];

    // Handle NaNs
    if (
      oldValue !== undefined &&
      Number.isNaN(oldValue) &&
      Number.isNaN(value)
    ) {
      return true;
    }
    if (oldValue && oldValue[isProxySymbol]) {
      if (Array.isArray(value)) {
        if (oldValue !== value) {
          const listeners = this.watchers.get(property);

          if (listeners) {
            this.scheduleListener(listeners);
          }

          const foreignListeners = this.foreignListeners.get(property);

          if (foreignListeners) {
            this.scheduleListener(foreignListeners);
          }
        }

        if (this.objectListeners.get(target[property])) {
          this.objectListeners.delete(target[property]);
        }
        target[property] = createScope(value, this);
        this.objectListeners.set(target[property], [property]);
        return true;
      }

      if (isObject(value)) {
        if (Object.prototype.hasOwnProperty.call(target, property)) {
          Object.keys(oldValue)
            .filter((x) => !value[x])
            .forEach((k) => {
              delete oldValue[k];
            });
        }

        if (oldValue !== value) {
          const listeners = this.watchers.get(property);

          if (listeners) {
            this.scheduleListener(listeners);
          }

          const foreignListeners = this.foreignListeners.get(property);

          if (foreignListeners) {
            this.scheduleListener(foreignListeners);
          }

          this.checkeListenersForAllKeys(value);
        }
        target[property] = createScope(value, this);
        //setDeepValue(target[property], value);
        return true;
      }

      if (isUndefined(value)) {
        let called = false;
        Object.keys(oldValue.$target).forEach((k) => {
          if (oldValue.$target[k]?.[isProxySymbol]) {
            called = true;
          }
          delete oldValue[k];
        });

        target[property] = undefined;
        if (!called) {
          let listeners = this.watchers.get(property);

          if (listeners) {
            this.scheduleListener(listeners);
          }
        }

        return true;
      }

      if (isDefined(value)) {
        target[property] = value;
        let listeners = this.watchers.get(property);

        if (listeners) {
          this.scheduleListener(listeners);
        }

        if (Array.isArray(target)) {
          if (this.objectListeners.has(proxy) && property !== "length") {
            let keys = this.objectListeners.get(proxy);
            keys.forEach((key) => {
              const listeners = this.watchers.get(key);
              if (listeners) {
                this.scheduleListener(listeners);
              }
            });
          }
        }

        return true;
      }
      return true;
    } else {
      if (isUndefined(target[property]) && isProxy(value)) {
        this.foreignProxies.add(value);
        target[property] = value;
        return true;
      }

      if (isUndefined(value)) {
        target[property] = value;
      } else {
        target[property] = createScope(value, this);
      }

      if (oldValue !== value) {
        let expectedTarget = this.$target;
        let listeners = [];
        // Handle the case where we need to start observing object after a watcher has been set
        if (isUndefined(oldValue) && isObject(target[property])) {
          if (!this.objectListeners.has(target[property])) {
            this.objectListeners.set(target[property], [property]);
          }
          for (const k of Object.keys(value)) {
            this.watchers.get(k)?.forEach((l) => listeners.push(l));
            // overwhrite the context so we pass the owneship test in filter
            expectedTarget = value;
          }
        }

        if (Array.isArray(target)) {
          this.watchers.get("length")?.forEach((l) => listeners.push(l));
        }

        this.watchers.get(property)?.forEach((l) => listeners.push(l));
        if (listeners.length > 0) {
          // check if the listener actually appllies to this target
          this.scheduleListener(listeners, (x) => {
            return x.filter((x) => {
              if (!x.watchProp) return true;
              // Compute the expected target based on `watchProp`
              const wrapperExpr = x.watchProp.split(".").slice(0, -1).join(".");
              const expectedHandler = $parse(wrapperExpr)(
                x.originalTarget,
              )?.$handler;
              return expectedTarget === expectedHandler?.$target;
            });
          });
        }

        let foreignListeners = this.foreignListeners.get(property);

        if (!foreignListeners && this.$parent?.foreignListeners) {
          foreignListeners = this.$parent.foreignListeners.get(property);
        }
        if (foreignListeners) {
          // filter for repeaters
          if (this.$target.$$hashKey) {
            foreignListeners = foreignListeners.filter((x) =>
              x.originalTarget.$$hashKey
                ? x.originalTarget.$$hashKey == this.$target.$$hashKey
                : false,
            );
          }

          this.scheduleListener(foreignListeners);
        }
      }

      if (this.objectListeners.has(proxy) && property !== "length") {
        let keys = this.objectListeners.get(proxy);
        keys.forEach((key) => {
          const listeners = this.watchers.get(key);
          if (listeners) {
            if (this.scheduled !== listeners) {
              this.scheduleListener(listeners);
            }
          }
        });
      }

      return true;
    }
  }

  checkeListenersForAllKeys(value) {
    if (isUndefined(value)) {
      return;
    }
    Object.keys(value).forEach((k) => {
      const listeners = this.watchers.get(k);

      if (listeners) {
        this.scheduleListener(listeners);
      }
      if (isObject(value[k])) {
        this.checkeListenersForAllKeys(value[k]);
      }
    });
  }

  /**
   * Intercepts property access on the target object. It checks for specific
   * properties (`watch` and `sync`) and binds their methods. For other properties,
   * it returns the value directly.
   *
   * @param {Object} target - The target object.
   * @param {string|number|symbol} property - The name of the property being accessed.
   * @param {Proxy} proxy - The proxy object being invoked
   * @returns {*} - The value of the property or a method if accessing `watch` or `sync`.
   */
  get(target, property, proxy) {
    if (property === "$$watchersCount") return calculateWatcherCount(this);
    if (property === isProxySymbol) return true;

    if (target[property] && isProxy(target[property])) {
      this.$proxy = target[property];
    } else {
      this.$proxy = proxy;
    }

    this.propertyMap = {
      $watch: this.$watch.bind(this),
      $watchGroup: this.$watchGroup.bind(this),
      $watchCollection: this.$watchCollection.bind(this),
      $new: this.$new.bind(this),
      $newIsolate: this.$newIsolate.bind(this),
      $destroy: this.$destroy.bind(this),
      $eval: this.$eval.bind(this),
      $apply: this.$apply.bind(this),
      $evalAsync: this.$evalAsync.bind(this),
      $postUpdate: this.$postUpdate.bind(this),
      $isRoot: this.isRoot.bind(this),
      $target: target,
      $proxy: this.$proxy,
      $digest: this.$digest.bind(this),
      $on: this.$on.bind(this),
      $emit: this.$emit.bind(this),
      $broadcast: this.$broadcast.bind(this),
      $transcluded: this.$transcluded.bind(this),
      $handler: this,
      $parent: this.$parent,
      $root: this.$root,
      $children: this.$children,
      $id: this.$id,
      registerForeignKey: this.registerForeignKey.bind(this),
      notifyListener: this.notifyListener.bind(this),
      $merge: this.$merge.bind(this),
      $getById: this.$getById.bind(this),
    };

    if (
      Array.isArray(target) &&
      ["pop", "shift", "unshift"].includes(/** @type { string } */ (property))
    ) {
      if (this.objectListeners.has(proxy)) {
        let keys = this.objectListeners.get(this.$proxy);
        keys.forEach((key) => {
          const listeners = this.watchers.get(key);
          if (listeners) {
            this.scheduled = listeners;
          }
        });
      }

      // TODO aditional testing
      if (property === "unshift") {
        this.scheduleListener(this.scheduled);
      }
    }

    if (Object.prototype.hasOwnProperty.call(this.propertyMap, property)) {
      this.$target = target;
      return this.propertyMap[property];
    } else {
      // we are a simple getter
      return target[property];
    }
  }

  /**
   * @private
   * @param {Listener[]} listeners
   */
  scheduleListener(listeners, filter = (val) => val) {
    Promise.resolve().then(() => {
      let index = 0;
      let filteredListeners = filter(listeners);
      while (index < filteredListeners.length) {
        const listener = filteredListeners[index];
        if (listener.foreignListener) {
          listener.foreignListener.notifyListener(listener, this.$target);
        } else {
          this.notifyListener(listener, this.$target);
        }
        index++;
      }
    });
  }

  deleteProperty(target, property) {
    // Currently deletes $model
    if (target[property] && target[property][isProxySymbol]) {
      target[property] = undefined;

      let listeners = this.watchers.get(property);
      if (listeners) {
        this.scheduleListener(listeners);
      }
      if (this.objectListeners.has(this.$proxy)) {
        let keys = this.objectListeners.get(this.$proxy);
        keys.forEach((key) => {
          listeners = this.watchers.get(key);
          if (listeners) {
            this.scheduleListener(listeners);
          }
        });
      }

      if (this.scheduled) {
        this.scheduleListener(this.scheduled);
        this.scheduled = [];
      }
      return true;
    }

    delete target[property];

    if (this.objectListeners.has(this.$proxy)) {
      let keys = this.objectListeners.get(this.$proxy);
      keys.forEach((key) => {
        const listeners = this.watchers.get(key);
        if (listeners) {
          this.scheduleListener(listeners);
        }
      });
    } else {
      const listeners = this.watchers.get(property);
      if (listeners) {
        this.scheduleListener(listeners, target[property]);
      }
    }

    return true;
  }

  /**
   * Registers a watcher for a property along with a listener function. The listener
   * function is invoked when changes to that property are detected.
   *
   * @param {string} watchProp - An expression to be watched in the context of this model.
   * @param {ListenerFunction} [listenerFn] - A function to execute when changes are detected on watched context.
   * @param {boolean} [lazy] - A flag to indicate if the listener should be invoked immediately. Defaults to false.
   */
  $watch(watchProp, listenerFn, lazy = false) {
    assert(isString(watchProp), "Watched property required");
    watchProp = watchProp.trim();
    const get = $parse(watchProp);

    // Constant are immediately passed to listener function
    if (get.constant) {
      if (listenerFn) {
        Promise.resolve().then(() => {
          let res = get();
          while (isFunction(res)) {
            res = res();
          }
          listenerFn(res, this.$target);
        });
      }
      return () => {};
    }

    /** @type {Listener} */
    const listener = {
      originalTarget: this.$target,
      listenerFn: listenerFn,
      watchFn: get,
      scopeId: this.$id,
      id: nextUid(),
      property: [],
    };
    // simplest case
    let key = get.decoratedNode.body[0].expression.name;
    let keySet = [];

    let type = get.decoratedNode.body[0].expression.type;
    switch (type) {
      // 1
      case ASTType.Program: {
        throw new Error("Unsupported type " + type);
      }
      // 2
      case ASTType.ExpressionStatement: {
        throw new Error("Unsupported type " + type);
      }
      // 3
      case ASTType.AssignmentExpression:
        // assignment calls without listener functions
        if (!listenerFn) {
          let res = get(this.$target);
          while (isFunction(res)) {
            res = res(this.$target);
          }
          Promise.resolve().then(res);
          return () => {};
        }
        key = get.decoratedNode.body[0].expression.left.name;
        break;
      // 4
      case ASTType.ConditionalExpression: {
        key = get.decoratedNode.body[0].expression.toWatch[0]?.test?.name;
        listener.property.push(key);
        break;
      }
      // 5
      case ASTType.LogicalExpression: {
        let keys = [];
        keys.push(get.decoratedNode.body[0].expression.left.toWatch[0]?.name);
        keys.push(get.decoratedNode.body[0].expression.right.toWatch[0]?.name);
        keys.forEach((key) => {
          this.registerKey(key, listener);
        });
        return () => {
          keys.forEach((key) => {
            this.deregisterKey(key, listener.id);
          });
        };
      }
      // 6
      case ASTType.BinaryExpression: {
        let expr = get.decoratedNode.body[0].expression.toWatch[0];
        key = expr.property ? expr.property.name : expr.name;
        if (!key) {
          throw new Error("Unable to determine key");
        }
        listener.property.push(key);
        break;
      }
      // 7
      case ASTType.UnaryExpression: {
        let expr = get.decoratedNode.body[0].expression.toWatch[0];
        key = expr.property ? expr.property.name : expr.name;
        if (!key) {
          throw new Error("Unable to determine key");
        }
        listener.property.push(key);
        break;
      }
      // 8 function
      case ASTType.CallExpression: {
        let keys = [];
        get.decoratedNode.body[0].expression.toWatch.forEach((x) => {
          if (isDefined(x)) {
            keys.push(x.name);
          }
        });
        keys.forEach((key) => {
          this.registerKey(key, listener);
          this.scheduleListener([listener]);
        });

        return () => {
          keys.forEach((key) => {
            this.deregisterKey(key, listener.id);
          });
        };
      }

      // 9
      case ASTType.MemberExpression: {
        key = get.decoratedNode.body[0].expression.property.name;

        // array watcher
        if (!key) {
          key = get.decoratedNode.body[0].expression.object.name;
        }

        listener.property.push(key);
        if (watchProp !== key) {
          // Handle nested expression call
          listener.watchProp = watchProp;

          let potentialProxy = $parse(
            watchProp.split(".").slice(0, -1).join("."),
          )(listener.originalTarget);
          if (potentialProxy && this.foreignProxies.has(potentialProxy)) {
            potentialProxy.$handler.registerForeignKey(key, listener);
            potentialProxy.$handler.scheduleListener([listener]);
            return () => {
              return potentialProxy.$handler.deregisterKey(key, listener.id);
            };
          }
        }
        break;
      }

      // 10
      case ASTType.Identifier: {
        listener.property.push(get.decoratedNode.body[0].expression.name);
        break;
      }

      // 11
      case ASTType.Literal: {
        throw new Error("Unsupported type " + type);
      }

      // 12
      case ASTType.ArrayExpression: {
        let keys = get.decoratedNode.body[0].expression.elements
          .map((x) => {
            switch (x.type) {
              case 11:
                return x.value;
              default:
                return x.toWatch[0].name;
            }
          })
          .filter((x) => !!x);
        keys.forEach((key) => {
          this.registerKey(key, listener);
          this.scheduleListener([listener]);
        });
        return () => {
          keys.forEach((key) => {
            this.deregisterKey(key, listener.id);
          });
        };
      }

      // 13
      case ASTType.Property: {
        throw new Error("Unsupported type " + type);
      }

      // 14
      case ASTType.ObjectExpression: {
        // get.decoratedNode.body[0].expression.expression.forEach(x => {
        //   x.toWatch[0].name
        // });

        // key = get.decoratedNode.body[0].expression.properties[0].key.name;
        // listener.property.push(key);
        get.decoratedNode.body[0].expression.properties.forEach((prop) => {
          if (prop.key.isPure === false) {
            keySet.push(prop.key.name);
            listener.property.push(key);
          } else {
            if (prop.value.name) {
              keySet.push(prop.value.name);
              listener.property.push(key);
            } else {
              key = get.decoratedNode.body[0].expression.properties[0].key.name;
              listener.property.push(key);
            }
          }
        });

        // key = get.decoratedNode.body[0].expression.toWatch[0].name;
        // listener.property.push(key);
        break;
      }

      // 15
      case ASTType.ThisExpression: {
        throw new Error("Unsupported type " + type);
      }

      // 16
      case ASTType.LocalsExpression: {
        throw new Error("Unsupported type " + type);
      }

      // 17
      case ASTType.NGValueParameter: {
        throw new Error("Unsupported type " + type);
      }
    }

    // if the target is an object, then start observing it
    let listenerObject = listener.watchFn(this.$target);
    if (isObject(listenerObject)) {
      this.objectListeners.set(listenerObject, [key]);
    }

    if (keySet.length > 0) {
      keySet.forEach((key) => {
        this.registerKey(key, listener);
      });
    } else {
      this.registerKey(key, listener);
    }

    if (!lazy) {
      this.scheduleListener([listener]);
    }
    return () => {
      if (keySet.length > 0) {
        let res = true;
        keySet.forEach((key) => {
          let success = this.deregisterKey(key, listener.id);
          if (!success) {
            res = false;
          }
        });
        return res;
      } else {
        return this.deregisterKey(key, listener.id);
      }
    };
  }

  $watchGroup(watchArray, listenerFn) {
    watchArray.forEach((x) => this.$watch(x, listenerFn));
  }

  $watchCollection(watchProp, listenerFn) {
    return this.$watch(watchProp, listenerFn);
  }

  $new(childInstance) {
    let child;
    if (childInstance) {
      if (Object.getPrototypeOf(childInstance) === Object.prototype) {
        Object.setPrototypeOf(childInstance, this.$target);
      } else {
        if (Object.getPrototypeOf(childInstance) == this.$target) {
          Object.setPrototypeOf(childInstance, this.$target);
        } else {
          Object.setPrototypeOf(
            Object.getPrototypeOf(childInstance) || childInstance,
            this.$target,
          );
        }
      }

      child = childInstance;
    } else {
      child = Object.create(this.$target);
      // child.$parent = this.$parent;
    }

    const proxy = new Proxy(child, new Scope(this));
    this.$children.push(proxy);
    return proxy;
  }

  $newIsolate(instance) {
    let child = instance ? Object.create(instance) : Object.create(null);
    // child.$root = this.$root;
    const proxy = new Proxy(child, new Scope(this, this.$root));
    this.$children.push(proxy);
    return proxy;
  }

  $transcluded(parentInstance) {
    let child = Object.create(this.$target);
    const proxy = new Proxy(child, new Scope(this, parentInstance));
    this.$children.push(proxy);
    return proxy;
  }

  registerKey(key, listener) {
    if (this.watchers.has(key)) {
      this.watchers.get(key).push(listener);
    } else {
      this.watchers.set(key, [listener]);
    }
  }

  registerForeignKey(key, listener) {
    if (this.foreignListeners.has(key)) {
      this.foreignListeners.get(key).push(listener);
    } else {
      this.foreignListeners.set(key, [listener]);
    }
  }

  deregisterKey(key, id) {
    const listenerList = this.watchers.get(key);
    if (!listenerList) return false;

    const index = listenerList.findIndex((x) => x.id === id);
    if (index === -1) return false;

    listenerList.splice(index, 1);
    if (listenerList.length) {
      this.watchers.set(key, listenerList);
    } else {
      this.watchers.delete(key);
    }
    return true;
  }

  deregisterForeignKey(key, id) {
    const listenerList = this.foreignListeners.get(key);
    if (!listenerList) return false;

    const index = listenerList.findIndex((x) => x.id === id);
    if (index === -1) return false;

    listenerList.splice(index, 1);
    if (listenerList.length) {
      this.foreignListeners.set(key, listenerList);
    } else {
      this.foreignListeners.delete(key);
    }
    return true;
  }

  /**
   * @deprecated
   */
  $digest() {
    throw new Error("$Digest is deprecated");
  }

  $eval(expr, locals) {
    const fn = $parse(expr);
    const res = fn(this.$target, locals);

    if (isUndefined(res) || res === null) {
      return res;
    }

    if (res["name"] === Object.hasOwnProperty["name"]) {
      return res;
    }
    if (isFunction(res)) {
      return res();
    }

    if (Number.isNaN(res)) {
      return 0;
    }

    return res;
  }

  async $evalAsync(expr, locals) {
    return await this.$eval(expr, locals);
  }

  $merge(newTarget) {
    Object.entries(newTarget).forEach(([key, value]) => {
      this.set(this.$target, key, value);
    });
  }

  $apply(expr) {
    try {
      return $parse(expr)(this.$proxy);
    } catch (e) {
      $exceptionHandler(e);
    }
  }

  $on(name, listener) {
    let namedListeners = this.$$listeners.get(name);
    if (!namedListeners) {
      namedListeners = [];
      this.$$listeners.set(name, namedListeners);
    }
    namedListeners.push(listener);

    return () => {
      const indexOfListener = namedListeners.indexOf(listener);
      if (indexOfListener !== -1) {
        namedListeners.splice(indexOfListener, 1);
        if (namedListeners.length == 0) {
          this.$$listeners.delete(name);
        }
      }
    };
  }

  /**
   * @param {string} name
   * @param  {...any} args
   * @returns
   */
  $emit(name, ...args) {
    return this.eventHelper(
      { name: name, event: undefined, broadcast: false },
      ...args,
    );
  }

  /**
   * @param {string} name
   * @param  {...any} args
   * @returns
   */
  $broadcast(name, ...args) {
    return this.eventHelper(
      { name: name, event: undefined, broadcast: true },
      ...args,
    );
  }

  /**
   * @private
   * @returns {void}
   */
  eventHelper({ name, event, broadcast }, ...args) {
    if (!broadcast) {
      if (!this.$$listeners.has(name)) {
        if (this.$parent) {
          return this.$parent.$handler.eventHelper(
            { name: name, event: event, broadcast: broadcast },
            ...args,
          );
        }
        return;
      }
    }
    if (event) {
      event.currentScope = this.$target;
    } else {
      event = event || {
        name,
        targetScope: this.$target,
        currentScope: this.$target,
        stopped: false,
        stopPropagation() {
          event.stopped = true;
        },
        preventDefault() {
          event.defaultPrevented = true;
        },
        defaultPrevented: false,
      };
    }

    const listenerArgs = concat([event], [event].concat(args), 1);
    let listeners = this.$$listeners.get(name);
    if (listeners) {
      let length = listeners.length;
      for (let i = 0; i < length; i++) {
        try {
          let cb = listeners[i];
          cb.apply(null, listenerArgs);
          if (listeners.length !== length) {
            if (listeners.length < length) {
              i--;
            }
            length = listeners.length;
          }
        } catch (e) {
          $exceptionHandler(e);
        }
      }
    }

    event.currentScope = null;

    if (event.stopped) {
      return event;
    }

    if (broadcast) {
      if (this.$children.length > 0) {
        this.$children.forEach((child) => {
          event = child["$handler"].eventHelper(
            { name: name, event: event, broadcast: broadcast },
            ...args,
          );
        });
      }
      return event;
    } else {
      if (this.$parent) {
        return this.$parent?.eventHelper(
          { name: name, event: event, broadcast: broadcast },
          ...args,
        );
      } else {
        return event;
      }
    }
  }

  /**
   * @private
   * @returns {boolean}
   */
  isRoot() {
    return this.$root == /** @type {Scope} */ (this);
  }

  async $applyAsync(expr) {
    try {
      const result = $parse(expr)(this.$proxy);
      return result;
    } catch (error) {
      $exceptionHandler(error);
      throw error;
    }
  }

  $postUpdate(fn) {
    $postUpdateQueue.push(fn);
  }

  $destroy() {
    if (this.$$destroyed) return;

    this.$broadcast("$destroy");
    Array.from(this.watchers.entries()).forEach(([key, val]) => {
      this.watchers.set(
        key,
        val.filter((x) => x.scopeId !== this.$id),
      );
    });

    if (this.isRoot()) {
      this.watchers.clear();
    } else {
      let i = this.$parent.$children.filter((x) => x.$id == this.$id)[0];
      this.$parent.$children.splice(this.$parent.$children.indexOf(i), 1);
    }

    this.$$listeners.clear();

    this.$$destroyed = true;
  }

  /**
   * Invokes the registered listener function with watched property changes.
   *
   * @param {Listener} listener - The property path that was changed.
   */
  notifyListener(listener, target) {
    const { originalTarget, listenerFn, watchFn } = listener;
    try {
      let newVal = watchFn(originalTarget);
      if (isUndefined(newVal)) {
        newVal = watchFn(target);
      }
      if (isFunction(newVal)) {
        newVal = newVal(originalTarget);
      }

      if (Array.isArray(newVal)) {
        newVal.forEach((x, index) => {
          if (isFunction(x)) {
            newVal[index] = x(originalTarget);
          }
        });
      }
      listenerFn(newVal, originalTarget);
      this.$$asyncQueue.forEach((x) => {
        if (x.handler.$id == this.$id) {
          Promise.resolve().then(x.fn(x.handler, x.locals));
        }
      });

      while ($postUpdateQueue.length) {
        $postUpdateQueue.shift()();
      }
    } catch (e) {
      $exceptionHandler(e);
    }
  }

  /**
   * Searches the scope instance
   *
   * @param {string|number}id
   * @returns {Scope|undefined}
   */
  $getById(id) {
    if (isString(id)) {
      id = parseInt(id, 10);
    }
    if (this.$id === id) {
      return this;
    } else {
      let res = undefined;
      for (const child of this.$children) {
        let found = child.$getById(id);
        if (found) {
          res = found;
          break;
        }
      }
      return res;
    }
  }
}

/**
 * @param {Scope} model
 * @returns {number}
 */
function calculateWatcherCount(model) {
  const childIds = collectChildIds(model).add(model.$id);

  /** @type {number} */
  const count = Array.from(model.watchers.values()).reduce(
    (count, watcherArray) =>
      count +
      watcherArray.reduce(
        (subCount, watcher) =>
          subCount + (childIds.has(watcher.scopeId) ? 1 : 0),
        0,
      ),
    0,
  );
  return count;
}

/**
 * @param {Scope} child
 * @returns {Set<number>}
 */
function collectChildIds(child) {
  const ids = new Set([child.$id]);
  child.$children?.forEach((c) => {
    collectChildIds(c).forEach((id) => ids.add(id));
  });
  return ids;
}

class TaskTrackerFactoryProvider {
  $get = [
    "$log",
    /**
     * Creates a new `TaskTracker` instance.
     *
     * @param {import('../services/log').LogService} log - The logging service.
     * @returns {TaskTracker} A new `TaskTracker` instance.
     */
    (log) => new TaskTracker(log),
  ];
}

/**
 * A factory function to create `TaskTracker` instances.
 *
 * A `TaskTracker` tracks pending tasks (grouped by type) and notifies interested
 * parties when all pending tasks (or tasks of a specific type) have been completed.
 */
class TaskTracker {
  /**
   * @param {import('../services/log').LogService} log - The logging service.
   */
  constructor(log) {
    /** @private */
    this.log = log;

    /** @private */
    this.taskCounts = {};

    /** @private */
    this.taskCallbacks = [];

    /**
     * Special task types used for tracking all tasks and default tasks.
     * @type {string}
     */
    this.ALL_TASKS_TYPE = "$$all$$";

    /**
     * Default task type.
     * @type {string}
     */
    this.DEFAULT_TASK_TYPE = "$$default$$";
  }

  /**
   * Completes a task and decrements the associated task counter.
   * If the counter reaches 0, all corresponding callbacks are executed.
   *
   * @param {Function} fn - The function to execute when completing the task.
   * @param {string} [taskType=this.DEFAULT_TASK_TYPE] - The type of task being completed.
   */
  completeTask(fn, taskType = this.DEFAULT_TASK_TYPE) {
    try {
      fn();
    } finally {
      if (this.taskCounts[taskType]) {
        this.taskCounts[taskType]--;
        this.taskCounts[this.ALL_TASKS_TYPE]--;
      }

      const countForType = this.taskCounts[taskType];
      const countForAll = this.taskCounts[this.ALL_TASKS_TYPE];

      // If either the overall task queue or the specific task type queue is empty, run callbacks.
      if (!countForAll || !countForType) {
        const getNextCallback = !countForAll
          ? this.getLastCallback.bind(this)
          : () => this.getLastCallbackForType(taskType);

        let nextCb;
        while ((nextCb = getNextCallback())) {
          try {
            nextCb();
          } catch (e) {
            this.log.error(e);
          }
        }
      }
    }
  }

  /**
   * Increments the task count for the specified task type.
   *
   * @param {string} [taskType=this.DEFAULT_TASK_TYPE] - The type of task whose count will be increased.
   */
  incTaskCount(taskType = this.DEFAULT_TASK_TYPE) {
    this.taskCounts[taskType] = (this.taskCounts[taskType] || 0) + 1;
    this.taskCounts[this.ALL_TASKS_TYPE] =
      (this.taskCounts[this.ALL_TASKS_TYPE] || 0) + 1;
  }

  /**
   * Registers a callback to be executed when all pending tasks of the specified type are completed.
   * If there are no pending tasks of the specified type, the callback is executed immediately.
   *
   * @param {Function} callback - The function to execute when no pending tasks remain.
   * @param {string} [taskType=this.ALL_TASKS_TYPE] - The type of tasks to wait for completion.
   */
  notifyWhenNoPendingTasks(callback, taskType = this.ALL_TASKS_TYPE) {
    if (!this.taskCounts[taskType]) {
      callback();
    } else {
      this.taskCallbacks.push({ type: taskType, cb: callback });
    }
  }

  /**
   * Retrieves and removes the last registered callback from the queue.
   *
   * @private
   * @returns {Function|undefined} The last callback function or undefined if none exist.
   */
  getLastCallback() {
    const cbInfo = this.taskCallbacks.pop();
    return cbInfo ? cbInfo.cb : undefined;
  }

  /**
   * Retrieves and removes the last registered callback for the specified task type.
   *
   * @private
   * @param {string} taskType - The type of task for which the callback was registered.
   * @returns {Function|undefined} The last callback function for the task type, or undefined if none exist.
   */
  getLastCallbackForType(taskType) {
    for (let i = this.taskCallbacks.length - 1; i >= 0; --i) {
      const cbInfo = this.taskCallbacks[i];
      if (cbInfo.type === taskType) {
        this.taskCallbacks.splice(i, 1);
        return cbInfo.cb;
      }
    }
    return undefined;
  }
}

var $templateRequestMinErr = minErr("$templateRequest");

/**
 * Used to configure the options passed to the {@link $http} service when making a template request.
 *
 * For example, it can be used for specifying the "Accept" header that is sent to the server, when
 * requesting a template.
 */
function TemplateRequestProvider() {
  var httpOptions;

  /**
   * The options to be passed to the {@link $http} service when making the request.
   * You can use this to override options such as the "Accept" header for template requests.
   * The {@link $templateRequest} will set the `cache` and the `transformResponse` properties of the
   * options if not overridden here.
   *
   * @param {string=} val new value for the {@link $http} options.
   * @returns {string|TemplateRequestProvider} Returns the {@link $http} options when used as getter and self if used as setter.
   */
  this.httpOptions = function (val) {
    if (val) {
      httpOptions = val;
      return this;
    }
    return httpOptions;
  };

  /**
   * The `$templateRequest` service runs security checks then downloads the provided template using
   * `$http` and, upon success, stores the contents inside of `$templateCache`. If the HTTP request
   * fails or the response data of the HTTP request is empty, a `$compile` error will be thrown (the
   * exception can be thwarted by setting the 2nd parameter of the function to true). Note that the
   * contents of `$templateCache` are trusted, so the call to `$sce.getTrustedUrl(tpl)` is omitted
   * when `tpl` is of type string and `$templateCache` has the matching entry.
   *
   * If you want to pass custom options to the `$http` service, such as setting the Accept header you
   * can configure this via {@link $templateRequestProvider#httpOptions}.
   *
   * `$templateRequest` is used internally by {@link $compile}, {@link ngRoute.$route}, and directives such
   * as {@link ngInclude} to download and cache templates.
   *
   * 3rd party modules should use `$templateRequest` if their services or directives are loading
   * templates.
   *
   * @param {string} tpl The HTTP request template URL
   * @param {boolean=} ignoreRequestError Whether or not to ignore the exception when the request fails or the template is empty
   *
   * @return {Promise} a promise for the HTTP response data of the given URL.
   *
   * @property {number} totalPendingRequests total amount of pending template requests being downloaded.
   */
  this.$get = [
    "$exceptionHandler",
    "$templateCache",
    "$http",
    "$sce",
    /**
     *
     * @param {import('../core/exception-handler').ErrorHandler} $exceptionHandler
     * @param {import('../core/cache/cache-factory').TemplateCache} $templateCache
     * @param {*} $http
     * @param {*} $sce
     * @returns
     */
    function ($exceptionHandler, $templateCache, $http, $sce) {
      function handleRequestFn(tpl, ignoreRequestError) {
        handleRequestFn.totalPendingRequests++;

        // We consider the template cache holds only trusted templates, so
        // there's no need to go through adding the template again to the trusted
        // resources for keys that already are included in there. This also makes
        // AngularJS accept any script directive, no matter its name. However, we
        // still need to unwrap trusted types.
        if (!isString(tpl) || !$templateCache.has(tpl)) {
          tpl = $sce.getTrustedResourceUrl(tpl);
          if (!tpl) {
            return Promise.reject("Template not found");
          }
        }

        var transformResponse =
          $http.defaults && $http.defaults.transformResponse;

        if (Array.isArray(transformResponse)) {
          transformResponse = transformResponse.filter(function (transformer) {
            return transformer !== defaultHttpResponseTransform;
          });
        } else if (transformResponse === defaultHttpResponseTransform) {
          transformResponse = null;
        }

        return $http
          .get(
            tpl,
            extend(
              {
                cache: $templateCache,
                transformResponse: transformResponse,
              },
              httpOptions,
            ),
          )
          .finally(function () {
            handleRequestFn.totalPendingRequests--;
          })
          .then(function (response) {
            $templateCache.set(tpl, response.data);
            return response.data;
          }, handleError);

        function handleError(resp) {
          if (!ignoreRequestError) {
            resp = $templateRequestMinErr(
              "tpload",
              "Failed to load template: {0} (HTTP status: {1} {2})",
              tpl,
              resp.status,
              resp.statusText,
            );

            $exceptionHandler(resp);
          }

          return Promise.reject(resp);
        }
      }

      handleRequestFn.totalPendingRequests = 0;

      return handleRequestFn;
    },
  ];
}

/**
 *
 * @description
 * Private service to sanitize uris for links and images. Used by $compile.
 */
function SanitizeUriProvider() {
  let aHrefSanitizationTrustedUrlList = /^\s*(https?|s?ftp|mailto|tel|file):/;
  let imgSrcSanitizationTrustedUrlList =
    /^\s*((https?|ftp|file|blob):|data:image\/)/;

  /**
   * @description
   * Retrieves or overrides the default regular expression that is used for determining trusted safe
   * urls during a[href] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via HTML anchor links.
   *
   * Any url due to be assigned to an `a[href]` attribute via interpolation is marked as requiring
   * the $sce.URL security context. When interpolation occurs a call is made to `$sce.trustAsUrl(url)`
   * which in turn may call `$$sanitizeUri(url, isMedia)` to sanitize the potentially malicious URL.
   *
   * If the URL matches the `aHrefSanitizationTrustedUrlList` regular expression, it is returned unchanged.
   *
   * If there is no match the URL is returned prefixed with `'unsafe:'` to ensure that when it is written
   * to the DOM it is inactive and potentially malicious code will not be executed.
   *
   * @param {RegExp=} regexp New regexp to trust urls with.
   * @returns {RegExp|SanitizeUriProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.aHrefSanitizationTrustedUrlList = function (regexp) {
    if (isDefined(regexp)) {
      aHrefSanitizationTrustedUrlList = regexp;
      return this;
    }
    return aHrefSanitizationTrustedUrlList;
  };

  /**
   * @description
   * Retrieves or overrides the default regular expression that is used for determining trusted safe
   * urls during img[src] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via HTML image src links.
   *
   * Any URL due to be assigned to an `img[src]` attribute via interpolation is marked as requiring
   * the $sce.MEDIA_URL security context. When interpolation occurs a call is made to
   * `$sce.trustAsMediaUrl(url)` which in turn may call `$$sanitizeUri(url, isMedia)` to sanitize
   * the potentially malicious URL.
   *
   * If the URL matches the `imgSrcSanitizationTrustedUrlList` regular expression, it is returned
   * unchanged.
   *
   * If there is no match the URL is returned prefixed with `'unsafe:'` to ensure that when it is written
   * to the DOM it is inactive and potentially malicious code will not be executed.
   *
   * @param {RegExp=} regexp New regexp to trust urls with.
   * @returns {RegExp|SanitizeUriProvider} Current RegExp if called without value or self for chaining otherwise.
   */
  this.imgSrcSanitizationTrustedUrlList = function (regexp) {
    if (isDefined(regexp)) {
      imgSrcSanitizationTrustedUrlList = regexp;
      return this;
    }
    return imgSrcSanitizationTrustedUrlList;
  };

  this.$get = function () {
    return function (uri, isMediaUrl) {
      // if (!uri) return uri;
      const regex = isMediaUrl
        ? imgSrcSanitizationTrustedUrlList
        : aHrefSanitizationTrustedUrlList;
      const normalizedVal = urlResolve(uri && uri.trim()).href;
      if (normalizedVal !== "" && !normalizedVal.match(regex)) {
        return `unsafe:${normalizedVal}`;
      }
      return uri;
    };
  };
}

const ACTIVE_CLASS = "ng-active";
const INACTIVE_CLASS = "ng-inactive";

class NgMessageCtrl {
  /**
   * @param {import('../../shared//dom').JQLite} $element
   * @param {import('../../core/scope/scope.js').Scope} $scope
   * @param {import('../../core/compile/attributes').Attributes} $attrs
   * @param {*} $animate
   */
  constructor($element, $scope, $attrs, $animate) {
    this.$element = $element;
    this.$scope = $scope;
    this.$attrs = $attrs;
    this.$animate = $animate;

    this.latestKey = 0;
    this.nextAttachId = 0;
    this.messages = {};
    this.renderLater = false;
    this.cachedCollection = null;

    this.head = undefined;
    this.default = undefined;

    this.$scope.$watchCollection(
      this.$attrs["ngMessages"] || this.$attrs["for"],
      this.render.bind(this),
    );
  }

  getAttachId() {
    return this.nextAttachId++;
  }

  render(collection = {}) {
    this.renderLater = false;
    this.cachedCollection = collection;

    const multiple =
      isAttrTruthy(this.$scope, this.$attrs["ngMessagesMultiple"]) ||
      isAttrTruthy(this.$scope, this.$attrs["multiple"]);

    const unmatchedMessages = [];
    const matchedKeys = {};
    let truthyKeys = 0;
    let messageItem = this.head;
    let messageFound = false;
    let totalMessages = 0;

    while (messageItem != null) {
      totalMessages++;
      const messageCtrl = messageItem.message;
      let messageUsed = false;

      if (!messageFound) {
        Object.entries(collection).forEach(([key, value]) => {
          if (truthy(value) && !messageUsed) {
            truthyKeys++;

            if (messageCtrl.test(key)) {
              if (matchedKeys[key]) return;
              matchedKeys[key] = true;

              messageUsed = true;
              messageCtrl.attach();
            }
          }
        });
      }

      if (messageUsed) {
        messageFound = !multiple;
      } else {
        unmatchedMessages.push(messageCtrl);
      }

      messageItem = messageItem.next;
    }

    unmatchedMessages.forEach((messageCtrl) => {
      messageCtrl.detach();
    });

    const messageMatched = unmatchedMessages.length !== totalMessages;
    const attachDefault = this.default && !messageMatched && truthyKeys > 0;

    if (attachDefault) {
      this.default.attach();
    } else if (this.default) {
      this.default.detach();
    }

    if (messageMatched || attachDefault) {
      this.$animate.setClass(this.$element, ACTIVE_CLASS, INACTIVE_CLASS);
    } else {
      this.$animate.setClass(this.$element, INACTIVE_CLASS, ACTIVE_CLASS);
    }
  }

  reRender() {
    if (!this.renderLater) {
      this.renderLater = true;
      this.$scope.$evalAsync(() => {
        if (this.renderLater && this.cachedCollection) {
          this.render(this.cachedCollection);
        }
      });
    }
  }

  register(comment, messageCtrl, isDefault) {
    if (isDefault) {
      this.default = messageCtrl;
    } else {
      const nextKey = this.latestKey.toString();
      this.messages[nextKey] = {
        message: messageCtrl,
      };
      this.insertMessageNode(this.$element, comment, nextKey);
      comment.$$ngMessageNode = nextKey;
      this.latestKey++;
    }

    this.reRender();
  }

  deregister(comment, isDefault) {
    if (isDefault) {
      delete this.default;
    } else {
      const key = comment.$$ngMessageNode;
      delete comment.$$ngMessageNode;
      this.removeMessageNode(this.$element, comment, key);
      delete this.messages[key];
    }
    this.reRender();
  }

  findPreviousMessage(parent, comment) {
    let prevNode = comment;
    const parentLookup = [];

    while (prevNode && prevNode !== parent) {
      const prevKey = prevNode.$$ngMessageNode;
      if (prevKey && prevKey.length) {
        return this.messages[prevKey];
      }

      if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {
        parentLookup.push(prevNode);
        prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
      } else if (prevNode.previousSibling) {
        prevNode = prevNode.previousSibling;
      } else {
        prevNode = prevNode.parentNode;
        parentLookup.push(prevNode);
      }
    }
  }

  insertMessageNode(parent, comment, key) {
    const messageNode = this.messages[key];
    if (!this.head) {
      this.head = messageNode;
    } else {
      const match = this.findPreviousMessage(parent, comment);
      if (match) {
        messageNode.next = match.next;
        match.next = messageNode;
      } else {
        messageNode.next = this.head;
        this.head = messageNode;
      }
    }
  }

  removeMessageNode(parent, comment, key) {
    const messageNode = this.messages[key];

    if (!messageNode) return;

    const match = this.findPreviousMessage(parent, comment);
    if (match) {
      match.next = messageNode.next;
    } else {
      this.head = messageNode.next;
    }
  }
}

ngMessagesDirective.$inject = ["$animate"];
function ngMessagesDirective($animate) {
  return {
    require: "ngMessages",
    restrict: "AE",
    controller: ($element, $scope, $attrs) =>
      new NgMessageCtrl($element, $scope, $attrs, $animate),
  };
}

function isAttrTruthy(scope, attr) {
  return (
    (isString(attr) && attr.length === 0) || // empty attribute
    truthy(scope.$eval(attr))
  );
}

function truthy(val) {
  return isString(val) ? val.length : !!val;
}

ngMessagesIncludeDirective.$inject = ["$templateRequest", "$compile"];
function ngMessagesIncludeDirective($templateRequest, $compile) {
  return {
    restrict: "AE",
    require: "^^ngMessages", // we only require this for validation sake
    link($scope, element, attrs) {
      const src = attrs.ngMessagesInclude || attrs.src;
      $templateRequest(src).then((html) => {
        if ($scope.$$destroyed) return;
        if (isString(html) && !html.trim()) ; else {
          // Non-empty template - compile and link
          $compile(html)($scope, (contents) => {
            element.after(contents);
          });
        }
      });
    },
  };
}

const ngMessageDirective = ngMessageDirectiveFactory(false);
const ngMessageExpDirective = ngMessageDirectiveFactory(false);
const ngMessageDefaultDirective = ngMessageDirectiveFactory(true);

function ngMessageDirectiveFactory(isDefault) {
  ngMessageDirective.$inject = ["$animate"];
  function ngMessageDirective($animate) {
    return {
      restrict: "AE",
      transclude: "element",
      priority: 1, // must run before ngBind, otherwise the text is set on the comment
      terminal: true,
      require: "^^ngMessages",
      link(scope, element, attrs, ngMessagesCtrl, $transclude) {
        let commentNode;
        let records;
        let staticExp;
        let dynamicExp;

        if (!isDefault) {
          commentNode = element;
          staticExp = attrs.ngMessage || attrs.when;
          dynamicExp = attrs.ngMessageExp || attrs.whenExp;

          const assignRecords = function (items) {
            records = items
              ? Array.isArray(items)
                ? items
                : items.split(/[\s,]+/)
              : null;
            ngMessagesCtrl.reRender();
          };

          if (dynamicExp) {
            assignRecords(scope.$eval(dynamicExp));
            scope.$watchCollection(dynamicExp, assignRecords);
          } else {
            assignRecords(staticExp);
          }
        }

        let currentElement;
        let messageCtrl;
        ngMessagesCtrl.register(
          commentNode,
          (messageCtrl = {
            test(name) {
              return contains(records, name);
            },
            attach() {
              if (!currentElement) {
                $transclude((elm, newScope) => {
                  $animate.enter(elm, null, element);
                  currentElement = elm;

                  // Each time we attach this node to a message we get a new id that we can match
                  // when we are destroying the node later.
                  const $$attachId = (currentElement.$$attachId =
                    ngMessagesCtrl.getAttachId());

                  // in the event that the element or a parent element is destroyed
                  // by another structural directive then it's time
                  // to deregister the message from the controller
                  currentElement.addEventListener("$destroy", () => {
                    // If the message element was removed via a call to `detach` then `currentElement` will be null
                    // So this handler only handles cases where something else removed the message element.
                    if (
                      currentElement &&
                      currentElement.$$attachId === $$attachId
                    ) {
                      ngMessagesCtrl.deregister(commentNode, isDefault);
                      messageCtrl.detach();
                    }
                    newScope.$destroy();
                  });
                });
              }
            },
            detach() {
              if (currentElement) {
                const elm = currentElement;
                currentElement = null;
                $animate.leave(elm);
              }
            },
          }),
          isDefault,
        );

        // We need to ensure that this directive deregisters itself when it no longer exists
        // Normally this is done when the attached element is destroyed; but if this directive
        // gets removed before we attach the message to the DOM there is nothing to watch
        // in which case we must deregister when the containing scope is destroyed.
        scope.$on("$destroy", () => {
          ngMessagesCtrl.deregister(commentNode, isDefault);
        });
      },
    };
  }
  return ngMessageDirective;
}

function contains(collection, key) {
  if (collection) {
    return Array.isArray(collection)
      ? collection.indexOf(key) >= 0
      : Object.prototype.hasOwnProperty.call(collection, key);
  }
}

const ARIA_DISABLE_ATTR = "ngAriaDisable";

/**
 * Internal Utilities
 */
const nativeAriaNodeNames = [
  "BUTTON",
  "A",
  "INPUT",
  "TEXTAREA",
  "SELECT",
  "DETAILS",
  "SUMMARY",
];

const isNodeOneOf = function (elem, nodeTypeArray) {
  if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {
    return true;
  }
};

/**
 * Used for configuring the ARIA attributes injected and managed by ngAria.
 *
 * ```js
 * angular.module('myApp', ['ngAria'], function config($ariaProvider) {
 *   $ariaProvider.config({
 *     ariaValue: true,
 *     tabindex: false
 *   });
 * });
 *```
 *
 * ## Dependencies
 * Requires the {@link ngAria} module to be installed.
 *
 */
function AriaProvider() {
  let config = {
    ariaHidden: true,
    ariaChecked: true,
    ariaReadonly: true,
    ariaDisabled: true,
    ariaRequired: true,
    ariaInvalid: true,
    ariaValue: true,
    tabindex: true,
    bindKeydown: true,
    bindRoleForClick: true,
  };

  this.config = function (newConfig) {
    config = extend(config, newConfig);
  };

  function watchExpr(attrName, ariaAttr, nativeAriaNodeNames, negate) {
    return function (scope, elem, attr) {
      if (Object.prototype.hasOwnProperty.call(attr, ARIA_DISABLE_ATTR)) return;

      const ariaCamelName = attr.$normalize(ariaAttr);
      if (
        config[ariaCamelName] &&
        !isNodeOneOf(elem, nativeAriaNodeNames) &&
        !attr[ariaCamelName]
      ) {
        scope.$watch(attr[attrName], (boolVal) => {
          // ensure boolean value
          boolVal = negate ? !boolVal : !!boolVal;
          elem.setAttribute(ariaAttr, boolVal);
        });
      }
    };
  }

  this.$get = function () {
    return {
      config(key) {
        return config[key];
      },
      $$watchExpr: watchExpr,
    };
  };
}

ngDisabledAriaDirective.$inject = ["$aria"];
function ngDisabledAriaDirective($aria) {
  return $aria.$$watchExpr(
    "ngDisabled",
    "aria-disabled",
    nativeAriaNodeNames,
    false,
  );
}

ngShowAriaDirective.$inject = ["$aria"];
function ngShowAriaDirective($aria) {
  return $aria.$$watchExpr("ngShow", "aria-hidden", [], true);
}

function ngMessagesAriaDirective() {
  return {
    restrict: "A",
    require: "?ngMessages",
    link(_scope, elem, attr) {
      if (Object.prototype.hasOwnProperty.call(attr, ARIA_DISABLE_ATTR)) return;

      if (!elem.hasAttribute("aria-live")) {
        elem.setAttribute("aria-live", "assertive");
      }
    },
  };
}

ngClickAriaDirective.$inject = ["$aria", "$parse"];
function ngClickAriaDirective($aria, $parse) {
  return {
    restrict: "A",
    compile(elem, attr) {
      if (Object.prototype.hasOwnProperty.call(attr, ARIA_DISABLE_ATTR)) return;

      const fn = $parse(attr.ngClick);

      /**
       * @param {Element} elem
       */
      return function (scope, elem, attr) {
        if (!isNodeOneOf(elem, nativeAriaNodeNames)) {
          if ($aria.config("bindRoleForClick") && !elem.hasAttribute("role")) {
            elem.setAttribute("role", "button");
          }

          if ($aria.config("tabindex") && !elem.hasAttribute("tabindex")) {
            elem.setAttribute("tabindex", "0");
          }

          if (
            $aria.config("bindKeydown") &&
            !attr.ngKeydown &&
            !attr.ngKeypress &&
            !attr.ngKeyup
          ) {
            elem.addEventListener(
              "keydown",
              /** @param {KeyboardEvent} event */
              (event) => {
                const keyCode = parseInt(event.key, 10);

                if (keyCode === 13 || keyCode === 32) {
                  // If the event is triggered on a non-interactive element ...
                  if (
                    nativeAriaNodeNames.indexOf(
                      /** @type {Node} */ (event.target).nodeName,
                    ) === -1 &&
                    !(
                      /** @type {HTMLElement} */ (event.target)
                        .isContentEditable
                    )
                  ) {
                    // ... prevent the default browser behavior (e.g. scrolling when pressing spacebar)
                    // See https://github.com/angular/angular.js/issues/16664
                    event.preventDefault();
                  }
                  scope.$apply(callback);
                }

                function callback() {
                  fn(scope, { $event: event });
                }
              },
            );
          }
        }
      };
    },
  };
}

ngRequiredAriaDirective.$inject = ["$aria"];
function ngRequiredAriaDirective($aria) {
  return $aria.$$watchExpr(
    "ngRequired",
    "aria-required",
    nativeAriaNodeNames,
    false,
  );
}

ngCheckedAriaDirective.$inject = ["$aria"];
function ngCheckedAriaDirective($aria) {
  return $aria.$$watchExpr(
    "ngChecked",
    "aria-checked",
    nativeAriaNodeNames,
    false,
  );
}

ngValueAriaDirective.$inject = ["$aria"];
function ngValueAriaDirective($aria) {
  return $aria.$$watchExpr(
    "ngValue",
    "aria-checked",
    nativeAriaNodeNames,
    false,
  );
}

ngHideAriaDirective.$inject = ["$aria"];
function ngHideAriaDirective($aria) {
  return $aria.$$watchExpr("ngHide", "aria-hidden", [], false);
}

ngReadonlyAriaDirective.$inject = ["$aria"];
function ngReadonlyAriaDirective($aria) {
  return $aria.$$watchExpr(
    "ngReadonly",
    "aria-readonly",
    nativeAriaNodeNames,
    false,
  );
}

ngModelAriaDirective.$inject = ["$aria"];
function ngModelAriaDirective($aria) {
  function shouldAttachAttr(attr, normalizedAttr, elem, allowNonAriaNodes) {
    return (
      $aria.config(normalizedAttr) &&
      !elem.getAttribute(attr) &&
      (allowNonAriaNodes || !isNodeOneOf(elem, nativeAriaNodeNames)) &&
      (elem.getAttribute("type") !== "hidden" || elem.nodeName !== "INPUT")
    );
  }

  function shouldAttachRole(role, elem) {
    // if element does not have role attribute
    // AND element type is equal to role (if custom element has a type equaling shape) <-- remove?
    // AND element is not in nativeAriaNodeNames
    return (
      !elem.getAttribute("role") &&
      elem.getAttribute("type") === role &&
      !isNodeOneOf(elem, nativeAriaNodeNames)
    );
  }

  function getShape(attr) {
    const { type } = attr;
    const { role } = attr;

    return (type || role) === "checkbox" || role === "menuitemcheckbox"
      ? "checkbox"
      : (type || role) === "radio" || role === "menuitemradio"
        ? "radio"
        : type === "range" || role === "progressbar" || role === "slider"
          ? "range"
          : "";
  }

  return {
    restrict: "A",
    require: "ngModel",
    priority: 200, // Make sure watches are fired after any other directives that affect the ngModel value
    compile(elem, attr) {
      if (Object.prototype.hasOwnProperty.call(attr, ARIA_DISABLE_ATTR)) return;

      const shape = getShape(attr);

      return {
        post(scope, elem, attr, ngModel) {
          const needsTabIndex = shouldAttachAttr(
            "tabindex",
            "tabindex",
            elem,
            false,
          );

          function getRadioReaction() {
            // Strict comparison would cause a BC
            elem.setAttribute(
              "aria-checked",
              (attr.value == ngModel.$viewValue).toString(),
            );
          }

          function getCheckboxReaction() {
            elem.setAttribute(
              "aria-checked",
              (!ngModel.$isEmpty(ngModel.$viewValue)).toString(),
            );
          }

          switch (shape) {
            case "radio":
            case "checkbox":
              if (shouldAttachRole(shape, elem)) {
                elem.setAttribute("role", shape);
              }
              if (
                shouldAttachAttr("aria-checked", "ariaChecked", elem, false)
              ) {
                ngModel.$watch(
                  "$modelValue",
                  shape === "radio" ? getRadioReaction : getCheckboxReaction,
                );
              }
              if (needsTabIndex) {
                elem.setAttribute("tabindex", 0);
              }
              break;
            case "range":
              if (shouldAttachRole(shape, elem)) {
                elem.setAttribute("role", "slider");
              }
              if ($aria.config("ariaValue")) {
                const needsAriaValuemin =
                  !elem.hasAttribute("aria-valuemin") &&
                  (Object.prototype.hasOwnProperty.call(attr, "min") ||
                    Object.prototype.hasOwnProperty.call(attr, "ngMin"));
                const needsAriaValuemax =
                  !elem.hasAttribute("aria-valuemax") &&
                  (Object.prototype.hasOwnProperty.call(attr, "max") ||
                    Object.prototype.hasOwnProperty.call(attr, "ngMax"));
                const needsAriaValuenow = !elem.hasAttribute("aria-valuenow");

                if (needsAriaValuemin) {
                  attr.$observe("min", (newVal) => {
                    elem.setAttribute("aria-valuemin", newVal);
                  });
                }
                if (needsAriaValuemax) {
                  attr.$observe("max", (newVal) => {
                    elem.setAttribute("aria-valuemax", newVal);
                  });
                }
                if (needsAriaValuenow) {
                  ngModel.$watch("$modelValue", (newVal) => {
                    elem.setAttribute("aria-valuenow", newVal);
                  });
                }
              }
              if (needsTabIndex) {
                elem.setAttribute("tabindex", 0);
              }
              break;
          }

          if (
            !Object.prototype.hasOwnProperty.call(attr, "ngRequired") &&
            ngModel.$validators.required &&
            shouldAttachAttr("aria-required", "ariaRequired", elem, false)
          ) {
            // ngModel.$error.required is undefined on custom controls
            attr.$observe("required", () => {
              elem.setAttribute("aria-required", (!!attr.required).toString());
            });
          }

          if (shouldAttachAttr("aria-invalid", "ariaInvalid", elem, true)) {
            ngModel.$watch("$invalid", (newVal) => {
              elem.setAttribute("aria-invalid", (!!newVal).toString());
            });
          }
        },
      };
    },
  };
}

ngDblclickAriaDirective.$inject = ["$aria"];
function ngDblclickAriaDirective($aria) {
  return function (scope, elem, attr) {
    if (Object.prototype.hasOwnProperty.call(attr, ARIA_DISABLE_ATTR)) return;

    if (
      $aria.config("tabindex") &&
      !elem.hasAttribute("tabindex") &&
      !isNodeOneOf(elem, nativeAriaNodeNames)
    ) {
      elem.setAttribute("tabindex", 0);
    }
  };
}

const ANIMATE_TIMER_KEY = "$$animateCss";

const ONE_SECOND = 1000;

const ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
const CLOSING_TIME_BUFFER = 1.5;

const DETECT_CSS_PROPERTIES = {
  transitionDuration: TRANSITION_DURATION_PROP,
  transitionDelay: TRANSITION_DELAY_PROP,
  transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
  animationDuration: ANIMATION_DURATION_PROP,
  animationDelay: ANIMATION_DELAY_PROP,
  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY,
};

const DETECT_STAGGER_CSS_PROPERTIES = {
  transitionDuration: TRANSITION_DURATION_PROP,
  transitionDelay: TRANSITION_DELAY_PROP,
  animationDuration: ANIMATION_DURATION_PROP,
  animationDelay: ANIMATION_DELAY_PROP,
};

function getCssKeyframeDurationStyle(duration) {
  return [ANIMATION_DURATION_PROP, `${duration}s`];
}

function getCssDelayStyle(delay, isKeyframeAnimation) {
  const prop = isKeyframeAnimation
    ? ANIMATION_DELAY_PROP
    : TRANSITION_DELAY_PROP;
  return [prop, `${delay}s`];
}

function computeCssStyles(element, properties) {
  const styles = Object.create(null);
  const detectedStyles = window.getComputedStyle(element) || {};
  Object.entries(properties).forEach(([actualStyleName, formalStyleName]) => {
    let val = detectedStyles[formalStyleName];
    if (val) {
      const c = val.charAt(0);

      // only numerical-based values have a negative sign or digit as the first value
      if (c === "-" || c === "+" || c >= 0) {
        val = parseMaxTime(val);
      }

      // by setting this to null in the event that the delay is not set or is set directly as 0
      // then we can still allow for negative values to be used later on and not mistake this
      // value for being greater than any other negative value.
      if (val === 0) {
        val = null;
      }
      styles[actualStyleName] = val;
    }
  });

  return styles;
}

function parseMaxTime(str) {
  let maxValue = 0;
  str.split(/\s*,\s*/).forEach((value) => {
    // it's always safe to consider only second values and omit `ms` values since
    // getComputedStyle will always handle the conversion for us
    if (value.charAt(value.length - 1) === "s") {
      value = value.substring(0, value.length - 1);
    }
    value = parseFloat(value) || 0;
    maxValue = maxValue ? Math.max(value, maxValue) : value;
  });
  return maxValue;
}

function truthyTimingValue(val) {
  return val === 0 || val != null;
}

function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
  let style = TRANSITION_PROP;
  let value = `${duration}s`;
  if (applyOnlyDuration) {
    style += DURATION_KEY;
  } else {
    value += " linear all";
  }
  return [style, value];
}

// we do not reassign an already present style value since
// if we detect the style property value again we may be
// detecting styles that were added via the `from` styles.
// We make use of `isDefined` here since an empty string
// or null value (which is what getPropertyValue will return
// for a non-existing style) will still be marked as a valid
// value for the style (a falsy value implies that the style
// is to be removed at the end of the animation). If we had a simple
// "OR" statement then it would not be enough to catch that.
function registerRestorableStyles(backup, node, properties) {
  properties.forEach((prop) => {
    backup[prop] = isDefined(backup[prop])
      ? backup[prop]
      : node.style.getPropertyValue(prop);
  });
}

function AnimateCssProvider() {
  this.$get = [
    "$$AnimateRunner",
    "$$animateCache",
    "$$rAFScheduler",

    /**
     *
     * @param {*} $$AnimateRunner
     * @param {*} $$animateCache
     * @param {import("./raf-scheduler").RafScheduler} $$rAFScheduler
     * @returns
     */
    function ($$AnimateRunner, $$animateCache, $$rAFScheduler) {
      const applyAnimationClasses = applyAnimationClassesFactory();

      function computeCachedCssStyles(
        node,
        cacheKey,
        allowNoDuration,
        properties,
      ) {
        let timings = $$animateCache.get(cacheKey);

        if (!timings) {
          timings = computeCssStyles(node, properties);
          if (timings.animationIterationCount === "infinite") {
            timings.animationIterationCount = 1;
          }
        }

        // if a css animation has no duration we
        // should mark that so that repeated addClass/removeClass calls are skipped
        const hasDuration =
          allowNoDuration ||
          timings.transitionDuration > 0 ||
          timings.animationDuration > 0;

        // we keep putting this in multiple times even though the value and the cacheKey are the same
        // because we're keeping an internal tally of how many duplicate animations are detected.
        $$animateCache.put(cacheKey, timings, hasDuration);

        return timings;
      }

      function computeCachedCssStaggerStyles(
        node,
        className,
        cacheKey,
        properties,
      ) {
        let stagger;
        const staggerCacheKey = `stagger-${cacheKey}`;

        // if we have one or more existing matches of matching elements
        // containing the same parent + CSS styles (which is how cacheKey works)
        // then staggering is possible
        if ($$animateCache.count(cacheKey) > 0) {
          stagger = $$animateCache.get(staggerCacheKey);

          if (!stagger) {
            const staggerClassName = pendClasses(className, "-stagger");

            node.className += ` ${staggerClassName}`;
            stagger = computeCssStyles(node, properties);

            // force the conversion of a null value to zero incase not set
            stagger.animationDuration = Math.max(stagger.animationDuration, 0);
            stagger.transitionDuration = Math.max(
              stagger.transitionDuration,
              0,
            );

            node.classList.remove(staggerClassName);

            $$animateCache.put(staggerCacheKey, stagger, true);
          }
        }

        return stagger || {};
      }

      const rafWaitQueue = [];
      function waitUntilQuiet(callback) {
        rafWaitQueue.push(callback);
        $$rAFScheduler.waitUntilQuiet(() => {
          $$animateCache.flush();

          // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.
          // the line below will force the browser to perform a repaint so
          // that all the animated elements within the animation frame will
          // be properly updated and drawn on screen. This is required to
          // ensure that the preparation animation is properly flushed so that
          // the active state picks up from there. DO NOT REMOVE THIS LINE.
          // DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE WHICH
          // WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK DOWN AND
          // WILL TAKE YEARS AWAY FROM YOUR LIFE.

          const pageWidth = document.body.offsetWidth + 1;

          // we use a for loop to ensure that if the queue is changed
          // during this looping then it will consider new requests
          for (let i = 0; i < rafWaitQueue.length; i++) {
            rafWaitQueue[i](pageWidth);
          }
          rafWaitQueue.length = 0;
        });
      }

      function computeTimings(node, cacheKey, allowNoDuration) {
        const timings = computeCachedCssStyles(
          node,
          cacheKey,
          allowNoDuration,
          DETECT_CSS_PROPERTIES,
        );
        const aD = timings.animationDelay;
        const tD = timings.transitionDelay;
        timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD;
        timings.maxDuration = Math.max(
          timings.animationDuration * timings.animationIterationCount,
          timings.transitionDuration,
        );

        return timings;
      }

      return function init(element, initialOptions) {
        // all of the animation functions should create
        // a copy of the options data, however, if a
        // parent service has already created a copy then
        // we should stick to using that
        let options = initialOptions || {};
        if (!options.$$prepared) {
          options = prepareAnimationOptions(structuredClone(options));
        }

        const restoreStyles = {};
        const node = /** @type {HTMLElement} */ (element);
        // Note: this had an additional  !$$animateQueue.enabled() check
        if (!node || !node.parentNode) {
          return closeAndReturnNoopAnimator();
        }

        const temporaryStyles = [];
        const styles = packageStyles(options);
        let animationClosed;
        let animationPaused;
        let animationCompleted;
        let runner;
        let runnerHost;
        let maxDelay;
        let maxDelayTime;
        let maxDuration;
        let maxDurationTime;
        let startTime;
        const events = [];

        if (options.duration === 0) {
          return closeAndReturnNoopAnimator();
        }

        const method =
          options.event && Array.isArray(options.event)
            ? options.event.join(" ")
            : options.event;

        const isStructural = method && options.structural;
        let structuralClassName = "";
        let addRemoveClassName = "";

        if (isStructural) {
          structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
        } else if (method) {
          structuralClassName = method;
        }

        if (options.addClass) {
          addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
        }

        if (options.removeClass) {
          if (addRemoveClassName.length) {
            addRemoveClassName += " ";
          }
          addRemoveClassName += pendClasses(
            options.removeClass,
            REMOVE_CLASS_SUFFIX,
          );
        }

        // there may be a situation where a structural animation is combined together
        // with CSS classes that need to resolve before the animation is computed.
        // However this means that there is no explicit CSS code to block the animation
        // from happening (by setting 0s none in the class name). If this is the case
        // we need to apply the classes before the first rAF so we know to continue if
        // there actually is a detected transition or keyframe animation
        if (options.applyClassesEarly && addRemoveClassName.length) {
          applyAnimationClasses(element, options);
        }

        let preparationClasses = [structuralClassName, addRemoveClassName]
          .join(" ")
          .trim();
        const hasToStyles = styles.to && Object.keys(styles.to).length > 0;
        const containsKeyframeAnimation =
          (options.keyframeStyle || "").length > 0;

        // there is no way we can trigger an animation if no styles and
        // no classes are being applied which would then trigger a transition,
        // unless there a is raw keyframe value that is applied to the element.
        if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
          return closeAndReturnNoopAnimator();
        }

        let stagger;
        let cacheKey = $$animateCache.cacheKey(
          node,
          method,
          options.addClass,
          options.removeClass,
        );
        if ($$animateCache.containsCachedAnimationWithoutDuration(cacheKey)) {
          preparationClasses = null;
          return closeAndReturnNoopAnimator();
        }

        if (options.stagger > 0) {
          const staggerVal = parseFloat(options.stagger);
          stagger = {
            transitionDelay: staggerVal,
            animationDelay: staggerVal,
            transitionDuration: 0,
            animationDuration: 0,
          };
        } else {
          stagger = computeCachedCssStaggerStyles(
            node,
            preparationClasses,
            cacheKey,
            DETECT_STAGGER_CSS_PROPERTIES,
          );
        }

        if (!options.$$skipPreparationClasses) {
          element.classList.add(
            ...preparationClasses.split(" ").filter((x) => x !== ""),
          );
        }

        let applyOnlyDuration;

        if (options.transitionStyle) {
          const transitionStyle = [TRANSITION_PROP, options.transitionStyle];
          applyInlineStyle(node, transitionStyle);
          temporaryStyles.push(transitionStyle);
        }

        if (options.duration >= 0) {
          applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
          const durationStyle = getCssTransitionDurationStyle(
            options.duration,
            applyOnlyDuration,
          );

          // we set the duration so that it will be picked up by getComputedStyle later
          applyInlineStyle(node, durationStyle);

          temporaryStyles.push(durationStyle);
        }

        if (options.keyframeStyle) {
          const keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
          applyInlineStyle(node, keyframeStyle);
          temporaryStyles.push(keyframeStyle);
        }

        const itemIndex = stagger
          ? options.staggerIndex >= 0
            ? options.staggerIndex
            : $$animateCache.count(cacheKey)
          : 0;

        const isFirst = itemIndex === 0;

        // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY
        // without causing any combination of transitions to kick in. By adding a negative delay value
        // it forces the setup class' transition to end immediately. We later then remove the negative
        // transition delay to allow for the transition to naturally do it's thing. The beauty here is
        // that if there is no transition defined then nothing will happen and this will also allow
        // other transitions to be stacked on top of each other without any chopping them out.
        if (isFirst && !options.skipBlocking) {
          blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
        }

        let timings = computeTimings(node, cacheKey, !isStructural);
        let relativeDelay = timings.maxDelay;
        maxDelay = Math.max(relativeDelay, 0);
        maxDuration = timings.maxDuration;

        const flags = {};
        flags.hasTransitions = timings.transitionDuration > 0;
        flags.hasAnimations = timings.animationDuration > 0;
        flags.hasTransitionAll =
          flags.hasTransitions && timings.transitionProperty === "all";
        flags.applyTransitionDuration =
          hasToStyles &&
          ((flags.hasTransitions && !flags.hasTransitionAll) ||
            (flags.hasAnimations && !flags.hasTransitions));
        flags.applyAnimationDuration = options.duration && flags.hasAnimations;
        flags.applyTransitionDelay =
          truthyTimingValue(options.delay) &&
          (flags.applyTransitionDuration || flags.hasTransitions);
        flags.applyAnimationDelay =
          truthyTimingValue(options.delay) && flags.hasAnimations;
        flags.recalculateTimingStyles = addRemoveClassName.length > 0;

        if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
          maxDuration = options.duration
            ? parseFloat(options.duration)
            : maxDuration;

          if (flags.applyTransitionDuration) {
            flags.hasTransitions = true;
            timings.transitionDuration = maxDuration;
            applyOnlyDuration =
              node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
            temporaryStyles.push(
              getCssTransitionDurationStyle(maxDuration, applyOnlyDuration),
            );
          }

          if (flags.applyAnimationDuration) {
            flags.hasAnimations = true;
            timings.animationDuration = maxDuration;
            temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
          }
        }

        if (maxDuration === 0 && !flags.recalculateTimingStyles) {
          return closeAndReturnNoopAnimator();
        }

        var activeClasses = pendClasses(
          preparationClasses,
          ACTIVE_CLASS_SUFFIX,
        );

        if (options.delay != null) {
          var delayStyle;
          if (typeof options.delay !== "boolean") {
            delayStyle = parseFloat(options.delay);
            // number in options.delay means we have to recalculate the delay for the closing timeout
            maxDelay = Math.max(delayStyle, 0);
          }

          if (flags.applyTransitionDelay) {
            temporaryStyles.push(getCssDelayStyle(delayStyle));
          }

          if (flags.applyAnimationDelay) {
            temporaryStyles.push(getCssDelayStyle(delayStyle, true));
          }
        }

        // we need to recalculate the delay value since we used a pre-emptive negative
        // delay value and the delay value is required for the final event checking. This
        // property will ensure that this will happen after the RAF phase has passed.
        if (options.duration == null && timings.transitionDuration > 0) {
          flags.recalculateTimingStyles =
            flags.recalculateTimingStyles || isFirst;
        }

        maxDelayTime = maxDelay * ONE_SECOND;
        maxDurationTime = maxDuration * ONE_SECOND;
        if (!options.skipBlocking) {
          flags.blockTransition = timings.transitionDuration > 0;
          flags.blockKeyframeAnimation =
            timings.animationDuration > 0 &&
            stagger.animationDelay > 0 &&
            stagger.animationDuration === 0;
        }

        if (options.from) {
          if (options.cleanupStyles) {
            registerRestorableStyles(
              restoreStyles,
              node,
              Object.keys(options.from),
            );
          }
          applyAnimationFromStyles(element, options);
        }

        if (flags.blockTransition || flags.blockKeyframeAnimation) {
          applyBlocking(maxDuration);
        } else if (!options.skipBlocking) {
          blockTransitions(node, false);
        }

        // TODO(matsko): for 1.5 change this code to have an animator object for better debugging
        return {
          $$willAnimate: true,
          end: endFn,
          start() {
            if (animationClosed) return;

            runnerHost = {
              end: endFn,
              cancel: cancelFn,
              resume: null, // this will be set during the start() phase
              pause: null,
            };

            runner = new $$AnimateRunner(runnerHost);

            waitUntilQuiet(start);

            // we don't have access to pause/resume the animation
            // since it hasn't run yet. AnimateRunner will therefore
            // set noop functions for resume and pause and they will
            // later be overridden once the animation is triggered
            return runner;
          },
        };

        function endFn() {
          close();
        }

        function cancelFn() {
          close(true);
        }

        function close(rejected) {
          // if the promise has been called already then we shouldn't close
          // the animation again
          if (animationClosed || (animationCompleted && animationPaused))
            return;
          animationClosed = true;
          animationPaused = false;

          if (preparationClasses && !options.$$skipPreparationClasses) {
            element.classList.remove(...preparationClasses.split(" "));
          }
          activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
          if (activeClasses) {
            element.classList.remove(...activeClasses.split(" "));
          }

          blockKeyframeAnimations(node, false);
          blockTransitions(node, false);

          temporaryStyles.forEach((entry) => {
            // There is only one way to remove inline style properties entirely from elements.
            // By using `removeProperty` this works, but we need to convert camel-cased CSS
            // styles down to hyphenated values.
            node.style[entry[0]] = "";
          });

          applyAnimationClasses(element, options);
          applyAnimationStyles(element, options);

          if (Object.keys(restoreStyles).length) {
            Object.entries(restoreStyles).forEach(([prop, value]) => {
              if (value) {
                node.style.setProperty(prop, value);
              } else {
                node.style.removeProperty(prop);
              }
            });
          }

          // the reason why we have this option is to allow a synchronous closing callback
          // that is fired as SOON as the animation ends (when the CSS is removed) or if
          // the animation never takes off at all. A good example is a leave animation since
          // the element must be removed just after the animation is over or else the element
          // will appear on screen for one animation frame causing an overbearing flicker.
          if (options.onDone) {
            options.onDone();
          }

          if (events && events.length) {
            // Remove the transitionend / animationend listener(s)
            element.off(events.join(" "), onAnimationProgress);
          }

          // Cancel the fallback closing timeout and remove the timer data
          const animationTimerData = getCacheData(element, ANIMATE_TIMER_KEY);
          if (animationTimerData) {
            clearTimeout(animationTimerData[0].timer);
            removeElementData(element, ANIMATE_TIMER_KEY);
          }

          // if the preparation function fails then the promise is not setup
          if (runner) {
            runner.complete(!rejected);
          }
        }

        function applyBlocking(duration) {
          if (flags.blockTransition) {
            blockTransitions(node, duration);
          }

          if (flags.blockKeyframeAnimation) {
            blockKeyframeAnimations(node, !!duration);
          }
        }

        function closeAndReturnNoopAnimator() {
          runner = new $$AnimateRunner({
            end: endFn,
            cancel: cancelFn,
          });

          // should flush the cache animation
          waitUntilQuiet(() => {});
          close();

          return {
            $$willAnimate: false,
            start() {
              return runner;
            },
            end: endFn,
          };
        }

        function onAnimationProgress(event) {
          event.stopPropagation();
          const ev = event.originalEvent || event;

          if (ev.target !== node) {
            // Since TransitionEvent / AnimationEvent bubble up,
            // we have to ignore events by finished child animations
            return;
          }

          // we now always use `Date.now()` due to the recent changes with
          // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)
          const timeStamp = ev.$manualTimeStamp || Date.now();

          /* Firefox (or possibly just Gecko) likes to not round values up
           * when a ms measurement is used for the animation */
          const elapsedTime = parseFloat(
            ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES),
          );

          /* $manualTimeStamp is a mocked timeStamp value which is set
           * within browserTrigger(). This is only here so that tests can
           * mock animations properly. Real events fallback to event.timeStamp,
           * or, if they don't, then a timeStamp is automatically created for them.
           * We're checking to see if the timeStamp surpasses the expected delay,
           * but we're using elapsedTime instead of the timeStamp on the 2nd
           * pre-condition since animationPauseds sometimes close off early */
          if (
            Math.max(timeStamp - startTime, 0) >= maxDelayTime &&
            elapsedTime >= maxDuration
          ) {
            // we set this flag to ensure that if the transition is paused then, when resumed,
            // the animation will automatically close itself since transitions cannot be paused.
            animationCompleted = true;
            close();
          }
        }

        function start() {
          if (animationClosed) return;
          if (!node.parentNode) {
            close();
            return;
          }

          // even though we only pause keyframe animations here the pause flag
          // will still happen when transitions are used. Only the transition will
          // not be paused since that is not possible. If the animation ends when
          // paused then it will not complete until unpaused or cancelled.
          const playPause = function (playAnimation) {
            if (!animationCompleted) {
              animationPaused = !playAnimation;
              if (timings.animationDuration) {
                const value = blockKeyframeAnimations(node, animationPaused);
                if (animationPaused) {
                  temporaryStyles.push(value);
                } else {
                  removeFromArray(temporaryStyles, value);
                }
              }
            } else if (animationPaused && playAnimation) {
              animationPaused = false;
              close();
            }
          };

          // checking the stagger duration prevents an accidentally cascade of the CSS delay style
          // being inherited from the parent. If the transition duration is zero then we can safely
          // rely that the delay value is an intentional stagger delay style.
          const maxStagger =
            itemIndex > 0 &&
            ((timings.transitionDuration && stagger.transitionDuration === 0) ||
              (timings.animationDuration && stagger.animationDuration === 0)) &&
            Math.max(stagger.animationDelay, stagger.transitionDelay);
          if (maxStagger) {
            setTimeout(
              triggerAnimationStart,
              Math.floor(maxStagger * itemIndex * ONE_SECOND),
              false,
            );
          } else {
            triggerAnimationStart();
          }

          // this will decorate the existing promise runner with pause/resume methods
          runnerHost.resume = function () {
            playPause(true);
          };

          runnerHost.pause = function () {
            playPause(false);
          };

          function triggerAnimationStart() {
            // just incase a stagger animation kicks in when the animation
            // itself was cancelled entirely
            if (animationClosed) return;

            applyBlocking(false);

            temporaryStyles.forEach((entry) => {
              const key = entry[0];
              const value = entry[1];
              node.style[key] = value;
            });

            applyAnimationClasses(element, options);
            element.classList.add(
              ...activeClasses.split(" ").filter((x) => x !== ""),
            );
            if (flags.recalculateTimingStyles) {
              cacheKey = $$animateCache.cacheKey(
                node,
                method,
                options.addClass,
                options.removeClass,
              );

              timings = computeTimings(node, cacheKey, false);
              relativeDelay = timings.maxDelay;
              maxDelay = Math.max(relativeDelay, 0);
              maxDuration = timings.maxDuration;

              if (maxDuration === 0) {
                close();
                return;
              }

              flags.hasTransitions = timings.transitionDuration > 0;
              flags.hasAnimations = timings.animationDuration > 0;
            }

            if (flags.applyAnimationDelay) {
              relativeDelay =
                typeof options.delay !== "boolean" &&
                truthyTimingValue(options.delay)
                  ? parseFloat(options.delay)
                  : relativeDelay;

              maxDelay = Math.max(relativeDelay, 0);
              timings.animationDelay = relativeDelay;
              delayStyle = getCssDelayStyle(relativeDelay, true);
              temporaryStyles.push(delayStyle);
              node.style[delayStyle[0]] = delayStyle[1];
            }

            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;

            if (options.easing) {
              let easeProp;
              const easeVal = options.easing;
              if (flags.hasTransitions) {
                easeProp = TRANSITION_PROP + TIMING_KEY;
                temporaryStyles.push([easeProp, easeVal]);
                node.style[easeProp] = easeVal;
              }
              if (flags.hasAnimations) {
                easeProp = ANIMATION_PROP + TIMING_KEY;
                temporaryStyles.push([easeProp, easeVal]);
                node.style[easeProp] = easeVal;
              }
            }

            if (timings.transitionDuration) {
              events.push(TRANSITIONEND_EVENT);
            }

            if (timings.animationDuration) {
              events.push(ANIMATIONEND_EVENT);
            }

            startTime = Date.now();
            const timerTime =
              maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
            const endTime = startTime + timerTime;

            const animationsData =
              getCacheData(element, ANIMATE_TIMER_KEY) || [];
            let setupFallbackTimer = true;
            if (animationsData.length) {
              const currentTimerData = animationsData[0];
              setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
              if (setupFallbackTimer) {
                clearTimeout(currentTimerData.timer);
              } else {
                animationsData.push(close);
              }
            }

            if (setupFallbackTimer) {
              const timer = setTimeout(onAnimationExpired, timerTime, false);
              animationsData[0] = {
                timer,
                expectedEndTime: endTime,
              };
              animationsData.push(close);
              setCacheData(element, ANIMATE_TIMER_KEY, animationsData);
            }

            if (events.length) {
              events.forEach((x) => {
                element.addEventListener(x, onAnimationProgress);
              });
            }

            if (options.to) {
              if (options.cleanupStyles) {
                registerRestorableStyles(
                  restoreStyles,
                  node,
                  Object.keys(options.to),
                );
              }
              applyAnimationToStyles(element, options);
            }
          }

          function onAnimationExpired() {
            const animationsData = getCacheData(element, ANIMATE_TIMER_KEY);

            // this will be false in the event that the element was
            // removed from the DOM (via a leave animation or something
            // similar)
            if (animationsData) {
              for (let i = 1; i < animationsData.length; i++) {
                animationsData[i]();
              }
              removeElementData(element, ANIMATE_TIMER_KEY);
            }
          }
        }
      };
    },
  ];
}

function blockTransitions(node, duration) {
  // we use a negative delay value since it performs blocking
  // yet it doesn't kill any existing transitions running on the
  // same element which makes this safe for class-based animations
  const value = duration ? `-${duration}s` : "";
  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
  return [TRANSITION_DELAY_PROP, value];
}

const NG_ANIMATE_ATTR_NAME = "data-ng-animate";
const NG_ANIMATE_PIN_DATA = "$ngAnimatePin";
AnimateQueueProvider.$inject = ["$animateProvider"];
function AnimateQueueProvider($animateProvider) {
  const PRE_DIGEST_STATE = 1;
  const RUNNING_STATE = 2;
  const ONE_SPACE = " ";

  const rules = (this.rules = {
    skip: [],
    cancel: [],
    join: [],
  });

  function getEventData(options) {
    return {
      addClass: options.addClass,
      removeClass: options.removeClass,
      from: options.from,
      to: options.to,
    };
  }

  function makeTruthyCssClassMap(classString) {
    if (!classString) {
      return null;
    }

    const keys = classString.split(ONE_SPACE);
    const map = Object.create(null);

    keys.forEach((key) => {
      map[key] = true;
    });
    return map;
  }

  function hasMatchingClasses(newClassString, currentClassString) {
    if (newClassString && currentClassString) {
      const currentClassMap = makeTruthyCssClassMap(currentClassString);
      return newClassString
        .split(ONE_SPACE)
        .some((className) => currentClassMap[className]);
    }
  }

  function isAllowed(ruleType, currentAnimation, previousAnimation) {
    return rules[ruleType].some((fn) =>
      fn(currentAnimation, previousAnimation),
    );
  }

  function hasAnimationClasses(animation, and) {
    const a = (animation.addClass || "").length > 0;
    const b = (animation.removeClass || "").length > 0;
    return and ? a && b : a || b;
  }

  rules.join.push(
    (newAnimation) =>
      // if the new animation is class-based then we can just tack that on
      !newAnimation.structural && hasAnimationClasses(newAnimation),
  );

  rules.skip.push(
    (newAnimation) =>
      // there is no need to animate anything if no classes are being added and
      // there is no structural animation that will be triggered
      !newAnimation.structural && !hasAnimationClasses(newAnimation),
  );

  rules.skip.push(
    (newAnimation, currentAnimation) =>
      // why should we trigger a new structural animation if the element will
      // be removed from the DOM anyway?
      currentAnimation.event === "leave" && newAnimation.structural,
  );

  rules.skip.push(
    (newAnimation, currentAnimation) =>
      // if there is an ongoing current animation then don't even bother running the class-based animation
      currentAnimation.structural &&
      currentAnimation.state === RUNNING_STATE &&
      !newAnimation.structural,
  );

  rules.cancel.push(
    (newAnimation, currentAnimation) =>
      // there can never be two structural animations running at the same time
      currentAnimation.structural && newAnimation.structural,
  );

  rules.cancel.push(
    (newAnimation, currentAnimation) =>
      // if the previous animation is already running, but the new animation will
      // be triggered, but the new animation is structural
      currentAnimation.state === RUNNING_STATE && newAnimation.structural,
  );

  rules.cancel.push((newAnimation, currentAnimation) => {
    // cancel the animation if classes added / removed in both animation cancel each other out,
    // but only if the current animation isn't structural

    if (currentAnimation.structural) return false;

    const nA = newAnimation.addClass;
    const nR = newAnimation.removeClass;
    const cA = currentAnimation.addClass;
    const cR = currentAnimation.removeClass;

    // early detection to save the global CPU shortage :)
    if (
      (isUndefined(nA) && isUndefined(nR)) ||
      (isUndefined(cA) && isUndefined(cR))
    ) {
      return false;
    }

    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
  });

  this.$get = [
    "$rootScope",
    "$injector",
    "$$animation",
    "$$AnimateRunner",
    "$templateRequest",
    /**
     *
     * @param {import('../core/scope/scope.js').Scope} $rootScope
     * @param {*} $injector
     * @param {*} $$animation
     * @param {*} $$AnimateRunner
     * @param {*} $templateRequest
     * @returns
     */
    function (
      $rootScope,
      $injector,
      $$animation,
      $$AnimateRunner,
      $templateRequest,
    ) {
      const activeAnimationsLookup = new Map();
      const disabledElementsLookup = new Map();
      let animationsEnabled = null;

      function removeFromDisabledElementsLookup(evt) {
        disabledElementsLookup.delete(evt.target);
      }

      function postDigestTaskFactory() {
        let postDigestCalled = false;
        return function (fn) {
          // we only issue a call to postDigest before
          // it has first passed. This prevents any callbacks
          // from not firing once the animation has completed
          // since it will be out of the digest cycle.
          if (postDigestCalled) {
            fn();
          } else {
            $rootScope.$postUpdate(() => {
              postDigestCalled = true;
              fn();
            });
          }
        };
      }

      // Wait until all directive and route-related templates are downloaded and
      // compiled. The $templateRequest.totalPendingRequests variable keeps track of
      // all of the remote templates being currently downloaded. If there are no
      // templates currently downloading then the watcher will still fire anyway.
      $rootScope["templateRequest"] = $templateRequest;
      const deregisterWatch = $rootScope.$watch(
        "$templateRequest.totalPendingRequests",
        (val) => {
          if (val === 0) {
            deregisterWatch();
            $rootScope["$templateRequest"] = undefined;
            // Now that all templates have been downloaded, $animate will wait until
            // the post digest queue is empty before enabling animations. By having two
            // calls to $postDigest calls we can ensure that the flag is enabled at the
            // very end of the post digest queue. Since all of the animations in $animate
            // use $postDigest, it's important that the code below executes at the end.
            // This basically means that the page is fully downloaded and compiled before
            // any animations are triggered.
            $rootScope.$postUpdate(() => {
              $rootScope.$postUpdate(() => {
                // we check for null directly in the event that the application already called
                // .enabled() with whatever arguments that it provided it with
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          }
        },
        true,
      );

      const callbackRegistry = Object.create(null);

      // remember that the `customFilter`/`classNameFilter` are set during the
      // provider/config stage therefore we can optimize here and setup helper functions
      const customFilter = $animateProvider.customFilter();
      const classNameFilter = $animateProvider.classNameFilter();
      const returnTrue = function () {
        return true;
      };

      const isAnimatableByFilter = customFilter || returnTrue;
      const isAnimatableClassName = !classNameFilter
        ? returnTrue
        : function (node, options) {
            const className = [
              node.getAttribute("class"),
              options.addClass,
              options.removeClass,
            ].join(" ");
            return classNameFilter.test(className);
          };

      const applyAnimationClasses = applyAnimationClassesFactory();

      function normalizeAnimationDetails(element, animation) {
        return mergeAnimationDetails(element, animation, {});
      }

      // IE9-11 has no method "contains" in SVG element and in Node.prototype. Bug #10259.
      const contains =
        window.Node.prototype.contains ||
        function (arg) {
          return this === arg || !!(this.compareDocumentPosition(arg) & 16);
        };

      function findCallbacks(targetParentNode, targetNode, event) {
        const matches = [];
        const entries = callbackRegistry[event];
        if (entries) {
          entries.forEach((entry) => {
            if (contains.call(entry.node, targetNode)) {
              matches.push(entry.callback);
            } else if (
              event === "leave" &&
              contains.call(entry.node, targetParentNode)
            ) {
              matches.push(entry.callback);
            }
          });
        }

        return matches;
      }

      function filterFromRegistry(list, matchContainer, matchCallback) {
        const containerNode = extractElementNode(matchContainer);
        return list.filter((entry) => {
          const isMatch =
            entry.node === containerNode &&
            (!matchCallback || entry.callback === matchCallback);
          return !isMatch;
        });
      }

      function cleanupEventListeners(phase, node) {
        if (phase === "close" && !node.parentNode) {
          // If the element is not attached to a parentNode, it has been removed by
          // the domOperation, and we can safely remove the event callbacks
          $animate.off(node);
        }
      }

      let $animate = {
        on(event, container, callback) {
          const node = extractElementNode(container);
          callbackRegistry[event] = callbackRegistry[event] || [];
          callbackRegistry[event].push({
            node,
            callback,
          });

          // Remove the callback when the element is removed from the DOM
          container.addEventListener("$destroy", () => {
            const animationDetails = activeAnimationsLookup.get(node);

            if (!animationDetails) {
              // If there's an animation ongoing, the callback calling code will remove
              // the event listeners. If we'd remove here, the callbacks would be removed
              // before the animation ends
              $animate.off(event, container, callback);
            }
          });
        },

        off(event, container, callback) {
          if (arguments.length === 1 && !isString(arguments[0])) {
            container = arguments[0];
            for (const eventType in callbackRegistry) {
              callbackRegistry[eventType] = filterFromRegistry(
                callbackRegistry[eventType],
                container,
              );
            }

            return;
          }

          const entries = callbackRegistry[event];
          if (!entries) return;

          callbackRegistry[event] =
            arguments.length === 1
              ? null
              : filterFromRegistry(entries, container, callback);
        },

        pin(element, parentElement) {
          assertArg(isElement(element), "element", "not an element");
          assertArg(
            isElement(parentElement),
            "parentElement",
            "not an element",
          );
          setCacheData(element, NG_ANIMATE_PIN_DATA, parentElement);
        },

        push(element, event, options, domOperation) {
          options = options || {};
          options.domOperation = domOperation;
          return queueAnimation(element, event, options);
        },

        // this method has four signatures:
        //  () - global getter
        //  (bool) - global setter
        //  (element) - element getter
        //  (element, bool) - element setter<F37>
        enabled(element, bool) {
          const argCount = arguments.length;

          if (argCount === 0) {
            // () - Global getter
            bool = !!animationsEnabled;
          } else {
            const hasElement = isElement(element);

            if (!hasElement) {
              // (bool) - Global setter
              bool = animationsEnabled = !!element;
            } else {
              const node = element;

              if (argCount === 1) {
                // (element) - Element getter
                bool = !disabledElementsLookup.get(node);
              } else {
                // (element, bool) - Element setter
                if (!disabledElementsLookup.has(node)) {
                  // The element is added to the map for the first time.
                  // Create a listener to remove it on `$destroy` (to avoid memory leak).
                  element.addEventListener(
                    "$destroy",
                    removeFromDisabledElementsLookup,
                  );
                }
                disabledElementsLookup.set(node, !bool);
              }
            }
          }

          return bool;
        },
      };

      return $animate;

      /**
       * @param {Element} originalElement
       * @param {string} event
       * @param {*} initialOptions
       * @returns void
       */
      function queueAnimation(originalElement, event, initialOptions) {
        // we always make a copy of the options since
        // there should never be any side effects on
        // the input data when running `$animateCss`.
        let options = initialOptions;

        // strip comments

        let element = Array.isArray(originalElement)
          ? originalElement.filter((x) => x.nodeName !== "#comment")[0]
          : originalElement;
        const node = element;
        const parentNode = node && node.parentNode;

        options = prepareAnimationOptions(options);

        // we create a fake runner with a working promise.
        // These methods will become available after the digest has passed
        const runner = new $$AnimateRunner();

        // this is used to trigger callbacks in postDigest mode
        const runInNextPostDigestOrNow = postDigestTaskFactory();

        if (Array.isArray(options.addClass)) {
          options.addClass = options.addClass.join(" ");
        }

        if (options.addClass && !isString(options.addClass)) {
          options.addClass = null;
        }

        if (Array.isArray(options.removeClass)) {
          options.removeClass = options.removeClass.join(" ");
        }

        if (options.removeClass && !isString(options.removeClass)) {
          options.removeClass = null;
        }

        if (options.from && !isObject(options.from)) {
          options.from = null;
        }

        if (options.to && !isObject(options.to)) {
          options.to = null;
        }
        // If animations are hard-disabled for the whole application there is no need to continue.
        // There are also situations where a directive issues an animation for a JQLite wrapper that
        // contains only comment nodes. In this case, there is no way we can perform an animation.
        if (
          // !animationsEnabled ||
          !node ||
          !isAnimatableByFilter(node, event, initialOptions) ||
          !isAnimatableClassName(node, options)
        ) {
          close();
          return runner;
        }

        const isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;

        // This is a hard disable of all animations the element itself, therefore  there is no need to
        // continue further past this point if not enabled
        // Animations are also disabled if the document is currently hidden (page is not visible
        // to the user), because browsers slow down or do not flush calls to requestAnimationFrame
        let skipAnimations =
          document.hidden || disabledElementsLookup.get(node);
        const existingAnimation =
          (!skipAnimations && activeAnimationsLookup.get(node)) || {};
        const hasExistingAnimation = !!existingAnimation.state;
        // there is no point in traversing the same collection of parent ancestors if a followup
        // animation will be run on the same element that already did all that checking work
        if (
          !skipAnimations &&
          (!hasExistingAnimation ||
            existingAnimation.state !== PRE_DIGEST_STATE)
        ) {
          skipAnimations = !areAnimationsAllowed(node, parentNode);
        }

        if (skipAnimations) {
          // Callbacks should fire even if the document is hidden (regression fix for issue #14120)
          if (document.hidden)
            notifyProgress(runner, event, "start", getEventData(options));
          close();
          if (document.hidden)
            notifyProgress(runner, event, "close", getEventData(options));
          return runner;
        }

        if (isStructural) {
          closeChildAnimations(node);
        }

        const newAnimation = {
          structural: isStructural,
          element,
          event,
          addClass: options.addClass,
          removeClass: options.removeClass,
          close,
          options,
          runner,
        };

        if (hasExistingAnimation) {
          const skipAnimationFlag = isAllowed(
            "skip",
            newAnimation,
            existingAnimation,
          );
          if (skipAnimationFlag) {
            if (existingAnimation.state === RUNNING_STATE) {
              close();
              return runner;
            }
            mergeAnimationDetails(element, existingAnimation, newAnimation);
            return existingAnimation.runner;
          }
          const cancelAnimationFlag = isAllowed(
            "cancel",
            newAnimation,
            existingAnimation,
          );
          if (cancelAnimationFlag) {
            if (existingAnimation.state === RUNNING_STATE) {
              // this will end the animation right away and it is safe
              // to do so since the animation is already running and the
              // runner callback code will run in async
              existingAnimation.runner.end();
            } else if (existingAnimation.structural) {
              // this means that the animation is queued into a digest, but
              // hasn't started yet. Therefore it is safe to run the close
              // method which will call the runner methods in async.
              existingAnimation.close();
            } else {
              // this will merge the new animation options into existing animation options
              mergeAnimationDetails(element, existingAnimation, newAnimation);

              return existingAnimation.runner;
            }
          } else {
            // a joined animation means that this animation will take over the existing one
            // so an example would involve a leave animation taking over an enter. Then when
            // the postDigest kicks in the enter will be ignored.
            const joinAnimationFlag = isAllowed(
              "join",
              newAnimation,
              existingAnimation,
            );
            if (joinAnimationFlag) {
              if (existingAnimation.state === RUNNING_STATE) {
                normalizeAnimationDetails(element, newAnimation);
              } else {
                applyGeneratedPreparationClasses(
                  element,
                  isStructural ? event : null,
                  options,
                );

                event = newAnimation.event = existingAnimation.event;
                options = mergeAnimationDetails(
                  element,
                  existingAnimation,
                  newAnimation,
                );

                // we return the same runner since only the option values of this animation will
                // be fed into the `existingAnimation`.
                return existingAnimation.runner;
              }
            }
          }
        } else {
          // normalization in this case means that it removes redundant CSS classes that
          // already exist (addClass) or do not exist (removeClass) on the element
          normalizeAnimationDetails(element, newAnimation);
        }

        // when the options are merged and cleaned up we may end up not having to do
        // an animation at all, therefore we should check this before issuing a post
        // digest callback. Structural animations will always run no matter what.
        let isValidAnimation = newAnimation.structural;
        if (!isValidAnimation) {
          // animate (from/to) can be quickly checked first, otherwise we check if any classes are present
          isValidAnimation =
            (newAnimation.event === "animate" &&
              Object.keys(newAnimation.options.to || {}).length > 0) ||
            hasAnimationClasses(newAnimation);
        }

        if (!isValidAnimation) {
          close();
          clearElementAnimationState(node);
          return runner;
        }

        // the counter keeps track of cancelled animations
        const counter = (existingAnimation.counter || 0) + 1;
        newAnimation.counter = counter;

        markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);
        $rootScope.$postUpdate(() => {
          // It is possible that the DOM nodes inside `originalElement` have been replaced. This can
          // happen if the animated element is a transcluded clone and also has a `templateUrl`
          // directive on it. Therefore, we must recreate `element` in order to interact with the
          // actual DOM nodes.
          // Note: We still need to use the old `node` for certain things, such as looking up in
          //       HashMaps where it was used as the key.

          element = stripCommentsFromElement(originalElement);

          let animationDetails = activeAnimationsLookup.get(node);
          const animationCancelled = !animationDetails;
          animationDetails = animationDetails || {};

          // if addClass/removeClass is called before something like enter then the
          // registered parent element may not be present. The code below will ensure
          // that a final value for parent element is obtained
          const parentElement = element.parentElement || [];

          // animate/structural/class-based animations all have requirements. Otherwise there
          // is no point in performing an animation. The parent node must also be set.
          const isValidAnimation =
            parentElement &&
            (animationDetails.event === "animate" ||
              animationDetails.structural ||
              hasAnimationClasses(animationDetails));

          // this means that the previous animation was cancelled
          // even if the follow-up animation is the same event
          if (
            animationCancelled ||
            animationDetails.counter !== counter ||
            !isValidAnimation
          ) {
            // if another animation did not take over then we need
            // to make sure that the domOperation and options are
            // handled accordingly
            if (animationCancelled) {
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
            }

            // if the event changed from something like enter to leave then we do
            // it, otherwise if it's the same then the end result will be the same too
            if (
              animationCancelled ||
              (isStructural && animationDetails.event !== event)
            ) {
              options.domOperation();
              runner.end();
            }

            // in the event that the element animation was not cancelled or a follow-up animation
            // isn't allowed to animate from here then we need to clear the state of the element
            // so that any future animations won't read the expired animation data.
            if (!isValidAnimation) {
              clearElementAnimationState(node);
            }

            return;
          }

          // this combined multiple class to addClass / removeClass into a setClass event
          // so long as a structural event did not take over the animation
          event =
            !animationDetails.structural &&
            hasAnimationClasses(animationDetails, true)
              ? "setClass"
              : animationDetails.event;

          markElementAnimationState(node, RUNNING_STATE);
          const realRunner = $$animation(
            element,
            event,
            animationDetails.options,
          );

          // this will update the runner's flow-control events based on
          // the `realRunner` object.
          runner.setHost(realRunner);
          notifyProgress(runner, event, "start", getEventData(options));

          realRunner.done((status) => {
            close(!status);
            const animationDetails = activeAnimationsLookup.get(node);
            if (animationDetails && animationDetails.counter === counter) {
              clearElementAnimationState(node);
            }
            notifyProgress(runner, event, "close", getEventData(options));
          });
        });

        return runner;

        function notifyProgress(runner, event, phase, data) {
          runInNextPostDigestOrNow(() => {
            const callbacks = findCallbacks(parentNode, node, event);
            if (callbacks.length) {
              callbacks.forEach((callback) => {
                callback(element, phase, data);
              });
              cleanupEventListeners(phase, node);
            } else {
              cleanupEventListeners(phase, node);
            }
          });
          runner.progress(event, phase, data);
        }

        function close(reject) {
          clearGeneratedClasses(element, options);
          applyAnimationClasses(element, options);
          applyAnimationStyles(element, options);
          options.domOperation();
          runner.complete(!reject);
        }
      }

      function closeChildAnimations(node) {
        const children = node.querySelectorAll(`[${NG_ANIMATE_ATTR_NAME}]`);
        children.forEach((child) => {
          const state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);
          const animationDetails = activeAnimationsLookup.get(child);
          if (animationDetails) {
            switch (state) {
              case RUNNING_STATE:
                animationDetails.runner.end();
              /* falls through */
              case PRE_DIGEST_STATE:
                activeAnimationsLookup.delete(child);
                break;
            }
          }
        });
      }

      function clearElementAnimationState(node) {
        node.removeAttribute(NG_ANIMATE_ATTR_NAME);
        activeAnimationsLookup.delete(node);
      }

      /**
       * This fn returns false if any of the following is true:
       * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed
       * b) a parent element has an ongoing structural animation, and animateChildren is false
       * c) the element is not a child of the body
       * d) the element is not a child of the $rootElement
       */
      function areAnimationsAllowed(node, parentNode) {
        const bodyNode = document.body;
        const rootNode = $injector.get("$rootElement");

        let bodyNodeDetected = node === bodyNode || node.nodeName === "HTML";
        let rootNodeDetected = node === rootNode;
        let parentAnimationDetected = false;
        let elementDisabled = disabledElementsLookup.get(node);
        let animateChildren;

        let parentHost = getOrSetCacheData(node, NG_ANIMATE_PIN_DATA);
        if (parentHost) {
          parentNode = parentHost;
        }

        while (parentNode) {
          if (!rootNodeDetected) {
            // AngularJS doesn't want to attempt to animate elements outside of the application
            // therefore we need to ensure that the rootElement is an ancestor of the current element
            rootNodeDetected = parentNode === rootNode;
          }

          if (parentNode.nodeType !== Node.ELEMENT_NODE) {
            // no point in inspecting the #document element
            break;
          }

          const details = activeAnimationsLookup.get(parentNode) || {};
          // either an enter, leave or move animation will commence
          // therefore we can't allow any animations to take place
          // but if a parent animation is class-based then that's ok
          if (!parentAnimationDetected) {
            const parentNodeDisabled = disabledElementsLookup.get(parentNode);

            if (parentNodeDisabled === true && elementDisabled !== false) {
              // disable animations if the user hasn't explicitly enabled animations on the
              // current element
              elementDisabled = true;
              // element is disabled via parent element, no need to check anything else
              break;
            } else if (parentNodeDisabled === false) {
              elementDisabled = false;
            }
            parentAnimationDetected = details.structural;
          }

          if (isUndefined(animateChildren) || animateChildren === true) {
            const value = getOrSetCacheData(
              parentNode,
              NG_ANIMATE_CHILDREN_DATA,
            );
            if (isDefined(value)) {
              animateChildren = value;
            }
          }

          // there is no need to continue traversing at this point
          if (parentAnimationDetected && animateChildren === false) break;

          if (!bodyNodeDetected) {
            // we also need to ensure that the element is or will be a part of the body element
            // otherwise it is pointless to even issue an animation to be rendered
            bodyNodeDetected = parentNode === bodyNode;
          }

          if (bodyNodeDetected && rootNodeDetected) {
            // If both body and root have been found, any other checks are pointless,
            // as no animation data should live outside the application
            break;
          }

          if (!rootNodeDetected) {
            // If `rootNode` is not detected, check if `parentNode` is pinned to another element
            parentHost = getOrSetCacheData(parentNode, NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              // The pin target element becomes the next parent element
              parentNode = parentHost;
              continue;
            }
          }

          parentNode = parentNode.parentNode;
        }

        const allowAnimation =
          (!parentAnimationDetected || animateChildren) &&
          elementDisabled !== true;
        return allowAnimation && rootNodeDetected && bodyNodeDetected;
      }

      function markElementAnimationState(node, state, details) {
        details = details || {};
        details.state = state;

        node.setAttribute(NG_ANIMATE_ATTR_NAME, state);

        const oldValue = activeAnimationsLookup.get(node);
        const newValue = oldValue ? extend(oldValue, details) : details;
        activeAnimationsLookup.set(node, newValue);
      }
    },
  ];
}

// TODO: use caching here to speed things up for detection
// TODO: add documentation

AnimateJsProvider.$inject = ["$animateProvider"];
function AnimateJsProvider($animateProvider) {
  this.$get = [
    "$injector",
    "$$AnimateRunner",
    /**
     *
     * @param {import("../core/di/internal-injector").InjectorService} $injector
     * @param {*} $$AnimateRunner
     * @returns
     */
    function ($injector, $$AnimateRunner) {
      const applyAnimationClasses = applyAnimationClassesFactory();
      // $animateJs(element, 'enter');
      return function (element, event, classes, options) {
        let animationClosed = false;

        // the `classes` argument is optional and if it is not used
        // then the classes will be resolved from the element's className
        // property as well as options.addClass/options.removeClass.
        if (arguments.length === 3 && isObject(classes)) {
          options = classes;
          classes = null;
        }

        options = prepareAnimationOptions(options);
        if (!classes) {
          classes = element.getAttribute("class") || "";
          if (options.addClass) {
            classes += ` ${options.addClass}`;
          }
          if (options.removeClass) {
            classes += ` ${options.removeClass}`;
          }
        }

        const classesToAdd = options.addClass;
        const classesToRemove = options.removeClass;

        // the lookupAnimations function returns a series of animation objects that are
        // matched up with one or more of the CSS classes. These animation objects are
        // defined via the module.animation factory function. If nothing is detected then
        // we don't return anything which then makes $animation query the next driver.
        const animations = lookupAnimations(classes);
        let before;
        let after;
        if (animations.length) {
          let afterFn;
          let beforeFn;
          if (event === "leave") {
            beforeFn = "leave";
            afterFn = "afterLeave"; // TODO(matsko): get rid of this
          } else {
            beforeFn = `before${event.charAt(0).toUpperCase()}${event.substring(1)}`;
            afterFn = event;
          }

          if (event !== "enter" && event !== "move") {
            before = packageAnimations(
              element,
              event,
              options,
              animations,
              beforeFn,
            );
          }
          after = packageAnimations(
            element,
            event,
            options,
            animations,
            afterFn,
          );
        }

        // no matching animations
        if (!before && !after) return;

        function applyOptions() {
          options.domOperation();
          applyAnimationClasses(element, options);
        }

        function close() {
          animationClosed = true;
          applyOptions();
          applyAnimationStyles(element, options);
        }

        let runner;

        return {
          $$willAnimate: true,
          end() {
            if (runner) {
              runner.end();
            } else {
              close();
              runner = new $$AnimateRunner();
              runner.complete(true);
            }
            return runner;
          },
          start() {
            if (runner) {
              return runner;
            }

            runner = new $$AnimateRunner();
            let closeActiveAnimations;
            const chain = [];

            if (before) {
              chain.push((fn) => {
                closeActiveAnimations = before(fn);
              });
            }

            if (chain.length) {
              chain.push((fn) => {
                applyOptions();
                fn(true);
              });
            } else {
              applyOptions();
            }

            if (after) {
              chain.push((fn) => {
                closeActiveAnimations = after(fn);
              });
            }

            runner.setHost({
              end() {
                endAnimations();
              },
              cancel() {
                endAnimations(true);
              },
            });

            $$AnimateRunner.chain(chain, onComplete);
            return runner;

            function onComplete(success) {
              close();
              runner.complete(success);
            }

            function endAnimations(cancelled) {
              if (!animationClosed) {
                (closeActiveAnimations || (() => {}))(cancelled);
                onComplete(cancelled);
              }
            }
          },
        };

        function executeAnimationFn(fn, element, event, options, onDone) {
          let args;
          switch (event) {
            case "animate":
              args = [element, options.from, options.to, onDone];
              break;

            case "setClass":
              args = [element, classesToAdd, classesToRemove, onDone];
              break;

            case "addClass":
              args = [element, classesToAdd, onDone];
              break;

            case "removeClass":
              args = [element, classesToRemove, onDone];
              break;

            default:
              args = [element, onDone];
              break;
          }

          args.push(options);

          let value = fn.apply(fn, args);
          if (value) {
            if (isFunction(value.start)) {
              value = value.start();
            }

            if (value instanceof $$AnimateRunner) {
              value.done(onDone);
            } else if (isFunction(value)) {
              // optional onEnd / onCancel callback
              return value;
            }
          }

          return () => {};
        }

        function groupEventedAnimations(
          element,
          event,
          options,
          animations,
          fnName,
        ) {
          const operations = [];
          animations.forEach((ani) => {
            const animation = ani[fnName];
            if (!animation) return;

            // note that all of these animations will run in parallel
            operations.push(() => {
              let runner;
              let endProgressCb;

              let resolved = false;
              const onAnimationComplete = function (rejected) {
                if (!resolved) {
                  resolved = true;
                  (endProgressCb || (() => {}))(rejected);
                  runner.complete(!rejected);
                }
              };

              runner = new $$AnimateRunner({
                end() {
                  onAnimationComplete();
                },
                cancel() {
                  onAnimationComplete(true);
                },
              });

              endProgressCb = executeAnimationFn(
                animation,
                element,
                event,
                options,
                (result) => {
                  const cancelled = result === false;
                  onAnimationComplete(cancelled);
                },
              );

              return runner;
            });
          });

          return operations;
        }

        function packageAnimations(
          element,
          event,
          options,
          animations,
          fnName,
        ) {
          let operations = groupEventedAnimations(
            element,
            event,
            options,
            animations,
            fnName,
          );
          if (operations.length === 0) {
            let a;
            let b;
            if (fnName === "beforeSetClass") {
              a = groupEventedAnimations(
                element,
                "removeClass",
                options,
                animations,
                "beforeRemoveClass",
              );
              b = groupEventedAnimations(
                element,
                "addClass",
                options,
                animations,
                "beforeAddClass",
              );
            } else if (fnName === "setClass") {
              a = groupEventedAnimations(
                element,
                "removeClass",
                options,
                animations,
                "removeClass",
              );
              b = groupEventedAnimations(
                element,
                "addClass",
                options,
                animations,
                "addClass",
              );
            }

            if (a) {
              operations = operations.concat(a);
            }
            if (b) {
              operations = operations.concat(b);
            }
          }

          if (operations.length === 0) return;

          // TODO(matsko): add documentation
          return function startAnimation(callback) {
            const runners = [];
            if (operations.length) {
              operations.forEach((animateFn) => {
                runners.push(animateFn());
              });
            }

            if (runners.length) {
              $$AnimateRunner.all(runners, callback);
            } else {
              callback();
            }

            return function endFn(reject) {
              runners.forEach((runner) => {
                if (reject) {
                  runner.cancel();
                } else {
                  runner.end();
                }
              });
            };
          };
        }
      };

      function lookupAnimations(classes) {
        classes = Array.isArray(classes) ? classes : classes.split(" ");
        const matches = [];
        const flagMap = {};
        for (let i = 0; i < classes.length; i++) {
          const klass = classes[i];
          const animationFactory =
            $animateProvider.$$registeredAnimations[klass];
          if (animationFactory && !flagMap[klass]) {
            matches.push($injector.get(animationFactory));
            flagMap[klass] = true;
          }
        }
        return matches;
      }
    },
  ];
}

const RUNNER_STORAGE_KEY = "$$animationRunner";
const PREPARE_CLASSES_KEY = "$$animatePrepareClasses";

function AnimationProvider() {
  const NG_ANIMATE_REF_ATTR = "ng-animate-ref";

  const drivers = (this.drivers = []);

  function setRunner(element, runner) {
    setCacheData(element, RUNNER_STORAGE_KEY, runner);
  }

  function removeRunner(element) {
    deleteCacheData(element, RUNNER_STORAGE_KEY);
  }

  function getRunner(element) {
    return getCacheData(element, RUNNER_STORAGE_KEY);
  }

  this.$get = [
    "$rootScope",
    "$injector",
    "$$AnimateRunner",
    "$$rAFScheduler",
    "$$animateCache",
    /**
     *
     * @param {*} $rootScope
     * @param {import("../core/di/internal-injector").InjectorService} $injector
     * @param {*} $$AnimateRunner
     * @param {import("./raf-scheduler").RafScheduler} $$rAFScheduler
     * @param {*} $$animateCache
     * @returns
     */
    function (
      $rootScope,
      $injector,
      $$AnimateRunner,
      $$rAFScheduler,
      $$animateCache,
    ) {
      const animationQueue = [];
      const applyAnimationClasses = applyAnimationClassesFactory();

      function sortAnimations(animations) {
        const tree = { children: [] };
        let i;
        const lookup = new Map();

        // this is done first beforehand so that the map
        // is filled with a list of the elements that will be animated

        for (i = 0; i < animations.length; i++) {
          const animation = animations[i];
          lookup.set(
            animation.domNode,
            (animations[i] = {
              domNode: animation.domNode,
              element: animation.element,
              fn: animation.fn,
              children: [],
            }),
          );
        }

        for (i = 0; i < animations.length; i++) {
          processNode(animations[i]);
        }

        return flatten(tree);

        function processNode(entry) {
          if (entry.processed) return entry;
          entry.processed = true;

          const elementNode = entry.domNode;
          let { parentNode } = elementNode;
          lookup.set(elementNode, entry);

          let parentEntry;
          while (parentNode) {
            parentEntry = lookup.get(parentNode);
            if (parentEntry) {
              if (!parentEntry.processed) {
                parentEntry = processNode(parentEntry);
              }
              break;
            }
            parentNode = parentNode.parentNode;
          }

          (parentEntry || tree).children.push(entry);
          return entry;
        }

        function flatten(tree) {
          const result = [];
          const queue = [];
          let i;

          for (i = 0; i < tree.children.length; i++) {
            queue.push(tree.children[i]);
          }

          let remainingLevelEntries = queue.length;
          let nextLevelEntries = 0;
          let row = [];

          for (i = 0; i < queue.length; i++) {
            const entry = queue[i];
            if (remainingLevelEntries <= 0) {
              remainingLevelEntries = nextLevelEntries;
              nextLevelEntries = 0;
              result.push(row);
              row = [];
            }
            row.push(entry);
            entry.children.forEach((childEntry) => {
              nextLevelEntries++;
              queue.push(childEntry);
            });
            remainingLevelEntries--;
          }

          if (row.length) {
            result.push(row);
          }

          return result;
        }
      }

      // TODO(matsko): document the signature in a better way
      return function (element, event, options) {
        options = prepareAnimationOptions(options);
        const isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;

        // there is no animation at the current moment, however
        // these runner methods will get later updated with the
        // methods leading into the driver's end/cancel methods
        // for now they just stop the animation from starting
        const runner = new $$AnimateRunner({
          end() {
            close();
          },
          cancel() {
            close(true);
          },
        });

        if (!drivers.length) {
          close();
          return runner;
        }

        let classes = mergeClasses$1(
          element.getAttribute("class"),
          mergeClasses$1(options.addClass, options.removeClass),
        );
        let { tempClasses } = options;
        if (tempClasses) {
          classes += ` ${tempClasses}`;
          options.tempClasses = null;
        }

        if (isStructural) {
          setCacheData(
            element,
            PREPARE_CLASSES_KEY,
            `ng-${event}${PREPARE_CLASS_SUFFIX}`,
          );
        }

        setRunner(element, runner);

        animationQueue.push({
          // this data is used by the postDigest code and passed into
          // the driver step function
          element,
          classes,
          event,
          structural: isStructural,
          options,
          beforeStart,
          close,
        });

        element.addEventListener("$destroy", handleDestroyedElement);

        // we only want there to be one function called within the post digest
        // block. This way we can group animations for all the animations that
        // were apart of the same postDigest flush call.
        if (animationQueue.length > 1) return runner;

        $rootScope.$postUpdate(() => {
          const animations = [];
          animationQueue.forEach((entry) => {
            // the element was destroyed early on which removed the runner
            // form its storage. This means we can't animate this element
            // at all and it already has been closed due to destruction.
            if (getRunner(entry.element)) {
              animations.push(entry);
            } else {
              entry.close();
            }
          });

          // now any future animations will be in another postDigest
          animationQueue.length = 0;

          const groupedAnimations = groupAnimations(animations);
          const toBeSortedAnimations = [];

          groupedAnimations.forEach((animationEntry) => {
            const element = animationEntry.from
              ? animationEntry.from.element
              : animationEntry.element;
            let extraClasses = options.addClass;

            extraClasses =
              (extraClasses ? `${extraClasses} ` : "") + NG_ANIMATE_CLASSNAME;
            const cacheKey = $$animateCache.cacheKey(
              element,
              animationEntry.event,
              extraClasses,
              options.removeClass,
            );

            toBeSortedAnimations.push({
              element,
              domNode: element,
              fn: function triggerAnimationStart() {
                let startAnimationFn;
                const closeFn = animationEntry.close;

                // in the event that we've cached the animation status for this element
                // and it's in fact an invalid animation (something that has duration = 0)
                // then we should skip all the heavy work from here on
                if (
                  $$animateCache.containsCachedAnimationWithoutDuration(
                    cacheKey,
                  )
                ) {
                  closeFn();
                  return;
                }

                // it's important that we apply the `ng-animate` CSS class and the
                // temporary classes before we do any driver invoking since these
                // CSS classes may be required for proper CSS detection.
                animationEntry.beforeStart();

                // in the event that the element was removed before the digest runs or
                // during the RAF sequencing then we should not trigger the animation.
                const targetElement = animationEntry.anchors
                  ? animationEntry.from.element || animationEntry.to.element
                  : animationEntry.element;

                if (getRunner(targetElement)) {
                  const operation = invokeFirstDriver(animationEntry);
                  if (operation) {
                    startAnimationFn = operation.start;
                  }
                }

                if (!startAnimationFn) {
                  closeFn();
                } else {
                  const animationRunner = startAnimationFn();
                  animationRunner.done((status) => {
                    closeFn(!status);
                  });
                  updateAnimationRunners(animationEntry, animationRunner);
                }
              },
            });
          });

          // we need to sort each of the animations in order of parent to child
          // relationships. This ensures that the child classes are applied at the
          // right time.
          const finalAnimations = sortAnimations(toBeSortedAnimations);
          for (let i = 0; i < finalAnimations.length; i++) {
            const innerArray = finalAnimations[i];
            for (let j = 0; j < innerArray.length; j++) {
              const entry = innerArray[j];
              const { element } = entry;

              // the RAFScheduler code only uses functions
              finalAnimations[i][j] = entry.fn;

              // the first row of elements shouldn't have a prepare-class added to them
              // since the elements are at the top of the animation hierarchy and they
              // will be applied without a RAF having to pass...
              if (i === 0) {
                removeElementData(element, PREPARE_CLASSES_KEY);
                continue;
              }

              const prepareClassName = getCacheData(
                element,
                PREPARE_CLASSES_KEY,
              );
              if (prepareClassName) {
                element.classList.add(prepareClassName);
              }
            }
          }
          $$rAFScheduler(finalAnimations);
        });

        return runner;

        // TODO(matsko): change to reference nodes
        function getAnchorNodes(node) {
          const SELECTOR = `[${NG_ANIMATE_REF_ATTR}]`;
          const items = node.hasAttribute(NG_ANIMATE_REF_ATTR)
            ? [node]
            : node.querySelectorAll(SELECTOR);
          const anchors = [];
          items.forEach((node) => {
            const attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
            if (attr && attr.length) {
              anchors.push(node);
            }
          });
          return anchors;
        }

        function groupAnimations(animations) {
          const preparedAnimations = [];
          const refLookup = {};
          animations.forEach((animation, index) => {
            const { element } = animation;
            const node = element;
            const { event } = animation;
            const enterOrMove = ["enter", "move"].indexOf(event) >= 0;
            const anchorNodes = animation.structural
              ? getAnchorNodes(node)
              : [];

            if (anchorNodes.length) {
              const direction = enterOrMove ? "to" : "from";

              anchorNodes.forEach((anchor) => {
                const key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                refLookup[key] = refLookup[key] || {};
                refLookup[key][direction] = {
                  animationID: index,
                  element: anchor,
                };
              });
            } else {
              preparedAnimations.push(animation);
            }
          });

          const usedIndicesLookup = {};
          const anchorGroups = {};
          Object.values(refLookup).forEach((operations) => {
            const { from } = operations;
            const { to } = operations;

            if (!from || !to) {
              // only one of these is set therefore we can't have an
              // anchor animation since all three pieces are required
              const index = from ? from.animationID : to.animationID;
              const indexKey = index.toString();
              if (!usedIndicesLookup[indexKey]) {
                usedIndicesLookup[indexKey] = true;
                preparedAnimations.push(animations[index]);
              }
              return;
            }

            const fromAnimation = animations[from.animationID];
            const toAnimation = animations[to.animationID];
            const lookupKey = from.animationID.toString();
            if (!anchorGroups[lookupKey]) {
              const group = (anchorGroups[lookupKey] = {
                structural: true,
                beforeStart() {
                  fromAnimation.beforeStart();
                  toAnimation.beforeStart();
                },
                close() {
                  fromAnimation.close();
                  toAnimation.close();
                },
                classes: cssClassesIntersection(
                  fromAnimation.classes,
                  toAnimation.classes,
                ),
                from: fromAnimation,
                to: toAnimation,
                anchors: [], // TODO(matsko): change to reference nodes
              });

              // the anchor animations require that the from and to elements both have at least
              // one shared CSS class which effectively marries the two elements together to use
              // the same animation driver and to properly sequence the anchor animation.
              if (group.classes.length) {
                preparedAnimations.push(group);
              } else {
                preparedAnimations.push(fromAnimation);
                preparedAnimations.push(toAnimation);
              }
            }

            anchorGroups[lookupKey].anchors.push({
              out: from.element,
              in: to.element,
            });
          });

          return preparedAnimations;
        }

        function cssClassesIntersection(a, b) {
          a = a.split(" ");
          b = b.split(" ");
          const matches = [];

          for (let i = 0; i < a.length; i++) {
            const aa = a[i];
            if (aa.substring(0, 3) === "ng-") continue;

            for (let j = 0; j < b.length; j++) {
              if (aa === b[j]) {
                matches.push(aa);
                break;
              }
            }
          }

          return matches.join(" ");
        }

        function invokeFirstDriver(animationDetails) {
          // we loop in reverse order since the more general drivers (like CSS and JS)
          // may attempt more elements, but custom drivers are more particular
          for (let i = drivers.length - 1; i >= 0; i--) {
            const driverName = drivers[i];
            const factory = $injector.get(driverName);
            const driver = factory(animationDetails);
            if (driver) {
              return driver;
            }
          }
        }

        function beforeStart() {
          tempClasses =
            (tempClasses ? `${tempClasses} ` : "") + NG_ANIMATE_CLASSNAME;
          element.className += ` ${tempClasses}`;
          let prepareClassName = getCacheData(element, PREPARE_CLASSES_KEY);
          if (prepareClassName) {
            element.classList.remove(prepareClassName);
            prepareClassName = null;
          }
        }

        function updateAnimationRunners(animation, newRunner) {
          if (animation.from && animation.to) {
            update(animation.from.element);
            update(animation.to.element);
          } else {
            update(animation.element);
          }

          function update(element) {
            const runner = getRunner(element);
            if (runner) runner.setHost(newRunner);
          }
        }

        function handleDestroyedElement() {
          const runner = getRunner(element);
          if (runner && (event !== "leave" || !options.$$domOperationFired)) {
            runner.end();
          }
        }

        function close(rejected) {
          removeRunner(element);

          applyAnimationClasses(element, options);
          applyAnimationStyles(element, options);
          options.domOperation();

          if (tempClasses) {
            tempClasses
              .split(" ")
              .forEach((cls) => element.classList.remove(cls));
          }

          runner.complete(!rejected);
        }
      };
    },
  ];
}

/**
 * @typedef {Function} RafSchedulerFunction
 * @typedef {Object} RafSchedulerObject
 * @property {Function} waitUntilQuiet - Function to wait until the animation frame is quiet.
 * @typedef {RafSchedulerObject & RafSchedulerFunction} RafScheduler
 */

/**
 * Creates a requestAnimationFrame scheduler.
 */
function RafSchedulerProvider() {
  /**
   * @type {Array<Array<Function>>}
   */
  let queue = [];
  /**
   * @type {number|null}
   */
  let cancelFn = null;

  /**
   * Processes the next tick of the animation frame.
   */
  function nextTick() {
    if (!queue.length) return;

    const items = queue.shift();
    items.forEach((i) => i());

    if (!cancelFn) {
      window.requestAnimationFrame(() => {
        cancelFn = null;
        nextTick();
      });
    }
  }

  /**
   * Adds tasks to the queue and schedules the next tick.
   * @param {Array<Function>} tasks - The tasks to be added to the queue.
   */
  function scheduler(tasks) {
    // Make a copy since RAFScheduler mutates the state
    // of the passed in array variable and this would be difficult
    // to track down on the outside code
    queue = queue.concat(tasks);
    nextTick();
  }

  queue = scheduler.queue = [];

  /**
   * Waits until the animation frame is quiet before running the provided function.
   * Cancels any previous animation frame requests.
   * @param {Function} fn - The function to run when the animation frame is quiet.
   */
  scheduler.waitUntilQuiet = (fn) => {
    if (cancelFn !== null) {
      window.cancelAnimationFrame(cancelFn);
      cancelFn = null;
    }

    cancelFn = window.requestAnimationFrame(() => {
      cancelFn = null;
      fn();
      nextTick();
    });
  };

  /**
   * @returns {RafScheduler} The scheduler object.
   */
  this.$get = function () {
    return scheduler;
  };
}

const KEY = "$animId";
let parentCounter = 0;
const cache = new Map();

function animateCache() {
  return {
    /**
     * Generates a unique cache key based on the node's parent and other parameters.
     * @param {HTMLElement} node - The DOM node to generate the cache key for.
     * @param {string} method - The animation method being applied.
     * @param {string} [addClass] - Class to add during the animation.
     * @param {string} [removeClass] - Class to remove during the animation.
     * @returns {string} - The generated cache key.
     */
    cacheKey(node, method, addClass, removeClass) {
      const { parentNode } = node;
      const parentID = parentNode[KEY] ?? (parentNode[KEY] = ++parentCounter);
      const parts = [parentID, method, node.getAttribute("class")];
      if (addClass) parts.push(addClass);
      if (removeClass) parts.push(removeClass);
      return parts.join(" ");
    },

    /**
     * Checks if a cached animation without a duration exists.
     * @param {string} key - The cache key to check.
     * @returns {boolean} - True if an invalid animation is cached, false otherwise.
     */
    containsCachedAnimationWithoutDuration(key) {
      const entry = cache.get(key);
      return entry ? !entry.isValid : false;
    },

    /**
     * Clears the cache.
     * @returns {void}
     */
    flush() {
      cache.clear();
    },

    /**
     * Gets the count of a specific cache entry.
     * @param {string} key - The cache key to count.
     * @returns {number} - The count of the cache entry.
     */
    count(key) {
      return cache.get(key)?.total ?? 0;
    },

    /**
     * Retrieves a value associated with a specific cache key.
     * @param {string} key - The cache key to retrieve.
     * @returns {any} - The value associated with the cache key.
     */
    get(key) {
      return cache.get(key)?.value;
    },

    /**
     * Adds or updates a cache entry.
     * @param {string} key - The cache key to add or update.
     * @param {any} value - The value to store.
     * @param {boolean} isValid - Whether the cache entry is valid.
     */
    put(key, value, isValid) {
      const entry = cache.get(key);
      if (entry) {
        entry.total++;
        entry.value = value;
      } else {
        cache.set(key, { total: 1, value, isValid });
      }
    },
  };
}

function AnimateCacheProvider() {
  this.$get = [animateCache];
}

const NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim";
const NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor";

const NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out";
const NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";

AnimateCssDriverProvider.$inject = ["$$animationProvider"];
function AnimateCssDriverProvider($$animationProvider) {
  $$animationProvider.drivers.push("$$animateCssDriver");

  function isDocumentFragment(node) {
    return node.parentNode && node.parentNode.nodeType === 11;
  }

  /**
   * @returns {Function}
   */
  this.$get = [
    "$animateCss",
    "$$AnimateRunner",
    "$rootElement",
    /**
     *
     * @param {*} $animateCss
     * @param {typeof import('./animate-runner.js').AnimateRunner} $$AnimateRunner
     * @param {Element} $rootElement
     * @returns
     */
    function ($animateCss, $$AnimateRunner, $rootElement) {
      const bodyNode = document.body;
      const rootNode = $rootElement;

      const rootBodyElement =
        // this is to avoid using something that exists outside of the body
        // we also special case the doc fragment case because our unit test code
        // appends the $rootElement to the body after the app has been bootstrapped
        isDocumentFragment(rootNode) || bodyNode.contains(rootNode)
          ? rootNode
          : bodyNode;

      return function initDriverFn(animationDetails) {
        return animationDetails.from && animationDetails.to
          ? prepareFromToAnchorAnimation(
              animationDetails.from,
              animationDetails.to,
              animationDetails.anchors,
            )
          : prepareRegularAnimation(animationDetails);
      };

      function prepareAnchoredAnimation(outAnchor, inAnchor) {
        const clone = outAnchor.cloneNode(true);
        const startingClasses = filterCssClasses(getClassVal(clone));

        outAnchor[0].classList.add(NG_ANIMATE_SHIM_CLASS_NAME);
        inAnchor[0].classList.add(NG_ANIMATE_SHIM_CLASS_NAME);

        clone.classList.add(NG_ANIMATE_ANCHOR_CLASS_NAME);

        rootBodyElement.append(clone);

        let animatorIn;
        const animatorOut = prepareOutAnimation();

        // the user may not end up using the `out` animation and
        // only making use of the `in` animation or vice-versa.
        // In either case we should allow this and not assume the
        // animation is over unless both animations are not used.
        if (!animatorOut) {
          animatorIn = prepareInAnimation();
          if (!animatorIn) {
            return end();
          }
        }

        const startingAnimator = animatorOut || animatorIn;

        return {
          start() {
            let runner;

            let currentAnimation = startingAnimator.start();
            currentAnimation.done(() => {
              currentAnimation = null;
              if (!animatorIn) {
                animatorIn = prepareInAnimation();
                if (animatorIn) {
                  currentAnimation = animatorIn.start();
                  currentAnimation.done(() => {
                    currentAnimation = null;
                    end();
                    runner.complete();
                  });
                  return currentAnimation;
                }
              }
              // in the event that there is no `in` animation
              end();
              runner.complete();
            });

            runner = new $$AnimateRunner({
              end: endFn,
              cancel: endFn,
            });

            return runner;

            function endFn() {
              if (currentAnimation) {
                currentAnimation.end();
              }
            }
          },
        };

        function calculateAnchorStyles(anchor) {
          const styles = {};

          const coords = anchor.getBoundingClientRect();

          // we iterate directly since safari messes up and doesn't return
          // all the keys for the coords object when iterated
          ["width", "height", "top", "left"].forEach((key) => {
            let value = coords[key];
            switch (key) {
              case "top":
                value += bodyNode.scrollTop;
                break;
              case "left":
                value += bodyNode.scrollLeft;
                break;
            }
            styles[key] = `${Math.floor(value)}px`;
          });
          return styles;
        }

        function prepareOutAnimation() {
          const animator = $animateCss(clone, {
            addClass: NG_OUT_ANCHOR_CLASS_NAME,
            delay: true,
            from: calculateAnchorStyles(outAnchor),
          });

          // read the comment within `prepareRegularAnimation` to understand
          // why this check is necessary
          return animator.$$willAnimate ? animator : null;
        }

        function getClassVal(element) {
          return element.getAttribute("class") || "";
        }

        function prepareInAnimation() {
          const endingClasses = filterCssClasses(getClassVal(inAnchor));
          const toAdd = getUniqueValues(endingClasses, startingClasses);
          const toRemove = getUniqueValues(startingClasses, endingClasses);

          const animator = $animateCss(clone, {
            to: calculateAnchorStyles(inAnchor),
            addClass: `${NG_IN_ANCHOR_CLASS_NAME} ${toAdd}`,
            removeClass: `${NG_OUT_ANCHOR_CLASS_NAME} ${toRemove}`,
            delay: true,
          });

          // read the comment within `prepareRegularAnimation` to understand
          // why this check is necessary
          return animator.$$willAnimate ? animator : null;
        }

        function end() {
          clone.remove();
          outAnchor[0].classList.remove(NG_ANIMATE_SHIM_CLASS_NAME);
          inAnchor[0].classList.remove(NG_ANIMATE_SHIM_CLASS_NAME);
        }
      }

      function prepareFromToAnchorAnimation(from, to, anchors) {
        const fromAnimation = prepareRegularAnimation(from);
        const toAnimation = prepareRegularAnimation(to);

        const anchorAnimations = [];
        anchors.forEach((anchor) => {
          const outElement = anchor.out;
          const inElement = anchor.in;
          const animator = prepareAnchoredAnimation(outElement, inElement);
          if (animator) {
            anchorAnimations.push(animator);
          }
        });

        // no point in doing anything when there are no elements to animate
        if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
          return;

        return {
          start() {
            const animationRunners = [];

            if (fromAnimation) {
              animationRunners.push(fromAnimation.start());
            }

            if (toAnimation) {
              animationRunners.push(toAnimation.start());
            }

            anchorAnimations.forEach((animation) => {
              animationRunners.push(animation.start());
            });

            const runner = new $$AnimateRunner({
              end: endFn,
              cancel: endFn, // CSS-driven animations cannot be cancelled, only ended
            });

            $$AnimateRunner.all(animationRunners, (status) => {
              runner.complete(status);
            });

            return runner;

            function endFn() {
              animationRunners.forEach((runner) => {
                runner.end();
              });
            }
          },
        };
      }

      function prepareRegularAnimation(animationDetails) {
        const options = animationDetails.options || {};

        if (animationDetails.structural) {
          options.event = animationDetails.event;
          options.structural = true;
          options.applyClassesEarly = true;

          // we special case the leave animation since we want to ensure that
          // the element is removed as soon as the animation is over. Otherwise
          // a flicker might appear or the element may not be removed at all
          if (animationDetails.event === "leave") {
            options.onDone = options.domOperation;
          }
        }

        // We assign the preparationClasses as the actual animation event since
        // the internals of $animateCss will just suffix the event token values
        // with `-active` to trigger the animation.
        if (options.preparationClasses) {
          options.event = concatWithSpace(
            options.event,
            options.preparationClasses,
          );
        }

        const animator = $animateCss(animationDetails.element, options);

        // the driver lookup code inside of $$animation attempts to spawn a
        // driver one by one until a driver returns a.$$willAnimate animator object.
        // $animateCss will always return an object, however, it will pass in
        // a flag as a hint as to whether an animation was detected or not

        return animator.$$willAnimate ? animator : null;
      }
    },
  ];
}

function filterCssClasses(classes) {
  // remove all the `ng-` stuff
  return classes.replace(/\bng-\S+\b/g, "");
}

function getUniqueValues(a, b) {
  if (isString(a)) a = a.split(" ");
  if (isString(b)) b = b.split(" ");
  return a.filter((val) => b.indexOf(val) === -1).join(" ");
}

AnimateJsDriverProvider.$inject = ["$$animationProvider"];
function AnimateJsDriverProvider($$animationProvider) {
  $$animationProvider.drivers.push("$$animateJsDriver");
  this.$get = [
    "$$animateJs",
    "$$AnimateRunner",
    function ($$animateJs, $$AnimateRunner) {
      return function initDriverFn(animationDetails) {
        if (animationDetails.from && animationDetails.to) {
          const fromAnimation = prepareAnimation(animationDetails.from);
          const toAnimation = prepareAnimation(animationDetails.to);
          if (!fromAnimation && !toAnimation) return;

          return {
            start() {
              const animationRunners = [];

              if (fromAnimation) {
                animationRunners.push(fromAnimation.start());
              }

              if (toAnimation) {
                animationRunners.push(toAnimation.start());
              }

              $$AnimateRunner.all(animationRunners, done);

              const runner = new $$AnimateRunner({
                end: endFnFactory(),
                cancel: endFnFactory(),
              });

              return runner;

              function endFnFactory() {
                return function () {
                  animationRunners.forEach((runner) => {
                    // at this point we cannot cancel animations for groups just yet. 1.5+
                    runner.end();
                  });
                };
              }

              function done(status) {
                runner.complete(status);
              }
            },
          };
        }
        return prepareAnimation(animationDetails);
      };

      function prepareAnimation(animationDetails) {
        // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations
        const { element, event, options, classes } = animationDetails;
        return $$animateJs(element, event, classes, options);
      }
    },
  ];
}

ngAnimateSwapDirective.$inject = ["$animate"];
/**
 * @returns {import('../types.js').Directive}
 */
function ngAnimateSwapDirective($animate) {
  return {
    restrict: "A",
    transclude: "element",
    terminal: true,
    priority: 550, // We use 550 here to ensure that the directive is caught before others,
    // but after `ngIf` (at priority 600).
    link(scope, $element, attrs, ctrl, $transclude) {
      let previousElement;
      let previousScope;
      scope.$watchCollection(attrs.ngAnimateSwap || attrs.for, (value) => {
        if (previousElement) {
          $animate.leave(previousElement);
        }
        if (previousScope) {
          previousScope.$destroy();
          previousScope = null;
        }
        if (value) {
          $transclude((clone, childScope) => {
            previousElement = clone;
            previousScope = childScope;
            $animate.enter(clone, null, $element);
          });
        }
      });
    },
  };
}

$$AnimateChildrenDirective.$inject = ["$interpolate"];

/**
 * @param {*} $interpolate
 * @returns {import("../types").Directive}
 */
function $$AnimateChildrenDirective($interpolate) {
  return {
    link(scope, element, attrs) {
      const val = attrs.ngAnimateChildren;
      if (isString(val) && val.length === 0) {
        // empty attribute
        setCacheData(element, NG_ANIMATE_CHILDREN_DATA, true);
      } else {
        // Interpolate and set the value, so that it is available to
        // animations that run right after compilation
        setData($interpolate(val)(scope));
        attrs.$observe("ngAnimateChildren", setData);
      }

      function setData(value) {
        value = value === "on" || value === "true";
        setCacheData(element, NG_ANIMATE_CHILDREN_DATA, value);
      }
    },
  };
}

/**
 * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.
 *
 * Given a function with N parameters, returns a new function that supports partial application.
 * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,
 * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to
 * accept more parameters until all N parameters have been supplied.
 *
 *
 * This contrived example uses a partially applied function as an predicate, which returns true
 * if an object is found in both arrays.
 * @example
 * ```
 * // returns true if an object is in both of the two arrays
 * function inBoth(array1, array2, object) {
 *   return array1.indexOf(object) !== -1 &&
 *          array2.indexOf(object) !== 1;
 * }
 * let obj1, obj2, obj3, obj4, obj5, obj6, obj7
 * let foos = [obj1, obj3]
 * let bars = [obj3, obj4, obj5]
 *
 * // A curried "copy" of inBoth
 * let curriedInBoth = curry(inBoth);
 * // Partially apply both the array1 and array2
 * let inFoosAndBars = curriedInBoth(foos, bars);
 *
 * // Supply the final argument; since all arguments are
 * // supplied, the original inBoth function is then called.
 * let obj1InBoth = inFoosAndBars(obj1); // false
 *
 * // Use the inFoosAndBars as a predicate.
 * // Filter, on each iteration, supplies the final argument
 * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];
 * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]
 *
 * ```
 *
 * @param fn
 * @returns {*|function(): (*|any)}
 */
function curry(fn) {
  return function curried() {
    if (arguments.length >= fn.length) {
      return fn.apply(this, arguments);
    }
    const args = Array.prototype.slice.call(arguments);
    return curried.bind(this, ...args);
  };
}
/**
 * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left
 * given: f(x), g(x), h(x)
 * let composed = compose(f,g,h)
 * then, composed is: f(g(h(x)))
 */
function compose() {
  const args = arguments;
  const start = args.length - 1;
  return function () {
    let i = start,
      result = args[start].apply(this, arguments);
    while (i--) result = args[i].call(this, result);
    return result;
  };
}
/**
 * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right
 * given: f(x), g(x), h(x)
 * let piped = pipe(f,g,h);
 * then, piped is: h(g(f(x)))
 */
function pipe() {
  return compose.apply(null, [].slice.call(arguments).reverse());
}

/**
 * Given a property name and a value, returns a function that returns a boolean based on whether
 * the passed object has a property that matches the value
 * let obj = { foo: 1, name: "blarg" };
 * let getName = propEq("name", "blarg");
 * getName(obj) === true
 */
const propEq = curry((name, _val, obj) => obj && obj[name] === _val);
/**
 * Given a dotted property name, returns a function that returns a nested property from an object, or undefined
 * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };
 * let getName = prop("nestedObj.name");
 * getName(obj) === "blarg"
 * let propNotFound = prop("this.property.doesnt.exist");
 * propNotFound(obj) === undefined
 */
const parse = (name) =>
  pipe.apply(
    null,
    name.split(".").map((name) => (obj) => obj && obj[name]),
  );

/**
 * Given two functions that return truthy or falsey values, returns a function that returns truthy
 * if at least one of the functions returns truthy for the given arguments
 */
function or(fn1, fn2) {
  return (...args) => fn1.apply(null, args) || fn2.apply(null, args);
}
/**
 * Check if all the elements of an array match a predicate function
 *
 * @param fn1 a predicate function `fn1`
 * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array
 */
const all = (fn1) => (arr) => arr.reduce((b, x) => b && !!fn1(x), true);
/** Given a class, returns a Predicate function that returns true if the object is of that class */
const is = (ctor) => (obj) =>
  (obj != null && obj.constructor === ctor) || obj instanceof ctor;

/** Given a value, returns a function which returns the value */
const val = (v) => () => v;
/**
 * Sorta like Pattern Matching (a functional programming conditional construct)
 *
 * See http://c2.com/cgi/wiki?PatternMatching
 *
 * This is a conditional construct which allows a series of predicates and output functions
 * to be checked and then applied.  Each predicate receives the input.  If the predicate
 * returns truthy, then its matching output function (mapping function) is provided with
 * the input and, then the result is returned.
 *
 * Each combination (2-tuple) of predicate + output function should be placed in an array
 * of size 2: [ predicate, mapFn ]
 *
 * These 2-tuples should be put in an outer array.
 *
 * @example
 * ```
 *
 * // Here's a 2-tuple where the first element is the isString predicate
 * // and the second element is a function that returns a description of the input
 * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];
 *
 * // Second tuple: predicate "isNumber", mapfn returns a description
 * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];
 *
 * let third = [ (input) => input === null,  (input) => `Oh, null...` ];
 *
 * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];
 *
 * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);
 *
 * console.log(descriptionOf(undefined)); // 'notdefined'
 * console.log(descriptionOf(55)); // '(55) That's a number!'
 * console.log(descriptionOf("foo")); // 'Here's your string foo'
 * ```
 *
 * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,
 * with a Predicate and a mapping/output function
 * @returns {function(any): *}
 */
function pattern(struct) {
  return function (x) {
    for (let i = 0; i < struct.length; i++) {
      if (struct[i][0](x)) return struct[i][1](x);
    }
  };
}

function equals(o1, o2) {
  if (o1 === o2) return true;
  if (o1 === null || o2 === null) return false;
  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
  const t1 = typeof o1,
    t2 = typeof o2;
  if (t1 !== t2 || t1 !== "object") return false;
  const tup = [o1, o2];
  if (all(Array.isArray)(tup)) return _arraysEq(o1, o2);
  if (all(isDate)(tup)) return o1.getTime() === o2.getTime();
  if (all(isRegExp)(tup)) return o1.toString() === o2.toString();
  if (all(isFunction)(tup)) return true; // meh
  if ([isFunction, Array.isArray, isDate, isRegExp].some((fn) => !!fn(tup))) {
    return false;
  }
  const keys = {};

  for (const key in o1) {
    if (!equals(o1[key], o2[key])) return false;
    keys[key] = true;
  }
  for (const key in o2) {
    if (!keys[key]) return false;
  }
  return true;
}
/**
 * Builds proxy functions on the `to` object which pass through to the `from` object.
 *
 * For each key in `fnNames`, creates a proxy function on the `to` object.
 * The proxy function calls the real function on the `from` object.
 *
 *
 * #### Example:
 * This example creates an new class instance whose functions are prebound to the new'd object.
 * ```js
 * class Foo {
 *   constructor(data) {
 *     // Binds all functions from Foo.prototype to 'this',
 *     // then copies them to 'this'
 *     bindFunctions(Foo.prototype, this, this);
 *     this.data = data;
 *   }
 *
 *   log() {
 *     console.log(this.data);
 *   }
 * }
 *
 * let myFoo = new Foo([1,2,3]);
 * var logit = myFoo.log;
 * logit(); // logs [1, 2, 3] from the myFoo 'this' instance
 * ```
 *
 * #### Example:
 * This example creates a bound version of a service function, and copies it to another object
 * ```
 *
 * var SomeService = {
 *   this.data = [3, 4, 5];
 *   this.log = function() {
 *     console.log(this.data);
 *   }
 * }
 *
 * // Constructor fn
 * function OtherThing() {
 *   // Binds all functions from SomeService to SomeService,
 *   // then copies them to 'this'
 *   bindFunctions(SomeService, this, SomeService);
 * }
 *
 * let myOtherThing = new OtherThing();
 * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'
 * ```
 *
 * @param source A function that returns the source object which contains the original functions to be bound
 * @param target A function that returns the target object which will receive the bound functions
 * @param bind A function that returns the object which the functions will be bound to
 * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)
 * @param latebind If true, the binding of the function is delayed until the first time it's invoked
 */
function createProxyFunctions(
  source,
  target,
  bind,
  fnNames,
  latebind = false,
) {
  const bindFunction = (fnName) => source()[fnName].bind(bind());
  const makeLateRebindFn = (fnName) =>
    function lateRebindFunction() {
      target[fnName] = bindFunction(fnName);
      return target[fnName].apply(null, arguments);
    };
  fnNames = fnNames || Object.keys(source());
  return fnNames.reduce((acc, name) => {
    acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);
    return acc;
  }, target);
}
/**
 * prototypal inheritance helper.
 * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it
 */

/**
 * prototypal inheritance helper.
 * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it.
 *
 * @param {Object} parent - The object to be used as the prototype.
 * @param {Object} [extra] - The object containing additional properties to be copied.
 * @returns {Object} - A new object with `parent` as its prototype and properties from `extra`.
 */
function inherit(parent, extra) {
  const newObj = Object.create(parent);
  if (extra) {
    Object.assign(newObj, extra);
  }
  return newObj;
}

/**
 * Given an array, and an item, if the item is found in the array, it removes it (in-place).
 * The same array is returned
 */
const removeFrom = curry(_removeFrom);
function _removeFrom(array, obj) {
  const idx = array.indexOf(obj);
  if (idx >= 0) array.splice(idx, 1);
  return array;
}
/** pushes a values to an array and returns the value */
const pushTo = curry((arr, val) => {
  arr.push(val);
  return val;
});
/**
 * Applies a set of defaults to an options object.  The options object is filtered
 * to only those properties of the objects in the defaultsList.
 * Earlier objects in the defaultsList take precedence when applying defaults.
 */
function defaults(opts, ...defaultsList) {
  const defaultVals = Object.assign({}, ...defaultsList.reverse());
  return Object.assign(defaultVals, pick(opts || {}, Object.keys(defaultVals)));
}

/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
  const path = [];
  for (const n in first.path) {
    if (first.path[n] !== second.path[n]) break;
    path.push(first.path[n]);
  }
  return path;
}
/**
 * Return a copy of the object only containing the whitelisted properties.
 *
 * #### Example:
 * ```
 * var foo = { a: 1, b: 2, c: 3 };
 * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }
 * ```
 * @param obj the source object
 * @param propNames an Array of strings, which are the whitelisted property names
 */
function pick(obj, propNames) {
  const objCopy = {};
  for (const _prop in obj) {
    if (propNames.indexOf(_prop) !== -1) {
      objCopy[_prop] = obj[_prop];
    }
  }
  return objCopy;
}
/**
 * Return a copy of the object omitting the blacklisted properties.
 *
 * @example
 * ```
 *
 * var foo = { a: 1, b: 2, c: 3 };
 * var ab = omit(foo, ['a', 'b']); // { c: 3 }
 * ```
 * @param obj the source object
 * @param propNames an Array of strings, which are the blacklisted property names
 */
function omit(obj, propNames) {
  return Object.keys(obj)
    .filter((x) => !propNames.includes(x))
    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});
}

/** Filters an Array or an Object's properties based on a predicate */
function filter(collection, callback) {
  const arr = Array.isArray(collection),
    result = arr ? [] : {};
  const accept = arr ? (x) => result.push(x) : (x, key) => (result[key] = x);
  Object.entries(collection).forEach(([i, item]) => {
    if (callback(item, i)) accept(item, i);
  });
  return result;
}

/** Finds an object from an array, or a property of an object, that matches a predicate */
function find(collection, callback) {
  let result;
  Object.entries(collection).forEach(([i, item]) => {
    if (result) return;
    if (callback(item, i)) result = item;
  });
  return result;
}

/** Maps an array or object properties using a callback function */
function map(collection, callback, target) {
  target = target || (Array.isArray(collection) ? [] : {});
  Object.entries(collection).forEach(
    ([i, item]) => (target[i] = callback(item, i)),
  );
  return target;
}

/**
 * Reduce function that returns true if all of the values are truthy.
 *
 * @example
 * ```
 *
 * let vals = [ 1, true, {}, "hello world"];
 * vals.reduce(allTrueR, true); // true
 *
 * vals.push(0);
 * vals.reduce(allTrueR, true); // false
 * ```
 */
const allTrueR = (memo, elem) => memo && elem;
/**
 * Reduce function that returns true if any of the values are truthy.
 *
 *  * @example
 * ```
 *
 * let vals = [ 0, null, undefined ];
 * vals.reduce(anyTrueR, true); // false
 *
 * vals.push("hello world");
 * vals.reduce(anyTrueR, true); // true
 * ```
 */
const anyTrueR = (memo, elem) => memo || elem;
/**
 * Reduce function which un-nests a single level of arrays
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * input.reduce(unnestR, []) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
 * ```
 */
const unnestR = (memo, elem) => memo.concat(elem);
/**
 * Reduce function which recursively un-nests all arrays
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * input.reduce(unnestR, []) // [ "a", "b", "c", "d", "double, "nested" ]
 * ```
 */
const flattenR = (memo, elem) =>
  Array.isArray(elem)
    ? memo.concat(elem.reduce(flattenR, []))
    : pushR(memo, elem);
/**
 * Reduce function that pushes an object to an array, then returns the array.
 * Mostly just for [[flattenR]] and [[uniqR]]
 */
function pushR(arr, obj) {
  arr.push(obj);
  return arr;
}
/** Reduce function that filters out duplicates */
const uniqR = (acc, token) =>
  acc.includes(token) ? acc : pushR(acc, token);
/**
 * Return a new array with a single level of arrays unnested.
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * unnest(input) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
 * ```
 */
const unnest = (arr) => arr.reduce(unnestR, []);
/**
 * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.
 * @example
 * ```
 *
 * let isNumber = (obj) => typeof(obj) === 'number';
 * let allNumbers = [ 1, 2, 3, 4, 5 ];
 * allNumbers.filter(assertPredicate(isNumber)); //OK
 *
 * let oneString = [ 1, 2, 3, 4, "5" ];
 * oneString.filter(assertPredicate(isNumber, "Not all numbers")); // throws Error(""Not all numbers"");
 * ```
 */
const assertPredicate = assertFn;
function assertFn(predicateOrMap, errMsg = "assert failure") {
  return (obj) => {
    const result = predicateOrMap(obj);
    if (!result) {
      throw new Error(errMsg);
    }
    return result;
  };
}
/**
 * Given two or more parallel arrays, returns an array of tuples where
 * each tuple is composed of [ a[i], b[i], ... z[i] ]
 *
 * @example
 * ```
 *
 * let foo = [ 0, 2, 4, 6 ];
 * let bar = [ 1, 3, 5, 7 ];
 * let baz = [ 10, 30, 50, 70 ];
 * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]
 * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]
 * ```
 */
function arrayTuples(...args) {
  if (args.length === 0) return [];
  const maxArrayLen = args.reduce(
    (min, arr) => Math.min(arr.length, min),
    9007199254740991,
  ); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER
  const result = [];
  for (let i = 0; i < maxArrayLen; i++) {
    // This is a hot function
    // Unroll when there are 1-4 arguments
    switch (args.length) {
      case 1:
        result.push([args[0][i]]);
        break;
      case 2:
        result.push([args[0][i], args[1][i]]);
        break;
      case 3:
        result.push([args[0][i], args[1][i], args[2][i]]);
        break;
      case 4:
        result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);
        break;
      default:
        result.push(args.map((array) => array[i]));
        break;
    }
  }
  return result;
}
/**
 * Reduce function which builds an object from an array of [key, value] pairs.
 *
 * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.
 *
 * Each keyValueTuple should be an array with values [ key: string, value: any ]
 *
 * @example
 * ```
 *
 * var pairs = [ ["fookey", "fooval"], ["barkey", "barval"] ]
 *
 * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})
 * // pairsToObj == { fookey: "fooval", barkey: "barval" }
 *
 * // Or, more simply:
 * var pairsToObj = pairs.reduce(applyPairs, {})
 * // pairsToObj == { fookey: "fooval", barkey: "barval" }
 * ```
 */
function applyPairs(memo, keyValTuple) {
  let key, value;
  if (Array.isArray(keyValTuple)) [key, value] = keyValTuple;
  if (!isString(key)) throw new Error("invalid parameters to applyPairs");
  memo[key] = value;
  return memo;
}
/** Get the last element of an array */
function tail(arr) {
  return (arr.length && arr[arr.length - 1]) || undefined;
}
/**
 * shallow copy from src to dest
 */
function copy(src, dest) {
  if (dest) Object.keys(dest).forEach((key) => delete dest[key]);
  if (!dest) dest = {};
  return Object.assign(dest, src);
}

function _arraysEq(a1, a2) {
  if (a1.length !== a2.length) return false;
  return arrayTuples(a1, a2).reduce((b, t) => b && equals(t[0], t[1]), true);
}
// issue #2676
const silenceUncaughtInPromise = (promise) =>
  promise.catch(() => 0) && promise;
const silentRejection = (error) =>
  silenceUncaughtInPromise(Promise.reject(error));

/**
 * An internal class which implements [[ParamTypeDefinition]].
 *
 * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.
 * When a param type definition is registered, an instance of this class is created internally.
 *
 * This class has naive implementations for all the [[ParamTypeDefinition]] methods.
 *
 * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.
 *
 * #### Example:
 * ```js
 * var paramTypeDef = {
 *   decode: function(val) { return parseInt(val, 10); },
 *   encode: function(val) { return val && val.toString(); },
 *   equals: function(a, b) { return this.is(a) && a === b; },
 *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },
 *   pattern: /\d+/
 * }
 *
 * var paramType = new ParamType(paramTypeDef);
 * ```
 */
class ParamType {
  /**
   * @param def  A configuration object which contains the custom type definition.  The object's
   *        properties will override the default methods and/or pattern in `ParamType`'s public interface.
   * @returns a new ParamType object
   */
  constructor(def) {
    this.pattern = /.*/;
    this.inherit = true;
    Object.assign(this, def);
    this.name = undefined;
  }
  // consider these four methods to be "abstract methods" that should be overridden

  is(val) {
    return !!val;
  }
  encode(val) {
    return val;
  }
  decode(val) {
    return val;
  }
  equals(a, b) {
    return a == b;
  }
  $subPattern() {
    const sub = this.pattern.toString();
    return sub.substring(1, sub.length - 2);
  }
  toString() {
    return `{ParamType:${this.name}}`;
  }
  /** Given an encoded string, or a decoded object, returns a decoded object */
  $normalize(val) {
    return this.is(val) ? val : this.decode(val);
  }
  /**
   * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.
   * e.g.:
   * - urlmatcher pattern "/path?{queryParam[]:int}"
   * - url: "/path?queryParam=1&queryParam=2
   * - $stateParams.queryParam will be [1, 2]
   * if `mode` is "auto", then
   * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
   * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
   */
  $asArray(mode, isSearch) {
    if (!mode) return this;
    if (mode === "auto" && !isSearch)
      throw new Error("'auto' array mode is for query parameters only");
    return new ArrayType(this, mode);
  }
}
/** Wraps up a `ParamType` object to handle array values. */
function ArrayType(type, mode) {
  // Wrap non-array value as array
  function arrayWrap(val) {
    return Array.isArray(val) ? val : isDefined(val) ? [val] : [];
  }
  // Unwrap array value for "auto" mode. Return undefined for empty array.
  function arrayUnwrap(val) {
    switch (val.length) {
      case 0:
        return undefined;
      case 1:
        return mode === "auto" ? val[0] : val;
      default:
        return val;
    }
  }
  // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
  function arrayHandler(callback, allTruthyMode) {
    return function handleArray(val) {
      if (Array.isArray(val) && val.length === 0) return val;
      const arr = arrayWrap(val);
      const result = map(arr, callback);
      return allTruthyMode === true
        ? filter(result, (x) => !x).length === 0
        : arrayUnwrap(result);
    };
  }
  // Wraps type (.equals) functions to operate on each value of an array
  function arrayEqualsHandler(callback) {
    return function handleArray(val1, val2) {
      const left = arrayWrap(val1),
        right = arrayWrap(val2);
      if (left.length !== right.length) return false;
      for (let i = 0; i < left.length; i++) {
        if (!callback(left[i], right[i])) return false;
      }
      return true;
    };
  }
  ["encode", "decode", "equals", "$normalize"].forEach((name) => {
    const paramTypeFn = type[name].bind(type);
    const wrapperFn = name === "equals" ? arrayEqualsHandler : arrayHandler;
    this[name] = wrapperFn(paramTypeFn);
  });
  Object.assign(this, {
    dynamic: type.dynamic,
    name: type.name,
    pattern: type.pattern,
    inherit: type.inherit,
    raw: type.raw,
    is: arrayHandler(type.is.bind(type), true),
    $arrayMode: mode,
  });
}

/**
 * A registry for parameter types.
 *
 * This registry manages the built-in (and custom) parameter types.
 *
 * The built-in parameter types are:
 *
 * - [[string]]
 * - [[path]]
 * - [[query]]
 * - [[hash]]
 * - [[int]]
 * - [[bool]]
 * - [[date]]
 * - [[json]]
 * - [[any]]
 *
 * To register custom parameter types, use [[UrlConfig.type]], i.e.,
 *
 * ```js
 * router.urlService.config.type(customType)
 * ```
 */
class ParamTypes {
  constructor() {
    this.enqueue = true;
    this.typeQueue = [];
    this.defaultTypes = pick(ParamTypes.prototype, [
      "hash",
      "string",
      "query",
      "path",
      "int",
      "bool",
      "date",
      "json",
      "any",
    ]);
    // Register default types. Store them in the prototype of this.types.
    const makeType = (definition, name) =>
      new ParamType(Object.assign({ name }, definition));
    this.types = inherit(map(this.defaultTypes, makeType), {});
  }
  /**
   * Registers a parameter type
   *
   * End users should call [[UrlMatcherFactory.type]], which delegates to this method.
   */
  type(name, definition, definitionFn) {
    if (!isDefined(definition)) return this.types[name];
    if (Object.prototype.hasOwnProperty.call(this.types, name))
      throw new Error(`A type named '${name}' has already been defined.`);
    this.types[name] = new ParamType(Object.assign({ name }, definition));
    if (definitionFn) {
      this.typeQueue.push({ name, def: definitionFn });
      if (!this.enqueue) this._flushTypeQueue();
    }
    return this;
  }
  _flushTypeQueue() {
    while (this.typeQueue.length) {
      const type = this.typeQueue.shift();
      if (type.pattern)
        throw new Error("You cannot override a type's .pattern at runtime.");
      Object.assign(
        this.types[type.name],
        window.angular.$injector.invoke(type.def),
      );
    }
  }
}
function initDefaultTypes() {
  const makeDefaultType = (def) => {
    const valToString = (val) => (val != null ? val.toString() : val);
    const defaultTypeBase = {
      encode: valToString,
      decode: valToString,
      is: is(String),
      pattern: /.*/,

      equals: (a, b) => a == b, // allow coersion for null/undefined/""
    };
    return Object.assign({}, defaultTypeBase, def);
  };
  // Default Parameter Type Definitions
  Object.assign(ParamTypes.prototype, {
    string: makeDefaultType({}),
    path: makeDefaultType({
      pattern: /[^/]*/,
    }),
    query: makeDefaultType({}),
    hash: makeDefaultType({
      inherit: false,
    }),
    int: makeDefaultType({
      decode: (val) => parseInt(val, 10),
      is: function (val) {
        return !isNullOrUndefined(val) && this.decode(val.toString()) === val;
      },
      pattern: /-?\d+/,
    }),
    bool: makeDefaultType({
      encode: (val) => (val && 1) || 0,
      decode: (val) => parseInt(val, 10) !== 0,
      is: is(Boolean),
      pattern: /[01]/,
    }),
    date: makeDefaultType({
      encode: function (val) {
        return !this.is(val)
          ? undefined
          : [
              val.getFullYear(),
              ("0" + (val.getMonth() + 1)).slice(-2),
              ("0" + val.getDate()).slice(-2),
            ].join("-");
      },
      decode: function (val) {
        if (this.is(val)) return val;
        const match = this.capture.exec(val);
        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
      },
      is: (val) => val instanceof Date && !isNaN(val.valueOf()),
      equals(l, r) {
        return ["getFullYear", "getMonth", "getDate"].reduce(
          (acc, fn) => acc && l[fn]() === r[fn](),
          true,
        );
      },
      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,
    }),
    json: makeDefaultType({
      encode: JSON.stringify,
      decode: JSON.parse,
      is: is(Object),
      equals: equals,
      pattern: /[^/]*/,
    }),
    // does not encode/decode
    any: makeDefaultType({
      encode: (x) => x,
      decode: (x) => x,
      is: () => true,
      equals: equals,
    }),
  });
}
initDefaultTypes();

/**
 * An API to customize the URL behavior and retrieve URL configuration
 *
 * This API is used to customize the behavior of the URL.
 * This includes optional trailing slashes ([[strictMode]]), case sensitivity ([[caseInsensitive]]),
 * and custom parameter encoding (custom [[type]]).
 *
 * It also has information about the location (url) configuration such as [[port]] and [[baseHref]].
 * This information can be used to build absolute URLs, such as
 * `https://example.com:443/basepath/state/substate?param1=a#hashvalue`;
 *
 * This API is found at `router.urlService.config` (see: [[UIRouter.urlService]], [[URLService.config]])
 */
class UrlConfigProvider {
  constructor() {
    /** @type {ParamTypes} */
    this.paramTypes = new ParamTypes();
    /** @type {boolean} */
    this._isCaseInsensitive = false;
    /** @type {boolean} */
    this._isStrictMode = true;
    /** @type {boolean} */
    this._defaultSquashPolicy = false;
    /**
     * Applys ng1-specific path parameter encoding
     *
     * The Angular 1 `$location` service is a bit weird.
     * It doesn't allow slashes to be encoded/decoded bi-directionally.
     *
     * See the writeup at https://github.com/angular-ui/ng-router/issues/2598
     *
     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F
     *
     */
    const pathType = this.type("path");
    pathType.encode = (x) =>
      x != null
        ? x
            .toString()
            .replace(/([~\/])/g, (m) => ({ "~": "~~", "/": "~2F" })[m])
        : x;
    pathType.decode = (x) =>
      x != null
        ? x
            .toString()
            .replace(/(~~|~2F)/g, (m) => ({ "~~": "~", "~2F": "/" })[m])
        : x;
    this.paramTypes.enqueue = false;
    this.paramTypes._flushTypeQueue();
  }

  $get = [
    function () {
      return this;
    },
  ];

  /**
   * Defines whether URL matching should be case sensitive (the default behavior), or not.
   *
   * #### Example:
   * ```js
   * // Allow case insensitive url matches
   * urlService.config.caseInsensitive(true);
   * ```
   *
   * @param value `false` to match URL in a case sensitive manner; otherwise `true`;
   * @returns the current value of caseInsensitive
   */
  caseInsensitive(value) {
    return (this._isCaseInsensitive = isDefined(value)
      ? value
      : this._isCaseInsensitive);
  }
  /**
   * Sets the default behavior when generating or matching URLs with default parameter values.
   *
   * #### Example:
   * ```js
   * // Remove default parameter values from the url
   * urlService.config.defaultSquashPolicy(true);
   * ```
   *
   * @param value A string that defines the default parameter URL squashing behavior.
   *    - `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
   *    - `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
   *      parameter is surrounded by slashes, squash (remove) one slash from the URL
   *    - any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
   *      the parameter value from the URL and replace it with this string.
   * @returns the current value of defaultSquashPolicy
   */
  defaultSquashPolicy(value) {
    if (
      isDefined(value) &&
      value !== true &&
      value !== false &&
      !isString(value)
    )
      throw new Error(
        `Invalid squash policy: ${value}. Valid policies: false, true, arbitrary-string`,
      );
    return (this._defaultSquashPolicy = isDefined(value)
      ? value
      : this._defaultSquashPolicy);
  }
  /**
   * Defines whether URLs should match trailing slashes, or not (the default behavior).
   *
   * #### Example:
   * ```js
   * // Allow optional trailing slashes
   * urlService.config.strictMode(false);
   * ```
   *
   * @param value `false` to match trailing slashes in URLs, otherwise `true`.
   * @returns the current value of strictMode
   */
  strictMode(value) {
    return (this._isStrictMode = isDefined(value) ? value : this._isStrictMode);
  }
  /**
   * Creates and registers a custom [[ParamType]] object
   *
   * A custom parameter type can be used to generate URLs with typed parameters or custom encoding/decoding.
   *
   * #### Note: Register custom types *before using them* in a state definition.
   *
   * #### Example:
   * ```js
   * // Encode object parameter as JSON string
   * urlService.config.type('myjson', {
   *   encode: (obj) => JSON.stringify(obj),
   *   decode: (str) => JSON.parse(str),
   *   is: (val) => typeof(val) === 'object',
   *   pattern: /[^/]+/,
   *   equals: (a, b) => _.isEqual(a, b),
   * });
   * ```
   *
   * See [[ParamTypeDefinition]] for more examples
   *
   * @param name The type name.
   * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.
   * @param definitionFn A function that is injected before the app runtime starts.
   *        The result of this function should be a [[ParamTypeDefinition]].
   *        The result is merged into the existing `definition`.
   *        See [[ParamType]] for information on the values accepted.
   *
   * @returns if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined
   */
  type(name, definition, definitionFn) {
    const type = this.paramTypes.type(name, definition, definitionFn);
    return !isDefined(definition) ? type : this;
  }
}

class StateParams {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  /**
   * Merges a set of parameters with all parameters inherited between the common parents of the
   * current state and a given destination state.
   *
   * @param {Object} newParams The set of parameters which will be composited with inherited params.
   * @param {Object} $current Internal definition of object representing the current state.
   * @param {Object} $to Internal definition of object representing state to transition to.
   */
  $inherit(newParams, $current, $to) {
    const parents = ancestors($current, $to),
      inherited = {},
      inheritList = [];
    for (const i in parents) {
      if (!parents[i] || !parents[i].params) continue;
      const parentParams = parents[i].params;
      const parentParamsKeys = Object.keys(parentParams);
      if (!parentParamsKeys.length) continue;
      for (const j in parentParamsKeys) {
        if (
          parentParams[parentParamsKeys[j]].inherit == false ||
          inheritList.indexOf(parentParamsKeys[j]) >= 0
        )
          continue;
        inheritList.push(parentParamsKeys[j]);
        inherited[parentParamsKeys[j]] = this[parentParamsKeys[j]];
      }
    }
    return Object.assign({}, inherited, newParams);
  }
}

class Queue {
  constructor(_items = [], _limit = null) {
    this._items = _items;
    this._limit = _limit;
    this._evictListeners = [];
    this.onEvict = pushTo(this._evictListeners);
  }

  enqueue(item) {
    const items = this._items;
    items.push(item);
    if (this._limit && items.length > this._limit) this.evict();
    return item;
  }

  evict() {
    const item = this._items.shift();
    this._evictListeners.forEach((fn) => fn(item));
    return item;
  }

  dequeue() {
    if (this.size()) return this._items.splice(0, 1)[0];
  }

  clear() {
    const current = this._items;
    this._items = [];
    return current;
  }

  size() {
    return this._items.length;
  }

  remove(item) {
    const idx = this._items.indexOf(item);
    return idx > -1 && this._items.splice(idx, 1)[0];
  }

  peekTail() {
    return this._items[this._items.length - 1];
  }

  peekHead() {
    if (this.size()) return this._items[0];
  }
}

/**
 * Global router state
 *
 * This is where we hold the global mutable state such as current state, current
 * params, current transition, etc.
 */
class UIRouterGlobals {
  constructor() {
    /**
     * Current parameter values
     *
     * The parameter values from the latest successful transition
     * @type {StateParams}
     */
    this.params = new StateParams();

    /**
     * @type {Number}
     */
    this.lastStartedTransitionId = -1;

    /**
     * @type {Queue}
     */
    this.transitionHistory = new Queue([], 1);

    /**
     * @type {Queue}
     */
    this.successfulTransitions = new Queue([], 1);
  }

  $get = [() => this];
}

/**
 * Predicate which checks if a value is injectable
 *
 * A value is "injectable" if it is a function, or if it is an ng1 array-notation-style array
 * where all the elements in the array are Strings, except the last one, which is a Function
 * @param {*} val
 * @returns {boolean}
 */
function isInjectable(val) {
  if (Array.isArray(val) && val.length) {
    const head = val.slice(0, -1),
      tail = val.slice(-1);

    return !(
      head.filter((x) => !isString(x)).length ||
      tail.filter((x) => !isFunction(x)).length
    );
  }
  return isFunction(val);
}
/**
 * Predicate which checks if a value looks like a Promise
 *
 * It is probably a Promise if it's an object, and it has a `then` property which is a Function
 * @param {any} obj
 * @returns {boolean}
 */
function isPromise(obj) {
  return (
    obj !== null && typeof obj === "object" && typeof obj.then === "function"
  );
}

/**
 * Functions that manipulate strings
 */

/**
 * Returns a string shortened to a maximum length
 *
 * If the string is already less than the `max` length, return the string.
 * Else return the string, shortened to `max - 3` and append three dots ("...").
 *
 * @param max the maximum length of the string to return
 * @param str the input string
 */
function maxLength(max, str) {
  if (str.length <= max) return str;
  return str.substring(0, max - 3) + "...";
}
/**
 * Returns a string, with spaces added to the end, up to a desired str length
 *
 * If the string is already longer than the desired length, return the string.
 * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.
 *
 * @param length the desired length of the string to return
 * @param str the input string
 */
function padString(length, str) {
  while (str.length < length) str += " ";
  return str;
}
function kebobString(camelCase) {
  return camelCase
    .replace(/^([A-Z])/, ($1) => $1.toLowerCase()) // replace first char
    .replace(/([A-Z])/g, ($1) => "-" + $1.toLowerCase()); // replace rest
}
function functionToString(fn) {
  const fnStr = fnToString(fn);
  const namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);
  const toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;
  const fnName = fn["name"] || "";
  if (fnName && toStr.match(/function \(/)) {
    return "function " + fnName + toStr.substring(9);
  }
  return toStr;
}
function fnToString(fn) {
  const _fn = Array.isArray(fn) ? fn.slice(-1)[0] : fn;
  return (_fn && _fn.toString()) || "undefined";
}
function stringify(o) {
  const seen = [];
  const isRejection = (obj) => {
    return (
      obj &&
      typeof obj.then === "function" &&
      obj.constructor.name == "Rejection"
    );
  };
  const hasToString = (obj) =>
    isObject(obj) &&
    !Array.isArray(obj) &&
    obj.constructor !== Object &&
    isFunction(obj.toString);
  const stringifyPattern = pattern([
    [isUndefined, val("undefined")],
    [isNull, val("null")],
    [isPromise, val("[Promise]")],
    [isRejection, (x) => x._transitionRejection.toString()],
    [hasToString, (x) => x.toString()],
    [isInjectable, functionToString],
    [val(true), (x) => x],
  ]);
  function format(value) {
    if (isObject(value)) {
      if (seen.indexOf(value) !== -1) return "[circular ref]";
      seen.push(value);
    }
    return stringifyPattern(value);
  }
  if (isUndefined(o)) {
    // Workaround for IE & Edge Spec incompatibility where replacer function would not be called when JSON.stringify
    // is given `undefined` as value. To work around that, we simply detect `undefined` and bail out early by
    // manually stringifying it.
    return format(o);
  }
  return JSON.stringify(o, (key, value) => format(value)).replace(/\\"/g, '"');
}
const stripLastPathElement = (str) => str.replace(/\/[^/]*$/, "");
/**
 * Splits on a delimiter, but returns the delimiters in the array
 *
 * #### Example:
 * ```js
 * var splitOnSlashes = splitOnDelim('/');
 * splitOnSlashes("/foo"); // ["/", "foo"]
 * splitOnSlashes("/foo/"); // ["/", "foo", "/"]
 * ```
 */
function splitOnDelim(delim) {
  const re = new RegExp("(" + delim + ")", "g");
  return (str) => str.split(re).filter(Boolean);
}
/**
 * Reduce fn that joins neighboring strings
 *
 * Given an array of strings, returns a new array
 * where all neighboring strings have been joined.
 *
 * #### Example:
 * ```js
 * let arr = ["foo", "bar", 1, "baz", "", "qux" ];
 * arr.reduce(joinNeighborsR, []) // ["foobar", 1, "bazqux" ]
 * ```
 */
function joinNeighborsR(acc, x) {
  if (isString(tail(acc)) && isString(x))
    return acc.slice(0, -1).concat(tail(acc) + x);
  return pushR(acc, x);
}

/**
 * # Transition tracing (debug)
 *
 * Enable transition tracing to print transition information to the console,
 * in order to help debug your application.
 * Tracing logs detailed information about each Transition to your console.
 *
 * To enable tracing, import the [[Trace]] singleton and enable one or more categories.
 *
 * ### ES6
 * ```js
 * import {trace} from "@uirouter/core/index";
 * trace.enable(1, 5); // TRANSITION and VIEWCONFIG
 * ```
 *
 * ### CJS
 * ```js
 * let trace = require("@uirouter/core").trace;
 * trace.enable("TRANSITION", "VIEWCONFIG");
 * ```
 *
 * ### Globals
 * ```js
 * let trace = window["@uirouter/core"].trace;
 * trace.enable(); // Trace everything (very verbose)
 * ```
 *
 * ### Angular 1:
 * ```js
 * app.run($trace => $trace.enable());
 * ```
 *
 * @packageDocumentation
 */
function ngViewString(uiview) {
  if (!uiview) return "ng-view (defunct)";
  const state = uiview.creationContext
    ? uiview.creationContext.name || "(root)"
    : "(none)";
  return `[ng-view#${uiview.id}:${uiview.fqn} (${uiview.name}@${state})]`;
}
const viewConfigString = (viewConfig) => {
  const view = viewConfig.viewDecl;
  const state = view.$context.name || "(root)";
  return `[View#${viewConfig.$id} from '${state}' state]: target ng-view: '${view.$ngViewName}@${view.$ngViewContextAnchor}'`;
};
function normalizedCat(input) {
  return isNumber(input) ? Category[input] : Category[Category[input]];
}
/**
 * Trace categories Enum
 *
 * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]
 *
 * `trace.enable(Category.TRANSITION)`
 *
 * These can also be provided using a matching string, or position ordinal
 *
 * `trace.enable("TRANSITION")`
 *
 * `trace.enable(1)`
 */
var Category;
(function (Category) {
  Category[(Category["RESOLVE"] = 0)] = "RESOLVE";
  Category[(Category["TRANSITION"] = 1)] = "TRANSITION";
  Category[(Category["HOOK"] = 2)] = "HOOK";
  Category[(Category["UIVIEW"] = 3)] = "UIVIEW";
  Category[(Category["VIEWCONFIG"] = 4)] = "VIEWCONFIG";
})(Category || (Category = {}));
const _tid = parse("$id");
const _rid = parse("router.$id");
const transLbl = (trans) => `Transition #${_tid(trans)}-${_rid(trans)}`;
/**
 * Prints ng-router Transition trace information to the console.
 */
class Trace {
  constructor() {
    this._enabled = {};
    this.approximateDigests = 0;
  }

  _set(enabled, categories) {
    if (!categories.length) {
      categories = Object.keys(Category)
        .map((k) => parseInt(k, 10))
        .filter((k) => !isNaN(k))
        .map((key) => Category[key]);
    }
    categories
      .map(normalizedCat)
      .forEach((category) => (this._enabled[category] = enabled));
  }
  enable(...categories) {
    this._set(true, categories);
  }
  disable(...categories) {
    this._set(false, categories);
  }
  /**
   * Retrieves the enabled stateus of a [[Category]]
   *
   * ```js
   * trace.enabled("VIEWCONFIG"); // true or false
   * ```
   *
   * @returns boolean true if the category is enabled
   */
  enabled(category) {
    return !!this._enabled[normalizedCat(category)];
  }
  /** @internal called by ng-router code */
  traceTransitionStart(trans) {
    if (!this.enabled(Category.TRANSITION)) return;
    console.log(`${transLbl(trans)}: Started  -> ${stringify(trans)}`);
  }
  /** @internal called by ng-router code */
  traceTransitionIgnored(trans) {
    if (!this.enabled(Category.TRANSITION)) return;
    console.log(`${transLbl(trans)}: Ignored  <> ${stringify(trans)}`);
  }
  /** @internal called by ng-router code */
  traceHookInvocation(step, trans, options) {
    if (!this.enabled(Category.HOOK)) return;
    const event = parse("traceData.hookType")(options) || "internal",
      context =
        parse("traceData.context.state.name")(options) ||
        parse("traceData.context")(options) ||
        "unknown",
      name = functionToString(step.registeredHook.callback);
    console.log(
      `${transLbl(trans)}:   Hook -> ${event} context: ${context}, ${maxLength(200, name)}`,
    );
  }
  /** @internal called by ng-router code */
  traceHookResult(hookResult, trans) {
    if (!this.enabled(Category.HOOK)) return;
    console.log(
      `${transLbl(trans)}:   <- Hook returned: ${maxLength(200, stringify(hookResult))}`,
    );
  }
  /** @internal called by ng-router code */
  traceResolvePath(path, when, trans) {
    if (!this.enabled(Category.RESOLVE)) return;
    console.log(`${transLbl(trans)}:         Resolving ${path} (${when})`);
  }
  /** @internal called by ng-router code */
  traceResolvableResolved(resolvable, trans) {
    if (!this.enabled(Category.RESOLVE)) return;
    console.log(
      `${transLbl(trans)}:               <- Resolved  ${resolvable} to: ${maxLength(200, stringify(resolvable.data))}`,
    );
  }
  /** @internal called by ng-router code */
  traceError(reason, trans) {
    if (!this.enabled(Category.TRANSITION)) return;
    console.log(
      `${transLbl(trans)}: <- Rejected ${stringify(trans)}, reason: ${reason}`,
    );
  }
  /** @internal called by ng-router code */
  traceSuccess(finalState, trans) {
    if (!this.enabled(Category.TRANSITION)) return;
    console.log(
      `${transLbl(trans)}: <- Success  ${stringify(trans)}, final state: ${finalState.name}`,
    );
  }
  /** @internal called by ng-router code */
  traceUIViewEvent(event, viewData, extra = "") {
    if (!this.enabled(Category.UIVIEW)) return;
    console.log(
      `ng-view: ${padString(30, event)} ${ngViewString(viewData)}${extra}`,
    );
  }
  /** @internal called by ng-router code */
  traceUIViewConfigUpdated(viewData, context) {
    if (!this.enabled(Category.UIVIEW)) return;
    this.traceUIViewEvent(
      "Updating",
      viewData,
      ` with ViewConfig from context='${context}'`,
    );
  }
  /** @internal called by ng-router code */
  traceUIViewFill(viewData, html) {
    if (!this.enabled(Category.UIVIEW)) return;
    this.traceUIViewEvent("Fill", viewData, ` with: ${maxLength(200, html)}`);
  }
  /** @internal called by ng-router code */
  traceViewSync(pairs) {
    if (!this.enabled(Category.VIEWCONFIG)) return;
    const uivheader = "uiview component fqn";
    const cfgheader = "view config state (view name)";
    const mapping = pairs
      .map(({ ngView, viewConfig }) => {
        const uiv = ngView && ngView.fqn;
        const cfg =
          viewConfig &&
          `${viewConfig.viewDecl.$context.name}: (${viewConfig.viewDecl.$name})`;
        return { [uivheader]: uiv, [cfgheader]: cfg };
      })
      .sort((a, b) => (a[uivheader] || "").localeCompare(b[uivheader] || ""));
    console.table(mapping);
  }
  /** @internal called by ng-router code */
  traceViewServiceEvent(event, viewConfig) {
    if (!this.enabled(Category.VIEWCONFIG)) return;
    console.log(`VIEWCONFIG: ${event} ${viewConfigString(viewConfig)}`);
  }
  /** @internal called by ng-router code */
  traceViewServiceUIViewEvent(event, viewData) {
    if (!this.enabled(Category.VIEWCONFIG)) return;
    console.log(`VIEWCONFIG: ${event} ${ngViewString(viewData)}`);
  }
}
/**
 * The [[Trace]] singleton
 *
 * #### Example:
 * ```js
 * import {trace} from "@uirouter/core/index";
 * trace.enable(1, 5);
 * ```
 */
const trace = new Trace();

// TODO: explicitly make this user configurable
let defaultResolvePolicy = {
  when: "LAZY",
  async: "WAIT",
};
/**
 * The basic building block for the resolve system.
 *
 * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),
 * and the unwrapped-when-complete (.data) result of the resolveFn.
 *
 * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the
 * resolveFn) and returns the resulting promise.
 *
 * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first
 * parameter to those fns.
 */
class Resolvable {
  constructor(arg1, resolveFn, deps, policy, data) {
    this.resolved = false;
    this.promise = undefined;
    if (arg1 instanceof Resolvable) {
      Object.assign(this, arg1);
    } else if (isFunction(resolveFn)) {
      assert(!isNullOrUndefined(arg1), "token argument is required");
      this.token = arg1;
      this.policy = policy;
      this.resolveFn = resolveFn;
      this.deps = deps || [];
      this.data = data;
      this.resolved = data !== undefined;
      this.promise = this.resolved ? Promise.resolve(this.data) : undefined;
    } else if (
      isObject(arg1) &&
      arg1.token &&
      (Object.prototype.hasOwnProperty.call(arg1, "resolveFn") ||
        Object.prototype.hasOwnProperty.call(arg1, "data"))
    ) {
      this.token = arg1.token;
      this.resolveFn = arg1.resolveFn;
      this.deps = arg1.deps;
      this.policy = arg1.policy;
      this.data = arg1.data;
    }
  }

  getPolicy(state) {
    const thisPolicy = this.policy || {};
    const statePolicy = (state && state.resolvePolicy) || {};
    return {
      when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,
      async:
        thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,
    };
  }

  /**
   * Asynchronously resolve this Resolvable's data
   *
   * Given a ResolveContext that this Resolvable is found in:
   * Wait for this Resolvable's dependencies, then invoke this Resolvable's function
   * and update the Resolvable's state
   */
  resolve(resolveContext, trans) {
    // Gets all dependencies from ResolveContext and wait for them to be resolved
    const getResolvableDependencies = () =>
      Promise.all(
        resolveContext
          .getDependencies(this)
          .map((resolvable) => resolvable.get(resolveContext, trans)),
      );
    // Invokes the resolve function passing the resolved dependencies as arguments
    const invokeResolveFn = (resolvedDeps) =>
      this.resolveFn.apply(null, resolvedDeps);
    const node = resolveContext.findNode(this);
    const state = node && node.state;
    const asyncPolicy = this.getPolicy(state).async;
    const customAsyncPolicy = isFunction(asyncPolicy) ? asyncPolicy : (x) => x;
    // After the final value has been resolved, update the state of the Resolvable
    const applyResolvedValue = (resolvedValue) => {
      this.data = resolvedValue;
      this.resolved = true;
      this.resolveFn = null;
      trace.traceResolvableResolved(this, trans);
      return this.data;
    };
    // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.
    this.promise = Promise.resolve()
      .then(getResolvableDependencies)
      .then(invokeResolveFn)
      .then(customAsyncPolicy)
      .then(applyResolvedValue);
    return this.promise;
  }
  /**
   * Gets a promise for this Resolvable's data.
   *
   * Fetches the data and returns a promise.
   * Returns the existing promise if it has already been fetched once.
   */
  get(resolveContext, trans) {
    return this.promise || this.resolve(resolveContext, trans);
  }

  toString() {
    return `Resolvable(token: ${stringify(this.token)}, requires: [${this.deps.map(stringify)}])`;
  }

  clone() {
    return new Resolvable(this);
  }
}
Resolvable.fromData = (token, data) =>
  new Resolvable(token, () => data, null, null, data);

/**
 * Encapsulate the target (destination) state/params/options of a [[Transition]].
 *
 * This class is frequently used to redirect a transition to a new destination.
 *
 * See:
 *
 * - [[HookResult]]
 * - [[TransitionHookFn]]
 * - [[TransitionService.onStart]]
 *
 * To create a `TargetState`, use [[StateService.target]].
 *
 * ---
 *
 * This class wraps:
 *
 * 1) an identifier for a state
 * 2) a set of parameters
 * 3) and transition options
 * 4) the registered state object (the [[StateDeclaration]])
 *
 * Many ng-router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can
 * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).
 * The `TargetState` class normalizes those options.
 *
 * A `TargetState` may be valid (the state being targeted exists in the registry)
 * or invalid (the state being targeted is not registered).
 */
class TargetState {
  /**
   * The TargetState constructor
   *
   * Note: Do not construct a `TargetState` manually.
   * To create a `TargetState`, use the [[StateService.target]] factory method.
   *
   * @param _stateRegistry The StateRegistry to use to look up the _definition
   * @param _identifier An identifier for a state.
   *    Either a fully-qualified state name, or the object used to define the state.
   * @param _params Parameters for the target state
   * @param _options Transition options.
   *
   * @internal
   */
  constructor(_stateRegistry, _identifier, _params, _options) {
    this._stateRegistry = _stateRegistry;
    this._identifier = _identifier;
    this._identifier = _identifier;
    this._params = Object.assign({}, _params || {});
    this._options = Object.assign({}, _options || {});
    this._definition = _stateRegistry.matcher.find(
      _identifier,
      this._options.relative,
    );
  }
  /** The name of the state this object targets */
  name() {
    return (this._definition && this._definition.name) || this._identifier;
  }
  /** The identifier used when creating this TargetState */
  identifier() {
    return this._identifier;
  }
  /** The target parameter values */
  params() {
    return this._params;
  }
  /** The internal state object (if it was found) */
  $state() {
    return this._definition;
  }
  /** The internal state declaration (if it was found) */
  state() {
    return this._definition && this._definition.self;
  }
  /** The target options */
  options() {
    return this._options;
  }
  /** True if the target state was found */
  exists() {
    return !!(this._definition && this._definition.self);
  }
  /** True if the object is valid */
  valid() {
    return !this.error();
  }
  /** If the object is invalid, returns the reason why */
  error() {
    const base = this.options().relative;
    if (!this._definition && !!base) {
      const stateName = base.name ? base.name : base;
      return `Could not resolve '${this.name()}' from state '${stateName}'`;
    }
    if (!this._definition) return `No such state '${this.name()}'`;
    if (!this._definition.self)
      return `State '${this.name()}' has an invalid definition`;
  }
  toString() {
    return `'${this.name()}'${stringify(this.params())}`;
  }
  /**
   * Returns a copy of this TargetState which targets a different state.
   * The new TargetState has the same parameter values and transition options.
   *
   * @param state The new state that should be targeted
   */
  withState(state) {
    return new TargetState(
      this._stateRegistry,
      state,
      this._params,
      this._options,
    );
  }
  /**
   * Returns a copy of this TargetState, using the specified parameter values.
   *
   * @param params the new parameter values to use
   * @param replace When false (default) the new parameter values will be merged with the current values.
   *                When true the parameter values will be used instead of the current values.
   */
  withParams(params, replace = false) {
    const newParams = replace
      ? params
      : Object.assign({}, this._params, params);
    return new TargetState(
      this._stateRegistry,
      this._identifier,
      newParams,
      this._options,
    );
  }
  /**
   * Returns a copy of this TargetState, using the specified Transition Options.
   *
   * @param options the new options to use
   * @param replace When false (default) the new options will be merged with the current options.
   *                When true the options will be used instead of the current options.
   */
  withOptions(options, replace = false) {
    const newOpts = replace
      ? options
      : Object.assign({}, this._options, options);
    return new TargetState(
      this._stateRegistry,
      this._identifier,
      this._params,
      newOpts,
    );
  }
}
/** Returns true if the object has a state property that might be a state or state name */
TargetState.isDef = (obj) => {
  return (
    obj &&
    obj.state &&
    (isString(obj.state) || (isObject(obj.state) && isString(obj.state.name)))
  );
};

const isShorthand = (cfg) =>
  ["value", "type", "squash", "array", "dynamic"].filter(
    Object.prototype.hasOwnProperty.bind(cfg || {}),
  ).length === 0;

var DefType;
(function (DefType) {
  DefType[(DefType["PATH"] = 0)] = "PATH";
  DefType[(DefType["SEARCH"] = 1)] = "SEARCH";
  DefType[(DefType["CONFIG"] = 2)] = "CONFIG";
})(DefType || (DefType = {}));

function getParamDeclaration(paramName, location, state) {
  const noReloadOnSearch =
    (state.reloadOnSearch === false && location === DefType.SEARCH) ||
    undefined;
  const dynamic = find([state.dynamic, noReloadOnSearch], isDefined);
  const defaultConfig = isDefined(dynamic) ? { dynamic } : {};
  const paramConfig = unwrapShorthand(
    state && state.params && state.params[paramName],
  );
  return Object.assign(defaultConfig, paramConfig);
}
function unwrapShorthand(cfg) {
  cfg = isShorthand(cfg) ? { value: cfg } : cfg;
  getStaticDefaultValue["__cacheable"] = true;
  function getStaticDefaultValue() {
    return cfg.value;
  }
  const $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;
  return Object.assign(cfg, { $$fn });
}
function getType(cfg, urlType, location, id, paramTypes) {
  if (cfg.type && urlType && urlType.name !== "string")
    throw new Error(`Param '${id}' has two type configurations.`);
  if (
    cfg.type &&
    urlType &&
    urlType.name === "string" &&
    paramTypes.type(cfg.type)
  )
    return paramTypes.type(cfg.type);
  if (urlType) return urlType;
  if (!cfg.type) {
    const type =
      location === DefType.CONFIG
        ? "any"
        : location === DefType.PATH
          ? "path"
          : location === DefType.SEARCH
            ? "query"
            : "string";
    return paramTypes.type(type);
  }
  return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);
}
/** returns false, true, or the squash value to indicate the "default parameter url squash policy". */
function getSquashPolicy(config, isOptional, defaultPolicy) {
  const squash = config.squash;
  if (!isOptional || squash === false) return false;
  if (!isDefined(squash) || squash == null) return defaultPolicy;
  if (squash === true || isString(squash)) return squash;
  throw new Error(
    `Invalid squash policy: '${squash}'. Valid policies: false, true, or arbitrary string`,
  );
}
function getReplace(config, arrayMode, isOptional, squash) {
  const defaultPolicy = [
    { from: "", to: isOptional || arrayMode ? undefined : "" },
    { from: null, to: isOptional || arrayMode ? undefined : "" },
  ];
  const replace = Array.isArray(config.replace) ? config.replace : [];
  if (isString(squash)) replace.push({ from: squash, to: undefined });
  const configuredKeys = map(replace, (x) => x.from);
  return filter(
    defaultPolicy,
    (item) => configuredKeys.indexOf(item.from) === -1,
  ).concat(replace);
}
class Param {
  constructor(id, type, location, urlConfig, state) {
    const config = getParamDeclaration(id, location, state);
    type = getType(config, type, location, id, urlConfig.paramTypes);
    const arrayMode = getArrayMode();
    type = arrayMode
      ? type.$asArray(arrayMode, location === DefType.SEARCH)
      : type;
    const isOptional =
      config.value !== undefined || location === DefType.SEARCH;
    const dynamic = isDefined(config.dynamic)
      ? !!config.dynamic
      : !!type.dynamic;
    const raw = isDefined(config.raw) ? !!config.raw : !!type.raw;
    const squash = getSquashPolicy(
      config,
      isOptional,
      urlConfig.defaultSquashPolicy(),
    );
    const replace = getReplace(config, arrayMode, isOptional, squash);
    const inherit = isDefined(config.inherit)
      ? !!config.inherit
      : !!type.inherit;
    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
    function getArrayMode() {
      const arrayDefaults = {
        array: location === DefType.SEARCH ? "auto" : false,
      };
      const arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
      return Object.assign(arrayDefaults, arrayParamNomenclature, config).array;
    }
    this.isOptional = isOptional;
    this.type = type;
    this.location = location;
    this.id = id;
    this.dynamic = dynamic;
    this.raw = raw;
    this.squash = squash;
    this.replace = replace;
    this.inherit = inherit;
    this.array = arrayMode;
    this.config = config;
  }

  isDefaultValue(value) {
    return this.isOptional && this.type.equals(this.value(), value);
  }
  /**
   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
   * default value, which may be the result of an injectable function.
   */
  value(value) {
    /**
     * [Internal] Get the default value of a parameter, which may be an injectable function.
     */
    const getDefaultValue = () => {
      if (this._defaultValueCache) return this._defaultValueCache.defaultValue;
      if (!window.angular.$injector)
        throw new Error(
          "Injectable functions cannot be called at configuration time",
        );
      const defaultValue = window.angular.$injector.invoke(this.config.$$fn);
      if (
        defaultValue !== null &&
        defaultValue !== undefined &&
        !this.type.is(defaultValue)
      )
        throw new Error(
          `Default value (${defaultValue}) for parameter '${this.id}' is not an instance of ParamType (${this.type.name})`,
        );
      if (this.config.$$fn["__cacheable"]) {
        this._defaultValueCache = { defaultValue };
      }
      return defaultValue;
    };
    const replaceSpecialValues = (val) => {
      for (const tuple of this.replace) {
        if (tuple.from === val) return tuple.to;
      }
      return val;
    };
    value = replaceSpecialValues(value);
    return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
  }
  isSearch() {
    return this.location === DefType.SEARCH;
  }
  validates(value) {
    // There was no parameter value, but the param is optional
    if ((isUndefined(value) || value === null) && this.isOptional) return true;
    // The value was not of the correct ParamType, and could not be decoded to the correct ParamType
    const normalized = this.type.$normalize(value);
    if (!this.type.is(normalized)) return false;
    // The value was of the correct type, but when encoded, did not match the ParamType's regexp
    const encoded = this.type.encode(normalized);
    return !(isString(encoded) && !this.type.pattern.exec(encoded));
  }
  toString() {
    return `{Param:${this.id} ${this.type} squash: '${this.squash}' optional: ${this.isOptional}}`;
  }

  static values(params, values = {}) {
    const paramValues = {};
    for (const param of params) {
      paramValues[param.id] = param.value(values[param.id]);
    }
    return paramValues;
  }
  /**
   * Finds [[Param]] objects which have different param values
   *
   * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects
   *
   * @param params: The list of Param objects to filter
   * @param values1: The first set of parameter values
   * @param values2: the second set of parameter values
   *
   * @returns any Param objects whose values were different between values1 and values2
   */
  static changed(params, values1 = {}, values2 = {}) {
    return params.filter(
      (param) => !param.type.equals(values1[param.id], values2[param.id]),
    );
  }
  /**
   * Checks if two param value objects are equal (for a set of [[Param]] objects)
   *
   * @param params The list of [[Param]] objects to check
   * @param values1 The first set of param values
   * @param values2 The second set of param values
   *
   * @returns true if the param values in values1 and values2 are equal
   */
  static equals(params, values1 = {}, values2 = {}) {
    return Param.changed(params, values1, values2).length === 0;
  }
  /** Returns true if a the parameter values are valid, according to the Param definitions */
  static validates(params, values = {}) {
    return params
      .map((param) => param.validates(values[param.id]))
      .reduce(allTrueR, true);
  }
}

/**
 * A node in a [[TreeChanges]] path
 *
 * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.
 * Each PathNode corresponds to a state being entered, exited, or retained.
 * The stateful information includes parameter values and resolve data.
 */
class PathNode {
  constructor(stateOrNode) {
    if (stateOrNode instanceof PathNode) {
      const node = stateOrNode;
      this.state = node.state;
      this.paramSchema = node.paramSchema.slice();
      this.paramValues = Object.assign({}, node.paramValues);
      this.resolvables = node.resolvables.slice();
      this.views = node.views && node.views.slice();
    } else {
      const state = stateOrNode;
      this.state = state;
      this.paramSchema = state.parameters({ inherit: false });
      this.paramValues = {};
      this.resolvables = state.resolvables.map((res) => res.clone());
    }
  }

  clone() {
    return new PathNode(this);
  }

  /** Sets [[paramValues]] for the node, from the values of an object hash */
  applyRawParams(params) {
    const getParamVal = (paramDef) => [
      paramDef.id,
      paramDef.value(params[paramDef.id]),
    ];
    this.paramValues = this.paramSchema.reduce(
      (memo, pDef) => applyPairs(memo, getParamVal(pDef)),
      {},
    );
    return this;
  }

  /** Gets a specific [[Param]] metadata that belongs to the node */
  parameter(name) {
    return find(this.paramSchema, propEq("id", name));
  }

  /**
   * @returns true if the state and parameter values for another PathNode are
   * equal to the state and param values for this PathNode
   */
  equals(node, paramsFn) {
    const diff = this.diff(node, paramsFn);
    return diff && diff.length === 0;
  }

  /**
   * Finds Params with different parameter values on another PathNode.
   *
   * Given another node (of the same state), finds the parameter values which differ.
   * Returns the [[Param]] (schema objects) whose parameter values differ.
   *
   * Given another node for a different state, returns `false`
   *
   * @param node The node to compare to
   * @param paramsFn A function that returns which parameters should be compared.
   * @returns The [[Param]]s which differ, or null if the two nodes are for different states
   */
  diff(node, paramsFn) {
    if (this.state !== node.state) return false;
    const params = paramsFn ? paramsFn(this) : this.paramSchema;
    return Param.changed(params, this.paramValues, node.paramValues);
  }
}

/**
 * This class contains functions which convert TargetStates, Nodes and paths from one type to another.
 */
class PathUtils {
  static buildPath(targetState) {
    const toParams = targetState.params();
    return targetState
      .$state()
      .path.map((state) => new PathNode(state).applyRawParams(toParams));
  }
  /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */
  static buildToPath(fromPath, targetState) {
    const toPath = PathUtils.buildPath(targetState);
    if (targetState.options().inherit) {
      return PathUtils.inheritParams(
        fromPath,
        toPath,
        Object.keys(targetState.params()),
      );
    }
    return toPath;
  }
  /**
   * Creates ViewConfig objects and adds to nodes.
   *
   * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state
   */
  static applyViewConfigs($view, path, states) {
    // Only apply the viewConfigs to the nodes for the given states
    path
      .filter((node) => states.includes(node.state))
      .forEach((node) => {
        const viewDecls = Object.values(node.state.views || {});
        const subPath = PathUtils.subPath(path, (n) => n === node);
        const viewConfigs = viewDecls.map((view) => {
          return $view.createViewConfig(subPath, view);
        });
        node.views = viewConfigs.reduce(unnestR, []);
      });
  }
  /**
   * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath
   *
   * For a parameter in a node to be inherited from the from path:
   * - The toPath's node must have a matching node in the fromPath (by state).
   * - The parameter name must not be found in the toKeys parameter array.
   *
   * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some
   * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,
   * it is not inherited from the fromPath.
   */
  static inheritParams(fromPath, toPath, toKeys = []) {
    function nodeParamVals(path, state) {
      /** @type {PathNode} */
      const node = find(path, propEq("state", state));
      return Object.assign({}, node && node.paramValues);
    }
    const noInherit = fromPath
      .map((node) => node.paramSchema)
      .reduce(unnestR, [])
      .filter((param) => !param.inherit)
      .map((x) => x.id);
    /**
     * Given an [[PathNode]] "toNode", return a new [[PathNode]] with param values inherited from the
     * matching node in fromPath.  Only inherit keys that aren't found in "toKeys" from the node in "fromPath""
     */
    function makeInheritedParamsNode(toNode) {
      // All param values for the node (may include default key/vals, when key was not found in toParams)
      let toParamVals = Object.assign({}, toNode && toNode.paramValues);
      // limited to only those keys found in toParams
      const incomingParamVals = pick(toParamVals, toKeys);
      toParamVals = omit(toParamVals, toKeys);
      const fromParamVals = omit(
        nodeParamVals(fromPath, toNode.state) || {},
        noInherit,
      );
      // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals
      const ownParamVals = Object.assign(
        toParamVals,
        fromParamVals,
        incomingParamVals,
      );
      return new PathNode(toNode.state).applyRawParams(ownParamVals);
    }
    // The param keys specified by the incoming toParams
    return toPath.map(makeInheritedParamsNode);
  }
  /**
   * Computes the tree changes (entering, exiting) between a fromPath and toPath.
   */
  static treeChanges(fromPath, toPath, reloadState) {
    const max = Math.min(fromPath.length, toPath.length);
    let keep = 0;
    const nodesMatch = (node1, node2) =>
      node1.equals(node2, PathUtils.nonDynamicParams);
    while (
      keep < max &&
      fromPath[keep].state !== reloadState &&
      nodesMatch(fromPath[keep], toPath[keep])
    ) {
      keep++;
    }
    /** Given a retained node, return a new node which uses the to node's param values */
    function applyToParams(retainedNode, idx) {
      const cloned = retainedNode.clone();
      cloned.paramValues = toPath[idx].paramValues;
      return cloned;
    }
    let from, retained, exiting, entering, to;
    from = fromPath;
    retained = from.slice(0, keep);
    exiting = from.slice(keep);
    // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped
    const retainedWithToParams = retained.map(applyToParams);
    entering = toPath.slice(keep);
    to = retainedWithToParams.concat(entering);
    return { from, to, retained, retainedWithToParams, exiting, entering };
  }
  /**
   * Returns a new path which is: the subpath of the first path which matches the second path.
   *
   * The new path starts from root and contains any nodes that match the nodes in the second path.
   * It stops before the first non-matching node.
   *
   * Nodes are compared using their state property and their parameter values.
   * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.
   *
   * @param pathA the first path
   * @param pathB the second path
   * @param paramsFn a function which returns the parameters to consider when comparing
   *
   * @returns an array of PathNodes from the first path which match the nodes in the second path
   */
  static matching(pathA, pathB, paramsFn) {
    let done = false;
    const tuples = arrayTuples(pathA, pathB);
    return tuples.reduce((matching, [nodeA, nodeB]) => {
      done = done || !nodeA.equals(nodeB, paramsFn);
      return done ? matching : matching.concat(nodeA);
    }, []);
  }
  /**
   * Returns true if two paths are identical.
   *
   * @param pathA
   * @param pathB
   * @param paramsFn a function which returns the parameters to consider when comparing
   * @returns true if the the states and parameter values for both paths are identical
   */
  static equals(pathA, pathB, paramsFn) {
    return (
      pathA.length === pathB.length &&
      PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length
    );
  }
  /**
   * Return a subpath of a path, which stops at the first matching node
   *
   * Given an array of nodes, returns a subset of the array starting from the first node,
   * stopping when the first node matches the predicate.
   *
   * @param path a path of [[PathNode]]s
   * @param predicate a [[Predicate]] fn that matches [[PathNode]]s
   * @returns a subpath up to the matching node, or undefined if no match is found
   */
  static subPath(path, predicate) {
    const node = find(path, predicate);
    const elementIdx = path.indexOf(node);
    return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);
  }

  static nonDynamicParams(node) {
    return node.state
      .parameters({ inherit: false })
      .filter((param) => !param.dynamic);
  }

  /** Gets the raw parameter values from a path */
  static paramValues(path) {
    return path.reduce((acc, node) => Object.assign(acc, node.paramValues), {});
  }
}

/** Given a PathNode[], create an TargetState
 * @param {import("../state/state-registry.js").StateRegistryProvider} registry
 * @param {Array<PathNode>} path
 * @returns
 */
function makeTargetState(registry, path) {
  return new TargetState(
    registry,
    path.at(-1).state,
    path
      .map((x) => x.paramValues)
      .reduce((acc, obj) => ({ ...acc, ...obj }), {}),
    {},
  );
}

const resolvePolicies = {
  when: {
    LAZY: "LAZY",
    EAGER: "EAGER",
  }};

const ALL_WHENS = [resolvePolicies.when.EAGER, resolvePolicies.when.LAZY];
const EAGER_WHENS = [resolvePolicies.when.EAGER];
/**
 * Encapsulates Dependency Injection for a path of nodes
 *
 * ng-router states are organized as a tree.
 * A nested state has a path of ancestors to the root of the tree.
 * When a state is being activated, each element in the path is wrapped as a [[PathNode]].
 * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.
 *
 * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.
 */
class ResolveContext {
  constructor(_path) {
    this._path = _path;
  }
  /** Gets all the tokens found in the resolve context, de-duplicated */
  getTokens() {
    return this._path
      .reduce(
        (acc, node) => acc.concat(node.resolvables.map((r) => r.token)),
        [],
      )
      .reduce(uniqR, []);
  }
  /**
   * Gets the Resolvable that matches the token
   *
   * Gets the last Resolvable that matches the token in this context, or undefined.
   * Throws an error if it doesn't exist in the ResolveContext
   */
  getResolvable(token) {
    const matching = this._path
      .map((node) => node.resolvables)
      .reduce(unnestR, [])
      .filter((r) => r.token === token);
    return tail(matching);
  }

  /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */
  getPolicy(resolvable) {
    const node = this.findNode(resolvable);
    return resolvable.getPolicy(node);
  }

  /**
   * Returns a ResolveContext that includes a portion of this one
   *
   * Given a state, this method creates a new ResolveContext from this one.
   * The new context starts at the first node (root) and stops at the node for the `state` parameter.
   *
   * #### Why
   *
   * When a transition is created, the nodes in the "To Path" are injected from a ResolveContext.
   * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.
   * The "To State" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).
   * This method is used to create a narrower context when injecting ancestor nodes.
   *
   * @example
   * `let ABCD = new ResolveContext([A, B, C, D]);`
   *
   * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:
   * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.
   * However, `B` should only be able to access resolvables from `A`, `B`.
   *
   * When resolving for the `B` node, first take the full "To Path" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.
   * `let AB = ABCD.subcontext(a)`
   */
  subContext(state) {
    return new ResolveContext(
      PathUtils.subPath(this._path, (node) => node.state === state),
    );
  }
  /**
   * Adds Resolvables to the node that matches the state
   *
   * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).
   * The resolvable is added to the node matching the `state` parameter.
   *
   * These new resolvables are not automatically fetched.
   * The calling code should either fetch them, fetch something that depends on them,
   * or rely on [[resolvePath]] being called when some state is being entered.
   *
   * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.
   *
   * @param {Resolvable[]} newResolvables the new Resolvables
   * @param state Used to find the node to put the resolvable on
   */
  addResolvables(newResolvables, state) {
    /** @type {import('../path/path-node').PathNode} */
    const node = find(this._path, propEq("state", state));
    const keys = newResolvables.map((r) => r.token);
    node.resolvables = node.resolvables
      .filter((r) => keys.indexOf(r.token) === -1)
      .concat(newResolvables);
  }
  /**
   * Returns a promise for an array of resolved path Element promises
   *
   * @param {string} when
   * @param trans
   * @returns {Promise<any>|any}
   */
  resolvePath(when = "LAZY", trans) {
    // This option determines which 'when' policy Resolvables we are about to fetch.
    const whenOption = ALL_WHENS.includes(when) ? when : "LAZY";
    // If the caller specified EAGER, only the EAGER Resolvables are fetched.
    // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`
    const matchedWhens =
      whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;
    // get the subpath to the state argument, if provided
    trace.traceResolvePath(this._path, when, trans);
    const matchesPolicy = (acceptedVals, whenOrAsync) => (resolvable) =>
      acceptedVals.includes(this.getPolicy(resolvable)[whenOrAsync]);
    // Trigger all the (matching) Resolvables in the path
    // Reduce all the "WAIT" Resolvables into an array
    const promises = this._path.reduce((acc, node) => {
      const nodeResolvables = node.resolvables.filter(
        matchesPolicy(matchedWhens, "when"),
      );
      const nowait = nodeResolvables.filter(matchesPolicy(["NOWAIT"], "async"));
      const wait = nodeResolvables.filter(
        (x) => !matchesPolicy(["NOWAIT"], "async")(x),
      );
      // For the matching Resolvables, start their async fetch process.
      const subContext = this.subContext(node.state);
      const getResult = (r) =>
        r
          .get(subContext, trans)
          // Return a tuple that includes the Resolvable's token
          .then((value) => ({ token: r.token, value: value }));
      nowait.forEach(getResult);
      return acc.concat(wait.map(getResult));
    }, []);
    // Wait for all the "WAIT" resolvables
    return Promise.all(promises);
  }

  injector() {
    return this._injector || (this._injector = new UIInjectorImpl());
  }

  findNode(resolvable) {
    return find(this._path, (node) => node.resolvables.includes(resolvable));
  }

  /**
   * Gets the async dependencies of a Resolvable
   *
   * Given a Resolvable, returns its dependencies as a Resolvable[]
   * @param {Resolvable} resolvable
   * @returns {Resolvable[]}
   */
  getDependencies(resolvable) {
    const node = this.findNode(resolvable);
    // Find which other resolvables are "visible" to the `resolvable` argument
    // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)
    const subPath =
      PathUtils.subPath(this._path, (x) => x === node) || this._path;
    const availableResolvables = subPath
      .reduce((acc, _node) => acc.concat(_node.resolvables), []) // all of subpath's resolvables
      .filter((res) => res !== resolvable); // filter out the `resolvable` argument
    return resolvable.deps.map((token) => {
      const matching = availableResolvables.filter((r) => r.token === token);
      if (matching.length) return tail(matching);
      const fromInjector = window.angular.$injector.get(token);
      if (isUndefined(fromInjector)) {
        throw new Error(
          "Could not find Dependency Injection token: " + stringify(token),
        );
      }
      return new Resolvable(token, () => fromInjector, [], fromInjector);
    });
  }
}

class UIInjectorImpl {
  constructor() {
    this.native = window.angular.$injector;
  }
  get(token) {
    return window.angular.$injector.get(token);
  }
  getAsync(token) {
    return Promise.resolve(window.angular.$injector.get(token));
  }
  getNative(token) {
    return window.angular.$injector.get(token);
  }
}

function getNg1ViewConfigFactory() {
  let templateFactory = null;
  return (path, view) => {
    templateFactory =
      templateFactory || window.angular.$injector.get("$templateFactory"); // TODO: remove static injector
    return [new Ng1ViewConfig(path, view, templateFactory)];
  };
}

const hasAnyKey = (keys, obj) =>
  keys.reduce((acc, key) => acc || isDefined(obj[key]), false);
/**
 * This is a [[StateBuilder.builder]] function for angular1 `views`.
 *
 * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
 * handles the `views` property with logic specific to @uirouter/angularjs (ng1).
 *
 * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object
 * and applies the state-level configuration to a view named `$default`.
 *
 */
function ng1ViewsBuilder(state) {
  // Do not process root state
  if (!state.parent) return {};
  const tplKeys = [
      "templateProvider",
      "templateUrl",
      "template",
      "notify",
      "async",
    ],
    ctrlKeys = [
      "controller",
      "controllerProvider",
      "controllerAs",
      "resolveAs",
    ],
    compKeys = ["component", "bindings", "componentProvider"],
    nonCompKeys = tplKeys.concat(ctrlKeys),
    allViewKeys = compKeys.concat(nonCompKeys);
  // Do not allow a state to have both state-level props and also a `views: {}` property.
  // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.
  // However, the `$default` approach should not be mixed with a separate `views: ` block.
  if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {
    throw new Error(
      `State '${state.name}' has a 'views' object. ` +
        `It cannot also have "view properties" at the state level.  ` +
        `Move the following properties into a view (in the 'views' object): ` +
        ` ${allViewKeys.filter((key) => isDefined(state[key])).join(", ")}`,
    );
  }
  const views = {},
    viewsObject = state.views || { $default: pick(state, allViewKeys) };
  Object.entries(viewsObject).forEach(([name, config]) => {
    // Account for views: { "": { template... } }
    name = name || "$default";
    // Account for views: { header: "headerComponent" }
    if (isString(config)) config = { component: config };
    // Make a shallow copy of the config object
    config = Object.assign({}, config);
    // Do not allow a view to mix props for component-style view with props for template/controller-style view
    if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {
      throw new Error(
        `Cannot combine: ${compKeys.join("|")} with: ${nonCompKeys.join("|")} in stateview: '${name}@${state.name}'`,
      );
    }
    config.resolveAs = config.resolveAs || "$resolve";
    config.$context = state;
    config.$name = name;
    const normalized = Ng1ViewConfig.normalizeUIViewTarget(
      config.$context,
      config.$name,
    );
    config.$ngViewName = normalized.ngViewName;
    config.$ngViewContextAnchor = normalized.ngViewContextAnchor;
    views[name] = config;
  });
  return views;
}

/**
 * @type {Number}
 */
let id$1 = 0;

class Ng1ViewConfig {
  constructor(path, viewDecl, factory) {
    this.path = path;
    this.viewDecl = viewDecl;
    this.factory = factory;
    this.component = undefined;
    this.template = undefined;

    /** @type {Number} */ this.$id = id$1++;
    this.loaded = false;
    this.getTemplate = (ngView, context) =>
      this.component
        ? this.factory.makeComponentTemplate(
            ngView,
            context,
            this.component,
            this.viewDecl.bindings,
          )
        : this.template;
  }

  load() {
    const context = new ResolveContext(this.path);
    const params = this.path.reduce(
      (acc, node) => Object.assign(acc, node.paramValues),
      {},
    );
    const promises = [
      Promise.resolve(this.factory.fromConfig(this.viewDecl, params, context)),
      Promise.resolve(this.getController(context)),
    ];
    return Promise.all(promises).then((results) => {
      trace.traceViewServiceEvent("Loaded", this);
      this.controller = results[1];
      Object.assign(this, results[0]); // Either { template: "tpl" } or { component: "cmpName" }
      return this;
    });
  }
  /**
   * Gets the controller for a view configuration.
   *
   * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.
   */
  getController(context) {
    const provider = this.viewDecl.controllerProvider;
    if (!isInjectable(provider)) return this.viewDecl.controller;
    const deps = annotate(provider);
    const providerFn = Array.isArray(provider) ? tail(provider) : provider;
    const resolvable = new Resolvable("", providerFn, deps);
    return resolvable.get(context);
  }

  /**
   * Normalizes a view's name from a state.views configuration block.
   *
   * This should be used by a framework implementation to calculate the values for
   * [[_ViewDeclaration.$ngViewName]] and [[_ViewDeclaration.$ngViewContextAnchor]].
   *
   * @param context the context object (state declaration) that the view belongs to
   * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]
   *
   * @returns the normalized ngViewName and ngViewContextAnchor that the view targets
   */
  static normalizeUIViewTarget(context, rawViewName = "") {
    // TODO: Validate incoming view name with a regexp to allow:
    // ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,
    // "@" , "$default@^" , "!$default.$default" , "!foo.bar"
    const viewAtContext = rawViewName.split("@");
    let ngViewName = viewAtContext[0] || "$default"; // default to unnamed view
    let ngViewContextAnchor = isString(viewAtContext[1])
      ? viewAtContext[1]
      : "^"; // default to parent context
    // Handle relative view-name sugar syntax.
    // Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],
    const relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(ngViewName);
    if (relativeViewNameSugar) {
      // Clobbers existing contextAnchor (rawViewName validation will fix this)
      ngViewContextAnchor = relativeViewNameSugar[1]; // set anchor to "^.^.^"
      ngViewName = relativeViewNameSugar[2]; // set view-name to "foo.bar"
    }
    if (ngViewName.charAt(0) === "!") {
      ngViewName = ngViewName.substring(1);
      ngViewContextAnchor = ""; // target absolutely from root
    }
    // handle parent relative targeting "^.^.^"
    const relativeMatch = /^(\^(?:\.\^)*)$/;
    if (relativeMatch.exec(ngViewContextAnchor)) {
      const anchorState = ngViewContextAnchor
        .split(".")
        .reduce((anchor) => anchor.parent, context);
      ngViewContextAnchor = anchorState.name;
    } else if (ngViewContextAnchor === ".") {
      ngViewContextAnchor = context.name;
    }
    return { ngViewName, ngViewContextAnchor };
  }
}

/**
 * The View service
 *
 * This service pairs existing `ng-view` components (which live in the DOM)
 * with view configs (from the state declaration objects: [[StateDeclaration.views]]).
 *
 * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].
 *   The views from exited states are deactivated via [[deactivateViewConfig]].
 *   (See: the [[registerActivateViews]] Transition Hook)
 *
 * - As `ng-view` components pop in and out of existence, they register themselves using [[registerUIView]].
 *
 * - When the [[sync]] function is called, the registered `ng-view`(s) ([[ActiveUIView]])
 * are configured with the matching [[ViewConfig]](s)
 *
 */
class ViewService {
  constructor() {
    this._ngViews = [];
    this._viewConfigs = [];
    this._viewConfigFactories = {};
    this._listeners = [];
    this._pluginapi = {
      _rootViewContext: this._rootViewContext.bind(this),
      _viewConfigFactory: this._viewConfigFactory.bind(this),
      _registeredUIView: (id) => {
        const res = find(this._ngViews, (view) => view.id === id);
        return res;
      },

      _registeredUIViews: () => this._ngViews,
      _activeViewConfigs: () => this._viewConfigs,
      _onSync: (listener) => {
        this._listeners.push(listener);
        return () => removeFrom(this._listeners, listener);
      },
    };
    this._pluginapi._viewConfigFactory(getNg1ViewConfigFactory());
  }

  $get = [() => this];

  _rootViewContext(context) {
    return (this._rootContext = context || this._rootContext);
  }

  _viewConfigFactory(factory) {
    this._viewConfigFactory = factory;
  }
  createViewConfig(path, decl) {
    const cfgFactory = this._viewConfigFactory;
    if (!cfgFactory)
      throw new Error(
        "ViewService: No view config factory registered for type " + decl.$type,
      );
    const cfgs = cfgFactory(path, decl);
    return Array.isArray(cfgs) ? cfgs : [cfgs];
  }
  /**
   * Deactivates a ViewConfig.
   *
   * This function deactivates a `ViewConfig`.
   * After calling [[sync]], it will un-pair from any `ng-view` with which it is currently paired.
   *
   * @param viewConfig The ViewConfig view to deregister.
   */
  deactivateViewConfig(viewConfig) {
    trace.traceViewServiceEvent("<- Removing", viewConfig);
    removeFrom(this._viewConfigs, viewConfig);
  }
  activateViewConfig(viewConfig) {
    trace.traceViewServiceEvent("-> Registering", viewConfig);
    this._viewConfigs.push(viewConfig);
  }
  sync() {
    const ngViewsByFqn = this._ngViews
      .map((uiv) => [uiv.fqn, uiv])
      .reduce(applyPairs, {});
    // Return a weighted depth value for a ngView.
    // The depth is the nesting depth of ng-views (based on FQN; times 10,000)
    // plus the depth of the state that is populating the ngView
    function ngViewDepth(ngView) {
      const stateDepth = (context) =>
        context && context.parent ? stateDepth(context.parent) + 1 : 1;
      return (
        ngView.fqn.split(".").length * 10000 +
        stateDepth(ngView.creationContext)
      );
    }
    // Return the ViewConfig's context's depth in the context tree.
    function viewConfigDepth(config) {
      let context = config.viewDecl.$context,
        count = 0;
      while (++count && context.parent) context = context.parent;
      return count;
    }
    // Given a depth function, returns a compare function which can return either ascending or descending order
    const depthCompare = curry(
      (depthFn, posNeg, left, right) =>
        posNeg * (depthFn(left) - depthFn(right)),
    );
    const matchingConfigPair = (ngView) => {
      const matchingConfigs = this._viewConfigs.filter(
        ViewService.matches(ngViewsByFqn, ngView),
      );
      if (matchingConfigs.length > 1) {
        // This is OK.  Child states can target a ng-view that the parent state also targets (the child wins)
        // Sort by depth and return the match from the deepest child
        // console.log(`Multiple matching view configs for ${ngView.fqn}`, matchingConfigs);
        matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending
      }
      return { ngView, viewConfig: matchingConfigs[0] };
    };
    const configureUIView = (tuple) => {
      // If a parent ng-view is reconfigured, it could destroy child ng-views.
      // Before configuring a child ng-view, make sure it's still in the active ngViews array.
      if (this._ngViews.indexOf(tuple.ngView) !== -1) {
        tuple.ngView.configUpdated(tuple.viewConfig);
      }
    };
    // Sort views by FQN and state depth. Process uiviews nearest the root first.
    const ngViewTuples = this._ngViews
      .sort(depthCompare(ngViewDepth, 1))
      .map(matchingConfigPair);
    const matchedViewConfigs = ngViewTuples.map((tuple) => tuple.viewConfig);
    const unmatchedConfigTuples = this._viewConfigs
      .filter((config) => !matchedViewConfigs.includes(config))
      .map((viewConfig) => ({ ngView: undefined, viewConfig }));
    ngViewTuples.forEach((tuple) => {
      configureUIView(tuple);
    });
    const allTuples = ngViewTuples.concat(unmatchedConfigTuples);
    this._listeners.forEach((cb) => cb(allTuples));
    trace.traceViewSync(allTuples);
  }
  /**
   * Registers a `ng-view` component
   *
   * When a `ng-view` component is created, it uses this method to register itself.
   * After registration the [[sync]] method is used to ensure all `ng-view` are configured with the proper [[ViewConfig]].
   *
   * Note: the `ng-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ng-view`,
   * and what the view's state context is.
   *
   * Note: There is no corresponding `deregisterUIView`.
   *       A `ng-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.
   *
   * @param ngView The metadata for a UIView
   * @return a de-registration function used when the view is destroyed.
   */
  registerUIView(ngView) {
    trace.traceViewServiceUIViewEvent("-> Registering", ngView);
    const ngViews = this._ngViews;
    const fqnAndTypeMatches = (uiv) => uiv.fqn === ngView.fqn;
    if (ngViews.filter(fqnAndTypeMatches).length)
      trace.traceViewServiceUIViewEvent("!!!! duplicate ngView named:", ngView);
    ngViews.push(ngView);
    this.sync();
    return () => {
      const idx = ngViews.indexOf(ngView);
      if (idx === -1) {
        trace.traceViewServiceUIViewEvent(
          "Tried removing non-registered ngView",
          ngView,
        );
        return;
      }
      trace.traceViewServiceUIViewEvent("<- Deregistering", ngView);
      removeFrom(ngViews)(ngView);
    };
  }
  /**
   * Returns the list of views currently available on the page, by fully-qualified name.
   *
   * @return {Array} Returns an array of fully-qualified view names.
   */
  available() {
    return this._ngViews.map((x) => x.fqn);
  }
  /**
   * Returns the list of views on the page containing loaded content.
   *
   * @return {Array} Returns an array of fully-qualified view names.
   */
  active() {
    return this._ngViews.filter((x) => x.$config).map((x) => x.name);
  }
}
/**
 * Given a ng-view and a ViewConfig, determines if they "match".
 *
 * A ng-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in
 * the DOM, describing its nesting relationship to any parent ng-view tags it is nested inside of.
 *
 * A ViewConfig has a target ng-view name and a context anchor.  The ng-view name can be a simple name, or
 * can be a segmented ng-view path, describing a portion of a ng-view fqn.
 *
 * In order for a ng-view to match ViewConfig, ng-view's $type must match the ViewConfig's $type
 *
 * If the ViewConfig's target ng-view name is a simple name (no dots), then a ng-view matches if:
 * - the ng-view's name matches the ViewConfig's target name
 * - the ng-view's context matches the ViewConfig's anchor
 *
 * If the ViewConfig's target ng-view name is a segmented name (with dots), then a ng-view matches if:
 * - There exists a parent ng-view where:
 *    - the parent ng-view's name matches the first segment (index 0) of the ViewConfig's target name
 *    - the parent ng-view's context matches the ViewConfig's anchor
 * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ng-view's fqn
 *
 * Example:
 *
 * DOM:
 * <ng-view>                        <!-- created in the root context (name: "") -->
 *   <ng-view name="foo">                <!-- created in the context named: "A"      -->
 *     <ng-view>                    <!-- created in the context named: "A.B"    -->
 *       <ng-view name="bar">            <!-- created in the context named: "A.B.C"  -->
 *       </ng-view>
 *     </ng-view>
 *   </ng-view>
 * </ng-view>
 *
 * ngViews: [
 *  { fqn: "$default",                  creationContext: { name: "" } },
 *  { fqn: "$default.foo",              creationContext: { name: "A" } },
 *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }
 *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }
 * ]
 *
 * These four view configs all match the ng-view with the fqn: "$default.foo.$default.bar":
 *
 * - ViewConfig1: { ngViewName: "bar",                       ngViewContextAnchor: "A.B.C" }
 * - ViewConfig2: { ngViewName: "$default.bar",              ngViewContextAnchor: "A.B" }
 * - ViewConfig3: { ngViewName: "foo.$default.bar",          ngViewContextAnchor: "A" }
 * - ViewConfig4: { ngViewName: "$default.foo.$default.bar", ngViewContextAnchor: "" }
 *
 * Using ViewConfig3 as an example, it matches the ng-view with fqn "$default.foo.$default.bar" because:
 * - The ViewConfig's segmented target name is: [ "foo", "$default", "bar" ]
 * - There exists a parent ng-view (which has fqn: "$default.foo") where:
 *    - the parent ng-view's name "foo" matches the first segment "foo" of the ViewConfig's target name
 *    - the parent ng-view's context "A" matches the ViewConfig's anchor context "A"
 * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig's target name match
 *   the tail of the ng-view's fqn "default.bar"
 *
 * @internal
 */
ViewService.matches = (ngViewsByFqn, ngView) => (viewConfig) => {
  // Don't supply an ng1 ng-view with an ng2 ViewConfig, etc
  if (ngView.$type !== viewConfig.viewDecl.$type) return false;
  // Split names apart from both viewConfig and ngView into segments
  const vc = viewConfig.viewDecl;
  const vcSegments = vc.$ngViewName.split(".");
  const uivSegments = ngView.fqn.split(".");
  // Check if the tails of the segment arrays match. ex, these arrays' tails match:
  // vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]
  if (!equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
    return false;
  // Now check if the fqn ending at the first segment of the viewConfig matches the context:
  // ["$default", "foo"].join(".") == "$default.foo", does the ng-view $default.foo context match?
  const negOffset = 1 - vcSegments.length || undefined;
  const fqnToFirstSegment = uivSegments.slice(0, negOffset).join(".");
  const ngViewContext = ngViewsByFqn[fqnToFirstSegment].creationContext;
  return vc.$ngViewContextAnchor === (ngViewContext && ngViewContext.name);
};

/**
 * An object for Transition Hook Phases
 * @enum {number}
 * @readonly
 */
const TransitionHookPhase = {
  CREATE: 0,
  BEFORE: 1,
  RUN: 2,
  SUCCESS: 3,
  ERROR: 4,
};

/** An object for Transition Hook Scopes */
const TransitionHookScope = {
  TRANSITION: 0,
  STATE: 1,
};

/**
 * An object for Transition Rejection reasons.
 * @enum {number}
 */
const RejectType = {
  /**
   * A new transition superseded this one.
   *
   * While this transition was running, a new transition started.
   * This transition is cancelled because it was superseded by a new transition.
   * @type {number}
   */
  SUPERSEDED: 2,

  /**
   * The transition was aborted.
   *
   * The transition was aborted by a hook which returned `false`.
   * @type {number}
   */
  ABORTED: 3,

  /**
   * The transition was invalid.
   *
   * The transition was never started because it was invalid.
   * @type {number}
   */
  INVALID: 4,

  /**
   * The transition was ignored.
   *
   * The transition was ignored because it would have no effect.
   * Either:
   * - The transition is targeting the current state and parameter values.
   * - The transition is targeting the same state and parameter values as the currently running transition.
   * @type {number}
   */
  IGNORED: 5,

  /**
   * The transition errored.
   *
   * This generally means a hook threw an error or returned a rejected promise.
   * @type {number}
   */
  ERROR: 6,
};

let id = 0;
class Rejection {
  /** Returns a Rejection due to transition superseded */
  static superseded(detail, options) {
    const message =
      "The transition has been superseded by a different transition";
    const rejection = new Rejection(RejectType.SUPERSEDED, message, detail);
    if (options && options.redirected) {
      rejection.redirected = true;
    }
    return rejection;
  }
  /** Returns a Rejection due to redirected transition */
  static redirected(detail) {
    return Rejection.superseded(detail, { redirected: true });
  }
  /** Returns a Rejection due to invalid transition */
  static invalid(detail) {
    const message = "This transition is invalid";
    return new Rejection(RejectType.INVALID, message, detail);
  }
  /** Returns a Rejection due to ignored transition */
  static ignored(detail) {
    const message = "The transition was ignored";
    return new Rejection(RejectType.IGNORED, message, detail);
  }
  /** Returns a Rejection due to aborted transition */
  static aborted(detail) {
    const message = "The transition has been aborted";
    return new Rejection(RejectType.ABORTED, message, detail);
  }
  /** Returns a Rejection due to aborted transition */
  static errored(detail) {
    const message = "The transition errored";
    return new Rejection(RejectType.ERROR, message, detail);
  }
  /**
   * Returns a Rejection
   *
   * Normalizes a value as a Rejection.
   * If the value is already a Rejection, returns it.
   * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).
   *
   * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.
   */
  static normalize(detail) {
    return is(Rejection)(detail) ? detail : Rejection.errored(detail);
  }
  constructor(type, message, detail) {
    this.$id = id++;
    this.type = type;
    this.message = message;
    this.detail = detail;
    this.redirected = false;
  }
  toString() {
    const detailString = (d) =>
      d && d.toString !== Object.prototype.toString
        ? d.toString()
        : stringify(d);
    const detail = detailString(this.detail);
    const { $id, type, message } = this;
    return `Transition Rejection($id: ${$id} type: ${type}, message: ${message}, detail: ${detail})`;
  }
  toPromise() {
    return Object.assign(silentRejection(this), { _transitionRejection: this });
  }
}

class PubSub {
  /**
   * Topic-based publish/subscribe channel.  Maintains a map of topics to
   * subscriptions.  When a message is published to a topic, all functions
   * subscribed to that topic are invoked in the order they were added.
   * Uncaught errors abort publishing.
   *
   * Topics may be identified by any nonempty string, <strong>except</strong>
   * strings corresponding to native Object properties, e.g. "constructor",
   * "toString", "hasOwnProperty", etc.
   *
   * @param {boolean=} opt_async Enable asynchronous behavior.  Recommended for
   *     new code.  See notes on the publish() method.
   */
  constructor(opt_async = false) {
    this.disposed = false;

    /**
     * The next available subscription key.  Internally, this is an index into the
     * sparse array of subscriptions.
     *
     * @private {number}
     */
    this.key = 1;

    /**
     * Array of subscription keys pending removal once publishing is done.
     *
     * @private {!Array<number>}
     * @const
     */
    this.pendingKeys = [];

    /**
     * Lock to prevent the removal of subscriptions during publishing. Incremented
     * at the beginning of {@link #publish}, and decremented at the end.
     *
     * @private {number}
     */
    this.publishDepth = 0;

    /**
     * Sparse array of subscriptions. Each subscription is represented by a tuple
     * comprising a topic identifier, a function, and an optional context object.
     * Each tuple occupies three consecutive positions in the array, with the
     * topic identifier at index n, the function at index (n + 1), the context
     * object at index (n + 2), the next topic at index (n + 3), etc. (This
     * representation minimizes the number of object allocations and has been
     * shown to be faster than an array of objects with three key-value pairs or
     * three parallel arrays, especially on IE.) Once a subscription is removed
     * via {@link #unsubscribe} or {@link #unsubscribeByKey}, the three
     * corresponding array elements are deleted, and never reused. This means the
     * total number of subscriptions during the lifetime of the pubsub channel is
     * limited by the maximum length of a JavaScript array to (2^32 - 1) / 3 =
     * 1,431,655,765 subscriptions, which should suffice for most applications.
     *
     * @private {!Array<?>}
     * @const
     */
    this.subscriptions = [];

    /**
     * Map of topics to arrays of subscription keys.
     *
     * @private {!Object<!Array<number>>}
     */
    this.topics = {};

    /**
     * @private @const {boolean}
     */
    this.async_ = Boolean(opt_async);
  }

  /**
   * Subscribes a function to a topic.  The function is invoked as a method on
   * the given `opt_context` object, or in the global scope if no context
   * is specified.  Subscribing the same function to the same topic multiple
   * times will result in multiple function invocations while publishing.
   * Returns a subscription key that can be used to unsubscribe the function from
   * the topic via {@link #unsubscribeByKey}.
   *
   * @param {string} topic Topic to subscribe to.
   * @param {Function} fn Function to be invoked when a message is published to
   *     the given topic.
   * @param {Object=} opt_context Object in whose context the function is to be
   *     called (the global scope if none).
   * @return {number} Subscription key.
   */
  subscribe(topic, fn, opt_context = null) {
    let keys = this.topics[topic];
    if (!keys) {
      // First subscription to this topic; initialize subscription key array.
      keys = this.topics[topic] = [];
    }

    // Push the tuple representing the subscription onto the subscription array.
    const key = this.key;
    this.subscriptions[key] = topic;
    this.subscriptions[key + 1] = fn;
    this.subscriptions[key + 2] = opt_context;
    this.key = key + 3;

    // Push the subscription key onto the list of subscriptions for the topic.
    keys.push(key);

    // Return the subscription key.
    return key;
  }

  /**
   * Subscribes a single-use function to a topic.  The function is invoked as a
   * method on the given `opt_context` object, or in the global scope if
   * no context is specified, and is then unsubscribed.  Returns a subscription
   * key that can be used to unsubscribe the function from the topic via
   * {@link #unsubscribeByKey}.
   *
   * @param {string} topic Topic to subscribe to.
   * @param {Function} fn Function to be invoked once and then unsubscribed when
   *     a message is published to the given topic.
   * @param {Object=} opt_context Object in whose context the function is to be
   *     called (the global scope if none).
   * @return {number} Subscription key.
   */
  subscribeOnce(topic, fn, opt_context = null) {
    let called = false;

    // Behold the power of lexical closures!
    const key = this.subscribe(
      topic,
      (...args) => {
        if (!called) {
          called = true;

          // Unsubscribe before calling function so the function is unsubscribed
          // even if it throws an exception.
          this.unsubscribeByKey(key);

          fn.apply(opt_context, args);
        }
      },
      this,
    );
    return key;
  }

  /**
   * Runs a function asynchronously.
   *
   * @private
   * @param {Function} fn Function to run.
   * @param {Object} context Context in which to run the function.
   * @param {Array} args Arguments to pass to the function.
   */
  static runAsync_(fn, context, args) {
    setTimeout(() => {
      fn.apply(context, args);
    }, 0);
  }

  /**
   * Unsubscribes a function from a topic.  Only deletes the first match found.
   * Returns a Boolean indicating whether a subscription was removed.
   *
   * @param {string} topic Topic to unsubscribe from.
   * @param {Function} fn Function to unsubscribe.
   * @param {Object=} opt_context Object in whose context the function was to be
   *     called (the global scope if none).
   * @return {boolean} Whether a matching subscription was removed.
   */
  unsubscribe(topic, fn, opt_context = null) {
    const keys = this.topics[topic];
    if (keys) {
      const subscriptions = this.subscriptions;
      const key = keys.find(
        (k) =>
          subscriptions[k + 1] === fn && subscriptions[k + 2] === opt_context,
      );

      if (key !== undefined) {
        return this.unsubscribeByKey(key);
      }
    }

    return false;
  }

  /**
   * Removes a subscription based on the key returned by {@link #subscribe}.
   * No-op if no matching subscription is found.  Returns a Boolean indicating
   * whether a subscription was removed.
   *
   * @param {number} key Subscription key.
   * @return {boolean} Whether a matching subscription was removed.
   */
  unsubscribeByKey(key) {
    const topic = this.subscriptions[key];
    if (topic) {
      let keys = this.topics[topic];

      if (this.publishDepth !== 0) {
        // Defer removal until after publishing is complete, but replace the
        // function with a no-op so it isn't called.
        this.pendingKeys.push(key);
        this.subscriptions[key + 1] = () => {};
      } else {
        if (keys) {
          this.topics[topic] = keys.filter((k) => k !== key);
        }
        delete this.subscriptions[key];
        delete this.subscriptions[key + 1];
        delete this.subscriptions[key + 2];
      }
    }

    return !!topic;
  }

  /**
   * Publishes a message to a topic.  Calls functions subscribed to the topic in
   * the order in which they were added, passing all arguments along.
   *
   * If this object was created with async=true, subscribed functions are called
   * via setTimeout().  Otherwise, the functions are called directly, and if
   * any of them throw an uncaught error, publishing is aborted.
   *
   * @param {string} topic Topic to publish to.
   * @param {...*} var_args Arguments that are applied to each subscription
   *     function.
   * @return {boolean} Whether any subscriptions were called.
   */
  publish(topic, ...var_args) {
    const keys = this.topics[topic];
    if (keys) {
      const args = var_args;

      if (this.async_) {
        // For each key in the list of subscription keys for the topic, schedule
        // the function to be applied to the arguments in the appropriate context.
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          PubSub.runAsync_(
            this.subscriptions[key + 1],
            this.subscriptions[key + 2],
            args,
          );
        }
      } else {
        this.publishDepth++;

        try {
          for (
            let i = 0, len = keys.length;
            i < len && !this.isDisposed();
            i++
          ) {
            const key = keys[i];
            this.subscriptions[key + 1].apply(
              this.subscriptions[key + 2],
              args,
            );
          }
        } finally {
          this.publishDepth--;

          if (this.pendingKeys.length > 0 && this.publishDepth === 0) {
            let pendingKey;
            while ((pendingKey = this.pendingKeys.pop())) {
              this.unsubscribeByKey(pendingKey);
            }
          }
        }
      }

      return true;
    }

    return false;
  }

  /**
   * Clears the subscription list for a topic, or all topics if unspecified.
   * @param {string=} opt_topic Topic to clear (all topics if unspecified).
   */
  clear(opt_topic) {
    if (opt_topic) {
      const keys = this.topics[opt_topic];
      if (keys) {
        keys.forEach(this.unsubscribeByKey, this);
        delete this.topics[opt_topic];
      }
    } else {
      this.subscriptions.length = 0;
      this.topics = {};
    }
  }

  /**
   * Returns the number of subscriptions to the given topic (or all topics if
   * unspecified). This number will not change while publishing any messages.
   * @param {string=} opt_topic The topic (all topics if unspecified).
   * @return {number} Number of subscriptions to the topic.
   */
  getCount(opt_topic) {
    if (opt_topic) {
      const keys = this.topics[opt_topic];
      return keys ? keys.length : 0;
    }

    let count = 0;
    for (const topic in this.topics) {
      count += this.getCount(topic);
    }

    return count;
  }

  isDisposed() {
    return this.disposed;
  }

  dispose() {
    this.clear();
    this.pendingKeys.length = 0;
    this.disposed = true;
  }
}

const EventBus = new PubSub(true);

const defaultOptions = {
  current: () => {},
  transition: null,
  traceData: {},
  bind: null,
};

class TransitionHook {
  /**
   * Chains together an array of TransitionHooks.
   *
   * Given a list of [[TransitionHook]] objects, chains them together.
   * Each hook is invoked after the previous one completes.
   *
   * #### Example:
   * ```js
   * var hooks: TransitionHook[] = getHooks();
   * let promise: Promise<any> = TransitionHook.chain(hooks);
   *
   * promise.then(handleSuccess, handleError);
   * ```
   *
   * @param hooks the list of hooks to chain together
   * @param waitFor if provided, the chain is `.then()`'ed off this promise
   * @returns a `Promise` for sequentially invoking the hooks (in order)
   */
  static chain(hooks, waitFor) {
    // Chain the next hook off the previous
    const createHookChainR = (prev, nextHook) =>
      prev.then(() => nextHook.invokeHook());
    return hooks.reduce(createHookChainR, waitFor || Promise.resolve());
  }

  /**
   * Invokes all the provided TransitionHooks, in order.
   * Each hook's return value is checked.
   * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.
   * If no hook returns a promise, then all hooks are processed synchronously.
   *
   * @param hooks the list of TransitionHooks to invoke
   * @param doneCallback a callback that is invoked after all the hooks have successfully completed
   *
   * @returns a promise for the async result, or the result of the callback
   */
  static invokeHooks(hooks, doneCallback) {
    for (let idx = 0; idx < hooks.length; idx++) {
      const hookResult = hooks[idx].invokeHook();
      if (isPromise(hookResult)) {
        const remainingHooks = hooks.slice(idx + 1);
        return TransitionHook.chain(remainingHooks, hookResult).then(() => {
          doneCallback();
        });
      }
    }
    return doneCallback();
  }

  /**
   * Run all TransitionHooks, ignoring their return value.
   */
  static runAllHooks(hooks) {
    hooks.forEach((hook) => hook.invokeHook());
  }

  constructor(transition, stateContext, registeredHook, options) {
    this.transition = transition;
    this.stateContext = stateContext;
    this.registeredHook = registeredHook;
    this.options = options;
    this.isSuperseded = () =>
      this.type.hookPhase === TransitionHookPhase.RUN &&
      !this.options.transition.isActive();
    this.options = defaults(options, defaultOptions);
    this.type = registeredHook.eventType;
  }

  logError(err) {
    EventBus.publish("$stateService:defaultErrorHandler", err);
  }

  invokeHook() {
    const hook = this.registeredHook;
    if (hook._deregistered) return;
    const notCurrent = this.getNotCurrentRejection();
    if (notCurrent) return notCurrent;
    const options = this.options;
    trace.traceHookInvocation(this, this.transition, options);
    const invokeCallback = () =>
      hook.callback.call(options.bind, this.transition, this.stateContext);
    const normalizeErr = (err) => Rejection.normalize(err).toPromise();
    const handleError = (err) => hook.eventType.getErrorHandler(this)(err);
    const handleResult = (result) =>
      hook.eventType.getResultHandler(this)(result);
    try {
      const result = invokeCallback();
      if (!this.type.synchronous && isPromise(result)) {
        return result.catch(normalizeErr).then(handleResult, handleError);
      } else {
        return handleResult(result);
      }
    } catch (err) {
      // If callback throws (synchronously)
      return handleError(Rejection.normalize(err));
    } finally {
      if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {
        hook.deregister();
      }
    }
  }
  /**
   * This method handles the return value of a Transition Hook.
   *
   * A hook can return false (cancel), a TargetState (redirect),
   * or a promise (which may later resolve to false or a redirect)
   *
   * This also handles "transition superseded" -- when a new transition
   * was started while the hook was still running
   */
  handleHookResult(result) {
    const notCurrent = this.getNotCurrentRejection();
    if (notCurrent) return notCurrent;
    // Hook returned a promise
    if (isPromise(result)) {
      // Wait for the promise, then reprocess with the resulting value
      return result.then((val) => this.handleHookResult(val));
    }
    trace.traceHookResult(result, this.transition);
    // Hook returned false
    if (result === false) {
      // Abort this Transition
      return Rejection.aborted("Hook aborted transition").toPromise();
    }

    // hook returned a TargetState
    if (result instanceof TargetState) {
      // Halt the current Transition and redirect (a new Transition) to the TargetState.
      return Rejection.redirected(result).toPromise();
    }
  }
  /**
   * Return a Rejection promise if the transition is no longer current due
   * a new transition has started and superseded this one.
   */
  getNotCurrentRejection() {
    if (this.transition._aborted) {
      return Rejection.aborted().toPromise();
    }
    // This transition is no longer current.
    // Another transition started while this hook was still running.
    if (this.isSuperseded()) {
      // Abort this transition
      return Rejection.superseded(this.options.current()).toPromise();
    }
  }
  toString() {
    const { options, registeredHook } = this;
    const event = parse("traceData.hookType")(options) || "internal",
      context =
        parse("traceData.context.state.name")(options) ||
        parse("traceData.context")(options) ||
        "unknown",
      name = fnToString(registeredHook.callback);
    return `${event} context: ${context}, ${maxLength(200, name)}`;
  }
}
/**
 * These GetResultHandler(s) are used by [[invokeHook]] below
 * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])
 */
TransitionHook.HANDLE_RESULT = (hook) => (result) =>
  hook.handleHookResult(result);
/**
 * If the result is a promise rejection, log it.
 * Otherwise, ignore the result.
 */
TransitionHook.LOG_REJECTED_RESULT = (hook) => (result) => {
  isPromise(result) &&
    result.catch((err) => hook.logError(Rejection.normalize(err)));
  return undefined;
};
/**
 * These GetErrorHandler(s) are used by [[invokeHook]] below
 * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])
 */
TransitionHook.LOG_ERROR = (hook) => (error) => hook.logError(error);
TransitionHook.REJECT_ERROR = () => (error) => silentRejection(error);
TransitionHook.THROW_ERROR = () => (error) => {
  throw error;
};

/**
 * Matches state names using glob-like pattern strings.
 *
 * Globs can be used in specific APIs including:
 *
 * - [[StateService.is]]
 * - [[StateService.includes]]
 * - The first argument to Hook Registration functions like [[TransitionService.onStart]]
 *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]
 *
 * A `Glob` string is a pattern which matches state names.
 * Nested state names are split into segments (separated by a dot) when processing.
 * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']
 *
 * Globs work according to the following rules:
 *
 * ### Exact match:
 *
 * The glob `'A.B'` matches the state named exactly `'A.B'`.
 *
 * | Glob        |Matches states named|Does not match state named|
 * |:------------|:--------------------|:---------------------|
 * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |
 * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |
 * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|
 *
 * ### Single star (`*`)
 *
 * A single star (`*`) is a wildcard that matches exactly one segment.
 *
 * | Glob        |Matches states named  |Does not match state named |
 * |:------------|:---------------------|:--------------------------|
 * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |
 * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |
 * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|
 *
 * ### Double star (`**`)
 *
 * A double star (`'**'`) is a wildcard that matches *zero or more segments*
 *
 * | Glob        |Matches states named                           |Does not match state named         |
 * |:------------|:----------------------------------------------|:----------------------------------|
 * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |
 * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |
 * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |
 * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |
 *
 * @packageDocumentation
 */
class Glob {
  /** Returns true if the string has glob-like characters in it */
  static is(text) {
    return !!/[!,*]+/.exec(text);
  }
  /** Returns a glob from the string, or null if the string isn't Glob-like */
  static fromString(text) {
    return Glob.is(text) ? new Glob(text) : null;
  }
  constructor(text) {
    this.text = text;
    this.glob = text.split(".");
    const regexpString = this.text
      .split(".")
      .map((seg) => {
        if (seg === "**") return "(?:|(?:\\.[^.]*)*)";
        if (seg === "*") return "\\.[^.]*";
        return "\\." + seg;
      })
      .join("");
    this.regexp = new RegExp("^" + regexpString + "$");
  }
  matches(name) {
    return this.regexp.test("." + name);
  }
}

/**
 * Determines if the given state matches the matchCriteria
 *
 * @internal
 *
 * @param state a State Object to test against
 * @param criterion
 * - If a string, matchState uses the string as a glob-matcher against the state name
 * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name
 *   and returns a positive match if any of the globs match.
 * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.
 * @returns {boolean}
 */
function matchState(state, criterion, transition) {
  const toMatch = isString(criterion) ? [criterion] : criterion;
  function matchGlobs(_state) {
    const globStrings = toMatch;
    for (let i = 0; i < globStrings.length; i++) {
      const glob = new Glob(globStrings[i]);
      if (
        (glob && glob.matches(_state.name)) ||
        (!glob && globStrings[i] === _state.name)
      ) {
        return true;
      }
    }
    return false;
  }
  const matchFn = isFunction(toMatch) ? toMatch : matchGlobs;
  return !!matchFn(state, transition);
}
/**
 * The registration data for a registered transition hook
 */
class RegisteredHook {
  constructor(
    tranSvc,
    eventType,
    callback,
    matchCriteria,
    removeHookFromRegistry,
    options = {},
  ) {
    this.tranSvc = tranSvc;
    this.eventType = eventType;
    this.callback = callback;
    this.matchCriteria = matchCriteria;
    this.removeHookFromRegistry = removeHookFromRegistry;
    this.invokeCount = 0;
    this._deregistered = false;
    this.priority = options.priority || 0;
    this.bind = options.bind || null;
    this.invokeLimit = options.invokeLimit;
  }
  /**
   * Gets the matching [[PathNode]]s
   *
   * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing
   * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.
   *
   * Returning `null` is significant to distinguish between the default
   * "match-all criterion value" of `true` compared to a `() => true` function,
   * when the nodes is an empty array.
   *
   * This is useful to allow a transition match criteria of `entering: true`
   * to still match a transition, even when `entering === []`.  Contrast that
   * with `entering: (state) => true` which only matches when a state is actually
   * being entered.
   */
  _matchingNodes(nodes, criterion, transition) {
    if (criterion === true) return nodes;
    const matching = nodes.filter((node) =>
      matchState(node.state, criterion, transition),
    );
    return matching.length ? matching : null;
  }
  /**
   * Gets the default match criteria (all `true`)
   *
   * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:
   *
   * ```js
   * {
   *   to: true,
   *   from: true,
   *   entering: true,
   *   exiting: true,
   *   retained: true,
   * }
   */
  _getDefaultMatchCriteria() {
    return map(this.tranSvc._pluginapi._getPathTypes(), () => true);
  }
  /**
   * Gets matching nodes as [[IMatchingNodes]]
   *
   * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:
   *
   * ```js
   * let matches: IMatchingNodes = {
   *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),
   *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),
   *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),
   *   retained: _matchingNodes(treeChanges.retained,     mc.retained),
   *   entering: _matchingNodes(treeChanges.entering,     mc.entering),
   * };
   * ```
   */
  _getMatchingNodes(treeChanges, transition) {
    const criteria = Object.assign(
      this._getDefaultMatchCriteria(),
      this.matchCriteria,
    );
    const paths = Object.values(this.tranSvc._pluginapi._getPathTypes());
    return paths.reduce((mn, pathtype) => {
      // STATE scope criteria matches against every node in the path.
      // TRANSITION scope criteria matches against only the last node in the path
      const isStateHook = pathtype.scope === TransitionHookScope.STATE;
      const path = treeChanges[pathtype.name] || [];
      const nodes = isStateHook ? path : [tail(path)];
      mn[pathtype.name] = this._matchingNodes(
        nodes,
        criteria[pathtype.name],
        transition,
      );
      return mn;
    }, {});
  }
  /**
   * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]
   *
   * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values
   * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)
   */
  matches(treeChanges, transition) {
    const matches = this._getMatchingNodes(treeChanges, transition);
    // Check if all the criteria matched the TreeChanges object
    const allMatched = Object.values(matches).every((x) => x);
    return allMatched ? matches : null;
  }
  deregister() {
    this.removeHookFromRegistry(this);
    this._deregistered = true;
  }
}
/** Return a registration function of the requested type. */
function makeEvent(registry, transitionService, eventType) {
  // Create the object which holds the registered transition hooks.
  const _registeredHooks = (registry._registeredHooks =
    registry._registeredHooks || {});
  const hooks = (_registeredHooks[eventType.name] = []);
  const removeHookFn = removeFrom(hooks);
  // Create hook registration function on the IHookRegistry for the event
  registry[eventType.name] = hookRegistrationFn;
  function hookRegistrationFn(matchObject, callback, options = {}) {
    const registeredHook = new RegisteredHook(
      transitionService,
      eventType,
      callback,
      matchObject,
      removeHookFn,
      options,
    );
    hooks.push(registeredHook);
    return registeredHook.deregister.bind(registeredHook);
  }
  return hookRegistrationFn;
}

/**
 * This class returns applicable TransitionHooks for a specific Transition instance.
 *
 * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.
 * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is
 * determined by the type of hook)
 *
 * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.
 *
 * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder
 * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private
 * in the Transition class, so we must also provide the Transition's _treeChanges)
 */
class HookBuilder {
  constructor(transition) {
    this.transition = transition;
  }

  /**
   * @param {TransitionHookPhase} phase
   * @returns
   */
  buildHooksForPhase(phase) {
    return this.transition.transitionService._pluginapi
      ._getEvents(phase)
      .map((type) => this.buildHooks(type))
      .reduce(unnestR, [])
      .filter(Boolean);
  }

  /**
   * Returns an array of newly built TransitionHook objects.
   *
   * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].
   * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)
   * - For each of the [[PathNode]]s, creates a TransitionHook
   *
   * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.
   */
  buildHooks(hookType) {
    const transition = this.transition;
    const treeChanges = transition.treeChanges();
    // Find all the matching registered hooks for a given hook type
    const matchingHooks = this.getMatchingHooks(
      hookType,
      treeChanges,
      transition,
    );
    if (!matchingHooks) return [];
    const baseHookOptions = {
      transition: transition,
      current: transition.options().current,
    };
    const makeTransitionHooks = (hook) => {
      // Fetch the Nodes that caused this hook to match.
      const matches = hook.matches(treeChanges, transition);
      // Select the PathNode[] that will be used as TransitionHook context objects
      const matchingNodes = matches[hookType.criteriaMatchPath.name];
      // Return an array of HookTuples
      return matchingNodes.map((node) => {
        const _options = Object.assign(
          {
            bind: hook.bind,
            traceData: { hookType: hookType.name, context: node },
          },
          baseHookOptions,
        );
        const state =
          hookType.criteriaMatchPath.scope === TransitionHookScope.STATE
            ? node.state.self
            : null;
        const transitionHook = new TransitionHook(
          transition,
          state,
          hook,
          _options,
        );
        return { hook, node, transitionHook };
      });
    };
    return matchingHooks
      .map(makeTransitionHooks)
      .reduce(unnestR, [])
      .sort(tupleSort(hookType.reverseSort))
      .map((tuple) => tuple.transitionHook);
  }
  /**
   * Finds all RegisteredHooks from:
   * - The Transition object instance hook registry
   * - The TransitionService ($transitions) global hook registry
   *
   * which matched:
   * - the eventType
   * - the matchCriteria (to, from, exiting, retained, entering)
   *
   * @returns an array of matched [[RegisteredHook]]s
   */
  getMatchingHooks(hookType, treeChanges, transition) {
    const isCreate = hookType.hookPhase === TransitionHookPhase.CREATE;
    // Instance and Global hook registries
    const $transitions = this.transition.transitionService;
    const registries = isCreate
      ? [$transitions]
      : [this.transition, $transitions];
    return registries
      .map((reg) => reg.getHooks(hookType.name)) // Get named hooks from registries
      .filter(
        assertPredicate(Array.isArray, `broken event named: ${hookType.name}`),
      ) // Sanity check
      .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array
      .filter((hook) => hook.matches(treeChanges, transition)); // Only those satisfying matchCriteria
  }
}
/**
 * A factory for a sort function for HookTuples.
 *
 * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares
 * the EventHook priority.
 *
 * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth
 * @returns a tuple sort function
 */
function tupleSort(reverseDepthSort = false) {
  return function nodeDepthThenPriority(l, r) {
    const factor = reverseDepthSort ? -1 : 1;
    const depthDelta =
      (l.node.state.path.length - r.node.state.path.length) * factor;
    return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;
  };
}

/**
 * Represents a transition between two states.
 *
 * When navigating to a state, we are transitioning **from** the current state **to** the new state.
 *
 * This object contains all contextual information about the to/from states, parameters, resolves.
 * It has information about all states being entered and exited as a result of the transition.
 */
class Transition {
  /**
   * Creates a new Transition object.
   *
   * If the target state is not valid, an error is thrown.
   *
   * @internal
   *
   * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`
   *        encapsulates the "from state".
   * @param targetState The target state and parameters being transitioned to (also, the transition options)
   * @param {import('../transition/transition-service.js').TransitionProvider} transitionService The [[TransitionService]] instance
   * @internal
   */
  constructor(fromPath, targetState, transitionService, globals) {
    this.globals = globals;
    this.transitionService = transitionService;
    this._deferred = Promise.withResolvers();
    /**
     * This promise is resolved or rejected based on the outcome of the Transition.
     *
     * When the transition is successful, the promise is resolved
     * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error
     */
    this.promise = this._deferred.promise;
    /** @internal Holds the hook registration functions such as those passed to Transition.onStart() */
    this._registeredHooks = {};

    this._hookBuilder = new HookBuilder(this);
    /** Checks if this transition is currently active/running. */
    this.isActive = () => this.globals.transition === this;
    this._targetState = targetState;
    if (!targetState.valid()) {
      throw new Error(targetState.error());
    }
    // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.
    this._options = Object.assign(
      { current: val(this) },
      targetState.options(),
    );
    this.$id = transitionService._transitionCount++;
    const toPath = PathUtils.buildToPath(fromPath, targetState);
    this._treeChanges = PathUtils.treeChanges(
      fromPath,
      toPath,
      this._options.reloadState,
    );
    this.createTransitionHookRegFns();
    const onCreateHooks = this._hookBuilder.buildHooksForPhase(
      TransitionHookPhase.CREATE,
    );
    TransitionHook.invokeHooks(onCreateHooks, () => null);
    this.applyViewConfigs();
  }

  /**
   * Creates the transition-level hook registration functions
   * (which can then be used to register hooks)
   */
  createTransitionHookRegFns() {
    this.transitionService._pluginapi
      ._getEvents()
      .filter((type) => type.hookPhase !== TransitionHookPhase.CREATE)
      .forEach((type) => makeEvent(this, this.transitionService, type));
  }

  getHooks(hookName) {
    return this._registeredHooks[hookName];
  }

  applyViewConfigs() {
    const enteringStates = this._treeChanges.entering.map((node) => node.state);
    PathUtils.applyViewConfigs(
      this.transitionService.$view,
      this._treeChanges.to,
      enteringStates,
    );
  }
  /**
   * @internal
   * @returns the internal from [State] object
   */
  $from() {
    return tail(this._treeChanges.from).state;
  }
  /**
   * @internal
   * @returns the internal to [State] object
   */
  $to() {
    return tail(this._treeChanges.to).state;
  }
  /**
   * Returns the "from state"
   *
   * Returns the state that the transition is coming *from*.
   *
   * @returns The state declaration object for the Transition's ("from state").
   */
  from() {
    return this.$from().self;
  }
  /**
   * Returns the "to state"
   *
   * Returns the state that the transition is going *to*.
   *
   * @returns The state declaration object for the Transition's target state ("to state").
   */
  to() {
    return this.$to().self;
  }
  /**
   * Gets the Target State
   *
   * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.
   *
   * @returns the [[TargetState]] of this Transition
   */
  targetState() {
    return this._targetState;
  }
  /**
   * Determines whether two transitions are equivalent.
   * @deprecated
   */
  is(compare) {
    if (compare instanceof Transition) {
      // TODO: Also compare parameters
      return this.is({ to: compare.$to().name, from: compare.$from().name });
    }
    return !(
      (compare.to && !matchState(this.$to(), compare.to, this)) ||
      (compare.from && !matchState(this.$from(), compare.from, this))
    );
  }
  params(pathname = "to") {
    return Object.freeze(
      this._treeChanges[pathname]
        .map((x) => x.paramValues)
        .reduce((acc, obj) => ({ ...acc, ...obj }), {}),
    );
  }
  paramsChanged() {
    const fromParams = this.params("from");
    const toParams = this.params("to");
    // All the parameters declared on both the "to" and "from" paths
    const allParamDescriptors = []
      .concat(this._treeChanges.to)
      .concat(this._treeChanges.from)
      .map((pathNode) => pathNode.paramSchema)
      .reduce(flattenR, [])
      .reduce(uniqR, []);
    const changedParamDescriptors = Param.changed(
      allParamDescriptors,
      fromParams,
      toParams,
    );
    return changedParamDescriptors.reduce((changedValues, descriptor) => {
      changedValues[descriptor.id] = toParams[descriptor.id];
      return changedValues;
    }, {});
  }
  /**
   * Creates a [[UIInjector]] Dependency Injector
   *
   * Returns a Dependency Injector for the Transition's target state (to state).
   * The injector provides resolve values which the target state has access to.
   *
   * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).
   *
   * #### Example:
   * ```js
   * .onEnter({ entering: 'myState' }, trans => {
   *   var myResolveValue = trans.injector().get('myResolve');
   *   // Inject a global service from the global/native injector (if it exists)
   *   var MyService = trans.injector().get('MyService');
   * })
   * ```
   *
   * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.
   * You can use [[UIInjector.getAsync]] to get a promise for the data.
   * #### Example:
   * ```js
   * .onBefore({}, trans => {
   *   return trans.injector().getAsync('myResolve').then(myResolveValue =>
   *     return myResolveValue !== 'ABORT';
   *   });
   * });
   * ```
   *
   * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.
   * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.
   * #### Example:
   * ```js
   * .onEnter({ to: 'foo.bar' }, trans => {
   *   // returns result of `foo` state's `myResolve` resolve
   *   // even though `foo.bar` also has a `myResolve` resolve
   *   var fooData = trans.injector('foo').get('myResolve');
   * });
   * ```
   *
   * If you need resolve data from the exiting states, pass `'from'` as `pathName`.
   * The resolve data from the `from` path will be returned.
   * #### Example:
   * ```js
   * .onExit({ exiting: 'foo.bar' }, trans => {
   *   // Gets the resolve value of `myResolve` from the state being exited
   *   var fooData = trans.injector(null, 'from').get('myResolve');
   * });
   * ```
   *
   *
   * @param state Limits the resolves provided to only the resolves the provided state has access to.
   * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.
   *
   * @returns a [[UIInjector]]
   */
  injector(state, pathName = "to") {
    let path = this._treeChanges[pathName];
    if (state)
      path = PathUtils.subPath(
        path,
        (node) => node.state === state || node.state.name === state,
      );
    return new ResolveContext(path).injector();
  }
  /**
   * Gets all available resolve tokens (keys)
   *
   * This method can be used in conjunction with [[injector]] to inspect the resolve values
   * available to the Transition.
   *
   * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states
   * in the Transition's [[TreeChanges.to]] path.
   *
   * #### Example:
   * This example logs all resolve values
   * ```js
   * let tokens = trans.getResolveTokens();
   * tokens.forEach(token => console.log(token + " = " + trans.injector().get(token)));
   * ```
   *
   * #### Example:
   * This example creates promises for each resolve value.
   * This triggers fetches of resolves (if any have not yet been fetched).
   * When all promises have all settled, it logs the resolve values.
   * ```js
   * let tokens = trans.getResolveTokens();
   * let promise = tokens.map(token => trans.injector().getAsync(token));
   * Promise.all(promises).then(values => console.log("Resolved values: " + values));
   * ```
   *
   * Note: Angular 1 users whould use `$q.all()`
   *
   * @param pathname resolve context's path name (e.g., `to` or `from`)
   *
   * @returns an array of resolve tokens (keys)
   */
  getResolveTokens(pathname = "to") {
    return new ResolveContext(this._treeChanges[pathname]).getTokens();
  }
  /**
   * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.
   *
   * Allows a transition hook to dynamically add a Resolvable to this Transition.
   *
   * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).
   *
   * If a `state` argument is provided, the Resolvable is processed when that state is being entered.
   * If no `state` is provided then the root state is used.
   * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.
   * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.
   *
   * The `state` argument also scopes the resolved data.
   * The resolved data is available from the injector for that `state` and any children states.
   *
   * #### Example:
   * ```js
   * transitionService.onBefore({}, transition => {
   *   transition.addResolvable({
   *     token: 'myResolve',
   *     deps: ['MyService'],
   *     resolveFn: myService => myService.getData()
   *   });
   * });
   * ```
   *
   * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])
   * @param state the state in the "to path" which should receive the new resolve (otherwise, the root state)
   */
  addResolvable(resolvable, state) {
    if (state === void 0) {
      state = "";
    }
    resolvable = is(Resolvable)(resolvable)
      ? resolvable
      : new Resolvable(resolvable);
    const stateName = typeof state === "string" ? state : state.name;
    const topath = this._treeChanges.to;
    const targetNode = find(topath, (node) => {
      return node.state.name === stateName;
    });
    assert(!!targetNode, `targetNode not found ${stateName}`);
    const resolveContext = new ResolveContext(topath);
    resolveContext.addResolvables([resolvable], targetNode.state);
  }
  /**
   * Gets the transition from which this transition was redirected.
   *
   * If the current transition is a redirect, this method returns the transition that was redirected.
   *
   * #### Example:
   * ```js
   * let transitionA = $state.go('A').transition
   * transitionA.onStart({}, () => $state.target('B'));
   * $transitions.onSuccess({ to: 'B' }, (trans) => {
   *   trans.to().name === 'B'; // true
   *   trans.redirectedFrom() === transitionA; // true
   * });
   * ```
   *
   * @returns The previous Transition, or null if this Transition is not the result of a redirection
   */
  redirectedFrom() {
    return this._options.redirectedFrom || null;
  }
  /**
   * Gets the original transition in a redirect chain
   *
   * A transition might belong to a long chain of multiple redirects.
   * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.
   *
   * #### Example:
   * ```js
   * // states
   * registry.register({ name: 'A', redirectTo: 'B' });
   * registry.register({ name: 'B', redirectTo: 'C' });
   * registry.register({ name: 'C', redirectTo: 'D' });
   * registry.register({ name: 'D' });
   *
   * let transitionA = $state.go('A').transition
   *
   * $transitions.onSuccess({ to: 'D' }, (trans) => {
   *   trans.to().name === 'D'; // true
   *   trans.redirectedFrom().to().name === 'C'; // true
   *   trans.originalTransition() === transitionA; // true
   *   trans.originalTransition().to().name === 'A'; // true
   * });
   * ```
   *
   * @returns The original Transition that started a redirect chain
   */
  originalTransition() {
    const rf = this.redirectedFrom();
    return (rf && rf.originalTransition()) || this;
  }
  /**
   * Get the transition options
   *
   * @returns the options for this Transition.
   */
  options() {
    return this._options;
  }
  /**
   * Gets the states being entered.
   *
   * @returns an array of states that will be entered during this transition.
   */
  entering() {
    return map(this._treeChanges.entering, (x) => x.state).map((x) => x.self);
  }
  /**
   * Gets the states being exited.
   *
   * @returns an array of states that will be exited during this transition.
   */
  exiting() {
    return map(this._treeChanges.exiting, (x) => x.state)
      .map((x) => x.self)
      .reverse();
  }
  /**
   * Gets the states being retained.
   *
   * @returns an array of states that are already entered from a previous Transition, that will not be
   *    exited during this Transition
   */
  retained() {
    return map(this._treeChanges.retained, (x) => x.state).map((x) => x.self);
  }
  /**
   * Get the [[ViewConfig]]s associated with this Transition
   *
   * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.
   * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., "to" or "entering").
   *
   * @param pathname the name of the path to fetch views for:
   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)
   * @param state If provided, only returns the `ViewConfig`s for a single state in the path
   *
   * @returns a list of ViewConfig objects for the given path.
   */
  views(pathname = "entering", state) {
    let path = this._treeChanges[pathname];
    path = !state ? path : path.filter(propEq("state", state));
    return path.map((x) => x.views).reduce(unnestR, []);
  }
  treeChanges(pathname) {
    return pathname ? this._treeChanges[pathname] : this._treeChanges;
  }
  /**
   * Creates a new transition that is a redirection of the current one.
   *
   * This transition can be returned from a [[TransitionService]] hook to
   * redirect a transition to a new state and/or set of parameters.
   *
   * @internal
   *
   * @returns Returns a new [[Transition]] instance.
   */
  redirect(targetState) {
    let redirects = 1,
      trans = this;
    while ((trans = trans.redirectedFrom()) != null) {
      if (++redirects > 20)
        throw new Error(`Too many consecutive Transition redirects (20+)`);
    }
    const redirectOpts = { redirectedFrom: this, source: "redirect" };
    // If the original transition was caused by URL sync, then use { location: 'replace' }
    // on the new transition (unless the target state explicitly specifies location: false).
    // This causes the original url to be replaced with the url for the redirect target
    // so the original url disappears from the browser history.
    if (
      this.options().source === "url" &&
      targetState.options().location !== false
    ) {
      redirectOpts.location = "replace";
    }
    const newOptions = Object.assign(
      {},
      this.options(),
      targetState.options(),
      redirectOpts,
    );
    targetState = targetState.withOptions(newOptions, true);
    const newTransition = this.transitionService.create(
      this._treeChanges.from,
      targetState,
    );
    const originalEnteringNodes = this._treeChanges.entering;
    const redirectEnteringNodes = newTransition._treeChanges.entering;
    // --- Re-use resolve data from original transition ---
    // When redirecting from a parent state to a child state where the parent parameter values haven't changed
    // (because of the redirect), the resolves fetched by the original transition are still valid in the
    // redirected transition.
    //
    // This allows you to define a redirect on a parent state which depends on an async resolve value.
    // You can wait for the resolve, then redirect to a child state based on the result.
    // The redirected transition does not have to re-fetch the resolve.
    // ---------------------------------------------------------
    const nodeIsReloading = (reloadState) => (node) => {
      return reloadState && node.state.includes[reloadState.name];
    };
    // Find any "entering" nodes in the redirect path that match the original path and aren't being reloaded
    const matchingEnteringNodes = PathUtils.matching(
      redirectEnteringNodes,
      originalEnteringNodes,
      PathUtils.nonDynamicParams,
    ).filter((x) => !nodeIsReloading(targetState.options().reloadState)(x));
    // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.
    matchingEnteringNodes.forEach((node, idx) => {
      node.resolvables = originalEnteringNodes[idx].resolvables;
    });
    return newTransition;
  }
  /** @internal If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */
  _changedParams() {
    const tc = this._treeChanges;
    /** Return undefined if it's not a "dynamic" transition, for the following reasons */
    // If user explicitly wants a reload
    if (this._options.reload) return undefined;
    // If any states are exiting or entering
    if (tc.exiting.length || tc.entering.length) return undefined;
    // If to/from path lengths differ
    if (tc.to.length !== tc.from.length) return undefined;
    // If the to/from paths are different
    const pathsDiffer = arrayTuples(tc.to, tc.from)
      .map((tuple) => tuple[0].state !== tuple[1].state)
      .reduce(anyTrueR, false);
    if (pathsDiffer) return undefined;
    // Find any parameter values that differ
    const nodeSchemas = tc.to.map((node) => node.paramSchema);
    const [toValues, fromValues] = [tc.to, tc.from].map((path) =>
      path.map((x) => x.paramValues),
    );
    const tuples = arrayTuples(nodeSchemas, toValues, fromValues);
    return tuples
      .map(([schema, toVals, fromVals]) =>
        Param.changed(schema, toVals, fromVals),
      )
      .reduce(unnestR, []);
  }
  /**
   * Returns true if the transition is dynamic.
   *
   * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.
   *
   * @returns true if the Transition is dynamic
   */
  dynamic() {
    const changes = this._changedParams();
    return !changes
      ? false
      : changes.map((x) => x.dynamic).reduce(anyTrueR, false);
  }
  /**
   * Returns true if the transition is ignored.
   *
   * A transition is ignored if no states are entered nor exited, and no parameter values have changed.
   *
   * @returns true if the Transition is ignored.
   */
  ignored() {
    return !!this._ignoredReason();
  }

  _ignoredReason() {
    const pending = this.globals.transition;
    const reloadState = this._options.reloadState;
    const same = (pathA, pathB) => {
      if (pathA.length !== pathB.length) return false;
      const matching = PathUtils.matching(pathA, pathB);
      return (
        pathA.length ===
        matching.filter(
          (node) => !reloadState || !node.state.includes[reloadState.name],
        ).length
      );
    };
    const newTC = this.treeChanges();
    const pendTC = pending && pending.treeChanges();
    if (
      pendTC &&
      same(pendTC.to, newTC.to) &&
      same(pendTC.exiting, newTC.exiting)
    )
      return "SameAsPending";
    if (
      newTC.exiting.length === 0 &&
      newTC.entering.length === 0 &&
      same(newTC.from, newTC.to)
    )
      return "SameAsCurrent";
  }
  /**
   * Runs the transition
   *
   * This method is generally called from the [[StateService.transitionTo]]
   *
   * @internal
   *
   * @returns a promise for a successful transition.
   */
  run() {
    // Gets transition hooks array for the given phase
    const getHooksFor = (phase) => this._hookBuilder.buildHooksForPhase(phase);
    // When the chain is complete, then resolve or reject the deferred
    const transitionSuccess = () => {
      trace.traceSuccess(this.$to(), this);
      this.success = true;
      this._deferred.resolve(this.to());
      const hooks = this._hookBuilder.buildHooksForPhase(
        TransitionHookPhase.SUCCESS,
      );
      hooks.forEach((hook) => {
        hook.invokeHook();
      });
    };

    const transitionError = (reason) => {
      trace.traceError(reason, this);
      this.success = false;
      this._deferred.reject(reason);
      this._error = reason;
      const hooks = getHooksFor(TransitionHookPhase.ERROR);
      hooks.forEach((hook) => hook.invokeHook());
    };

    const runTransition = () => {
      // Wait to build the RUN hook chain until the BEFORE hooks are done
      // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.
      const allRunHooks = getHooksFor(TransitionHookPhase.RUN);
      const resolved = Promise.resolve();
      return TransitionHook.invokeHooks(allRunHooks, () => resolved);
    };
    const startTransition = () => {
      const globals = this.globals;
      globals.lastStartedTransitionId = this.$id;
      globals.transition = this;
      globals.transitionHistory.enqueue(this);
      trace.traceTransitionStart(this);
      return Promise.resolve();
    };
    const allBeforeHooks = getHooksFor(TransitionHookPhase.BEFORE);
    TransitionHook.invokeHooks(allBeforeHooks, startTransition)
      .then(runTransition)
      .then(transitionSuccess, transitionError);
    return this.promise;
  }
  /**
   * Checks if the Transition is valid
   *
   * @returns true if the Transition is valid
   */
  valid() {
    return !this.error() || this.success !== undefined;
  }
  /**
   * Aborts this transition
   *
   * Imperative API to abort a Transition.
   * This only applies to Transitions that are not yet complete.
   */
  abort() {
    // Do not set flag if the transition is already complete
    if (isUndefined(this.success)) {
      this._aborted = true;
    }
  }
  /**
   * The Transition error reason.
   *
   * If the transition is invalid (and could not be run), returns the reason the transition is invalid.
   * If the transition was valid and ran, but was not successful, returns the reason the transition failed.
   *
   * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.
   */
  error() {
    const state = this.$to();
    if (state.self.abstract) {
      return Rejection.invalid(
        `Cannot transition to abstract state '${state.name}'`,
      );
    }
    const paramDefs = state.parameters();
    const values = this.params();
    const invalidParams = paramDefs.filter(
      (param) => !param.validates(values[param.id]),
    );
    if (invalidParams.length) {
      const invalidValues = invalidParams
        .map((param) => `[${param.id}:${stringify(values[param.id])}]`)
        .join(", ");
      const detail = `The following parameter values are not valid for state '${state.name}': ${invalidValues}`;
      return Rejection.invalid(detail);
    }
    if (this.success === false) return this._error;
  }
  /**
   * A string representation of the Transition
   *
   * @returns A string representation of the Transition
   */
  toString() {
    const fromStateOrName = this.from();
    const toStateOrName = this.to();
    const avoidEmptyHash = (params) =>
      params["#"] !== null && params["#"] !== undefined
        ? params
        : omit(params, ["#"]);
    // (X) means the to state is invalid.
    const id = this.$id,
      from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName,
      fromParams = stringify(
        avoidEmptyHash(
          this._treeChanges.from
            .map((x) => x.paramValues)
            .reduce((acc, obj) => ({ ...acc, ...obj }), {}),
        ),
      ),
      toValid = this.valid() ? "" : "(X) ",
      to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName,
      toParams = stringify(avoidEmptyHash(this.params()));
    return `Transition#${id}( '${from}'${fromParams} -> ${toValid}'${to}'${toParams} )`;
  }
}

Transition.diToken = Transition;

function registerAddCoreResolvables(transitionService) {
  transitionService.onCreate({}, function addCoreResolvables(trans) {
    trans.addResolvable(Resolvable.fromData(Transition, trans), "");
    trans.addResolvable(Resolvable.fromData("$transition$", trans), "");
    trans.addResolvable(
      Resolvable.fromData("$stateParams", trans.params()),
      "",
    );
    trans.entering().forEach((state) => {
      trans.addResolvable(Resolvable.fromData("$state$", state), state);
    });
  });
}

const TRANSITION_TOKENS = ["$transition$", Transition];

// References to Transition in the treeChanges pathnodes makes all
// previous Transitions reachable in memory, causing a memory leak
// This function removes resolves for '$transition$' and `Transition` from the treeChanges.
// Do not use this on current transitions, only on old ones.
function treeChangesCleanup(trans) {
  const nodes = Object.values(trans.treeChanges())
    .reduce(unnestR, [])
    .reduce(uniqR, []);
  // If the resolvable is a Transition, return a new resolvable with null data
  const replaceTransitionWithNull = (r) => {
    return TRANSITION_TOKENS.includes(r.token)
      ? Resolvable.fromData(r.token, null)
      : r;
  };
  nodes.forEach((node) => {
    node.resolvables = node.resolvables.map(replaceTransitionWithNull);
  });
}

/**
 * A factory which creates an onEnter, onExit or onRetain transition hook function
 *
 * The returned function invokes the (for instance) state.onEnter hook when the
 * state is being entered.
 */
function makeEnterExitRetainHook(hookName) {
  return (transition, state) => {
    const _state = state.$$state();
    const hookFn = _state[hookName];
    return hookFn(transition, state);
  };
}
/**
 * The [[TransitionStateHookFn]] for onExit
 *
 * When the state is being exited, the state's .onExit function is invoked.
 *
 * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`
 *
 * See: [[IHookRegistry.onExit]]
 */
const onExitHook = makeEnterExitRetainHook("onExit");
const registerOnExitHook = (transitionService) =>
  transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);
/**
 * The [[TransitionStateHookFn]] for onRetain
 *
 * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.
 *
 * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`
 *
 * See: [[IHookRegistry.onRetain]]
 */
const onRetainHook = makeEnterExitRetainHook("onRetain");
const registerOnRetainHook = (transitionService) =>
  transitionService.onRetain(
    { retained: (state) => !!state.onRetain },
    onRetainHook,
  );
/**
 * The [[TransitionStateHookFn]] for onEnter
 *
 * When the state is being entered, the state's .onEnter function is invoked.
 *
 * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`
 *
 * See: [[IHookRegistry.onEnter]]
 */
const onEnterHook = makeEnterExitRetainHook("onEnter");
const registerOnEnterHook = (transitionService) =>
  transitionService.onEnter(
    { entering: (state) => !!state.onEnter },
    onEnterHook,
  );

const RESOLVE_HOOK_PRIORITY = 1000;
/**
 * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path
 *
 * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`
 *
 * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.
 *
 * See [[StateDeclaration.resolve]]
 */
const eagerResolvePath = (trans) =>
  new ResolveContext(trans.treeChanges().to)
    .resolvePath("EAGER", trans)
    .then(() => {});
const registerEagerResolvePath = (transitionService) =>
  transitionService.onStart({}, eagerResolvePath, {
    priority: RESOLVE_HOOK_PRIORITY,
  });
/**
 * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path
 *
 * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`
 *
 * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.
 *
 * See [[StateDeclaration.resolve]]
 */
const lazyResolveState = (trans, state) =>
  new ResolveContext(trans.treeChanges().to)
    .subContext(state.$$state())
    .resolvePath("LAZY", trans)
    .then(() => {});
const registerLazyResolveState = (transitionService) =>
  transitionService.onEnter({ entering: val(true) }, lazyResolveState, {
    priority: RESOLVE_HOOK_PRIORITY,
  });
/**
 * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.
 *
 * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`
 *
 * After all entering states have been entered, this hook resolves any remaining Resolvables.
 * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].
 *
 * See [[StateDeclaration.resolve]]
 */
const resolveRemaining = (trans) =>
  new ResolveContext(trans.treeChanges().to)
    .resolvePath("LAZY", trans)
    .then(() => {});
const registerResolveRemaining = (transitionService) =>
  transitionService.onFinish({}, resolveRemaining, {
    priority: RESOLVE_HOOK_PRIORITY,
  });

/**
 * A [[TransitionHookFn]] which waits for the views to load
 *
 * Registered using `transitionService.onStart({}, loadEnteringViews);`
 *
 * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.
 * In angular 1, this includes loading the templates.
 */
const loadEnteringViews = (transition) => {
  const enteringViews = transition.views("entering");
  if (!enteringViews.length) return;
  return Promise.all(
    enteringViews.map((view) => Promise.resolve(view.load())),
  ).then(() => {});
};
const registerLoadEnteringViews = (transitionService) =>
  transitionService.onFinish({}, loadEnteringViews);

const registerActivateViews = (transitionService, viewService) => {
  /**
   * A [[TransitionHookFn]] which activates the new views when a transition is successful.
   *
   * Registered using `transitionService.onSuccess({}, activateViews);`
   *
   * After a transition is complete, this hook deactivates the old views from the previous state,
   * and activates the new views from the destination state.
   *
   * See [[ViewService]]
   */
  const activateViews = (transition) => {
    const enteringViews = transition.views("entering");
    const exitingViews = transition.views("exiting");
    if (!enteringViews.length && !exitingViews.length) return;
    exitingViews.forEach((vc) => viewService.deactivateViewConfig(vc));
    enteringViews.forEach((vc) => {
      viewService.activateViewConfig(vc);
    });
    viewService.sync();
  };
  transitionService.onSuccess({}, activateViews);
};

/**
 * A [[TransitionHookFn]] which updates global ng-router state
 *
 * Registered using `transitionService.onBefore({}, updateGlobalState);`
 *
 * Before a [[Transition]] starts, updates the global value of "the current transition" ([[Globals.transition]]).
 * After a successful [[Transition]], updates the global values of "the current state"
 * ([[Globals.current]] and [[Globals.$current]]) and "the current param values" ([[Globals.params]]).
 *
 * See also the deprecated properties:
 * [[StateService.transition]], [[StateService.current]], [[StateService.params]]
 */
const updateGlobalState = (trans) => {
  const globals = trans.globals;
  const transitionSuccessful = () => {
    globals.successfulTransitions.enqueue(trans);
    globals.$current = trans.$to();
    globals.current = globals.$current.self;
    copy(trans.params(), globals.params);
  };
  const clearCurrentTransition = () => {
    // Do not clear globals.transition if a different transition has started in the meantime
    if (globals.transition === trans) globals.transition = null;
  };
  trans.onSuccess({}, transitionSuccessful, { priority: 10000 });
  trans.promise.then(clearCurrentTransition, clearCurrentTransition);
};

const registerUpdateGlobalState = (transitionService) =>
  transitionService.onCreate({}, updateGlobalState);

/**
 * A [[TransitionHookFn]] that performs lazy loading
 *
 * When entering a state "abc" which has a `lazyLoad` function defined:
 * - Invoke the `lazyLoad` function (unless it is already in process)
 *   - Flag the hook function as "in process"
 *   - The function should return a promise (that resolves when lazy loading is complete)
 * - Wait for the promise to settle
 *   - If the promise resolves to a [[LazyLoadResult]], then register those states
 *   - Flag the hook function as "not in process"
 * - If the hook was successful
 *   - Remove the `lazyLoad` function from the state declaration
 * - If all the hooks were successful
 *   - Retry the transition (by returning a TargetState)
 *
 * ```
 * .state('abc', {
 *   component: 'fooComponent',
 *   lazyLoad: () => import('./fooComponent')
 *   });
 * ```
 *
 * See [[StateDeclaration.lazyLoad]]
 */
function registerLazyLoadHook(
  transitionService,
  stateService,
  urlService,
  stateRegistry,
) {
  return transitionService.onBefore(
    { entering: (state) => !!state.lazyLoad },
    (transition) => {
      function retryTransition() {
        if (transition.originalTransition().options().source !== "url") {
          // The original transition was not triggered via url sync
          // The lazy state should be loaded now, so re-try the original transition
          const orig = transition.targetState();
          return stateService.target(
            orig.identifier(),
            orig.params(),
            orig.options(),
          );
        }
        // The original transition was triggered via url sync
        // Run the URL rules and find the best match
        const result = urlService.match(urlService.parts());
        const rule = result && result.rule;
        // If the best match is a state, redirect the transition (instead
        // of calling sync() which supersedes the current transition)
        if (rule && rule.type === "STATE") {
          const state = rule.state;
          const params = result.match;
          return stateService.target(state, params, transition.options());
        }
        // No matching state found, so let .sync() choose the best non-state match/otherwise
        urlService.sync();
      }
      const promises = transition
        .entering()
        .filter((state) => !!state.$$state().lazyLoad)
        .map((state) => lazyLoadState(transition, state, stateRegistry));
      return Promise.all(promises).then(retryTransition);
    },
  );
}

/**
 * Invokes a state's lazy load function
 *
 * @param transition a Transition context
 * @param state the state to lazy load
 * @returns A promise for the lazy load result
 */
function lazyLoadState(transition, state, stateRegistry) {
  const lazyLoadFn = state.$$state().lazyLoad;
  // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked
  let promise = lazyLoadFn["_promise"];
  if (!promise) {
    const success = (result) => {
      delete state.lazyLoad;
      delete state.$$state().lazyLoad;
      delete lazyLoadFn["_promise"];
      return result;
    };
    const error = (err) => {
      delete lazyLoadFn["_promise"];
      return Promise.reject(err);
    };
    promise = lazyLoadFn["_promise"] = Promise.resolve(
      lazyLoadFn(transition, state),
    )
      .then(updateStateRegistry)
      .then(success, error);
  }
  /** Register any lazy loaded state definitions */
  function updateStateRegistry(result) {
    if (result && Array.isArray(result.states)) {
      result.states.forEach((_state) => stateRegistry.register(_state));
    }
    return result;
  }
  return promise;
}

/**
 * This class defines a type of hook, such as `onBefore` or `onEnter`.
 * Plugins can define custom hook types, such as sticky states does for `onInactive`.
 */
class TransitionEventType {
  constructor(
    name,
    hookPhase,
    hookOrder,
    criteriaMatchPath,
    reverseSort = false,
    getResultHandler = TransitionHook.HANDLE_RESULT,
    getErrorHandler = TransitionHook.REJECT_ERROR,
    synchronous = false,
  ) {
    this.name = name;
    this.hookPhase = hookPhase;
    this.hookOrder = hookOrder;
    this.criteriaMatchPath = criteriaMatchPath;
    this.reverseSort = reverseSort;
    this.getResultHandler = getResultHandler;
    this.getErrorHandler = getErrorHandler;
    this.synchronous = synchronous;
  }
}

/**
 * A [[TransitionHookFn]] that skips a transition if it should be ignored
 *
 * This hook is invoked at the end of the onBefore phase.
 *
 * If the transition should be ignored (because no parameter or states changed)
 * then the transition is ignored and not processed.
 */
function ignoredHook(trans) {
  const ignoredReason = trans._ignoredReason();
  if (!ignoredReason) return;
  trace.traceTransitionIgnored(trans);
  const pending = trans.globals.transition;
  // The user clicked a link going back to the *current state* ('A')
  // However, there is also a pending transition in flight (to 'B')
  // Abort the transition to 'B' because the user now wants to be back at 'A'.
  if (ignoredReason === "SameAsCurrent" && pending) {
    pending.abort();
  }
  return Rejection.ignored().toPromise();
}
const registerIgnoredTransitionHook = (transitionService) =>
  transitionService.onBefore({}, ignoredHook, { priority: -9999 });

/**
 * A [[TransitionHookFn]] that rejects the Transition if it is invalid
 *
 * This hook is invoked at the end of the onBefore phase.
 * If the transition is invalid (for example, param values do not validate)
 * then the transition is rejected.
 */
function invalidTransitionHook(trans) {
  if (!trans.valid()) {
    throw new Error(trans.error().toString());
  }
}
const registerInvalidTransitionHook = (transitionService) =>
  transitionService.onBefore({}, invalidTransitionHook, { priority: -1e4 });

const registerRedirectToHook = (transitionService, stateService) => {
  /**
   * A [[TransitionHookFn]] that redirects to a different state or params
   *
   * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`
   *
   * See [[StateDeclaration.redirectTo]]
   */
  const redirectToHook = (trans) => {
    const redirect = trans.to().redirectTo;
    if (!redirect) return;
    const $state = stateService;
    function handleResult(result) {
      if (!result) return;
      if (result instanceof TargetState) return result;
      if (isString(result))
        return $state.target(result, trans.params(), trans.options());
      if (result["state"] || result["params"])
        return $state.target(
          result["state"] || trans.to(),
          result["params"] || trans.params(),
          trans.options(),
        );
    }
    if (isFunction(redirect)) {
      return Promise.resolve(redirect(trans)).then(handleResult);
    }
    return handleResult(redirect);
  };

  transitionService.onStart(
    { to: (state) => !!state.redirectTo },
    redirectToHook,
  );
};

const registerUpdateUrl = (
  transitionService,
  stateService,
  urlService,
) => {
  /**
   * A [[TransitionHookFn]] which updates the URL after a successful transition
   *
   * Registered using `transitionService.onSuccess({}, updateUrl);`
   */
  const updateUrl = (transition) => {
    const options = transition.options();
    const $state = stateService;

    // Dont update the url in these situations:
    // The transition was triggered by a URL sync (options.source === 'url')
    // The user doesn't want the url to update (options.location === false)
    // The destination state, and all parents have no navigable url
    if (
      options.source !== "url" &&
      options.location &&
      $state.$current.navigable
    ) {
      const urlOptions = { replace: options.location === "replace" };
      urlService.push(
        $state.$current.navigable.url,
        $state.globals.params,
        urlOptions,
      );
    }
    urlService.update(true);
  };
  transitionService.onSuccess({}, updateUrl, { priority: 9999 });
};

/**
 * The default [[Transition]] options.
 *
 * Include this object when applying custom defaults:
 * let reloadOpts = { reload: true, notify: true }
 * let options = defaults(theirOpts, customDefaults, defaultOptions);
 */
let defaultTransOpts = {
  location: true,
  relative: null,
  inherit: false,
  notify: true,
  reload: false,
  supercede: true,
  custom: {},
  current: () => null,
  source: "unknown",
};
/**
 * This class provides services related to Transitions.
 *
 * - Most importantly, it allows global Transition Hooks to be registered.
 * - It allows the default transition error handler to be set.
 * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).
 *
 * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.
 *
 * This API is located at `router.transitionService` ([[UIRouter.transitionService]])
 */
class TransitionProvider {
  static $inject = ["$routerGlobalsProvider", "$viewProvider"];

  /**
   * @param {import('../globals').UIRouterGlobals} globals
   */
  constructor(globals, viewService) {
    this._transitionCount = 0;
    /** The transition hook types, such as `onEnter`, `onStart`, etc */
    this._eventTypes = [];
    /** @internal The registered transition hooks */
    this._registeredHooks = {};
    /** The  paths on a criteria object */
    this._criteriaPaths = {};
    this.globals = globals;
    this.$view = viewService;
    this._deregisterHookFns = {};
    this._pluginapi = createProxyFunctions(val(this), {}, val(this), [
      "_definePathType",
      "_defineEvent",
      "_getPathTypes",
      "_getEvents",
      "getHooks",
    ]);
    this._defineCorePaths();
    this._defineCoreEvents();
    this._registerCoreTransitionHooks();
    globals.successfulTransitions.onEvict(treeChangesCleanup);
  }

  $get = [
    "$state",
    "$urlService",
    "$stateRegistry",
    "$view",
    (stateService, urlService, stateRegistry, viewService) => {
      // Lazy load state trees
      this._deregisterHookFns.lazyLoad = registerLazyLoadHook(
        this,
        stateService,
        urlService,
        stateRegistry,
      );

      // After globals.current is updated at priority: 10000
      this._deregisterHookFns.updateUrl = registerUpdateUrl(
        this,
        stateService,
        urlService,
      );

      // Wire up redirectTo hook
      this._deregisterHookFns.redirectTo = registerRedirectToHook(
        this,
        stateService,
      );

      this._deregisterHookFns.activateViews = registerActivateViews(
        this,
        viewService,
      );
      return this;
    },
  ];
  /**
   * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.
   *
   * Registers a transition lifecycle hook, which is invoked during transition construction.
   *
   * This low level hook should only be used by plugins.
   * This can be a useful time for plugins to add resolves or mutate the transition as needed.
   * The Sticky States plugin uses this hook to modify the treechanges.
   *
   * ### Lifecycle
   *
   * `onCreate` hooks are invoked *while a transition is being constructed*.
   *
   * ### Return value
   *
   * The hook's return value is ignored
   *
   * @internal
   * @param criteria defines which Transitions the Hook should be invoked for.
   * @param callback the hook function which will be invoked.
   * @param options the registration options
   * @returns a function which deregisters the hook.
   */

  /**
   * Creates a new [[Transition]] object
   *
   * This is a factory function for creating new Transition objects.
   * It is used internally by the [[StateService]] and should generally not be called by application code.
   *
   * @internal
   * @param fromPath the path to the current state (the from state)
   * @param targetState the target state (destination)
   * @returns a Transition
   */
  create(fromPath, targetState) {
    return new Transition(fromPath, targetState, this, this.globals);
  }

  _defineCoreEvents() {
    const Phase = TransitionHookPhase;
    const TH = TransitionHook;
    const paths = this._criteriaPaths;
    const NORMAL_SORT = false,
      REVERSE_SORT = true;
    const SYNCHRONOUS = true;
    this._defineEvent(
      "onCreate",
      Phase.CREATE,
      0,
      paths.to,
      NORMAL_SORT,
      TH.LOG_REJECTED_RESULT,
      TH.THROW_ERROR,
      SYNCHRONOUS,
    );
    this._defineEvent("onBefore", Phase.BEFORE, 0, paths.to);
    this._defineEvent("onStart", Phase.RUN, 0, paths.to);
    this._defineEvent("onExit", Phase.RUN, 100, paths.exiting, REVERSE_SORT);
    this._defineEvent("onRetain", Phase.RUN, 200, paths.retained);
    this._defineEvent("onEnter", Phase.RUN, 300, paths.entering);
    this._defineEvent("onFinish", Phase.RUN, 400, paths.to);
    this._defineEvent(
      "onSuccess",
      Phase.SUCCESS,
      0,
      paths.to,
      NORMAL_SORT,
      TH.LOG_REJECTED_RESULT,
      TH.LOG_ERROR,
      SYNCHRONOUS,
    );
    this._defineEvent(
      "onError",
      Phase.ERROR,
      0,
      paths.to,
      NORMAL_SORT,
      TH.LOG_REJECTED_RESULT,
      TH.LOG_ERROR,
      SYNCHRONOUS,
    );
  }

  _defineCorePaths() {
    const { STATE, TRANSITION } = TransitionHookScope;
    this._definePathType("to", TRANSITION);
    this._definePathType("from", TRANSITION);
    this._definePathType("exiting", STATE);
    this._definePathType("retained", STATE);
    this._definePathType("entering", STATE);
  }

  _defineEvent(
    name,
    hookPhase,
    hookOrder,
    criteriaMatchPath,
    reverseSort = false,
    getResultHandler = TransitionHook.HANDLE_RESULT,
    getErrorHandler = TransitionHook.REJECT_ERROR,
    synchronous = false,
  ) {
    const eventType = new TransitionEventType(
      name,
      hookPhase,
      hookOrder,
      criteriaMatchPath,
      reverseSort,
      getResultHandler,
      getErrorHandler,
      synchronous,
    );
    this._eventTypes.push(eventType);
    makeEvent(this, this, eventType);
  }

  _getEvents(phase) {
    const transitionHookTypes = isDefined(phase)
      ? this._eventTypes.filter((type) => type.hookPhase === phase)
      : this._eventTypes.slice();
    return transitionHookTypes.sort((l, r) => {
      const cmpByPhase = l.hookPhase - r.hookPhase;
      return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;
    });
  }
  /**
   * Adds a Path to be used as a criterion against a TreeChanges path
   *
   * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.
   * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`
   * Each state in the exiting path is checked against the criteria and returned as part of the match.
   *
   * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.
   * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`
   * Only the tail of the `to` path is checked against the criteria and returned as part of the match.
   *
   * @internal
   */
  _definePathType(name, hookScope) {
    this._criteriaPaths[name] = { name, scope: hookScope };
  }

  _getPathTypes() {
    return this._criteriaPaths;
  }

  getHooks(hookName) {
    return this._registeredHooks[hookName];
  }

  _registerCoreTransitionHooks() {
    const fns = this._deregisterHookFns;
    fns.addCoreResolves = registerAddCoreResolvables(this);
    fns.ignored = registerIgnoredTransitionHook(this);
    fns.invalid = registerInvalidTransitionHook(this);

    // Wire up onExit/Retain/Enter state hooks
    fns.onExit = registerOnExitHook(this);
    fns.onRetain = registerOnRetainHook(this);
    fns.onEnter = registerOnEnterHook(this);
    // Wire up Resolve hooks
    fns.eagerResolve = registerEagerResolvePath(this);
    fns.lazyResolve = registerLazyResolveState(this);
    fns.resolveAll = registerResolveRemaining(this);
    // Wire up the View management hooks
    fns.loadViews = registerLoadEnteringViews(this);

    // Updates global state after a transition
    fns.updateGlobals = registerUpdateGlobalState(this);
    // Lazy load state trees
    fns.lazyLoad = registerLazyLoadHook(this);
  }
}

const err = minErr("$stateProvider");

/**
 * Provides services related to ng-router states.
 *
 * This API is located at `router.stateService` ([[UIRouter.stateService]])
 */
class StateProvider {
  /**
   * The latest successful state parameters
   *
   * @deprecated This is a passthrough through to [[UIRouterGlobals.params]]
   */
  get params() {
    return this.globals.params;
  }
  /**
   * The current [[StateDeclaration]]
   *
   * @deprecated This is a passthrough through to [[UIRouterGlobals.current]]
   */
  get current() {
    return this.globals.current;
  }
  /**
   * The current [[StateObject]] (an internal API)
   *
   * @deprecated This is a passthrough through to [[UIRouterGlobals.$current]]
   */
  get $current() {
    return this.globals.$current;
  }

  static $inject = ["$routerGlobalsProvider", "$transitionsProvider"];

  // Needs access to urlService, stateRegistry
  constructor(globals, transitionService) {
    this.stateRegistry = undefined;
    this.urlService = undefined;
    this.globals = globals;
    this.transitionService = transitionService;
    this.invalidCallbacks = [];

    this._defaultErrorHandler = function $defaultErrorHandler($error$) {
      if ($error$ instanceof Error && $error$.stack) {
        throw $error$;
      } else if ($error$ instanceof Rejection) {
        throw new Error($error$.toString());
      } else {
        throw new Error($error$);
      }
    };
    const getters = ["current", "$current", "params", "transition"];
    const boundFns = Object.keys(StateProvider.prototype).filter(
      (x) => !getters.includes(x),
    );
    createProxyFunctions(
      val(StateProvider.prototype),
      this,
      val(this),
      boundFns,
    );

    EventBus.subscribe("$stateService:defaultErrorHandler", (err) =>
      this.defaultErrorHandler()(err),
    );
  }

  $get = () => this;

  /**
   * Decorates states when they are registered
   *
   * Allows you to extend (carefully) or override (at your own peril) the
   * `stateBuilder` object used internally by [[StateRegistry]].
   * This can be used to add custom functionality to ng-router,
   * for example inferring templateUrl based on the state name.
   *
   * When passing only a name, it returns the current (original or decorated) builder
   * function that matches `name`.
   *
   * The builder functions that can be decorated are listed below. Though not all
   * necessarily have a good use case for decoration, that is up to you to decide.
   *
   * In addition, users can attach custom decorators, which will generate new
   * properties within the state's internal definition. There is currently no clear
   * use-case for this beyond accessing internal states (i.e. $state.$current),
   * however, expect this to become increasingly relevant as we introduce additional
   * meta-programming features.
   *
   * **Warning**: Decorators should not be interdependent because the order of
   * execution of the builder functions in non-deterministic. Builder functions
   * should only be dependent on the state definition object and super function.
   *
   *
   * Existing builder functions and current return values:
   *
   * - **parent** `{object}` - returns the parent state object.
   * - **data** `{object}` - returns state data, including any inherited data that is not
   *   overridden by own values (if any).
   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
   *   or `null`.
   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is
   *   navigable).
   * - **params** `{object}` - returns an array of state params that are ensured to
   *   be a super-set of parent's params.
   * - **views** `{object}` - returns a views object where each key is an absolute view
   *   name (i.e. "viewName@stateName") and each value is the config object
   *   (template, controller) for the view. Even when you don't use the views object
   *   explicitly on a state config, one is still created for you internally.
   *   So by decorating this builder function you have access to decorating template
   *   and controller properties.
   * - **ownParams** `{object}` - returns an array of params that belong to the state,
   *   not including any params defined by ancestor states.
   * - **path** `{string}` - returns the full path from the root down to this state.
   *   Needed for state activation.
   * - **includes** `{object}` - returns an object that includes every state that
   *   would pass a `$state.includes()` test.
   *
   * #### Example:
   * Override the internal 'views' builder with a function that takes the state
   * definition, and a reference to the internal function being overridden:
   * ```js
   * $stateProvider.decorator('views', function (state, parent) {
   *   let result = {},
   *       views = parent(state);
   *
   *   angular.forEach(views, function (config, name) {
   *     let autoName = (state.name + '.' + name).replace('.', '/');
   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
   *     result[name] = config;
   *   });
   *   return result;
   * });
   *
   * $stateProvider.state('home', {
   *   views: {
   *     'contact.list': { controller: 'ListController' },
   *     'contact.item': { controller: 'ItemController' }
   *   }
   * });
   * ```
   *
   *
   * ```js
   * // Auto-populates list and item views with /partials/home/contact/list.html,
   * // and /partials/home/contact/item.html, respectively.
   * $state.go('home');
   * ```
   *
   * @param {string} name The name of the builder function to decorate.
   * @param {object} func A function that is responsible for decorating the original
   * builder function. The function receives two parameters:
   *
   *   - `{object}` - state - The state config object.
   *   - `{object}` - super - The original builder function.
   *
   * @return {object} $stateProvider - $stateProvider instance
   */
  decorator(name, func) {
    return this.stateRegistry.decorator(name, func) || this;
  }

  /**
   *
   * @param {any} definition
   */
  state(definition) {
    if (!definition.name) {
      throw err("stateinvalid", `'name' required`);
    }
    try {
      this.stateRegistry.register(definition);
    } catch (e) {
      throw err("stateinvalid", e.message);
    }
    return this;
  }

  /**
   * Handler for when [[transitionTo]] is called with an invalid state.
   *
   * Invokes the [[onInvalid]] callbacks, in natural order.
   * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.
   * The results of the callbacks are wrapped in Promise.resolve(), so the callbacks may return promises.
   *
   * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.
   *
   * @internal
   */
  _handleInvalidTargetState(fromPath, toState) {
    const fromState = makeTargetState(this.stateRegistry, fromPath);
    const globals = this.globals;
    const latestThing = () => globals.transitionHistory.peekTail();
    const latest = latestThing();
    const callbackQueue = new Queue(this.invalidCallbacks.slice());
    const injector = new ResolveContext(fromPath).injector();
    const checkForRedirect = (result) => {
      if (!(result instanceof TargetState)) {
        return;
      }
      let target = result;
      // Recreate the TargetState, in case the state is now defined.
      target = this.target(
        target.identifier(),
        target.params(),
        target.options(),
      );
      if (!target.valid()) {
        return Rejection.invalid(target.error()).toPromise();
      }
      if (latestThing() !== latest) {
        return Rejection.superseded().toPromise();
      }
      return this.transitionTo(
        target.identifier(),
        target.params(),
        target.options(),
      );
    };
    function invokeNextCallback() {
      const nextCallback = callbackQueue.dequeue();
      if (nextCallback === undefined)
        return Rejection.invalid(toState.error()).toPromise();
      const callbackResult = Promise.resolve(
        nextCallback(toState, fromState, injector),
      );
      return callbackResult
        .then(checkForRedirect)
        .then((result) => result || invokeNextCallback());
    }
    return invokeNextCallback();
  }
  /**
   * Registers an Invalid State handler
   *
   * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]
   * has been called with an invalid state reference parameter
   *
   * Example:
   * ```js
   * stateService.onInvalid(function(to, from, injector) {
   *   if (to.name() === 'foo') {
   *     let lazyLoader = injector.get('LazyLoadService');
   *     return lazyLoader.load('foo')
   *         .then(() => stateService.target('foo'));
   *   }
   * });
   * ```
   *
   * @param {function} callback invoked when the toState is invalid
   *   This function receives the (invalid) toState, the fromState, and an injector.
   *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.
   *   If one is returned, it is treated as a redirect.
   *
   * @returns a function which deregisters the callback
   */
  onInvalid(callback) {
    this.invalidCallbacks.push(callback);
    return function deregisterListener() {
      removeFrom(this.invalidCallbacks)(callback);
    }.bind(this);
  }
  /**
   * Reloads the current state
   *
   * A method that force reloads the current state, or a partial state hierarchy.
   * All resolves are re-resolved, and components reinstantiated.
   *
   * #### Example:
   * ```js
   * let app angular.module('app', ['ui.router']);
   *
   * app.controller('ctrl', function ($scope, $state) {
   *   $scope.reload = function(){
   *     $state.reload();
   *   }
   * });
   * ```
   *
   * Note: `reload()` is just an alias for:
   *
   * ```js
   * $state.transitionTo($state.current, $state.params, {
   *   reload: true, inherit: false
   * });
   * ```
   *
   * @param reloadState A state name or a state object.
   *    If present, this state and all its children will be reloaded, but ancestors will not reload.
   *
   * #### Example:
   * ```js
   * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'
   * //and current state is 'contacts.detail.item'
   * let app angular.module('app', ['ui.router']);
   *
   * app.controller('ctrl', function ($scope, $state) {
   *   $scope.reload = function(){
   *     //will reload 'contact.detail' and nested 'contact.detail.item' states
   *     $state.reload('contact.detail');
   *   }
   * });
   * ```
   *
   * @returns A promise representing the state of the new transition. See [[StateService.go]]
   */
  reload(reloadState) {
    return this.transitionTo(this.globals.current, this.globals.params, {
      reload: isDefined(reloadState) ? reloadState : true,
      inherit: false,
      notify: false,
    });
  }
  /**
   * Transition to a different state and/or parameters
   *
   * Convenience method for transitioning to a new state.
   *
   * `$state.go` calls `$state.transitionTo` internally but automatically sets options to
   * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.
   * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).
   * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters
   * inherit from the current parameter values (because of `inherit: true`).
   *
   * #### Example:
   * ```js
   * let app = angular.module('app', ['ui.router']);
   *
   * app.controller('ctrl', function ($scope, $state) {
   *   $scope.changeState = function () {
   *     $state.go('contact.detail');
   *   };
   * });
   * ```
   *
   * @param to Absolute state name, state object, or relative state path (relative to current state).
   *
   * Some examples:
   *
   * - `$state.go('contact.detail')` - will go to the `contact.detail` state
   * - `$state.go('^')` - will go to the parent state
   * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state
   * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state
   *
   * @param params A map of the parameters that will be sent to the state, will populate $stateParams.
   *
   *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).
   *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.
   *
   * @param options Transition options
   *
   * @returns {promise} A promise representing the state of the new transition.
   */
  go(to, params, options) {
    const defautGoOpts = { relative: this.$current, inherit: true };
    const transOpts = defaults(options, defautGoOpts, defaultTransOpts);
    return this.transitionTo(to, params, transOpts);
  }
  /**
   * Creates a [[TargetState]]
   *
   * This is a factory method for creating a TargetState
   *
   * This may be returned from a Transition Hook to redirect a transition, for example.
   */
  target(identifier, params, options = {}) {
    // If we're reloading, find the state object to reload from
    if (isObject(options.reload) && !options.reload.name)
      throw new Error("Invalid reload state object");
    const reg = this.stateRegistry;
    options.reloadState =
      options.reload === true
        ? reg.root()
        : reg.matcher.find(options.reload, options.relative);
    if (options.reload && !options.reloadState)
      throw new Error(
        `No such reload state '${isString(options.reload) ? options.reload : options.reload.name}'`,
      );
    return new TargetState(this.stateRegistry, identifier, params, options);
  }

  getCurrentPath() {
    const globals = this.globals;
    const latestSuccess = globals.successfulTransitions.peekTail();
    const rootPath = () => [new PathNode(this.stateRegistry.root())];
    return latestSuccess ? latestSuccess.treeChanges().to : rootPath();
  }
  /**
   * Low-level method for transitioning to a new state.
   *
   * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.
   *
   * #### Example:
   * ```js
   * let app = angular.module('app', ['ui.router']);
   *
   * app.controller('ctrl', function ($scope, $state) {
   *   $scope.changeState = function () {
   *     $state.transitionTo('contact.detail');
   *   };
   * });
   * ```
   *
   * @param to State name or state object.
   * @param toParams A map of the parameters that will be sent to the state,
   *      will populate $stateParams.
   * @param options Transition options
   *
   * @returns A promise representing the state of the new transition. See [[go]]
   */
  transitionTo(to, toParams = {}, options = {}) {
    options = defaults(options, defaultTransOpts);
    const getCurrent = () => this.globals.transition;
    options = Object.assign(options, { current: getCurrent });
    const ref = this.target(to, toParams, options);
    const currentPath = this.getCurrentPath();
    if (!ref.exists()) return this._handleInvalidTargetState(currentPath, ref);
    if (!ref.valid()) return silentRejection(ref.error());
    if (options.supercede === false && getCurrent()) {
      return Rejection.ignored(
        "Another transition is in progress and supercede has been set to false in TransitionOptions for the transition. So the transition was ignored in favour of the existing one in progress.",
      ).toPromise();
    }
    /**
     * Special handling for Ignored, Aborted, and Redirected transitions
     *
     * The semantics for the transition.run() promise and the StateService.transitionTo()
     * promise differ. For instance, the run() promise may be rejected because it was
     * IGNORED, but the transitionTo() promise is resolved because from the user perspective
     * no error occurred.  Likewise, the transition.run() promise may be rejected because of
     * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.
     */
    const rejectedTransitionHandler = (trans) => (error) => {
      if (error instanceof Rejection) {
        const isLatest = this.globals.lastStartedTransitionId <= trans.$id;
        if (error.type === RejectType.IGNORED) {
          isLatest && this.urlService.update();
          // Consider ignored `Transition.run()` as a successful `transitionTo`
          return Promise.resolve(this.globals.current);
        }
        const detail = error.detail;
        if (
          error.type === RejectType.SUPERSEDED &&
          error.redirected &&
          detail instanceof TargetState
        ) {
          // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully
          // by returning the promise for the new (redirect) `Transition.run()`.
          const redirect = trans.redirect(detail);
          return redirect.run().catch(rejectedTransitionHandler(redirect));
        }
        if (error.type === RejectType.ABORTED) {
          isLatest && this.urlService.update();
          return Promise.reject(error);
        }
      }
      const errorHandler = this.defaultErrorHandler();
      errorHandler(error);
      return Promise.reject(error);
    };
    const transition = this.transitionService.create(currentPath, ref);
    const transitionToPromise = transition
      .run()
      .catch(rejectedTransitionHandler(transition));
    silenceUncaughtInPromise(transitionToPromise); // issue #2676
    // Return a promise for the transition, which also has the transition object on it.
    return Object.assign(transitionToPromise, { transition });
  }
  /**
   * Checks if the current state *is* the provided state
   *
   * Similar to [[includes]] but only checks for the full state name.
   * If params is supplied then it will be tested for strict equality against the current
   * active params object, so all params must match with none missing and no extras.
   *
   * #### Example:
   * ```js
   * $state.$current.name = 'contacts.details.item';
   *
   * // absolute name
   * $state.is('contact.details.item'); // returns true
   * $state.is(contactDetailItemStateObject); // returns true
   * ```
   *
   * // relative name (. and ^), typically from a template
   * // E.g. from the 'contacts.details' template
   * ```html
   * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
   * ```
   *
   * @param stateOrName The state name (absolute or relative) or state object you'd like to check.
   * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like
   * to test against the current active state.
   * @param options An options object. The options are:
   *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
   *     test relative to `options.relative` state (or name).
   *
   * @returns Returns true if it is the state.
   */
  is(stateOrName, params, options) {
    options = defaults(options, { relative: this.$current });
    const state = this.stateRegistry.matcher.find(
      stateOrName,
      options.relative,
    );
    if (!isDefined(state)) return undefined;
    if (this.$current !== state) return false;
    if (!params) return true;
    const schema = state.parameters({ inherit: true, matchingKeys: params });
    return Param.equals(
      schema,
      Param.values(schema, params),
      this.globals.params,
    );
  }
  /**
   * Checks if the current state *includes* the provided state
   *
   * A method to determine if the current active state is equal to or is the child of the
   * state stateName. If any params are passed then they will be tested for a match as well.
   * Not all the parameters need to be passed, just the ones you'd like to test for equality.
   *
   * #### Example when `$state.$current.name === 'contacts.details.item'`
   * ```js
   * // Using partial names
   * $state.includes("contacts"); // returns true
   * $state.includes("contacts.details"); // returns true
   * $state.includes("contacts.details.item"); // returns true
   * $state.includes("contacts.list"); // returns false
   * $state.includes("about"); // returns false
   * ```
   *
   * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:
   * ```js
   * $state.includes("*.details.*.*"); // returns true
   * $state.includes("*.details.**"); // returns true
   * $state.includes("**.item.**"); // returns true
   * $state.includes("*.details.item.url"); // returns true
   * $state.includes("*.details.*.url"); // returns true
   * $state.includes("*.details.*"); // returns false
   * $state.includes("item.**"); // returns false
   * ```
   *
   * @param stateOrName A partial name, relative name, glob pattern,
   *   or state object to be searched for within the current state name.
   * @param params A param object, e.g. `{sectionId: section.id}`,
   *   that you'd like to test against the current active state.
   * @param options An options object. The options are:
   *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
   *     test relative to `options.relative` state (or name).
   *
   * @returns {boolean} Returns true if it does include the state
   */
  includes(stateOrName, params, options) {
    options = defaults(options, { relative: this.$current });
    const glob = isString(stateOrName) && Glob.fromString(stateOrName);
    if (glob) {
      if (!glob.matches(this.$current.name)) return false;
      stateOrName = this.$current.name;
    }
    const state = this.stateRegistry.matcher.find(
        stateOrName,
        options.relative,
      ),
      include = this.$current.includes;
    if (!isDefined(state)) return undefined;
    if (!isDefined(include[state.name])) return false;
    if (!params) return true;
    const schema = state.parameters({ inherit: true, matchingKeys: params });
    return Param.equals(
      schema,
      Param.values(schema, params),
      this.globals.params,
    );
  }
  /**
   * Generates a URL for a state and parameters
   *
   * Returns the url for the given state populated with the given params.
   *
   * #### Example:
   * ```js
   * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
   * ```
   *
   * @param stateOrName The state name or state object you'd like to generate a url from.
   * @param params An object of parameter values to fill the state's required parameters.
   * @param options Options object. The options are:
   *
   * @returns {string} compiled state url
   */
  href(stateOrName, params, options) {
    const defaultHrefOpts = {
      lossy: true,
      inherit: true,
      absolute: false,
      relative: this.$current,
    };
    options = defaults(options, defaultHrefOpts);
    params = params || {};
    const state = this.stateRegistry.matcher.find(
      stateOrName,
      options.relative,
    );
    if (!isDefined(state)) return null;
    if (options.inherit)
      params = this.globals.params.$inherit(params, this.$current, state);
    const nav = state && options.lossy ? state.navigable : state;
    if (!nav || nav.url === undefined || nav.url === null) {
      return null;
    }
    return this.urlService.href(nav.url, params, {
      absolute: options.absolute,
    });
  }
  /**
   * Sets or gets the default [[transitionTo]] error handler.
   *
   * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.
   * This includes errors caused by resolves and transition hooks.
   *
   * Note:
   * This handler does not receive certain Transition rejections.
   * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].
   *
   * The built-in default error handler logs the error to the console.
   *
   * You can provide your own custom handler.
   *
   * #### Example:
   * ```js
   * stateService.defaultErrorHandler(function() {
   *   // Do not log transitionTo errors
   * });
   * ```
   *
   * @param handler a global error handler function
   * @returns the current global error handler
   */
  defaultErrorHandler(handler) {
    return (this._defaultErrorHandler = handler || this._defaultErrorHandler);
  }

  get(stateOrName, base) {
    const reg = this.stateRegistry;
    if (arguments.length === 0) return reg.get();
    return reg.get(stateOrName, base || this.$current);
  }
  /**
   * Lazy loads a state
   *
   * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.
   *
   * @param stateOrName the state that should be lazy loaded
   * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)
   * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.
   * This noop transition is not actually run.
   *
   * @returns a promise to lazy load
   */
  lazyLoad(stateOrName, transition) {
    const state = this.get(stateOrName);
    if (!state || !state.lazyLoad)
      throw new Error("Can not lazy load " + stateOrName);
    const currentPath = this.getCurrentPath();
    const target = makeTargetState(this.stateRegistry, currentPath);
    transition =
      transition || this.transitionService.create(currentPath, target);
    return lazyLoadState(transition, state);
  }
}

class ViewScrollProvider {
  constructor() {
    this.enabled = false;
  }

  useAnchorScroll() {
    this.enabled = true;
  }

  $get = [
    "$anchorScroll",
    /**
     * @param {import('../services/anchor-scroll.js').AnchorScrollObject} $anchorScroll
     * @returns {import('../services/anchor-scroll.js').AnchorScrollObject|Function}
     */
    ($anchorScroll) => {
      if (this.enabled) {
        return $anchorScroll;
      }
      /**
       * @param {Element} $element
       * @returns {Promise<number>}
       */
      return async function ($element) {
        setTimeout(() => {
          $element.scrollIntoView(false);
        }, 0);
      };
    },
  ];
}

/**
 * @typedef BindingTuple
 * @property {string} name
 * @property {string} type
 */

/**
 * Service which manages loading of templates from a ViewConfig.
 */
class TemplateFactoryProvider {
  constructor() {
    /** @type {boolean} */
    this._useHttp = false;
  }

  $get = [
    "$http",
    "$templateCache",
    "$templateRequest",
    "$injector",
    /**
     * @param {any} $http
     * @param {import("../core/cache/cache-factory.js").TemplateCache} $templateCache
     * @param {any} $templateRequest
     * @param {import("../core/di/internal-injector.js").InjectorService} $injector
     * @returns
     */
    ($http, $templateCache, $templateRequest, $injector) => {
      this.$templateRequest = $templateRequest;
      this.$http = $http;
      this.$templateCache = $templateCache;
      this.$injector = $injector;
      return this;
    },
  ];

  /**
   * Forces the provider to use $http service directly
   * @param {boolean} value
   */
  useHttpService(value) {
    this._useHttp = value;
  }

  /**
   * Creates a template from a configuration object.
   *
   * @param config Configuration object for which to load a template.
   * The following properties are search in the specified order, and the first one
   * that is defined is used to create the template:
   *
   * @param {any} config
   * @param {any} params  Parameters to pass to the template function.
   * @param {import("./resolve/resolve-context.js").ResolveContext} context The resolve context associated with the template's view
   *
   * @return {string|object}  The template html as a string, or a promise for
   * that string,or `null` if no template is configured.
   */
  fromConfig(config, params, context) {
    const defaultTemplate = "<ng-view></ng-view>";
    const asTemplate = (result) =>
      Promise.resolve(result).then((str) => ({ template: str }));
    const asComponent = (result) =>
      Promise.resolve(result).then((str) => ({ component: str }));

    const getConfigType = (config) => {
      if (isDefined(config.template)) return "template";
      if (isDefined(config.templateUrl)) return "templateUrl";
      if (isDefined(config.templateProvider)) return "templateProvider";
      if (isDefined(config.component)) return "component";
      if (isDefined(config.componentProvider)) return "componentProvider";
      return "default";
    };

    switch (getConfigType(config)) {
      case "template":
        return asTemplate(this.fromString(config.template, params));
      case "templateUrl":
        return asTemplate(this.fromUrl(config.templateUrl, params));
      case "templateProvider":
        return asTemplate(
          this.fromProvider(config.templateProvider, params, context),
        );
      case "component":
        return asComponent(config.component);
      case "componentProvider":
        return asComponent(
          this.fromComponentProvider(config.componentProvider, context),
        );
      default:
        return asTemplate(defaultTemplate);
    }
  }
  /**
   * Creates a template from a string or a function returning a string.
   *
   * @param {string | Function} template html template as a string or function that returns an html template as a string.
   * @param {any} [params] Parameters to pass to the template function.
   *
   * @return {string|object} The template html as a string, or a promise for that
   * string.
   */
  fromString(template, params) {
    return isFunction(template)
      ? /** @type {Function} */ (template)(params)
      : template;
  }
  /**
   * Loads a template from the a URL via `$http` and `$templateCache`.
   *
   * @param {string|Function} url url of the template to load, or a function
   * that returns a url.
   * @param {Object} params Parameters to pass to the url function.
   * @return {string|Promise.<string>} The template html as a string, or a promise
   * for that string.
   */
  fromUrl(url, params) {
    if (isFunction(url)) url = /** @type {Function} */ (url)(params);
    if (url == null) return null;
    if (this._useHttp) {
      return this.$http
        .get(url, {
          cache: this.$templateCache,
          headers: { Accept: "text/html" },
        })
        .then(function (response) {
          return response.data;
        });
    }
    return this.$templateRequest(url);
  }
  /**
   * Creates a template by invoking an injectable provider function.
   *
   * @param {import('../types.js').Injectable<any>} provider Function to invoke via `locals`
   * @param {Function} params a function used to invoke the template provider
   * @param {import("./resolve/resolve-context.js").ResolveContext} context
   * @return {string|Promise.<string>} The template html as a string, or a promise
   * for that string.
   */
  fromProvider(provider, params, context) {
    const deps = annotate(provider);
    const providerFn = Array.isArray(provider) ? tail(provider) : provider;
    const resolvable = new Resolvable("", providerFn, deps);
    return resolvable.get(context);
  }
  /**
   * Creates a component's template by invoking an injectable provider function.
   *
   * @param {import('../types.js').Injectable<any>} provider Function to invoke via `locals`
   * @return {string} The template html as a string: "<component-name input1='::$resolve.foo'></component-name>".
   */
  fromComponentProvider(provider, context) {
    const deps = annotate(provider);
    const providerFn = Array.isArray(provider) ? tail(provider) : provider;
    const resolvable = new Resolvable("", providerFn, deps);
    return resolvable.get(context); // https://github.com/angular-ui/ng-router/pull/3165/files
  }
  /**
   * Creates a template from a component's name
   *
   * This implements route-to-component.
   * It works by retrieving the component (directive) metadata from the injector.
   * It analyses the component's bindings, then constructs a template that instantiates the component.
   * The template wires input and output bindings to resolves or from the parent component.
   *
   * @param {any} ngView {object} The parent ng-view (for binding outputs to callbacks)
   * @param {import("./resolve/resolve-context.js").ResolveContext} context The ResolveContext (for binding outputs to callbacks returned from resolves)
   * @param {string} component {string} Component's name in camel case.
   * @param {any} [bindings] An object defining the component's bindings: {foo: '<'}
   * @return {string} The template as a string: "<component-name input1='$resolve.foo'></component-name>".
   */
  makeComponentTemplate(ngView, context, component, bindings) {
    bindings = bindings || {};
    // Bind once prefix
    // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`
    const kebob = (camelCase) => {
      const kebobed = kebobString(camelCase);
      return /^(x|data)-/.exec(kebobed) ? `x-${kebobed}` : kebobed;
    };

    const attributeTpl = /** @param {BindingTuple} input*/ (input) => {
      const { name, type } = input;
      const attrName = kebob(name);
      // If the ng-view has an attribute which matches a binding on the routed component
      // then pass that attribute through to the routed component template.
      // Prefer ng-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`
      if (ngView.getAttribute(attrName) && !bindings[name])
        return `${attrName}='${ngView.getAttribute(attrName)}'`;
      const resolveName = bindings[name] || name;
      // Pre-evaluate the expression for "@" bindings by enclosing in {{ }}
      // some-attr="{{$resolve.someResolveName }}"
      if (type === "@") return `${attrName}='{{s$resolve.${resolveName}}}'`;
      // Wire "&" callbacks to resolves that return a callback function
      // Get the result of the resolve (should be a function) and annotate it to get its arguments.
      // some-attr="$resolve.someResolveResultName(foo, bar)"
      if (type === "&") {
        const res = context.getResolvable(resolveName);
        const fn = res && res.data;
        const args = (fn && annotate(fn)) || [];
        // account for array style injection, i.e., ['foo', function(foo) {}]
        const arrayIdxStr = Array.isArray(fn) ? `[${fn.length - 1}]` : "";
        return `${attrName}='$resolve.${resolveName}${arrayIdxStr}(${args.join(",")})'`;
      }
      // some-attr="::$resolve.someResolveName"
      return `${attrName}='$resolve.${resolveName}'`;
    };
    const attrs = getComponentBindings(this.$injector, component)
      .map(attributeTpl)
      .join(" ");
    const kebobName = kebob(component);
    return `<${kebobName} ${attrs}></${kebobName}>`;
  }
}

/**
 * Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')
 */
function getComponentBindings($injector, name) {
  const cmpDefs = $injector.get(name + DirectiveSuffix); // could be multiple
  if (!cmpDefs || !cmpDefs.length)
    throw new Error(`Unable to find component named '${name}'`);
  return cmpDefs.map(getBindings).reduce(unnestR, []);
}
// Given a directive definition, find its object input attributes
// Use different properties, depending on the type of directive (component, bindToController, normal)
const getBindings = (def) => {
  if (isObject(def.bindToController))
    return scopeBindings(def.bindToController);
  return scopeBindings(def.scope);
};
// for ng 1.2 style, process the scope: { input: "=foo" }
// for ng 1.3 through ng 1.5, process the component's bindToController: { input: "=foo" } object
const scopeBindings = (bindingsObj) =>
  Object.keys(bindingsObj || {})
    // [ 'input', [ '=foo', '=', 'foo' ] ]
    .map((key) => [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])])
    // skip malformed values
    .filter((tuple) => isDefined(tuple) && Array.isArray(tuple[1]))
    // { name: ('foo' || 'input'), type: '=' }
    .map((tuple) => ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }));

function quoteRegExp(str, param) {
  let surroundPattern = ["", ""];
  let result = str.replace(/[\\[\]^$*+?.()|{}]/g, "\\$&");
  if (!param) return result;
  switch (param.squash) {
    case false:
      surroundPattern = ["(", ")" + (param.isOptional ? "?" : "")];
      break;
    case true:
      result = result.replace(/\/$/, "");
      surroundPattern = ["(?:/(", ")|/)?"];
      break;
    default:
      surroundPattern = [`(${param.squash}|`, ")?"];
      break;
  }
  return (
    result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1]
  );
}
const memoizeTo = (obj, _prop, fn) => (obj[_prop] = obj[_prop] || fn());
const splitOnSlash = splitOnDelim("/");
const defaultConfig = {
  state: { params: {} },
  strict: true,
  caseInsensitive: true,
};
/**
 * Matches URLs against patterns.
 *
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL.
 *
 * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)
 * parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by [[UrlMatcher.exec]].
 *
 * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)
 * or colon placeholders (`/somePath/:param`).
 *
 * - *A parameter RegExp* may be defined for a param after a colon
 * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.
 * The regexp must match for the url to be matched.
 * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].
 *
 * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.
 *   See [[UrlMatcherFactory.type]] for more information.
 *
 * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).
 *   A catch-all * parameter value will contain the remainder of the URL.
 *
 * ---
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters).
 * A path parameter matches any number of characters other than '/'. For catch-all
 * placeholders the path parameter matches any number of characters.
 *
 * Examples:
 *
 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
 * * `'/user/{id:[^/]*}'` - Same as the previous example.
 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * `'/files/*path'` - ditto.
 * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
 *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start
 *
 */
class UrlMatcher {
  static encodeDashes(str) {
    // Replace dashes with encoded "\-"
    return encodeURIComponent(str).replace(
      /-/g,
      (c) => `%5C%${c.charCodeAt(0).toString(16).toUpperCase()}`,
    );
  }
  /** @internal Given a matcher, return an array with the matcher's path segments and path params, in order */
  static pathSegmentsAndParams(matcher) {
    const staticSegments = matcher._segments;
    const pathParams = matcher._params.filter(
      (p) => p.location === DefType.PATH,
    );
    return arrayTuples(staticSegments, pathParams.concat(undefined))
      .reduce(unnestR, [])
      .filter((x) => x !== "" && isDefined(x));
  }
  /** @internal Given a matcher, return an array with the matcher's query params */
  static queryParams(matcher) {
    return matcher._params.filter((p) => p.location === DefType.SEARCH);
  }
  /**
   * Compare two UrlMatchers
   *
   * This comparison function converts a UrlMatcher into static and dynamic path segments.
   * Each static path segment is a static string between a path separator (slash character).
   * Each dynamic segment is a path parameter.
   *
   * The comparison function sorts static segments before dynamic ones.
   */
  static compare(a, b) {
    /**
     * Turn a UrlMatcher and all its parent matchers into an array
     * of slash literals '/', string literals, and Param objects
     *
     * This example matcher matches strings like "/foo/:param/tail":
     * var matcher = $umf.compile("/foo").append($umf.compile("/:param")).append($umf.compile("/")).append($umf.compile("tail"));
     * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]
     *
     * Caches the result as `matcher._cache.segments`
     */
    const segments = (matcher) =>
      (matcher._cache.segments =
        matcher._cache.segments ||
        matcher._cache.path
          .map(UrlMatcher.pathSegmentsAndParams)
          .reduce(unnestR, [])
          .reduce(joinNeighborsR, [])
          .map((x) => (isString(x) ? splitOnSlash(x) : x))
          .reduce(unnestR, []));
    /**
     * Gets the sort weight for each segment of a UrlMatcher
     *
     * Caches the result as `matcher._cache.weights`
     */
    const weights = (matcher) =>
      (matcher._cache.weights =
        matcher._cache.weights ||
        segments(matcher).map((segment) => {
          // Sort slashes first, then static strings, the Params
          if (segment === "/") return 1;
          if (isString(segment)) return 2;
          if (segment instanceof Param) return 3;
        }));
    /**
     * Pads shorter array in-place (mutates)
     */
    const padArrays = (l, r, padVal) => {
      const len = Math.max(l.length, r.length);
      while (l.length < len) l.push(padVal);
      while (r.length < len) r.push(padVal);
    };
    const weightsA = weights(a),
      weightsB = weights(b);
    padArrays(weightsA, weightsB, 0);
    const _pairs = arrayTuples(weightsA, weightsB);
    let cmp, i;
    for (i = 0; i < _pairs.length; i++) {
      cmp = _pairs[i][0] - _pairs[i][1];
      if (cmp !== 0) return cmp;
    }
    return 0;
  }
  /**
   * @param pattern The pattern to compile into a matcher.
   * @param paramTypes The [[ParamTypes]] registry
   * @param paramFactory A [[ParamFactory]] object
   * @param config  A [[UrlMatcherCompileConfig]] configuration object
   */
  constructor(pattern, paramTypes, paramFactory, config) {
    this._cache = { path: [/** @type {UrlMatcher} */ (this)] };

    this._children = [];

    this._params = [];

    this._segments = [];

    this._compiled = [];
    this.config = config = defaults(config, defaultConfig);
    this.pattern = pattern;
    // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
    //   '*' name
    //   ':' name
    //   '{' name '}'
    //   '{' name ':' regexp '}'
    // The regular expression is somewhat complicated due to the need to allow curly braces
    // inside the regular expression. The placeholder regexp breaks down as follows:
    //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
    //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
    //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
    //    [^{}\\]+                       - anything other than curly braces or backslash
    //    \\.                            - a backslash escape
    //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
    const placeholder =
      /([:*])([\w[\]]+)|\{([\w[\]]+)(?::\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g;
    const searchPlaceholder =
      /([:]?)([\w[\].-]+)|\{([\w[\].-]+)(?::\s*((?:[^{\\}]+|\\.|{(?:[^{\\}]+|\\.)*})+))?\}/g;
    const patterns = [];
    let last = 0;
    let matchArray;
    const checkParamErrors = (id) => {
      if (!UrlMatcher.nameValidator.test(id))
        throw new Error(
          `Invalid parameter name '${id}' in pattern '${pattern}'`,
        );
      if (find(this._params, propEq("id", id)))
        throw new Error(
          `Duplicate parameter name '${id}' in pattern '${pattern}'`,
        );
    };
    // Split into static segments separated by path parameter placeholders.
    // The number of segments is always 1 more than the number of parameters.
    const matchDetails = (m, isSearch) => {
      // IE[78] returns '' for unmatched groups instead of null
      const id = m[2] || m[3];
      const regexp = isSearch
        ? m[4]
        : m[4] || (m[1] === "*" ? "[\\s\\S]*" : null);
      const makeRegexpType = (str) =>
        inherit(paramTypes.type(isSearch ? "query" : "path"), {
          pattern: new RegExp(
            str,
            this.config.caseInsensitive ? "i" : undefined,
          ),
        });
      return {
        id,
        regexp,
        segment: pattern.substring(last, m.index),
        type: !regexp
          ? null
          : paramTypes.type(regexp) || makeRegexpType(regexp),
      };
    };
    let details;
    let segment;
    while ((matchArray = placeholder.exec(pattern))) {
      details = matchDetails(matchArray, false);
      if (details.segment.indexOf("?") >= 0) break; // we're into the search part
      checkParamErrors(details.id);
      this._params.push(
        paramFactory.fromPath(details.id, details.type, config.state),
      );
      this._segments.push(details.segment);
      patterns.push([details.segment, tail(this._params)]);
      last = placeholder.lastIndex;
    }
    segment = pattern.substring(last);
    // Find any search parameter names and remove them from the last segment
    const i = segment.indexOf("?");
    if (i >= 0) {
      const search = segment.substring(i);
      segment = segment.substring(0, i);
      if (search.length > 0) {
        last = 0;
        while ((matchArray = searchPlaceholder.exec(search))) {
          details = matchDetails(matchArray, true);
          checkParamErrors(details.id);
          this._params.push(
            paramFactory.fromSearch(details.id, details.type, config.state),
          );
          last = placeholder.lastIndex;
          // check if ?&
        }
      }
    }
    this._segments.push(segment);
    this._compiled = patterns
      .map((_pattern) => quoteRegExp.apply(null, _pattern))
      .concat(quoteRegExp(segment));
  }
  /**
   * Creates a new concatenated UrlMatcher
   *
   * Builds a new UrlMatcher by appending another UrlMatcher to this one.
   *
   * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.
   */
  append(url) {
    this._children.push(url);
    url._cache = {
      path: this._cache.path.concat(url),
      parent: this,
      pattern: null,
    };
    return url;
  }

  isRoot() {
    return this._cache.path[0] === this;
  }
  /** Returns the input pattern string */
  toString() {
    return this.pattern;
  }
  _getDecodedParamValue(value, param) {
    if (isDefined(value)) {
      value = param.type.decode(value);
    }
    return param.value(value);
  }
  /**
   * Tests the specified url/path against this matcher.
   *
   * Tests if the given url matches this matcher's pattern, and returns an object containing the captured
   * parameter values.  Returns null if the path does not match.
   *
   * The returned object contains the values
   * of any search parameters that are mentioned in the pattern, but their value may be null if
   * they are not present in `search`. This means that search parameters are always treated
   * as optional.
   *
   * #### Example:
   * ```js
   * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
   *   x: '1', q: 'hello'
   * });
   * // returns { id: 'bob', q: 'hello', r: null }
   * ```
   *
   * @param path    The URL path to match, e.g. `$location.path()`.
   * @param search  URL search parameters, e.g. `$location.search()`.
   * @param hash    URL hash e.g. `$location.hash()`.
   *
   * @returns The captured parameter values.
   */
  exec(path, search = {}, hash) {
    const match = memoizeTo(this._cache, "pattern", () => {
      return new RegExp(
        [
          "^",
          unnest(this._cache.path.map((x) => x._compiled)).join(""),
          this.config.strict === false ? "/?" : "",
          "$",
        ].join(""),
        this.config.caseInsensitive ? "i" : undefined,
      );
    }).exec(path);
    if (!match) return null;
    // options = defaults(options, { isolate: false });
    const allParams = this.parameters(),
      pathParams = allParams.filter((param) => !param.isSearch()),
      searchParams = allParams.filter((param) => param.isSearch()),
      nPathSegments = this._cache.path
        .map((urlm) => urlm._segments.length - 1)
        .reduce((a, x) => a + x),
      values = {};
    if (nPathSegments !== match.length - 1)
      throw new Error(`Unbalanced capture group in route '${this.pattern}'`);
    function decodePathArray(paramVal) {
      const reverseString = (str) => str.split("").reverse().join("");
      const unquoteDashes = (str) => str.replace(/\\-/g, "-");
      const split = reverseString(paramVal).split(/-(?!\\)/);
      const allReversed = map(split, reverseString);
      return map(allReversed, unquoteDashes).reverse();
    }
    for (let i = 0; i < nPathSegments; i++) {
      const param = pathParams[i];
      let value = match[i + 1];
      // if the param value matches a pre-replace pair, replace the value before decoding.
      for (let j = 0; j < param.replace.length; j++) {
        if (param.replace[j].from === value) value = param.replace[j].to;
      }
      if (value && param.array === true) value = decodePathArray(value);
      values[param.id] = this._getDecodedParamValue(value, param);
    }
    searchParams.forEach((param) => {
      let value = search[param.id];
      for (let j = 0; j < param.replace.length; j++) {
        if (param.replace[j].from === value) value = param.replace[j].to;
      }
      values[param.id] = this._getDecodedParamValue(value, param);
    });
    if (hash) values["#"] = hash;
    return values;
  }
  /**
   * @internal
   * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.
   *
   * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the
   *    pattern has no parameters, an empty array is returned.
   */
  parameters(opts = {}) {
    if (opts.inherit === false) return this._params;
    return unnest(this._cache.path.map((matcher) => matcher._params));
  }
  /**
   * @internal
   * Returns a single parameter from this UrlMatcher by id
   *
   * @param id
   * @param opts
   * @returns {Param|any|boolean|UrlMatcher|null}
   */
  parameter(id, opts = {}) {
    const findParam = () => {
      for (const param of this._params) {
        if (param.id === id) return param;
      }
    };
    const parent = this._cache.parent;
    return (
      findParam() ||
      (opts.inherit !== false && parent && parent.parameter(id, opts)) ||
      null
    );
  }
  /**
   * Validates the input parameter values against this UrlMatcher
   *
   * Checks an object hash of parameters to validate their correctness according to the parameter
   * types of this `UrlMatcher`.
   *
   * @param params The object hash of parameters to validate.
   * @returns Returns `true` if `params` validates, otherwise `false`.
   */
  validates(params) {
    const validParamVal = (param, val) => !param || param.validates(val);
    params = params || {};
    // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher
    const paramSchema = this.parameters().filter((paramDef) =>
      Object.prototype.hasOwnProperty.call(params, paramDef.id),
    );
    return paramSchema
      .map((paramDef) => validParamVal(paramDef, params[paramDef.id]))
      .reduce(allTrueR, true);
  }
  /**
   * Given a set of parameter values, creates a URL from this UrlMatcher.
   *
   * Creates a URL that matches this pattern by substituting the specified values
   * for the path and search parameters.
   *
   * #### Example:
   * ```js
   * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
   * // returns '/user/bob?q=yes'
   * ```
   *
   * @param values  the values to substitute for the parameters in this pattern.
   * @returns the formatted URL (path and optionally search part).
   */
  format(values = {}) {
    // Build the full path of UrlMatchers (including all parent UrlMatchers)
    const urlMatchers = this._cache.path;
    // Extract all the static segments and Params (processed as ParamDetails)
    // into an ordered array
    const pathSegmentsAndParams = urlMatchers
      .map(UrlMatcher.pathSegmentsAndParams)
      .reduce(unnestR, [])
      .map((x) => (isString(x) ? x : getDetails(x)));
    // Extract the query params into a separate array
    const queryParams = urlMatchers
      .map(UrlMatcher.queryParams)
      .reduce(unnestR, [])
      .map(getDetails);
    const isInvalid = (param) => param.isValid === false;
    if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {
      return null;
    }
    /**
     * Given a Param, applies the parameter value, then returns detailed information about it
     */
    function getDetails(param) {
      // Normalize to typed value
      const value = param.value(values[param.id]);
      const isValid = param.validates(value);
      const isDefaultValue = param.isDefaultValue(value);
      // Check if we're in squash mode for the parameter
      const squash = isDefaultValue ? param.squash : false;
      // Allow the Parameter's Type to encode the value
      const encoded = param.type.encode(value);
      return { param, value, isValid, isDefaultValue, squash, encoded };
    }
    // Build up the path-portion from the list of static segments and parameters
    const pathString = pathSegmentsAndParams.reduce((acc, x) => {
      // The element is a static segment (a raw string); just append it
      if (isString(x)) return acc + x;
      // Otherwise, it's a ParamDetails.
      const { squash, encoded, param } = x;
      // If squash is === true, try to remove a slash from the path
      if (squash === true) return acc.match(/\/$/) ? acc.slice(0, -1) : acc;
      // If squash is a string, use the string for the param value
      if (isString(squash)) return acc + squash;
      if (squash !== false) return acc; // ?
      if (encoded == null) return acc;
      // If this parameter value is an array, encode the value using encodeDashes
      if (Array.isArray(encoded))
        return acc + map(encoded, UrlMatcher.encodeDashes).join("-");
      // If the parameter type is "raw", then do not encodeURIComponent
      if (param.raw) return acc + encoded;
      // Encode the value
      return acc + encodeURIComponent(encoded);
    }, "");
    // Build the query string by applying parameter values (array or regular)
    // then mapping to key=value, then flattening and joining using "&"
    const queryString = queryParams
      .map((paramDetails) => {
        let { param, squash, encoded, isDefaultValue } = paramDetails;
        if (encoded == null || (isDefaultValue && squash !== false)) return;
        if (!Array.isArray(encoded)) encoded = [encoded];
        if (encoded.length === 0) return;
        if (!param.raw) encoded = map(encoded, encodeURIComponent);
        return encoded.map((val) => `${param.id}=${val}`);
      })
      .reduce(unnestR, [])
      .join("&");
    // Concat the pathstring with the queryString (if exists) and the hashString (if exists)
    return (
      pathString +
      (queryString ? `?${queryString}` : "") +
      (values["#"] ? "#" + values["#"] : "")
    );
  }
}

UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;

/**
 * Internal representation of a ng-router state.
 *
 * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].
 *
 * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.
 *
 * This class prototypally inherits from the corresponding [[StateDeclaration]].
 * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].
 */
class StateObject {
  name = undefined;
  navigable = undefined;
  /** @type {?StateObject} */
  parent = undefined;
  params = undefined;
  url = undefined;

  constructor(config) {
    Object.assign(this, config);
    this.$$state = () => this;
    this.self = config;
    const nameGlob = this.name ? Glob.fromString(this.name) : null;
    this.__stateObjectCache = { nameGlob };
  }
  /**
   * Returns true if the provided parameter is the same state.
   *
   * Compares the identity of the state against the passed value, which is either an object
   * reference to the actual `State` instance, the original definition object passed to
   * `$stateProvider.state()`, or the fully-qualified name.
   *
   * @param ref Can be one of (a) a `State` instance, (b) an object that was passed
   *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.
   * @returns Returns `true` if `ref` matches the current `State` instance.
   */
  is(ref) {
    return this === ref || this.self === ref || this.fqn() === ref;
  }
  /**
   * @deprecated this does not properly handle dot notation
   * @returns Returns a dot-separated name of the state.
   */
  fqn() {
    if (!this.parent || !(this.parent instanceof this.constructor))
      return this.name;
    const name = this.parent.fqn();
    return name ? name + "." + this.name : this.name;
  }
  /**
   * Returns the root node of this state's tree.
   *
   * @returns The root of this state's tree.
   */
  root() {
    return (this.parent && this.parent.root()) || this;
  }
  /**
   * Gets the state's `Param` objects
   *
   * Gets the list of [[Param]] objects owned by the state.
   * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.
   * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object
   *
   * @param opts options
   */
  parameters(opts) {
    opts = defaults(opts, { inherit: true, matchingKeys: null });
    const inherited =
      (opts.inherit && this.parent && this.parent.parameters()) || [];
    return inherited
      .concat(Object.values(this.params))
      .filter(
        (param) =>
          !opts.matchingKeys ||
          Object.prototype.hasOwnProperty.call(opts.matchingKeys, param.id),
      );
  }
  /**
   * Returns a single [[Param]] that is owned by the state
   *
   * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.
   * @param id the name of the [[Param]] to return
   * @param opts options
   */
  parameter(id, opts = {}) {
    return (
      (this.url && this.url.parameter(id, opts)) ||
      find(Object.values(this.params), propEq("id", id)) ||
      (opts.inherit && this.parent && this.parent.parameter(id))
    );
  }
  toString() {
    return this.fqn();
  }
}
/** Predicate which returns true if the object is a [[StateDeclaration]] object */
StateObject.isStateDeclaration = (obj) => isFunction(obj["$$state"]);
/** Predicate which returns true if the object is an internal [[StateObject]] object */
StateObject.isState = (obj) => isObject(obj["__stateObjectCache"]);

/**
 * Creates a [[UrlRule]]
 *
 * Creates a [[UrlRule]] from a:
 *
 * - `string`
 * - [[UrlMatcher]]
 * - `RegExp`
 * - [[StateObject]]
 */
class UrlRuleFactory {
  constructor(urlService, stateService, routerGlobals) {
    this.urlService = urlService;
    this.stateService = stateService;
    this.routerGlobals = routerGlobals;
  }

  /**
   *
   * @param {*} what
   * @param {*} handler
   * @returns {BaseUrlRule}
   */
  create(what, handler) {
    const { isState, isStateDeclaration } = StateObject;
    const makeRule = pattern([
      [isString, (_what) => makeRule(this.urlService.compile(_what))],
      [is(UrlMatcher), (_what) => this.fromUrlMatcher(_what, handler)],
      [
        or(isState, isStateDeclaration),
        (_what) => this.fromState(_what, this.stateService, this.routerGlobals),
      ],
      [is(RegExp), (_what) => this.fromRegExp(_what, handler)],
      [isFunction, (_what) => new BaseUrlRule(_what, handler)],
    ]);
    const rule = makeRule(what);
    if (!rule) throw new Error("invalid 'what' in when()");
    return rule;
  }
  /**
   * A UrlRule which matches based on a UrlMatcher
   *
   * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]
   *
   * ## Handler as a function
   *
   * If `handler` is a function, the function is invoked with:
   *
   * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])
   * - url: the current Url ([[UrlParts]])
   * - router: the router object ([[UIRouter]])
   *
   * #### Example:
   * ```js
   * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
   * var rule = factory.fromUrlMatcher(urlMatcher, match => "/home/" + match.fooId + "/" + match.barId);
   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
   * var result = rule.handler(match); // '/home/123/456'
   * ```
   *
   * ## Handler as UrlMatcher
   *
   * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.
   * The `handler` UrlMatcher is formatted using the matched param from the first matcher.
   * The url is replaced with the result.
   *
   * #### Example:
   * ```js
   * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
   * var handler = $umf.compile("/home/:fooId/:barId");
   * var rule = factory.fromUrlMatcher(urlMatcher, handler);
   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
   * var result = rule.handler(match); // '/home/123/456'
   * ```
   */
  fromUrlMatcher(urlMatcher, handler) {
    let _handler = handler;
    if (isString(handler)) handler = this.urlService.compile(handler);
    if (is(UrlMatcher)(handler)) _handler = (match) => handler.format(match);
    function matchUrlParamters(url) {
      const params = urlMatcher.exec(url.path, url.search, url.hash);
      return urlMatcher.validates(params) && params;
    }
    // Prioritize URLs, lowest to highest:
    // - Some optional URL parameters, but none matched
    // - No optional parameters in URL
    // - Some optional parameters, some matched
    // - Some optional parameters, all matched
    function matchPriority(params) {
      const optional = urlMatcher
        .parameters()
        .filter((param) => param.isOptional);
      if (!optional.length) return 0.000001;
      const matched = optional.filter((param) => params[param.id]);
      return matched.length / optional.length;
    }
    const details = { urlMatcher, matchPriority, type: "URLMATCHER" };
    return Object.assign(new BaseUrlRule(matchUrlParamters, _handler), details);
  }
  /**
   * A UrlRule which matches a state by its url
   *
   * #### Example:
   * ```js
   * var rule = factory.fromState($state.get('foo'), router);
   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
   * var result = rule.handler(match);
   * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }
   * ```
   */
  fromState(stateOrDecl, stateService, globals) {
    const state = StateObject.isStateDeclaration(stateOrDecl)
      ? stateOrDecl.$$state()
      : stateOrDecl;
    /**
     * Handles match by transitioning to matched state
     *
     * First checks if the router should start a new transition.
     * A new transition is not required if the current state's URL
     * and the new URL are already identical
     */
    const handler = (match) => {
      const $state = stateService;
      if (
        $state.href(state, match) !==
        $state.href(globals.current, globals.params)
      ) {
        $state.transitionTo(state, match, { inherit: true, source: "url" });
      }
    };
    const details = { state, type: "STATE" };
    return Object.assign(this.fromUrlMatcher(state.url, handler), details);
  }
  /**
   * A UrlRule which matches based on a regular expression
   *
   * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.
   *
   * ## Handler as a function
   *
   * If `handler` is a function, the function is invoked with:
   *
   * - regexp match array (from `regexp`)
   * - url: the current Url ([[UrlParts]])
   * - router: the router object ([[UIRouter]])
   *
   * #### Example:
   * ```js
   * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, match => "/home/" + match[1])
   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
   * var result = rule.handler(match); // '/home/bar'
   * ```
   *
   * ## Handler as string
   *
   * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.
   * The string is first interpolated using `string.replace()` style pattern.
   *
   * #### Example:
   * ```js
   * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, "/home/$1")
   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
   * var result = rule.handler(match); // '/home/bar'
   * ```
   */
  fromRegExp(regexp, handler) {
    if (regexp.global || regexp.sticky)
      throw new Error("Rule RegExp must not be global or sticky");
    /**
     * If handler is a string, the url will be replaced by the string.
     * If the string has any String.replace() style variables in it (like `$2`),
     * they will be replaced by the captures from [[match]]
     */
    const redirectUrlTo = (match) =>
      // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern
      handler.replace(
        /\$(\$|\d{1,2})/,
        (m, what) => match[what === "$" ? 0 : Number(what)],
      );
    const _handler = isString(handler) ? redirectUrlTo : handler;
    const matchParamsFromRegexp = (url) => regexp.exec(url.path);
    const details = { regexp, type: "REGEXP" };
    return Object.assign(
      new BaseUrlRule(matchParamsFromRegexp, _handler),
      details,
    );
  }
}
UrlRuleFactory.isUrlRule = (obj) =>
  obj && ["type", "match", "handler"].every((key) => isDefined(obj[key]));

/**
 * A base rule which calls `match`
 *
 * The value from the `match` function is passed through to the `handler`.
 */
class BaseUrlRule {
  constructor(match, handler) {
    this.match = match;
    this.type = "RAW";
    this.$id = -1;
    this._group = undefined;
    this.handler = handler || ((x) => x);
  }

  /**
   * This function should be overridden
   * @param {*} [params]
   * @returns {number}
   */
  matchPriority(params) {
    assert(isUndefined(params));
    return 0 - this.$id;
  }
}

const prioritySort = (a, b) => (b.priority || 0) - (a.priority || 0);

const typeSort = (a, b) => {
  const weights = { STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1 };
  return (weights[a.type] || 0) - (weights[b.type] || 0);
};

const urlMatcherSort = (a, b) =>
  !a.urlMatcher || !b.urlMatcher
    ? 0
    : UrlMatcher.compare(a.urlMatcher, b.urlMatcher);

const idSort = (a, b) => {
  // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL
  const useMatchPriority = { STATE: true, URLMATCHER: true };
  const equal = useMatchPriority[a.type] && useMatchPriority[b.type];
  return equal ? 0 : (a.$id || 0) - (b.$id || 0);
};

/**
 * Default rule priority sorting function.
 *
 * Sorts rules by:
 *
 * - Explicit priority (set rule priority using [[UrlRules.when]])
 * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)
 * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.
 * - Rule registration order (for rule types other than STATE and URLMATCHER)
 *   - Equally sorted State and UrlMatcher rules will each match the URL.
 *     Then, the *best* match is chosen based on how many parameter values were matched.
 */
let defaultRuleSortFn;
defaultRuleSortFn = (a, b) => {
  let cmp = prioritySort(a, b);
  if (cmp !== 0) return cmp;
  cmp = typeSort(a, b);
  if (cmp !== 0) return cmp;
  cmp = urlMatcherSort(a, b);
  if (cmp !== 0) return cmp;
  return idSort(a, b);
};
function getHandlerFn(handler) {
  if (
    !isFunction(handler) &&
    !isString(handler) &&
    !is(TargetState)(handler) &&
    !TargetState.isDef(handler)
  ) {
    throw new Error(
      "'handler' must be a string, function, TargetState, or have a state: 'newtarget' property",
    );
  }
  return isFunction(handler) ? handler : val(handler);
}
/**
 * API for managing URL rules
 *
 * This API is used to create and manage URL rules.
 * URL rules are a mechanism to respond to specific URL patterns.
 *
 * The most commonly used methods are [[otherwise]] and [[when]].
 *
 * This API is found at `$urlService.rules` (see: [[UIRouter.urlService]], [[URLService.rules]])
 */
class UrlRules {
  constructor(urlRuleFactory) {
    this._sortFn = defaultRuleSortFn;
    this._rules = [];
    this._id = 0;
    this.urlRuleFactory = urlRuleFactory;
  }

  /**
   * Defines the initial state, path, or behavior to use when the app starts.
   *
   * This rule defines the initial/starting state for the application.
   *
   * This rule is triggered the first time the URL is checked (when the app initially loads).
   * The rule is triggered only when the url matches either `""` or `"/"`.
   *
   * Note: The rule is intended to be used when the root of the application is directly linked to.
   * When the URL is *not* `""` or `"/"` and doesn't match other rules, the [[otherwise]] rule is triggered.
   * This allows 404-like behavior when an unknown URL is deep-linked.
   *
   * #### Example:
   * Start app at `home` state.
   * ```js
   * .initial({ state: 'home' });
   * ```
   *
   * #### Example:
   * Start app at `/home` (by url)
   * ```js
   * .initial('/home');
   * ```
   *
   * #### Example:
   * When no other url rule matches, go to `home` state
   * ```js
   * .initial((matchValue, url, router) => {
   *   console.log('initial state');
   *   return { state: 'home' };
   * })
   * ```
   *
   * @param handler The initial state or url path, or a function which returns the state or url path (or performs custom logic).
   */
  initial(handler) {
    const handlerFn = getHandlerFn(handler);
    const matchFn = (urlParts, router) =>
      router.globals.transitionHistory.size() === 0 &&
      !!/^\/?$/.exec(urlParts.path);
    this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
  }
  /**
   * Defines the state, url, or behavior to use when no other rule matches the URL.
   *
   * This rule is matched when *no other rule* matches.
   * It is generally used to handle unknown URLs (similar to "404" behavior, but on the client side).
   *
   * - If `handler` a string, it is treated as a url redirect
   *
   * #### Example:
   * When no other url rule matches, redirect to `/index`
   * ```js
   * .otherwise('/index');
   * ```
   *
   * - If `handler` is an object with a `state` property, the state is activated.
   *
   * #### Example:
   * When no other url rule matches, redirect to `home` and provide a `dashboard` parameter value.
   * ```js
   * .otherwise({ state: 'home', params: { dashboard: 'default' } });
   * ```
   *
   * - If `handler` is a function, the function receives the current url ([[UrlParts]]) and the [[UIRouter]] object.
   *   The function can perform actions, and/or return a value.
   *
   * #### Example:
   * When no other url rule matches, manually trigger a transition to the `home` state
   * ```js
   * .otherwise((matchValue, urlParts, router) => {
   *   router.stateService.go('home');
   * });
   * ```
   *
   * #### Example:
   * When no other url rule matches, go to `home` state
   * ```js
   * .otherwise((matchValue, urlParts, router) => {
   *   return { state: 'home' };
   * });
   * ```
   *
   * @param handler The url path to redirect to, or a function which returns the url path (or performs custom logic).
   */
  otherwise(handler) {
    const handlerFn = getHandlerFn(handler);
    this._otherwiseFn = this.urlRuleFactory.create(val(true), handlerFn);
    this._sorted = false;
  }
  /**
   * Remove a rule previously registered
   *
   * @param rule the matcher rule that was previously registered using [[rule]]
   */
  removeRule(rule) {
    removeFrom(this._rules, rule);
  }
  /**
   * Manually adds a URL Rule.
   *
   * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].
   * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).
   * Rules can be created using [[urlRuleFactory]], or created manually as simple objects.
   *
   * A rule should have a `match` function which returns truthy if the rule matched.
   * It should also have a `handler` function which is invoked if the rule is the best match.
   *
   * @return a function that deregisters the rule
   */
  rule(rule) {
    if (!UrlRuleFactory.isUrlRule(rule)) throw new Error("invalid rule");
    rule.$id = this._id++;
    rule.priority = rule.priority || 0;
    this._rules.push(rule);
    this._sorted = false;
    return () => this.removeRule(rule);
  }
  /**
   * Gets all registered rules
   *
   * @returns an array of all the registered rules
   */
  rules() {
    this.ensureSorted();
    return this._rules.concat(this._otherwiseFn ? [this._otherwiseFn] : []);
  }
  /**
   * Defines URL Rule priorities
   *
   * More than one rule ([[UrlRule]]) might match a given URL.
   * This `compareFn` is used to sort the rules by priority.
   * Higher priority rules should sort earlier.
   *
   * The [[defaultRuleSortFn]] is used by default.
   *
   * You only need to call this function once.
   * The `compareFn` will be used to sort the rules as each is registered.
   *
   * If called without any parameter, it will re-sort the rules.
   *
   * ---
   *
   * Url rules may come from multiple sources: states's urls ([[StateDeclaration.url]]), [[when]], and [[rule]].
   * Each rule has a (user-provided) [[UrlRule.priority]], a [[UrlRule.type]], and a [[UrlRule.$id]]
   * The `$id` is is the order in which the rule was registered.
   *
   * The sort function should use these data, or data found on a specific type
   * of [[UrlRule]] (such as [[StateRule.state]]), to order the rules as desired.
   *
   * #### Example:
   * This compare function prioritizes rules by the order in which the rules were registered.
   * A rule registered earlier has higher priority.
   *
   * ```js
   * function compareFn(a, b) {
   *   return a.$id - b.$id;
   * }
   * ```
   *
   * @param compareFn a function that compares to [[UrlRule]] objects.
   *    The `compareFn` should abide by the `Array.sort` compare function rules.
   *    Given two rules, `a` and `b`, return a negative number if `a` should be higher priority.
   *    Return a positive number if `b` should be higher priority.
   *    Return `0` if the rules are identical.
   *
   *    See the [mozilla reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description)
   *    for details.
   */
  sort(compareFn) {
    const sorted = this.stableSort(
      this._rules,
      (this._sortFn = compareFn || this._sortFn),
    );
    // precompute _sortGroup values and apply to each rule
    let group = 0;
    for (let i = 0; i < sorted.length; i++) {
      sorted[i]._group = group;
      if (
        i < sorted.length - 1 &&
        this._sortFn(sorted[i], sorted[i + 1]) !== 0
      ) {
        group++;
      }
    }
    this._rules = sorted;
    this._sorted = true;
  }

  ensureSorted() {
    this._sorted || this.sort();
  }

  stableSort(arr, compareFn) {
    const arrOfWrapper = arr.map((elem, idx) => ({ elem, idx }));
    arrOfWrapper.sort((wrapperA, wrapperB) => {
      const cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);
      return cmpDiff === 0 ? wrapperA.idx - wrapperB.idx : cmpDiff;
    });
    return arrOfWrapper.map((wrapper) => wrapper.elem);
  }
  /**
   * Registers a `matcher` and `handler` for custom URLs handling.
   *
   * The `matcher` can be:
   *
   * - a [[UrlMatcher]]: See: [[UrlMatcherFactory.compile]]
   * - a `string`: The string is compiled to a [[UrlMatcher]]
   * - a `RegExp`: The regexp is used to match the url.
   *
   * The `handler` can be:
   *
   * - a string: The url is redirected to the value of the string.
   * - a function: The url is redirected to the return value of the function.
   *
   * ---
   *
   * When the `handler` is a `string` and the `matcher` is a `UrlMatcher` (or string), the redirect
   * string is interpolated with parameter values.
   *
   * #### Example:
   * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
   * ```js
   * .when("/foo/:param1", "/bar/:param1")
   * ```
   *
   * ---
   *
   * When the `handler` is a string and the `matcher` is a `RegExp`, the redirect string is
   * interpolated with capture groups from the RegExp.
   *
   * #### Example:
   * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
   * ```js
   * .when(new RegExp("^/foo/(.*)$"), "/bar/$1");
   * ```
   *
   * ---
   *
   * When the handler is a function, it receives the matched value, the current URL, and the `UIRouter` object (See [[UrlRuleHandlerFn]]).
   * The "matched value" differs based on the `matcher`.
   * For [[UrlMatcher]]s, it will be the matched state params.
   * For `RegExp`, it will be the match array from `regexp.exec()`.
   *
   * If the handler returns a string, the URL is redirected to the string.
   *
   * #### Example:
   * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
   * ```js
   * .when(new RegExp("^/foo/(.*)$"), match => "/bar/" + match[1]);
   * ```
   *
   * Note: the `handler` may also invoke arbitrary code, such as `$state.go()`
   *
   * @param matcher A pattern `string` to match, compiled as a [[UrlMatcher]], or a `RegExp`.
   * @param handler The path to redirect to, or a function that returns the path.
   * @param options `{ priority: number }`
   *
   * @return the registered [[UrlRule]]
   */
  when(matcher, handler, options) {
    const rule = this.urlRuleFactory.create(matcher, handler);
    if (isDefined(options && options.priority))
      rule.priority = options.priority;
    this.rule(rule);
    return rule;
  }
}

class ParamFactory {
  constructor(urlServiceConfig) {
    this.urlServiceConfig = urlServiceConfig;
  }

  fromConfig(id, type, state) {
    return new Param(id, type, DefType.CONFIG, this.urlServiceConfig, state);
  }
  fromPath(id, type, state) {
    return new Param(id, type, DefType.PATH, this.urlServiceConfig, state);
  }
  fromSearch(id, type, state) {
    return new Param(id, type, DefType.SEARCH, this.urlServiceConfig, state);
  }
}

/**
 * API for URL management
 */
class UrlService {
  static $inject = [
    "$locationProvider",
    "$stateProvider",
    "$routerGlobalsProvider",
    "$urlConfigProvider",
  ];

  /**
   * @param {import("../../core/location/location").LocationProvider} $locationProvider
   * @param {import("../../router/state/state-service.js").StateProvider} stateService
   * @param globals
   * @param {import("../../router/url/url-config.js").UrlConfigProvider} urlConfigProvider
   */
  constructor($locationProvider, stateService, globals, urlConfigProvider) {
    this.stateService = stateService;
    this.stateService.urlService = this; // circular wiring
    this.$locationProvider = $locationProvider;

    this.$location = undefined;
    this.$browser = undefined;

    /** Provides services related to the URL */
    this.urlRuleFactory = new UrlRuleFactory(this, this.stateService, globals);

    /**
     * The nested [[UrlRules]] API for managing URL rules and rewrites
     *
     * See: [[UrlRules]] for details
     * @type {UrlRules}
     */
    this.rules = new UrlRules(this.urlRuleFactory);
    /**
     * The nested [[UrlConfig]] API to configure the URL and retrieve URL information
     *
     * See: [[UrlConfig]] for details
     * @type {import("./url-config").UrlConfigProvider}
     */
    this.config = urlConfigProvider;

    /** Creates a new [[Param]] for a given location (DefType) */
    this.paramFactory = new ParamFactory(this.config);

    /**
     * Gets the path part of the current url
     *
     * If the current URL is `/some/path?query=value#anchor`, this returns `/some/path`
     *
     * @return the path portion of the url
     */
    this.path = () => this.$location.path();
    /**
     * Gets the search part of the current url as an object
     *
     * If the current URL is `/some/path?query=value#anchor`, this returns `{ query: 'value' }`
     *
     * @return the search (query) portion of the url, as an object
     */
    this.search = () => this.$location.search();
    /**
     * Gets the hash part of the current url
     *
     * If the current URL is `/some/path?query=value#anchor`, this returns `anchor`
     *
     * @return the hash (anchor) portion of the url
     */
    this.hash = () => this.$location.hash();

    this._urlListeners = [];
  }

  $get = [
    "$location",
    "$browser",
    "$rootScope",
    /**
     *
     * @param {import('../../core/location/location.js').Location} $location
     * @param {import('../../services/browser.js').Browser} $browser
     * @param {import('../../core/scope/scope.js').Scope} $rootScope
     * @returns {UrlService}
     */
    ($location, $browser, $rootScope) => {
      this.$location = $location;
      this.$browser = $browser;
      $rootScope.$on("$locationChangeSuccess", (evt) => {
        this._urlListeners.forEach((fn) => {
          fn(evt);
        });
      });
      this.listen();
      return this;
    },
  ];

  /**
   * @returns {boolean}
   */
  html5Mode() {
    return (
      this.$locationProvider.getHtml5Mode().enabled &&
      typeof history !== "undefined"
    );
  }

  baseHref() {
    return (
      this._baseHref ||
      (this._baseHref = this.$browser.baseHref() || window.location.pathname)
    );
  }

  /**
   * Gets the current url, or updates the url
   *
   * ### Getting the current URL
   *
   * When no arguments are passed, returns the current URL.
   * The URL is normalized using the internal [[path]]/[[search]]/[[hash]] values.
   *
   * For example, the URL may be stored in the hash ([[HashLocationServices]]) or
   * have a base HREF prepended ([[PushStateLocationServices]]).
   *
   * The raw URL in the browser might be:
   *
   * ```
   * http://mysite.com/somepath/index.html#/internal/path/123?param1=foo#anchor
   * ```
   *
   * or
   *
   * ```
   * http://mysite.com/basepath/internal/path/123?param1=foo#anchor
   * ```
   *
   * then this method returns:
   *
   * ```
   * /internal/path/123?param1=foo#anchor
   * ```
   *
   *
   * #### Example:
   * ```js
   * locationServices.url(); // "/some/path?query=value#anchor"
   * ```
   *
   * ### Updating the URL
   *
   * When `newurl` arguments is provided, changes the URL to reflect `newurl`
   *
   * #### Example:
   * ```js
   * locationServices.url("/some/path?query=value#anchor", true);
   * ```
   *
   * @param {string} [newUrl] The new value for the URL.
   *               This url should reflect only the new internal [[path]], [[search]], and [[hash]] values.
   *               It should not include the protocol, site, port, or base path of an absolute HREF.
   * @param {boolean} [replace] When true, replaces the current history entry (instead of appending it) with this new url
   * @param {any} [state] The history's state object, i.e., pushState (if the LocationServices implementation supports it)
   *
   * @return the url (after potentially being processed)
   */
  url(newUrl, replace = false, state) {
    if (isDefined(newUrl)) this.$location.url(newUrl);
    if (replace) this.$location.replace();
    if (state) this.$location.state(state);
    return this.$location.url();
  }

  /**
   * @internal
   *
   * Registers a low level url change handler
   *
   * Note: Because this is a low level handler, it's not recommended for general use.
   *
   * #### Example:
   * ```js
   * let deregisterFn = locationServices.onChange((evt) => console.log("url change", evt));
   * ```
   *
   * @param callback a function that will be called when the url is changing
   * @return a function that de-registers the callback
   */
  onChange(callback) {
    this._urlListeners.push(callback);
    return () => removeFrom(this._urlListeners)(callback);
  }

  /**
   * Gets the current URL parts
   *
   * This method returns the different parts of the current URL (the [[path]], [[search]], and [[hash]]) as a [[UrlParts]] object.
   */
  parts() {
    return { path: this.path(), search: this.search(), hash: this.hash() };
  }
  /**
   * Activates the best rule for the current URL
   *
   * Checks the current URL for a matching [[UrlRule]], then invokes that rule's handler.
   * This method is called internally any time the URL has changed.
   *
   * This effectively activates the state (or redirect, etc) which matches the current URL.
   *
   * #### Example:
   * ```js
   *
   * fetch('/states.json').then(resp => resp.json()).then(data => {
   *   data.forEach(state => $stateRegistry.register(state));
   *   urlService.listen();
   *   // Find the matching URL and invoke the handler.
   *   urlService.sync();
   * });
   * ```
   */
  sync(evt) {
    if (evt && evt.defaultPrevented) return;
    const stateService = this.stateService;
    const url = {
      path: this.path(),
      search: this.search(),
      hash: this.hash(),
    };
    /**
     * @type {*}
     */
    const best = this.match(url);
    const applyResult = pattern([
      [isString, (newurl) => this.url(newurl, true)],
      [
        TargetState.isDef,
        (def) => stateService.go(def.state, def.params, def.options),
      ],
      [
        is(TargetState),
        (target) =>
          stateService.go(target.state(), target.params(), target.options()),
      ],
    ]);

    applyResult(best && best.rule.handler(best.match, url));
  }
  /**
   * Starts or stops listening for URL changes
   *
   * Call this sometime after calling [[deferIntercept]] to start monitoring the url.
   * This causes ng-router to start listening for changes to the URL, if it wasn't already listening.
   *
   * If called with `false`, ng-router will stop listening (call listen(true) to start listening again).
   *
   * #### Example:
   * ```js
   *
   * fetch('/states.json').then(resp => resp.json()).then(data => {
   *   data.forEach(state => $stateRegistry.register(state));
   *   // Start responding to URL changes
   *   urlService.listen();
   *   urlService.sync();
   * });
   * ```
   *
   * @param enabled `true` or `false` to start or stop listening to URL changes
   */
  listen(enabled) {
    if (enabled === false) {
      this._stopListeningFn && this._stopListeningFn();
      delete this._stopListeningFn;
    } else {
      return (this._stopListeningFn =
        this._stopListeningFn || this.onChange((evt) => this.sync(evt)));
    }
  }

  /**
   * Matches a URL
   *
   * Given a URL (as a [[UrlParts]] object), check all rules and determine the best matching rule.
   * Return the result as a [[MatchResult]].
   * @returns {any}
   */
  match(url) {
    url = Object.assign({ path: "", search: {}, hash: "" }, url);
    const rules = this.rules.rules();
    // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined
    /**
     *
     * @param {import("./url-rule").BaseUrlRule} rule
     */
    const checkRule = (rule) => {
      const match = rule.match(url);
      return match && { match, rule, weight: rule.matchPriority(match) };
    };
    // The rules are pre-sorted.
    // - Find the first matching rule.
    // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.
    // - Choose the rule with the highest match weight.
    let best;
    for (let i = 0; i < rules.length; i++) {
      // Stop when there is a 'best' rule and the next rule sorts differently than it.
      if (best && best.rule._group !== rules[i]._group) break;
      const current = checkRule(rules[i]);
      // Pick the best MatchResult
      best =
        !best || (current && current.weight > best.weight) ? current : best;
    }
    return best;
  }

  update(read) {
    if (read) {
      this.location = this.url();
      return;
    }
    if (this.url() === this.location) return;
    this.url(/** @type {string} */ (this.location), true);
  }

  /**
   * Internal API.
   *
   * Pushes a new location to the browser history.
   *
   * @internal
   * @param urlMatcher
   * @param params
   * @param options
   */
  push(urlMatcher, params, options) {
    const replace = options && !!options.replace;
    this.url(urlMatcher.format(params || {}), replace);
  }

  /**
   * Builds and returns a URL with interpolated parameters
   *
   * #### Example:
   * ```js
   * matcher = $umf.compile("/about/:person");
   * params = { person: "bob" };
   * $bob = $urlService.href(matcher, params);
   * // $bob == "/about/bob";
   * ```
   *
   * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.
   * @param params An object of parameter values to fill the matcher's required parameters.
   * @param options Options object. The options are:
   *
   * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
   *
   * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
   */
  href(urlMatcher, params, options) {
    let url = urlMatcher.format(params);
    if (url == null) return null;
    options = options || { absolute: false };
    const isHtml5 = this.html5Mode();
    if (!isHtml5 && url !== null) {
      url = "#" + this.$locationProvider.getHashPrefix() + url;
    }
    url = appendBasePath(url, isHtml5, options.absolute, this.baseHref());
    if (!options.absolute || !url) {
      return url;
    }
    const slash = !isHtml5 && url ? "/" : "";
    const cfgPort = this.$location.port();
    const port = cfgPort === 80 || cfgPort === 443 ? "" : ":" + cfgPort;
    return [
      this.$location.protocol(),
      "://",
      this.$location.host(),
      port,
      slash,
      url,
    ].join("");
  }

  /**
   * Creates a [[UrlMatcher]] for the specified pattern.
   *
   * @param pattern  The URL pattern.
   * @param config  The config object hash.
   * @returns The UrlMatcher.
   */
  compile(pattern, config) {
    const urlConfig = this.config;
    // backward-compatible support for config.params -> config.state.params
    const params = config && !config.state && config.params;
    config = params ? Object.assign({ state: { params } }, config) : config;
    const globalConfig = {
      strict: urlConfig._isStrictMode,
      caseInsensitive: urlConfig._isCaseInsensitive,
    };
    return new UrlMatcher(
      pattern,
      urlConfig.paramTypes,
      this.paramFactory,
      Object.assign(globalConfig, config),
    );
  }

  /**
   * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.
   *
   * @param object  The object to perform the type check against.
   * @returns `true` if the object matches the `UrlMatcher` interface, by
   *          implementing all the same methods.
   */
  isMatcher(object) {
    // TODO: typeof?
    if (!isObject(object)) return false;
    let result = true;
    Object.entries(UrlMatcher.prototype).forEach(([name, val]) => {
      if (isFunction(val))
        result = result && isDefined(object[name]) && isFunction(object[name]);
    });
    return result;
  }
}

function appendBasePath(url, isHtml5, absolute, baseHref) {
  if (baseHref === "/") return url;
  if (isHtml5) return stripLastPathElement(baseHref) + url;
  if (absolute) return baseHref.slice(1) + url;
  return url;
}

class StateMatcher {
  constructor(_states) {
    this._states = _states;
  }
  isRelative(stateName) {
    stateName = stateName || "";
    return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
  }
  find(stateOrName, base, matchGlob = true) {
    if (!stateOrName && stateOrName !== "") return undefined;
    const isStr = isString(stateOrName);
    let name = isStr ? stateOrName : stateOrName.name;
    if (this.isRelative(name)) name = this.resolvePath(name, base);
    const state = this._states[name];
    if (
      state &&
      (isStr ||
        (!isStr && (state === stateOrName || state.self === stateOrName)))
    ) {
      return state;
    } else if (isStr && matchGlob) {
      const _states = Object.values(this._states);
      const matches = _states.filter(
        (_state) =>
          _state.__stateObjectCache.nameGlob &&
          _state.__stateObjectCache.nameGlob.matches(name),
      );
      if (matches.length > 1) {
        console.error(
          `stateMatcher.find: Found multiple matches for ${name} using glob: `,
          matches.map((match) => match.name),
        );
      }
      return matches[0];
    }
    return undefined;
  }
  resolvePath(name, base) {
    if (!base) throw new Error(`No reference point given for path '${name}'`);
    const baseState = this.find(base);
    const splitName = name.split(".");
    const pathLength = splitName.length;
    let i = 0,
      current = baseState;
    for (; i < pathLength; i++) {
      if (splitName[i] === "" && i === 0) {
        current = baseState;
        continue;
      }
      if (splitName[i] === "^") {
        if (!current.parent)
          throw new Error(
            `Path '${name}' not valid for state '${baseState.name}'`,
          );
        current = current.parent;
        continue;
      }
      break;
    }
    const relName = splitName.slice(i).join(".");
    return current.name + (current.name && relName ? "." : "") + relName;
  }
}

function parseUrl(url) {
  if (!isString(url)) return false;
  const root = url.charAt(0) === "^";
  return { val: root ? url.substring(1) : url, root };
}

function selfBuilder(state) {
  state.self.$$state = () => state;
  return state.self;
}

function dataBuilder(state) {
  if (state.parent && state.parent.data) {
    state.data = state.self.data = inherit(state.parent.data, state.data);
  }
  return state.data;
}

function getUrlBuilder($urlService, root) {
  return function (stateObject) {
    let stateDec = stateObject.self;
    // For future states, i.e., states whose name ends with `.**`,
    // match anything that starts with the url prefix
    if (
      stateDec &&
      stateDec.url &&
      stateDec.name &&
      stateDec.name.match(/\.\*\*$/)
    ) {
      const newStateDec = {};
      copy(stateDec, newStateDec);
      newStateDec.url += "{remainder:any}"; // match any path (.*)
      stateDec = newStateDec;
    }
    const parent = stateObject.parent;
    const parsed = parseUrl(stateDec.url);
    const url = !parsed
      ? stateDec.url
      : $urlService.compile(parsed.val, { state: stateDec });
    if (!url) return null;
    if (!$urlService.isMatcher(url))
      throw new Error(`Invalid url '${url}' in state '${stateObject}'`);
    return parsed && parsed.root
      ? url
      : ((parent && parent.navigable) || root()).url.append(url);
  };
}

function getNavigableBuilder(isRoot) {
  return function (state) {
    return !isRoot(state) && state.url
      ? state
      : state.parent
        ? state.parent.navigable
        : null;
  };
}

function getParamsBuilder(paramFactory) {
  return function (state) {
    const makeConfigParam = (_config, id) =>
      paramFactory.fromConfig(id, null, state.self);
    const urlParams =
      (state.url && state.url.parameters({ inherit: false })) || [];
    const nonUrlParams = Object.values(
      map(
        omit(
          state.params || {},
          urlParams.map((x) => x.id),
        ),
        makeConfigParam,
      ),
    );
    return urlParams
      .concat(nonUrlParams)
      .map((p) => [p.id, p])
      .reduce(applyPairs, {});
  };
}

function pathBuilder(state) {
  return state.parent ? state.parent.path.concat(state) : [state];
}

function includesBuilder(state) {
  const includes = state.parent ? Object.assign({}, state.parent.includes) : {};
  includes[state.name] = true;
  return includes;
}

/**
 * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].
 *
 * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
 * validates the `resolve` property and converts it to a [[Resolvable]] array.
 *
 * resolve: input value can be:
 *
 * {
 *   // analyzed but not injected
 *   myFooResolve: function() { return "myFooData"; },
 *
 *   // function.toString() parsed, "DependencyName" dep as string (not min-safe)
 *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },
 *
 *   // Array split; "DependencyName" dep as string
 *   myBazResolve: [ "DependencyName", function(dep) { return dep.fetchSomethingAsPromise() },
 *
 *   // Array split; DependencyType dep as token (compared using ===)
 *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },
 *
 *   // val.$inject used as deps
 *   // where:
 *   //     corgeResolve.$inject = ["DependencyName"];
 *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }
 *   // then "DependencyName" dep as string
 *   myCorgeResolve: corgeResolve,
 *
 *  // inject service by name
 *  // When a string is found, desugar creating a resolve that injects the named service
 *   myGraultResolve: "SomeService"
 * }
 *
 * or:
 *
 * [
 *   new Resolvable("myFooResolve", function() { return "myFooData" }),
 *   new Resolvable("myBarResolve", function(dep) { return dep.fetchSomethingAsPromise() }, [ "DependencyName" ]),
 *   { provide: "myBazResolve", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ "DependencyName" ] }
 * ]
 */
function resolvablesBuilder(state) {
  /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */
  const objects2Tuples = (resolveObj, resolvePolicies) =>
    Object.keys(resolveObj || {}).map((token) => ({
      token,
      val: resolveObj[token],
      deps: undefined,
      policy: resolvePolicies[token],
    }));
  /** fetch DI annotations from a function or ng1-style array */
  const annotateFn = (fn) => {
    const $injector = window.angular.$injector;
    // ng1 doesn't have an $injector until runtime.
    // If the $injector doesn't exist, use "deferred" literal as a
    // marker indicating they should be annotated when runtime starts
    return (
      fn["$inject"] ||
      ($injector && annotate(fn, $injector.strictDi)) ||
      "deferred"
    );
  };
  /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */
  const isResolveLiteral = (obj) => !!(obj.token && obj.resolveFn);
  /** true if the object looks like a tuple from obj2Tuples */
  const isTupleFromObj = (obj) =>
    !!(
      obj &&
      obj.val &&
      (isString(obj.val) || Array.isArray(obj.val) || isFunction(obj.val))
    );

  // Given a literal resolve or provider object, returns a Resolvable
  const literal2Resolvable = pattern([
    [
      (x) => x.resolveFn,
      (p) => new Resolvable(getToken(p), p.resolveFn, p.deps, p.policy),
    ],
    [
      (x) => x.useFactory,
      (p) =>
        new Resolvable(
          getToken(p),
          p.useFactory,
          p.deps || p.dependencies,
          p.policy,
        ),
    ],
    [
      (x) => x.useClass,
      (p) => new Resolvable(getToken(p), () => new p.useClass(), [], p.policy),
    ],
    [
      (x) => x.useValue,
      (p) =>
        new Resolvable(getToken(p), () => p.useValue, [], p.policy, p.useValue),
    ],
    [
      (x) => x.useExisting,
      (p) => new Resolvable(getToken(p), (x) => x, [p.useExisting], p.policy),
    ],
  ]);
  const tuple2Resolvable = pattern([
    [
      pipe((x) => x.val, isString),
      (tuple) =>
        new Resolvable(tuple.token, (x) => x, [tuple.val], tuple.policy),
    ],
    [
      pipe((x) => x.val, Array.isArray),
      (tuple) =>
        new Resolvable(
          tuple.token,
          tail(tuple.val),
          tuple.val.slice(0, -1),
          tuple.policy,
        ),
    ],
    [
      pipe((x) => x.val, isFunction),
      (tuple) =>
        new Resolvable(
          tuple.token,
          tuple.val,
          annotateFn(tuple.val),
          tuple.policy,
        ),
    ],
  ]);
  const item2Resolvable = pattern([
    [is(Resolvable), (r) => r],
    [isResolveLiteral, literal2Resolvable],
    [isTupleFromObj, tuple2Resolvable],
    [
      val(true),
      (obj) => {
        throw new Error("Invalid resolve value: " + stringify(obj));
      },
    ],
  ]);
  // If resolveBlock is already an array, use it as-is.
  // Otherwise, assume it's an object and convert to an Array of tuples
  const decl = state.resolve;
  const items = Array.isArray(decl)
    ? decl
    : objects2Tuples(decl, state.resolvePolicy || {});
  return items.map(item2Resolvable);
}
/**
 * A internal global service
 *
 * StateBuilder is a factory for the internal [[StateObject]] objects.
 *
 * When you register a state with the [[StateRegistry]], you register a plain old javascript object which
 * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding
 * [[StateObject]] object, which has an API and is used internally.
 *
 * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function
 * using the [[builder]] method.
 */
class StateBuilder {
  constructor(matcher, urlService) {
    this.matcher = matcher;
    this.$injector = undefined;
    const self = this;
    const root = () => matcher.find("");
    function parentBuilder(state) {
      if (isRoot(state)) return null;
      return matcher.find(self.parentName(state)) || root();
    }
    this.builders = {
      name: [(state) => state.name],
      self: [selfBuilder],
      parent: [parentBuilder],
      data: [dataBuilder],
      // Build a URLMatcher if necessary, either via a relative or absolute URL
      url: [getUrlBuilder(urlService, root)],
      // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
      navigable: [getNavigableBuilder(isRoot)],
      // TODO
      params: [getParamsBuilder(urlService.paramFactory)],
      // Each framework-specific ng-router implementation should define its own `views` builder
      // e.g., src/ng1/statebuilders/views.ts
      views: [],
      // Keep a full path from the root down to this state as this is needed for state activation.
      path: [pathBuilder],
      // Speed up $state.includes() as it's used a lot
      includes: [includesBuilder],
      resolvables: [resolvablesBuilder],
    };
  }
  builder(name, fn) {
    const builders = this.builders;
    const array = builders[name] || [];
    // Backwards compat: if only one builder exists, return it, else return whole arary.
    if (isString(name) && !isDefined(fn))
      return array.length > 1 ? array : array[0];
    if (!isString(name) || !isFunction(fn)) return;
    builders[name] = array;
    builders[name].push(fn);
    return () => builders[name].splice(builders[name].indexOf(fn, 1)) && null;
  }
  /**
   * Builds all of the properties on an essentially blank State object, returning a State object which has all its
   * properties and API built.
   *
   * @param state an uninitialized State object
   * @returns the built State object
   */
  build(state) {
    const { matcher, builders } = this;
    const parent = this.parentName(state);
    if (parent && !matcher.find(parent, undefined, false)) {
      return null;
    }
    for (const key in builders) {
      if (!Object.prototype.hasOwnProperty.call(builders, key)) continue;
      const chain = builders[key].reduce(
        (parentFn, step) => (_state) => step(_state, parentFn),
        () => {},
      );
      state[key] = chain(state);
    }
    return state;
  }

  parentName(state) {
    // name = 'foo.bar.baz.**'
    const name = state.name || "";
    // segments = ['foo', 'bar', 'baz', '.**']
    const segments = name.split(".");
    // segments = ['foo', 'bar', 'baz']
    const lastSegment = segments.pop();
    // segments = ['foo', 'bar'] (ignore .** segment for future states)
    if (lastSegment === "**") segments.pop();
    if (segments.length) {
      if (state.parent) {
        throw new Error(
          `States that specify the 'parent:' property should not have a '.' in their name (${name})`,
        );
      }
      // 'foo.bar'
      return segments.join(".");
    }
    if (!state.parent) return "";
    return isString(state.parent) ? state.parent : state.parent.name;
  }
  name(state) {
    const name = state.name;
    if (name.indexOf(".") !== -1 || !state.parent) return name;
    const parentName = isString(state.parent)
      ? state.parent
      : state.parent.name;
    return parentName ? parentName + "." + name : name;
  }
}

function isRoot(state) {
  return state.name === "";
}

/** extracts the token from a Provider or provide literal */
function getToken(p) {
  return p.provide || p.token;
}

class StateQueueManager {
  /**
   * @param {import("./state-registry.js").StateRegistryProvider} stateRegistry
   * @param {*} urlServiceRules
   * @param {*} states
   * @param {*} builder
   * @param {*} listeners
   */
  constructor(stateRegistry, urlServiceRules, states, builder, listeners) {
    this.stateRegistry = stateRegistry;
    this.urlServiceRules = urlServiceRules;
    this.states = states;
    this.builder = builder;
    this.listeners = listeners;
    /**
     * @type {Array<StateObject>}
     */
    this.queue = [];
  }

  register(stateDecl) {
    const state = new StateObject(stateDecl);
    if (!isString(name)) throw new Error("State must have a valid name");
    if (
      Object.prototype.hasOwnProperty.call(this.states, state.name) ||
      this.queue.map((x) => x.name).includes(state.name)
    )
      throw new Error(`State '${state.name}' is already defined`);
    this.queue.push(state);
    this.flush();
    return state;
  }

  flush() {
    const { queue, states, builder } = this;
    const registered = [], // states that got registered
      orphans = [], // states that don't yet have a parent registered
      previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered
    const getState = (name) =>
      Object.prototype.hasOwnProperty.call(this.states, name) &&
      this.states[name];
    const notifyListeners = () => {
      if (registered.length) {
        this.listeners.forEach((listener) =>
          listener(
            "registered",
            registered.map((s) => s.self),
          ),
        );
      }
    };
    while (queue.length > 0) {
      const state = queue.shift();
      const name = state.name;
      const result = builder.build(state);
      const orphanIdx = orphans.indexOf(state);
      if (result) {
        const existingState = getState(name);
        if (existingState && existingState.name === name) {
          throw new Error(`State '${name}' is already defined`);
        }
        const existingFutureState = getState(name + ".**");
        if (existingFutureState) {
          // Remove future state of the same name
          this.stateRegistry.deregister(existingFutureState);
        }
        states[name] = state;
        this.attachRoute(state);
        if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);
        registered.push(state);
        continue;
      }
      const prev = previousQueueLength[name];
      previousQueueLength[name] = queue.length;
      if (orphanIdx >= 0 && prev === queue.length) {
        // Wait until two consecutive iterations where no additional states were dequeued successfully.
        // throw new Error(`Cannot register orphaned state '${name}'`);
        queue.push(state);
        notifyListeners();
        return states;
      } else if (orphanIdx < 0) {
        orphans.push(state);
      }
      queue.push(state);
    }
    notifyListeners();
    return states;
  }
  attachRoute(state) {
    if (state.abstract || !state.url) return;
    const rulesApi = this.urlServiceRules;
    rulesApi.rule(rulesApi.urlRuleFactory.create(state));
  }
}

/**
 * A registry for all of the application's [[StateDeclaration]]s
 *
 * This API is found at `$stateRegistry` ([[UIRouter.stateRegistry]])
 */
class StateRegistryProvider {
  static $inject = [
    "$urlServiceProvider",
    "$stateProvider",
    "$routerGlobalsProvider",
    "$viewProvider",
  ];
  constructor(urlService, stateService, globals, viewService) {
    this.states = {};
    stateService.stateRegistry = this; // <- circular wiring
    this.urlService = urlService;
    this.urlServiceRules = urlService.rules;
    this.$injector = undefined;
    this.listeners = [];
    this.matcher = new StateMatcher(this.states);
    this.builder = new StateBuilder(this.matcher, urlService);
    // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties
    // TODO we can probably move this inside buildr
    this.builder.builder("views", ng1ViewsBuilder);
    this.builder.builder("onExit", this.getStateHookBuilder("onExit"));
    this.builder.builder("onRetain", this.getStateHookBuilder("onRetain"));
    this.builder.builder("onEnter", this.getStateHookBuilder("onEnter"));

    this.stateQueue = new StateQueueManager(
      this,
      this.urlServiceRules,
      this.states,
      this.builder,
      this.listeners,
    );

    this.registerRoot();

    viewService._pluginapi._rootViewContext(this.root());
    globals.$current = this.root();
    globals.current = globals.$current.self;
  }

  $get = [
    "$injector",
    /**
     *
     * @param {import("../../core/di/internal-injector").InjectorService} $injector
     * @returns
     */
    ($injector) => {
      this.$injector = $injector;
      this.builder.$injector = $injector;
      return this;
    },
  ];

  /**
   * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,
   * `onRetain` callback hooks on a [[Ng1StateDeclaration]].
   *
   * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
   * ensures that those hooks are injectable for @uirouter/angularjs (ng1).
   *
   * @internalapi
   */
  getStateHookBuilder(hookName) {
    let that = this;
    return function stateHookBuilder(stateObject) {
      const hook = stateObject[hookName];
      const pathname = hookName === "onExit" ? "from" : "to";
      function decoratedNg1Hook(trans, state) {
        const resolveContext = new ResolveContext(trans.treeChanges(pathname));
        const subContext = resolveContext.subContext(state.$$state());
        const locals = Object.assign(getLocals(subContext), {
          $state$: state,
          $transition$: trans,
        });
        return that.$injector.invoke(hook, this, locals);
      }
      return hook ? decoratedNg1Hook : undefined;
    };
  }

  /**
   * @private
   */
  registerRoot() {
    const rootStateDef = {
      name: "",
      url: "^",
      views: null,
      params: {
        "#": { value: null, type: "hash", dynamic: true },
      },
      abstract: true,
    };
    this._root = this.stateQueue.register(rootStateDef);
    this._root.navigable = null;
  }

  /**
   * Listen for a State Registry events
   *
   * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.
   *
   * #### Example:
   * ```js
   * let allStates = registry.get();
   *
   * // Later, invoke deregisterFn() to remove the listener
   * let deregisterFn = registry.onStatesChanged((event, states) => {
   *   switch(event) {
   *     case: 'registered':
   *       states.forEach(state => allStates.push(state));
   *       break;
   *     case: 'deregistered':
   *       states.forEach(state => {
   *         let idx = allStates.indexOf(state);
   *         if (idx !== -1) allStates.splice(idx, 1);
   *       });
   *       break;
   *   }
   * });
   * ```
   *
   * @param listener a callback function invoked when the registered states changes.
   *        The function receives two parameters, `event` and `state`.
   *        See [[StateRegistryListener]]
   * @return a function that deregisters the listener
   */
  onStatesChanged(listener) {
    this.listeners.push(listener);
    return function deregisterListener() {
      removeFrom(this.listeners)(listener);
    }.bind(this);
  }
  /**
   * Gets the implicit root state
   *
   * Gets the root of the state tree.
   * The root state is implicitly created by ng-router.
   * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]
   *
   * @return the root [[StateObject]]
   */
  root() {
    return this._root;
  }
  /**
   * Adds a state to the registry
   *
   * Registers a [[StateDeclaration]] or queues it for registration.
   *
   * Note: a state will be queued if the state's parent isn't yet registered.
   *
   * @param stateDefinition the definition of the state to register.
   * @returns the internal [[StateObject]] object.
   *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).
   *          If the state was only queued, then the object is not fully built.
   */
  register(stateDefinition) {
    return this.stateQueue.register(stateDefinition);
  }

  _deregisterTree(state) {
    const all = this.get().map((s) => s.$$state());
    const getChildren = (states) => {
      const _children = all.filter((s) => states.indexOf(s.parent) !== -1);
      return _children.length === 0
        ? _children
        : _children.concat(getChildren(_children));
    };
    const children = getChildren([state]);
    const deregistered = [state].concat(children).reverse();
    deregistered.forEach((_state) => {
      const rulesApi = this.urlServiceRules;
      // Remove URL rule
      rulesApi
        .rules()
        .filter(propEq("state", _state))
        .forEach((rule) => rulesApi.removeRule(rule));
      // Remove state from registry
      delete this.states[_state.name];
    });
    return deregistered;
  }
  /**
   * Removes a state from the registry
   *
   * This removes a state from the registry.
   * If the state has children, they are are also removed from the registry.
   *
   * @param stateOrName the state's name or object representation
   * @returns {import('./state-object').StateObject[]} a list of removed states
   */
  deregister(stateOrName) {
    const _state = this.get(stateOrName);
    if (!_state)
      throw new Error("Can't deregister state; not found: " + stateOrName);
    const deregisteredStates = this._deregisterTree(_state.$$state());
    this.listeners.forEach((listener) =>
      listener(
        "deregistered",
        deregisteredStates.map((s) => s.self),
      ),
    );
    return deregisteredStates;
  }

  get(stateOrName, base) {
    if (arguments.length === 0)
      return Object.keys(this.states).map((name) => this.states[name].self);
    const found = this.matcher.find(stateOrName, base);
    return (found && found.self) || null;
  }

  /**
   * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).
   * More than one BuilderFunction can be registered for a given property.
   *
   * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.
   *
   * @param property The name of the State property being registered for.
   * @param builderFunction The BuilderFunction which will be used to build the State property
   * @returns a function which deregisters the BuilderFunction
   */
  decorator(property, builderFunction) {
    return this.builder.builder(property, builderFunction);
  }
}

const getLocals = (ctx) => {
  const tokens = ctx.getTokens().filter(isString);
  const tuples = tokens.map((key) => {
    const resolvable = ctx.getResolvable(key);
    const waitPolicy = ctx.getPolicy(resolvable).async;
    return [
      key,
      waitPolicy === "NOWAIT" ? resolvable.promise : resolvable.data,
    ];
  });
  return tuples.reduce(applyPairs, {});
};

function parseStateRef(ref) {
  const paramsOnly = ref.match(/^\s*({[^}]*})\s*$/);
  if (paramsOnly) ref = "(" + paramsOnly[1] + ")";
  const parsed = ref
    .replace(/\n/g, " ")
    .match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);
  if (!parsed || parsed.length !== 4)
    throw new Error("Invalid state ref '" + ref + "'");
  return { state: parsed[1] || null, paramExpr: parsed[3] || null };
}

function stateContext(el) {
  const $ngView = getInheritedData(el, "$ngView");
  const path = parse("$cfg.path")($ngView);
  return path ? tail(path).state.name : undefined;
}

function processedDef($state, $element, def) {
  const ngState = def.ngState || $state.current.name;
  const ngStateOpts = Object.assign(
    defaultOpts($element, $state),
    def.ngStateOpts || {},
  );
  const href = $state.href(ngState, def.ngStateParams, ngStateOpts);
  return { ngState, ngStateParams: def.ngStateParams, ngStateOpts, href };
}

function getTypeInfo(el) {
  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
  const isSvg =
    Object.prototype.toString.call(el.getAttribute("href")) ===
    "[object SVGAnimatedString]";
  const isForm = el.nodeName === "FORM";
  return {
    attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
    isAnchor: el.nodeName === "A",
    clickable: !isForm,
  };
}

function clickHook(el, $state, type, getDef, scope) {
  return function (e) {
    const button = e.which || e.button,
      target = getDef();

    let res =
      button > 1 ||
      e.ctrlKey ||
      e.metaKey ||
      e.shiftKey ||
      e.altKey ||
      el.getAttribute("target");
    if (!res) {
      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
      const transition = setTimeout(function () {
        if (!el.getAttribute("disabled")) {
          var res = $state.go(
            target.ngState,
            target.ngStateParams,
            target.ngStateOpts,
          );
          res.then(() => {
            scope.$emit("$updateBrowser");
          });
        }
      });
      e.preventDefault();
      // if the state has no URL, ignore one preventDefault from the <a> directive.
      let ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
      e.preventDefault = function () {
        if (ignorePreventDefaultCount-- <= 0) clearTimeout(transition);
      };
    } else {
      // ignored
      e.preventDefault();
      e.stopImmediatePropagation();
    }
  };
}

function defaultOpts(el, $state) {
  return {
    relative: stateContext(el) || $state.$current,
    inherit: true,
    source: "sref",
  };
}

function bindEvents(element, scope, hookFn, ngStateOpts) {
  let events;
  if (ngStateOpts) {
    events = ngStateOpts.events;
  }
  if (!Array.isArray(events)) {
    events = ["click"];
  }
  //const on = element.on ? "on" : "bind";

  for (const event of events) {
    element.addEventListener(event, hookFn);
  }
  scope.$on("$destroy", function () {
    // const off = element.off ? "off" : "unbind";
    for (const event of events) {
      element.removeEventListener(event, hookFn);
    }
  });
}

// // TODO: SEPARATE THESE OUT

$StateRefDirective.$inject = ["$state", "$stateRegistry", "$transitions"];
function $StateRefDirective(
  $stateService,
  $stateRegistry,
  $transitions,
) {
  const $state = $stateService;
  return {
    restrict: "A",
    require: ["?^ngSrefActive", "?^ngSrefActiveEq"],
    link: (scope, element, attrs, ngSrefActive) => {
      const type = getTypeInfo(element);
      const active = ngSrefActive[1] || ngSrefActive[0];
      let unlinkInfoFn = null;
      const rawDef = {};
      const getDef = () => processedDef($state, element, rawDef);
      const ref = parseStateRef(attrs.ngSref);
      rawDef.ngState = ref.state;
      rawDef.ngStateOpts = attrs.ngSrefOpts
        ? scope.$eval(attrs.ngSrefOpts)
        : {};

      function update() {
        // TODO this update used to happen inside a digest watche
        rawDef.ngStateParams = Object.assign({}, scope.$eval(ref.paramExpr));
        const def = getDef();
        if (unlinkInfoFn) {
          unlinkInfoFn();
        }
        if (active) {
          unlinkInfoFn = active.$$addStateInfo(def.ngState, def.ngStateParams);
        }
        if (def.href != null) {
          attrs.$set(type.attr, def.href);
        }
      }

      if (ref.paramExpr) {
        scope.$watch(
          ref.paramExpr,
          function (val) {
            rawDef.ngStateParams = Object.assign({}, val);
            update();
          },
          true,
        );
        rawDef.ngStateParams = Object.assign({}, scope.$eval(ref.paramExpr));
      }

      update();
      scope.$on("$destroy", $stateRegistry.onStatesChanged(update));
      scope.$on("$destroy", $transitions.onSuccess({}, update));
      if (!type.clickable) {
        return;
      }
      bindEvents(
        element,
        scope,
        clickHook(element, $state, type, getDef, scope),
        rawDef.ngStateOpts,
      );
    },
  };
}

$StateRefDynamicDirective.$inject = [
  "$state",
  "$stateRegistry",
  "$transitions",
];
function $StateRefDynamicDirective(
  $state,
  $stateRegistry,
  $transitions,
) {
  return {
    restrict: "A",
    require: ["?^ngSrefActive", "?^ngSrefActiveEq"],
    link: function (scope, element, attrs, ngSrefActive) {
      const type = getTypeInfo(element);
      const active = ngSrefActive[1] || ngSrefActive[0];
      let unlinkInfoFn = null;
      let hookFn;
      const rawDef = {};
      const getDef = () => processedDef($state, element, rawDef);
      const inputAttrs = ["ngState", "ngStateParams", "ngStateOpts"];
      const watchDeregFns = inputAttrs.reduce(
        (acc, attr) => ((acc[attr] = () => {}), acc),
        {},
      );
      function update() {
        const def = getDef();

        if (unlinkInfoFn) {
          unlinkInfoFn();
        }
        if (active) {
          unlinkInfoFn = active.$$addStateInfo(def.ngState, def.ngStateParams);
        }
        if (def.href != null) {
          attrs.$set(type.attr, def.href);
        }
      }
      inputAttrs.forEach((field) => {
        rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;
        attrs.$observe(field, (expr) => {
          watchDeregFns[field]();
          watchDeregFns[field] = scope.$watch(
            expr,
            (newval) => {
              rawDef[field] = newval;
              update();
            },
            true,
          );
        });
      });
      update();
      scope.$on("$destroy", $stateRegistry.onStatesChanged(update));
      scope.$on("$destroy", $transitions.onSuccess({}, update));
      if (!type.clickable) return;
      hookFn = clickHook(element, $state, type, getDef, scope);
      bindEvents(element, scope, hookFn, rawDef.ngStateOpts);
    },
  };
}

$StateRefActiveDirective.$inject = [
  "$state",
  "$routerGlobals",
  "$interpolate",
  "$stateRegistry",
  "$transitions",
];

/**
 *
 * @param {*} $state
 * @param {*} $routerGlobals
 * @param {*} $interpolate
 * @param {*} $stateRegistry
 * @param {*} $transitions
 * @returns {import("../../types").Directive}
 */
function $StateRefActiveDirective(
  $state,
  $routerGlobals,
  $interpolate,
  $stateRegistry,
  $transitions,
) {
  return {
    restrict: "A",
    controller: function ($scope, $element, $attrs) {
      let states = [];
      let activeEqClass;
      let ngSrefActive;
      // There probably isn't much point in $observing this
      // ngSrefActive and ngSrefActiveEq share the same directive object with some
      // slight difference in logic routing
      activeEqClass = $interpolate($attrs.ngSrefActiveEq || "", false)($scope);
      try {
        ngSrefActive = $scope.$eval($attrs.ngSrefActive);
      } catch (e) {
        // Do nothing. ngSrefActive is not a valid expression.
        // Fall back to using $interpolate below
      }
      ngSrefActive =
        ngSrefActive || $interpolate($attrs.ngSrefActive || "", false)($scope);
      setStatesFromDefinitionObject(ngSrefActive);
      // Allow ngSref to communicate with ngSrefActive[Equals]
      this.$$addStateInfo = function (newState, newParams) {
        // we already got an explicit state provided by ng-sref-active, so we
        // shadow the one that comes from ng-sref
        if (isObject(ngSrefActive) && states.length > 0) {
          return;
        }
        const deregister = addState(newState, newParams, ngSrefActive);
        update();
        return deregister;
      };
      function updateAfterTransition(trans) {
        trans.promise.then(update, () => {});
      }
      $scope.$on("$destroy", setupEventListeners());
      if ($routerGlobals.transition) {
        updateAfterTransition($routerGlobals.transition);
      }
      function setupEventListeners() {
        const deregisterStatesChangedListener =
          $stateRegistry.onStatesChanged(handleStatesChanged);
        const deregisterOnStartListener = $transitions.onStart(
          {},
          updateAfterTransition,
        );
        const deregisterStateChangeSuccessListener = $scope.$on(
          "$stateChangeSuccess",
          update,
        );
        return function cleanUp() {
          deregisterStatesChangedListener();
          deregisterOnStartListener();
          deregisterStateChangeSuccessListener();
        };
      }
      function handleStatesChanged() {
        setStatesFromDefinitionObject(ngSrefActive);
      }
      function setStatesFromDefinitionObject(statesDefinition) {
        if (isObject(statesDefinition)) {
          states = [];
          Object.entries(statesDefinition).forEach(
            ([activeClass, stateOrName]) => {
              // Helper function to abstract adding state.
              const addStateForClass = function (stateOrName, activeClass) {
                const ref = parseStateRef(stateOrName);
                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
              };
              if (isString(stateOrName)) {
                // If state is string, just add it.
                addStateForClass(stateOrName, activeClass);
              } else if (Array.isArray(stateOrName)) {
                // If state is an array, iterate over it and add each array item individually.
                stateOrName.forEach((stateOrName) => {
                  addStateForClass(stateOrName, activeClass);
                });
              }
            },
          );
        }
      }
      function addState(stateName, stateParams, activeClass) {
        const state = $state.get(stateName, stateContext($element));
        const stateInfo = {
          state: state || { name: stateName },
          params: stateParams,
          activeClass: activeClass,
        };
        states.push(stateInfo);
        return function removeState() {
          removeFrom(states)(stateInfo);
        };
      }
      // Update route state
      function update() {
        const splitClasses = (str) => str.split(/\s/).filter(Boolean);
        const getClasses = (stateList) =>
          stateList
            .map((x) => x.activeClass)
            .map(splitClasses)
            .reduce(unnestR, []);
        const allClasses = getClasses(states)
          .concat(splitClasses(activeEqClass))
          .reduce(uniqR, []);
        const fuzzyClasses = getClasses(
          states.filter((x) => $state.includes(x.state.name, x.params)),
        );
        const exactlyMatchesAny = !!states.filter((x) =>
          $state.is(x.state.name, x.params),
        ).length;
        const exactClasses = exactlyMatchesAny
          ? splitClasses(activeEqClass)
          : [];
        const addClasses = fuzzyClasses.concat(exactClasses).reduce(uniqR, []);
        const removeClasses = allClasses.filter(
          (cls) => !addClasses.includes(cls),
        );
        $scope.$evalAsync(() => {
          addClasses.forEach((className) => $element.classList.add(className));
          removeClasses.forEach((className) =>
            $element.classList.remove(className),
          );
        });
      }
      update();
    },
  };
}

/**
 * `ng-view`: A viewport directive which is filled in by a view from the active state.
 *
 * ### Attributes
 *
 * - `name`: (Optional) A view name.
 *   The name should be unique amongst the other views in the same state.
 *   You can have views of the same name that live in different states.
 *   The ng-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).
 *
 * - `autoscroll`: an expression. When it evaluates to true, the `ng-view` will be scrolled into view when it is activated.
 *   Uses [[$ngViewScroll]] to do the scrolling.
 *
 * - `onload`: Expression to evaluate whenever the view updates.
 *
 * #### Example:
 * A view can be unnamed or named.
 * ```html
 * <!-- Unnamed -->
 * <div ng-view></div>
 *
 * <!-- Named -->
 * <div ng-view="viewName"></div>
 *
 * <!-- Named (different style) -->
 * <ng-view name="viewName"></ng-view>
 * ```
 *
 * You can only have one unnamed view within any template (or root html). If you are only using a
 * single view and it is unnamed then you can populate it like so:
 *
 * ```html
 * <div ng-view></div>
 * $stateProvider.state("home", {
 *   template: "<h1>HELLO!</h1>"
 * })
 * ```
 *
 * The above is a convenient shortcut equivalent to specifying your view explicitly with the
 * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:
 *
 * ```js
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }
 * })
 * ```
 *
 * But typically you'll only use the views property if you name your view or have more than one view
 * in the same template. There's not really a compelling reason to name a view if its the only one,
 * but you could if you wanted, like so:
 *
 * ```html
 * <div ng-view="main"></div>
 * ```
 *
 * ```js
 * $stateProvider.state("home", {
 *   views: {
 *     "main": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }
 * })
 * ```
 *
 * Really though, you'll use views to set up multiple views:
 *
 * ```html
 * <div ng-view></div>
 * <div ng-view="chart"></div>
 * <div ng-view="data"></div>
 * ```
 *
 * ```js
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     },
 *     "chart": {
 *       template: "<chart_thing/>"
 *     },
 *     "data": {
 *       template: "<data_thing/>"
 *     }
 *   }
 * })
 * ```
 *
 * #### Examples for `autoscroll`:
 * ```html
 * <!-- If autoscroll present with no expression,
 *      then scroll ng-view into view -->
 * <ng-view autoscroll/>
 *
 * <!-- If autoscroll present with valid expression,
 *      then scroll ng-view into view if expression evaluates to true -->
 * <ng-view autoscroll='true'/>
 * <ng-view autoscroll='false'/>
 * <ng-view autoscroll='scopeVariable'/>
 * ```
 *
 * Resolve data:
 *
 * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this
 * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.
 *
 * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the
 * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which
 * depends on `$resolve` data.
 *
 * #### Example:
 * ```js
 * $stateProvider.state('home', {
 *   template: '<my-component user="$resolve.user"></my-component>',
 *   resolve: {
 *     user: function(UserService) { return UserService.fetchUser(); }
 *   }
 * });
 * ```
 */
let ngView = [
  "$view",
  "$animate",
  "$ngViewScroll",
  "$interpolate",
  function $ViewDirective($view, $animate, $ngViewScroll, $interpolate) {
    function getRenderer() {
      return {
        enter: function (element, target, cb) {
          if (hasAnimate(element)) {
            $animate.enter(element, null, target).then(cb);
          } else {
            target.after(element);
            cb();
          }
        },
        leave: function (element, cb) {
          if (hasAnimate(element)) {
            $animate.leave(element).then(cb);
          } else {
            element.parentElement.removeChild(element);
            cb();
          }
        },
      };
    }
    function configsEqual(config1, config2) {
      return config1 === config2;
    }
    const rootData = {
      $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },
      $ngView: {},
    };
    const directive = {
      count: 0,
      restrict: "EA",
      terminal: true,
      priority: 400,
      transclude: "element",
      compile: function (_tElement, _tAttrs, $transclude) {
        return function (scope, $element, attrs) {
          const onloadExp = attrs["onload"] || "",
            autoScrollExp = attrs["autoscroll"],
            renderer = getRenderer(),
            inherited = getInheritedData($element, "$ngView") || rootData,
            name =
              $interpolate(attrs["ngView"] || attrs["name"] || "")(scope) ||
              "$default";
          let previousEl, currentEl, currentScope, viewConfig;
          const activeUIView = {
            id: directive.count++, // Global sequential ID for ng-view tags added to DOM
            name: name, // ng-view name (<div ng-view="name"></div>
            fqn: inherited.$ngView.fqn
              ? inherited.$ngView.fqn + "." + name
              : name, // fully qualified name, describes location in DOM
            config: null, // The ViewConfig loaded (from a state.views definition)
            configUpdated: configUpdatedCallback, // Called when the matching ViewConfig changes
            get creationContext() {
              // The context in which this ng-view "tag" was created
              const fromParentTagConfig = parse("$cfg.viewDecl.$context")(
                inherited,
              );
              // Allow <ng-view name="foo"><ng-view name="bar"></ng-view></ng-view>
              // See https://github.com/angular-ui/ng-router/issues/3355
              const fromParentTag = parse("$ngView.creationContext")(inherited);
              return fromParentTagConfig || fromParentTag;
            },
          };
          trace.traceUIViewEvent("Linking", activeUIView);
          function configUpdatedCallback(config) {
            if (config && !(config instanceof Ng1ViewConfig)) return;
            if (configsEqual(viewConfig, config)) return;
            trace.traceUIViewConfigUpdated(
              activeUIView,
              config && config.viewDecl && config.viewDecl.$context,
            );
            viewConfig = config;
            updateView(config);
          }

          setCacheData($element, "$ngView", { $ngView: activeUIView });
          updateView();
          const unregister = $view.registerUIView(activeUIView);
          scope.$on("$destroy", function () {
            trace.traceUIViewEvent("Destroying/Unregistering", activeUIView);
            unregister();
          });
          function cleanupLastView() {
            if (previousEl) {
              trace.traceUIViewEvent(
                "Removing (previous) el",
                getCacheData(previousEl, "$ngView"),
              );
              previousEl.remove();
              previousEl = null;
            }
            if (currentScope) {
              trace.traceUIViewEvent("Destroying scope", activeUIView);
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentEl) {
              const _viewData = getCacheData(currentEl, "$ngViewAnim");
              trace.traceUIViewEvent("Animate out", _viewData);
              renderer.leave(currentEl, function () {
                _viewData.$$animLeave.resolve();
                previousEl = null;
              });
              previousEl = currentEl;
              currentEl = null;
            }
          }
          function updateView(config) {
            const newScope = scope.$new();
            const animEnter = Promise.withResolvers();
            const animLeave = Promise.withResolvers();
            const $ngViewData = {
              $cfg: config,
              $ngView: activeUIView,
            };
            const $ngViewAnim = {
              $animEnter: animEnter.promise,
              $animLeave: animLeave.promise,
              $$animLeave: animLeave,
            };
            /**
             * Fired once the view **begins loading**, *before* the DOM is rendered.
             *
             * @param {Object} event Event object.
             * @param {string} viewName Name of the view.
             */
            newScope.$emit("$viewContentLoading", name);
            const cloned = $transclude(newScope, function (clone) {
              setCacheData(clone, "$ngViewAnim", $ngViewAnim);
              setCacheData(clone, "$ngView", $ngViewData);
              renderer.enter(clone, $element, function () {
                animEnter.resolve();
                if (currentScope)
                  currentScope.$emit("$viewContentAnimationEnded");
                if (
                  (isDefined(autoScrollExp) && !autoScrollExp) ||
                  scope.$eval(autoScrollExp)
                ) {
                  $ngViewScroll(clone);
                }
              });
              cleanupLastView();
            });
            currentEl = cloned;
            currentScope = newScope;
            /**
             * Fired once the view is **loaded**, *after* the DOM is rendered.
             *
             * @param {Object} event Event object.
             */
            currentScope.$emit("$viewContentLoaded", config || viewConfig);
            currentScope.$eval(onloadExp);
          }
        };
      },
    };
    return directive;
  },
];

$ViewDirectiveFill.$inject = ["$compile", "$controller", "$transitions"];
function $ViewDirectiveFill($compile, $controller, $transitions) {
  const getControllerAs = parse("viewDecl.controllerAs");
  const getResolveAs = parse("viewDecl.resolveAs");
  return {
    restrict: "EA",
    priority: -400,
    compile: function (tElement) {
      const initial = tElement.innerHTML;
      dealoc(tElement, true);
      return function (scope, $element) {
        const data = getCacheData($element, "$ngView");
        if (!data) {
          $element.innerHTML = initial;
          $compile($element.contentDocument || $element.childNodes)(scope);
          return;
        }
        const cfg = data.$cfg || { viewDecl: {}, getTemplate: () => {} };
        const resolveCtx = cfg.path && new ResolveContext(cfg.path);
        $element.innerHTML = cfg.getTemplate($element, resolveCtx) || initial;
        trace.traceUIViewFill(data.$ngView, $element.innerHTML);
        const link = $compile($element.contentDocument || $element.childNodes);
        const controller = cfg.controller;
        const controllerAs = getControllerAs(cfg);
        const resolveAs = getResolveAs(cfg);
        const locals = resolveCtx && getLocals(resolveCtx);
        if (resolveAs) {
          scope.$target[resolveAs] = locals;
        }
        if (controller) {
          const controllerInstance = $controller(
            controller,
            Object.assign({}, locals, { $scope: scope, $element: $element }),
          );
          if (controllerAs) {
            scope.$target[controllerAs] = controllerInstance;
            scope.$target[controllerAs][resolveAs] = locals;
          }
          // TODO: Use $view service as a central point for registering component-level hooks
          // Then, when a component is created, tell the $view service, so it can invoke hooks
          // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });
          // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));
          setCacheData($element, "$ngControllerController", controllerInstance);
          Array.from($element.children).forEach((e) => {
            setCacheData(e, "$ngControllerController", controllerInstance);
          });
          registerControllerCallbacks(
            $transitions,
            controllerInstance,
            scope,
            cfg,
          );
        }
        // Wait for the component to appear in the DOM
        if (isString(cfg.component)) {
          const kebobName = kebobString(cfg.component);
          const tagRegexp = new RegExp(`^(x-|data-)?${kebobName}$`, "i");
          const getComponentController = () => {
            const directiveEl = [].slice
              .call($element.children)
              .filter((el) => el && el.tagName && tagRegexp.exec(el.tagName));
            return (
              directiveEl &&
              getCacheData(directiveEl, `$${cfg.component}Controller`)
            );
          };
          const deregisterWatch = scope.$watch(
            getComponentController,
            function (ctrlInstance) {
              if (!ctrlInstance) return;
              registerControllerCallbacks(
                $transitions,
                ctrlInstance,
                scope,
                cfg,
              );
              deregisterWatch();
            },
          );
        }
        link(scope);
      };
    },
  };
}
/** @ignore */
/** @ignore incrementing id */
let _uiCanExitId = 0;
/** @ignore TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */
function registerControllerCallbacks(
  $transitions,
  controllerInstance,
  $scope,
  cfg,
) {
  // Call $onInit() ASAP
  if (
    isFunction(controllerInstance.$onInit) &&
    !(cfg.viewDecl.component || cfg.viewDecl.componentProvider)
  ) {
    controllerInstance.$onInit();
  }
  const viewState = tail(cfg.path).state.self;
  const hookOptions = { bind: controllerInstance };
  // Add component-level hook for onUiParamsChanged
  if (isFunction(controllerInstance.uiOnParamsChanged)) {
    const resolveContext = new ResolveContext(cfg.path);
    const viewCreationTrans = resolveContext.getResolvable("$transition$").data;
    // Fire callback on any successful transition
    const paramsUpdated = ($transition$) => {
      // Exit early if the $transition$ is the same as the view was created within.
      // Exit early if the $transition$ will exit the state the view is for.
      if (
        $transition$ === viewCreationTrans ||
        $transition$.exiting().indexOf(viewState) !== -1
      )
        return;
      const toParams = $transition$.params("to");
      const fromParams = $transition$.params("from");
      const getNodeSchema = (node) => node.paramSchema;
      const toSchema = $transition$
        .treeChanges("to")
        .map(getNodeSchema)
        .reduce(unnestR, []);
      const fromSchema = $transition$
        .treeChanges("from")
        .map(getNodeSchema)
        .reduce(unnestR, []);
      // Find the to params that have different values than the from params
      const changedToParams = toSchema.filter((param) => {
        const idx = fromSchema.indexOf(param);
        return (
          idx === -1 ||
          !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id])
        );
      });
      // Only trigger callback if a to param has changed or is new
      if (changedToParams.length) {
        const changedKeys = changedToParams.map((x) => x.id);
        // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.
        const newValues = filter(
          toParams,
          (val, key) => changedKeys.indexOf(key) !== -1,
        );
        controllerInstance.uiOnParamsChanged(newValues, $transition$);
      }
    };
    $scope.$on(
      "$destroy",
      $transitions.onSuccess({}, paramsUpdated, hookOptions),
    );
  }
  // Add component-level hook for uiCanExit
  if (isFunction(controllerInstance.uiCanExit)) {
    const id = _uiCanExitId++;
    const cacheProp = "_uiCanExitIds";
    // Returns true if a redirect transition already answered truthy
    const prevTruthyAnswer = (trans) =>
      !!trans &&
      ((trans[cacheProp] && trans[cacheProp][id] === true) ||
        prevTruthyAnswer(trans.redirectedFrom()));
    // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition
    const wrappedHook = (trans) => {
      let promise;
      const ids = (trans[cacheProp] = trans[cacheProp] || {});
      if (!prevTruthyAnswer(trans)) {
        promise = Promise.resolve(controllerInstance.uiCanExit(trans));
        promise.then((val) => (ids[id] = val !== false));
      }
      return promise;
    };
    const criteria = { exiting: viewState.name };
    $scope.$on(
      "$destroy",
      $transitions.onBefore(criteria, wrappedHook, hookOptions),
    );
  }
}

/**
 * Dynamically updates an element's content based on events published on a specified channel.
 * If data is sent via `EventBus` on the specified `ngChannel`, the directive attempts to update the element's content accordingly,
 * either by directly setting the inner HTML or merging the scope's data if the element contains a template.
 *
 * If the element has a template and incoming data is an object, the directive will merge all key/value pairs onto the scope,
 * allowing Angular expressions (`{{ yourModel }}`) to be evaluated and rendered.
 *
 * When the scope is destroyed, the directive automatically unsubscribes from the channel.
 * Example:
 *
 * HTML:
 * <div ng-channel="userChannel">Hello {{ user.firstName }} {{ user.lastName }}</div>
 *
 * JavaScript:
 * angular.EventBus.publish('userChannel', { user: { firstName: 'John', lastName: 'Smith' } });
 *
 * @returns {import("../../types.js").Directive}
 */
function ngChannelDirective() {
  return {
    restrict: "EA",
    link: (scope, element, attrs) => {
      const hasTemplate = element.childNodes.length > 0;
      const channel = attrs["ngChannel"];

      const key = EventBus.subscribe(channel, async (val) => {
        if (!hasTemplate) {
          element.innerHTML = val;
        } else {
          if (isObject(val)) {
            scope.$merge(val);
          }
        }
      });

      scope.$on("$destroy", () => {
        EventBus.unsubscribeByKey(key);
      });
    },
  };
}

ngSetterDirective.$inject = ["$parse"];
/**
 * @returns {import('../../types.js').Directive}
 */
function ngSetterDirective($parse) {
  return {
    restrict: "A",
    link(scope, element, attrs) {
      const modelExpression = attrs.ngSetter;

      if (!modelExpression) {
        console.warn("ngSetter: Model expression is not provided.");
        return;
      }

      const assignModel = $parse(modelExpression).assign;

      if (!assignModel) {
        console.warn("ngSetter: Invalid model expression.");
        return;
      }

      const updateModel = (value) => {
        assignModel(scope, value);
      };

      const observer = new MutationObserver((mutationsList) => {
        let contentChanged = false;
        for (const mutation of mutationsList) {
          if (
            mutation.type === "childList" ||
            mutation.type === "characterData"
          ) {
            contentChanged = true;
            break;
          }
        }

        if (contentChanged) {
          updateModel(element.innerHTML);
        }
      });

      if (element && element) {
        observer.observe(element, {
          childList: true,
          subtree: true,
          characterData: true,
        });
      } else {
        console.warn("ngSetter: Element is not a valid DOM node.");
        return;
      }

      scope.$on("$destroy", () => observer.disconnect());
      updateModel(element.innerHTML);
    },
  };
}

/**
 * @type {string} `version` from `package.json`, injected by Rollup plugin
 */
const VERSION = "0.7.0";

/**
 * Initializes `ng`, `animate`, `message`, `aria` and `router` modules.
 * @param {import('./loader').Angular} angular
 * @returns {import('./types.js').Module} `ng`module
 */
function publishExternalAPI(angular) {
  const ng = angular
    .module(
      "ng",
      [],
      [
        "$provide",
        ($provide) => {
          // $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.
          $provide.provider({
            $$sanitizeUri: SanitizeUriProvider,
          });
          $provide
            .provider("$compile", CompileProvider)
            .directive({
              input: inputDirective,
              textarea: inputDirective,
              form: formDirective,
              script: scriptDirective,
              select: selectDirective,
              option: optionDirective,
              ngBind: ngBindDirective,
              ngBindHtml: ngBindHtmlDirective,
              ngBindTemplate: ngBindTemplateDirective,
              ngClass: ngClassDirective,
              ngClassEven: ngClassEvenDirective,
              ngClassOdd: ngClassOddDirective,
              ngCloak: ngCloakDirective,
              ngController: ngControllerDirective,
              ngDisabled: ngDisabledAriaDirective,
              ngForm: ngFormDirective,
              ngHide: ngHideDirective,
              ngIf: ngIfDirective,
              ngInclude: ngIncludeDirective,
              ngInit: ngInitDirective,
              ngMessages: ngMessagesDirective,
              ngMessage: ngMessageDirective,
              ngMessageExp: ngMessageExpDirective,
              ngMessagesInclude: ngMessagesIncludeDirective,
              ngMessageDefault: ngMessageDefaultDirective,
              ngNonBindable: ngNonBindableDirective,
              ngRef: ngRefDirective,
              ngRepeat: ngRepeatDirective,
              ngSetter: ngSetterDirective,
              ngShow: ngShowDirective,
              ngStyle: ngStyleDirective,
              ngSwitch: ngSwitchDirective,
              ngSwitchWhen: ngSwitchWhenDirective,
              ngSwitchDefault: ngSwitchDefaultDirective,
              ngOptions: ngOptionsDirective,
              ngTransclude: ngTranscludeDirective,
              ngModel: ngModelDirective,
              ngChange: ngChangeDirective,
              pattern: patternDirective,
              ngPattern: patternDirective,
              required: requiredDirective,
              ngRequired: requiredDirective,
              ngMinlength: minlengthDirective,
              minlength: minlengthDirective,
              ngMaxlength: maxlengthDirective,
              maxlength: maxlengthDirective,
              ngValue: ngValueDirective,
              ngModelOptions: ngModelOptionsDirective,
            })
            .directive({
              input: hiddenInputBrowserCacheDirective,
              ngAnimateSwap: ngAnimateSwapDirective,
              ngAnimateChildren: $$AnimateChildrenDirective,
              ngChecked: ngCheckedAriaDirective,
              ngClick: ngClickAriaDirective,
              ngDblclick: ngDblclickAriaDirective,
              ngInclude: ngIncludeFillContentDirective,
              ngHide: ngHideAriaDirective,
              ngShow: ngShowAriaDirective,
              ngMessages: ngMessagesAriaDirective,
              ngModel: ngModelAriaDirective,
              ngReadonly: ngReadonlyAriaDirective,
              ngRequired: ngRequiredAriaDirective,
              ngValue: ngValueAriaDirective,
              ngSref: $StateRefDirective,
              ngSrefActive: $StateRefActiveDirective,
              ngSrefActiveEq: $StateRefActiveDirective,
              ngState: $StateRefDynamicDirective,
              ngView: ngView,
              ngChannel: ngChannelDirective,
            })
            .directive({
              ngView: $ViewDirectiveFill,
            })
            .directive(ngAttributeAliasDirectives)
            .directive(ngEventDirectives);
          $provide.provider({
            $aria: AriaProvider,
            $anchorScroll: AnchorScrollProvider,
            $animate: AnimateProvider,
            $$animation: AnimationProvider,
            $animateCss: AnimateCssProvider,
            $$animateCssDriver: AnimateCssDriverProvider,
            $$animateJs: AnimateJsProvider,
            $$animateJsDriver: AnimateJsDriverProvider,
            $$animateCache: AnimateCacheProvider,
            $$animateQueue: AnimateQueueProvider,
            $$AnimateRunner: AnimateRunnerFactoryProvider,
            $$animateAsyncRun: AnimateAsyncRunFactoryProvider,
            $browser: BrowserProvider,
            $controller: ControllerProvider,
            $exceptionHandler: ExceptionHandlerProvider,
            $filter: FilterProvider,
            $interpolate: InterpolateProvider,
            $http: HttpProvider,
            $httpParamSerializer: HttpParamSerializerProvider,
            $httpBackend: HttpBackendProvider,
            $location: LocationProvider,
            $log: LogProvider,
            $parse: ParseProvider,
            $$rAFScheduler: RafSchedulerProvider,
            $rootScope: RootScopeProvider,
            $routerGlobals: UIRouterGlobals,
            $sce: SceProvider,
            $sceDelegate: SceDelegateProvider,
            $$taskTrackerFactory: TaskTrackerFactoryProvider,
            $templateCache: TemplateCacheProvider,
            $templateRequest: TemplateRequestProvider,
            $urlConfig: UrlConfigProvider,
            $view: ViewService,
            $transitions: TransitionProvider,
            $state: StateProvider,
            $ngViewScroll: ViewScrollProvider,
            $templateFactory: TemplateFactoryProvider,
            $urlService: UrlService,
            $stateRegistry: StateRegistryProvider,
          });
        },
      ],
    )
    .factory("$stateParams", [
      "$routerGlobals",
      function (globals) {
        return globals.params;
      },
    ])
    .value("$trace", trace)
    .info({ version: VERSION });

  return ng;
}

const ngMinErr = minErr("ng");
const $injectorMinErr = minErr("$injector");

/** @type {Object.<string, NgModule>} */
const modules = {};

/**
 * Configuration option for AngularTS bootstrap process.
 *
 * @typedef {Object} AngularBootstrapConfig
 * @property {boolean} [strictDi] - Disable automatic function annotation for the application. This is meant to assist in finding bugs which break minified code. Defaults to `false`.
 */

class Angular {
  constructor() {
    Cache.clear(); // a ensure new instance of angular gets a clean cache

    /** @type {Map<number, import("./core/cache/cache").ExpandoStore>} */
    this.Cache = Cache;

    /** @type {import('./core/pubsub/pubsub.js').PubSub} */
    this.EventBus = EventBus;

    /** @type {string} */
    this.version = VERSION;

    /** @type {!Array<string|any>} */
    this.bootsrappedModules = [];

    this.getController = getController;
    this.getInjector = getInjector;
    this.getScope = getScope;
    this.errorHandlingConfig = errorHandlingConfig;

    window["angular"] = this;
    publishExternalAPI(this);
  }

  /**
   * Use this function to manually start up AngularJS application.
   *
   * AngularTS will detect if it has been loaded into the browser more than once and only allow the
   * first loaded script to be bootstrapped and will report a warning to the browser console for
   * each of the subsequent scripts. This prevents strange results in applications, where otherwise
   * multiple instances of AngularJS try to work on the DOM.
   *   *
   * <div class="alert alert-warning">
   * **Note:** Do not bootstrap the app on an element with a directive that uses {@link ng.$compile#transclusion transclusion},
   * such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and {@link ngRoute.ngView `ngView`}.
   * Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},
   * causing animations to stop working and making the injector inaccessible from outside the app.
   * </div>
   *
   * ```html
   * <!doctype html>
   * <html>
   * <body>
   * <div ng-controller="WelcomeController">
   *   {{greeting}}
   * </div>
   *
   * <script src="angular.js"></script>
   * <script>
   *   let app = angular.module('demo', [])
   *   .controller('WelcomeController', function($scope) {
   *       $scope.greeting = 'Welcome!';
   *   });
   *   angular.bootstrap(document, ['demo']);
   * </script>
   * </body>
   * </html>
   * ```
   *
   * @param {string | Element | Document} element DOM element which is the root of AngularJS application.
   * @param {Array<String|any>} [modules] an array of modules to load into the application.
   *     Each item in the array should be the name of a predefined module or a (DI annotated)
   *     function that will be invoked by the injector as a `config` block.
   *     See: {@link angular.module modules}
   * @param {AngularBootstrapConfig} [config] an object for defining configuration options for the application. The
   *     following keys are supported:
   *
   * * `strictDi` - disable automatic function annotation for the application. This is meant to
   *   assist in finding bugs which break minified code. Defaults to `false`.
   *
   * @returns {any} InjectorService - Returns the newly created injector for this app.
   */
  bootstrap(element, modules, config) {
    config = config || {
      strictDi: false,
    };

    if (
      (element instanceof Element || element instanceof Document) &&
      getInjector(/** @type {Element} */ (element))
    ) {
      throw ngMinErr("btstrpd", "App already bootstrapped");
    }

    if (Array.isArray(modules)) {
      this.bootsrappedModules = modules;
    }

    this.bootsrappedModules.unshift([
      "$provide",
      ($provide) => {
        $provide.value("$rootElement", element);
      },
    ]);

    this.bootsrappedModules.unshift("ng");

    const injector = createInjector(this.bootsrappedModules, config.strictDi);
    injector.invoke([
      "$rootScope",
      "$rootElement",
      "$compile",
      "$injector",
      /**
       * @param {import('./core/scope/scope.js').Scope} scope
       * @param {Element} el
       * @param {*} compile
       * @param {import("./core/di/internal-injector.js").InjectorService} $injector
       */
      (scope, el, compile, $injector) => {
        // ng-route deps
        this.$injector = $injector;
        setCacheData(el, "$injector", $injector);

        const compileFn = compile(el);
        compileFn(scope);

        // https://github.com/angular-ui/ng-router/issues/3678
        if (!Object.prototype.hasOwnProperty.call($injector, "strictDi")) {
          try {
            $injector.invoke(() => {});
          } catch (error) {
            $injector.strictDi = !!/strict mode/.exec(
              error && error.toString(),
            );
          }
        }

        $injector
          .get("$stateRegistry")
          .get()
          .map((x) => x.$$state().resolvables)
          .reduce(unnestR, [])
          .filter((x) => x.deps === "deferred")
          .forEach(
            (resolvable) =>
              (resolvable.deps = annotate(
                resolvable.resolveFn,
                $injector.strictDi,
              )),
          );
      },
    ]);
    return injector;
  }

  /**
   * @param {any[]} modules
   * @param {boolean?} strictDi
   * @returns {import("./core/di/internal-injector.js").InjectorService}
   */
  injector(modules, strictDi) {
    return createInjector(modules, strictDi);
  }

  /**
   * @param {Element|Document} element
   */
  init(element) {
    let appElement;
    let module;
    const config = {};
    // The element `element` has priority over any other element.
    ngAttrPrefixes.forEach((prefix) => {
      const name = `${prefix}app`;
      if (
        /** @type {Element} */ (element).hasAttribute &&
        /** @type {Element} */ (element).hasAttribute(name)
      ) {
        appElement = element;
        module = /** @type {Element} */ (element).getAttribute(name);
      }
    });
    ngAttrPrefixes.forEach((prefix) => {
      const name = `${prefix}app`;
      let candidate;

      if (
        !appElement &&
        (candidate = element.querySelector(`[${name.replace(":", "\\:")}]`))
      ) {
        appElement = candidate;
        module = candidate.getAttribute(name);
      }
    });
    if (appElement) {
      config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
      this.bootstrap(appElement, module ? [module] : [], config);
    }
  }

  /**
   *
   * The `angular.module` is a global place for creating, registering and retrieving AngularJS
   * modules.
   * All modules (AngularJS core or 3rd party) that should be available to an application must be
   * registered using this mechanism.
   *
   * Passing one argument retrieves an existing {@link import('./types.js').Module},
   * whereas passing more than one argument creates a new {@link import('./types.js').Module}
   *
   *
   * # Module
   *
   * A module is a collection of services, directives, controllers, filters, and configuration information.
   * `angular.module` is used to configure the {@link auto.$injector $injector}.
   *
   * ```js
   * // Create a new module
   * let myModule = angular.module('myModule', []);
   *
   * // register a new service
   * myModule.value('appName', 'MyCoolApp');
   *
   * // configure existing services inside initialization blocks.
   * myModule.config(['$locationProvider', function($locationProvider) {
   *   // Configure existing providers
   *   $locationProvider.hashPrefix('!');
   * }]);
   * ```
   *
   * Then you can create an injector and load your modules like this:
   *
   * ```js
   * let injector = angular.injector(['ng', 'myModule'])
   * ```
   *
   * However it's more likely that you'll just use
   * {@link ng.directive:ngApp ngApp} or
   * {@link angular.bootstrap} to simplify this process for you.
   *
   * @param {string} name The name of the module to create or retrieve.
   * @param {Array.<string>} [requires] If specified then new module is being created. If
   *        unspecified then the module is being retrieved for further configuration.
   * @param {Array<any>|Function} [configFn] Optional configuration function for the module. Same as
   *        {@link import('./types.js').Module#config Module#config()}.
   * @returns {NgModule} A newly registered module.
   */
  module(name, requires, configFn) {
    assertNotHasOwnProperty(name, "module");
    if (requires && Object.prototype.hasOwnProperty.call(modules, name)) {
      modules[name] = null;
    }
    return ensure(modules, name, () => {
      if (!requires) {
        throw $injectorMinErr(
          "nomod",
          "Module '{0}' is not available. Possibly misspelled or not loaded",
          name,
        );
      }
      const moduleInstance = new NgModule(
        name,
        requires,
        /** @type {Function} */ (configFn),
      );
      return moduleInstance;
    });
  }
}

function ensure(obj, name, factory) {
  return obj[name] || (obj[name] = factory());
}

const angular = new Angular();
document.addEventListener("DOMContentLoaded", () => angular.init(document), {
  once: true,
});

export { angular };
